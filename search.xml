<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分布式系统之 — CAP 定理]]></title>
    <url>%2Fpost%2F11cb7677.html</url>
    <content type="text"><![CDATA[前言在互联网时代，我们的应用都是分布式系统，部署在 N 台机器上。说到分布式系统我们就不得不说分布式系统的祖先——集中式系统。它和分布式系统是两个完全相反的概念，集中式系统就是把所有的程序和功能都放到一台主机上，从而对外提供服务。集中式系统的优点就是容易理解、维护方便，它的的弊端也很明显，如果这个主机出故障了那么整个系统就崩溃了。著名投资家巴菲特有个关于投资的名言： 不要把鸡蛋放在一个篮子里 对于我们的系统而言也是如此，我们不可能保证主机永远不坏、也无法保证自己的程序永远不会出 bug，所以问题是无法避免的，我们只能把“鸡蛋”分散到不同的“篮子”里，降低系统出故障的风险，这就是我们为什么需要分布式系统的原因之一。使用分布式系统的另一个理由就是扩展性，毕竟单台主机都会有性能的极限，分布式系统可以通过增加主机数量来实现横向水平性能的扩展。接下来我们看看分布式系统中的一个基本定理——CAP定理。 什么是 CAP 定理CAP 定理指出对于一个分布式系统来说，不可能同时满足以下三点： 一致性（Consistency） 可用性（Availability） 分区容错性（Partition tolerance） 定理看起来很简单，但是一致性、可用性、分区容错性究竟是代表什么意思呢？理解定理的最简单的方式就是想象一个有两个节点分别处在不同的分区（PS：可以简单的把分区理解为不同的子网络）的分布式系统。 场景假设我们假定一个很简单的分布式系统，系统由两个系统 S1 和 S2 组成。两个系统上面有两个相同的变量 K，该变量在两个系统对应的初始值为 V0。系统 S1 和 S2 可以进行通信同时也对外提供服务。我们假定的分布式系统如下所示： 客户端 client 可以向 S1 和 S2 任何一个系统发起读和写请求。当一个服务接收到发过来的请求后进行一些相关业务操作，然后返回给客户端 client，发起写请求的过程如下图所示： 客户端发起读请求的过程如下所示： 我们的分布式系统模型建立好了，接下来我们通过这个模型来分析CAP 定理中的一致性、可用性和分区容错性的具体含义。 一致性（Consistency）一致性要求在一个写操作完成之后的任何读操作都必须返回该值或者以后进行写操作的结果。在满足一致性的分布式系统中，客户端发起一个写请求到分布式系统的任何一个子系统中，然后再向该系统中任何一个子系统发起读请求查询该变量对应的值，都会返回上次更新的最新结果。客户端向一个不满足一致性的分布式系统发起写-读请求的过程如下所示： 当客户端向系统 S1 发送写请求(write V1)，得到成功返回响应后，再向系统 S2 发送读请求读取该变量的值，系统 S2 还是返回旧值 V0。另一方面，我们看看客户端向一个满足一致性的分布式系统发起写-读请求的过程： 在这个满足一致性的系统中，在上述过程中系统 S1 在返回客户端请求结果之前会先把最新值 V1 发送到系统 S2，然后才返回客户端的写请求结果。因此，当客户端再去请求系统 S2 的时候就会返回最新值 V1。 可用性（Availability）可用性要求在分布式系统中非故障节点收到的每一个请求都必须返回响应。在一个满足可用性的分布式系统中，如果客户端向系统中任意一个节点发送请求并且服务器没有崩溃的情况下，则该节点必须响应客户端，不管是哪个节点，只要收到请求，就必须告诉用户，到底是 V0 还是 V1，否则就不满足可用性，不允许服务器忽略客户端的请求。 分区容错性（Partition tolerance）分区容错表明当消息从一个节点向另一个节点发送消息的过程中，消息可能会丢失。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在一致性和可用性之间做出选择。如果所有消息都无法发送的话，分布式系统的各个节点将无法同步消息。如下所示： 一般来说，分区容错无法避免，因此可以认为CAP定理的分区容错性总是成立。CAP 定理告诉我们，剩下的一致性和可用性无法同时做到。通常我们为了分区容错，我们的系统必须保证能够在任意网络分区下正常运行。 为何不能同时满足一致性和可用性我们现在知道了一致性、可用性、分区容错性所表示的具体含义，接下来看看为什么在一个分布式系统中不能同时满足一致性和可用性。我们假定存在一个同时满足这三个特性的系统。首先要做的就是对该系统进行分区，分区后系统如下所示： 下一步，客户端向分布式系统的节点 S1 发送一个写请求(write V1)，系统只要是可用的，该节点总是会返回响应。但是系统存在网络分区，因此节点 S1 无法将最新值 V1 通知节点 S2 去更新。如下所示： 接下来，客户端向分布式系统的节点 S2 发送一个读请求（read K）查询变量 K 的值，同样的，系统只要是可用的，该节点总是会返回响应，但是系统存在网络分区，因此节点 S2 无法从节点 S1 获取到最新值 V1 进行更新。如下所示： 客户端已经向节点 S1 发送写请求（write V1）成功后，再向节点 S2 发起读请求，得到的返回值是旧值 V0。这和我们假设的一致性冲突。如果要保证节点 S1 的一致性，那么节点 S1 必须在写操作时，锁定节点 S2 的读操作和写操作。只有当数据同步后，才能重新开放节点 S2 的读写操作。那么在锁定期间，S2不能读写，它就没有可用性了。再来看看，我们如果保证节点 S2 的可用性，那么就不能锁定节点 S2 的读写操作，所以一致性不成立。所以，节点 S2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性，如果追求所有节点的可用性，那就没法做到一致性了。 总结CAP定理指明了分布式系统的三大指标一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）不能同时满足，该定理是分布式系统的基本定理，也是理解分布式系统的起点。(PS: 像我们常用的注册中心 Eureka，因为节点之间的状态同步采用的异步方式，所以不能保证任意时刻各个节点间的状态一定是一致的，只能保证节点间最终状态是一致的。所以按照CAP理论，Eureka 的选择就是放弃了一致性，选择可用性和分区容错性。)]]></content>
      <categories>
        <category>分布式系统</category>
        <category>CAP定理</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>CAP定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 最新版（2019.3）激活教程]]></title>
    <url>%2Fpost%2Ff440d00b.html</url>
    <content type="text"><![CDATA[前言相信做 Java 开发的朋友们绝大部分人应该都是用 IntelliJ IDEA 作为开发工具，没用过的朋友们建议将你的开发工具换成这个，关于它的优点可以去 Google 一下，我之前都是用 Eclipse 作为开发工具，自从用过一次 IDEA 之后就再也回不去了。。。今天早上更新（作死）了一下 IDEA 到最新版（2019.3.1），安装完毕之后进入就提示说之前的激活码失效了，经过一顿搜索之后终于成功激活了，在此记录一下激活过程。 Step 1 升级 IDEA 到 2019.3 版本如果之前电脑安装过 IDEA，依次选择菜单项 IntelliJ IDEA -&gt; About IntelliJ IDEA 查看 IDEA 的版本（PS: windows 系统菜单项可能不同），如果不是 2019.3 版本，则要到 官网 下载 2019.3.1 版本，具体安装过程比较简单，安装过程有问题的朋友们请自行 Google。 Step 2 下载补丁包扫码关注微信公众号 mghio 后回复「idea」获取激活补丁包。 Step 3 编辑 IDEA 的 idea.vmoptions 文件经过 Step 1 安装完成之后，打开 IDEA 开发工具，然后它会提示要激活，这里我们先选择 试用 30 天。 然后将 Step 2 我们下载好的激活补丁包 jetbrains-agent.jar 拷贝到 IDEA 安装目录的 bin 目录下。 编辑 IDEA 的 idea.vmoptions（PS:推荐直接从IDEA中编辑），依次选择菜单项 Help -&gt; Edit Custom VM Optons...。 点击打开编辑，在其内容最后追加如下代码： 1-javaagent:你的 IDEA 的安装目录/bin/jetbrains-agent.jar Step 4 重启后输入激活码激活退出 IDEA 重新启动进入，依次选择菜单项 Help -&gt; Register...。 进入后选择 Activation code 以输入激活码方式激活，在第二步 Step 2 下载补丁包 中下载的 txt 文件（文件名：激活码.txt）为激活码，这里也贴一下，激活码如下（PS: 鼠标移至激活码区域，点击右侧 「复制」 按钮即可复制）： 1KNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g== 部分朋友输入以上激活码后点击激活可能会出现如下报错提示：Your activation code could not be validated（error 1653219），未出现此错误提示的朋友可以跳过以下步骤。 出现此错误是因为没有屏蔽 account.jetbrains.com 的 443 端口，因此修改本地 hosts 文件在其内容追加以下内容即可。 10.0.0.0 https://account.jetbrains.com:443 修改保存 hosts 文件后，再次激活即可激活。 Step 5 验证是否激活重启 IDEA 后，依次选择菜单项 IntelliJ IDEA -&gt; About IntelliJ IDEA，可以看到激活到期日期为：2089-07-08。 至此， IntelliJ IDEA 激活完成。 总结以上激活步骤只针对 IntelliJ IDEA 的 2019.3.1 版本，不同的版本可能无法激活，在激活前请确认好你所使用的 IDEA 版本。激活码和激活补丁包要一起使用，单独使用无效，在激活过程中有问题请在文末留言区留言讨论。]]></content>
      <categories>
        <category>Java</category>
        <category>IDEA</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射机制（二）]]></title>
    <url>%2Fpost%2F7528c810.html</url>
    <content type="text"><![CDATA[前言在上篇 Java 反射机制（一） 介绍了一些 Java 反射相关的常用 API ，在知道了如何去使用反射之后，作为一个合格的工程师，下一步肯定是要去了解它的如何实现的，我们今天就来看看在 JDK 源码中是如何去实现反射的(PS:以下源码分析基于 JDK1.8)。 Field 类 set 方法的实现Field 类的 set 方法是在运行时用来动态修改一个类的属性的值，进入到 Field 类的 set 方法的源码如下： 1234567891011public void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException&#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); &#125; &#125; getFieldAccessor(obj).set(obj, value);&#125; 首先根据 override 判断是否需要检查字段的访问权限，然后通过 getFieldAccessor 方法获得一个 FieldAccessor 字段访问者对象，最后调用的是 FieldAccessor 类的 set 方法进行下一步操作的，FieldAccessor 是一个接口，定义了对字段的一些操作，该接口有如下一些实现类： 要看 set 到底调用的是哪个实现类的方法，那么我们需要看看 getFieldAccessor() 返回的是哪个类的对象，下面是 getFieldAccessor 方法的源码实现： 12345678// security check is done before calling this methodprivate FieldAccessor getFieldAccessor(Object obj) throws IllegalAccessException&#123; boolean ov = override; FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor; return (a != null) ? a : acquireFieldAccessor(ov);&#125; 这里先通过 override 来获取不同的缓存的 FieldAccessor，其中 overrideFieldAccessor 代表本类覆盖父类的字段访问者对象缓存，fieldAccessor 是本类的字段访问器对象缓存。如果缓存存在的话就直接复用之前的对象，否则就调用 Field 类的 acquireFieldAccessor 方法获取。我们进入到 acquireFieldAccessor 方法中看看，方法源码如下： 123456789101112131415161718private FieldAccessor acquireFieldAccessor(boolean overrideFinalCheck) &#123; // First check to see if one has been created yet, and take it // if so FieldAccessor tmp = null; if (root != null) tmp = root.getFieldAccessor(overrideFinalCheck); if (tmp != null) &#123; if (overrideFinalCheck) overrideFieldAccessor = tmp; else fieldAccessor = tmp; &#125; else &#123; // Otherwise fabricate one and propagate it up to the root tmp = reflectionFactory.newFieldAccessor(this, overrideFinalCheck); setFieldAccessor(tmp, overrideFinalCheck); &#125; return tmp;&#125; 从 acquireFieldAccessor 的源码中我们可以看到，先判断是否已存在 FieldAccessor 对象，如果存在的话那么就会复用之前的 FieldAccessor 对象，否则就使用 reflectionFactory 工厂的 newFieldAccessor 方法生成一个新的 FieldAccessor 对象出来。所以我们就要进到 newFieldAccessor 方法里面看看是如何生成的，方法源码如下： 1234public FieldAccessor newFieldAccessor(Field var1, boolean var2) &#123; checkInitted(); return UnsafeFieldAccessorFactory.newFieldAccessor(var1, var2);&#125; 从 newFieldAccessor 方法代码可以得知，在方法里面是通过 UnsafeFieldAccessorFactory 类的 static 方法 newFieldAccessor 来生产 FieldAccessor 的，那么我们继续进入到 UnsafeFieldAccessorFactory 类的 newFieldAccessor 方法里面看看，方法源码如下： 123456789101112131415161718192021222324252627282930313233static FieldAccessor newFieldAccessor(Field var0, boolean var1) &#123; Class var2 = var0.getType(); boolean var3 = Modifier.isStatic(var0.getModifiers()); boolean var4 = Modifier.isFinal(var0.getModifiers()); boolean var5 = Modifier.isVolatile(var0.getModifiers()); boolean var6 = var4 || var5; boolean var7 = var4 &amp;&amp; (var3 || !var1); if (var3) &#123; UnsafeFieldAccessorImpl.unsafe.ensureClassInitialized(var0.getDeclaringClass()); if (!var6) &#123; if (var2 == Boolean.TYPE) &#123; return new UnsafeStaticBooleanFieldAccessorImpl(var0); &#125; else if (var2 == Byte.TYPE) &#123; return new UnsafeStaticByteFieldAccessorImpl(var0); &#125; else if (var2 == Short.TYPE) &#123; return new UnsafeStaticShortFieldAccessorImpl(var0); &#125; else if (var2 == Character.TYPE) &#123; return new UnsafeStaticCharacterFieldAccessorImpl(var0); &#125; else if (var2 == Integer.TYPE) &#123; return new UnsafeStaticIntegerFieldAccessorImpl(var0); &#125; else if (var2 == Long.TYPE) &#123; return new UnsafeStaticLongFieldAccessorImpl(var0); &#125; else if (var2 == Float.TYPE) &#123; return new UnsafeStaticFloatFieldAccessorImpl(var0); &#125; else &#123; return (FieldAccessor)(var2 == Double.TYPE ? new UnsafeStaticDoubleFieldAccessorImpl(var0) : new UnsafeStaticObjectFieldAccessorImpl(var0)); &#125; &#125; // 剩下的部分省略... &#125; &#125; 从以上 UnsafeFieldAccessorFactory 类的 newFieldAccessor 方法代码可以看出，方法里面通过类的字段修饰符类型和字段的类类型共同决定返回的 FieldAccessor 实现类，这里要注意一下方法里面这几个变量的含义： var3（isStatic）：静态属性，也就是 static 关键字修饰的属性。 var4（isFinal）：final 关键字修饰的属性。 var5（isVolatile）：valatile 关键字修饰的属性。 var6（isQualified）：valatile 关键字或者 final 关键字修饰的属性。 var7 (isReadOnly)：是否只读属性，final 关键字修饰的属性或者 static 关键字修饰并且不能覆盖（override = false）的属性 举一个例子，假设在一个类中的字段声明为 public static String name，那么返回的字段访问器为 UnsafeStaticCharacterFieldAccessorImpl，我们看看这个类的 set 方法是如何实现的，方法源码如下： 123456789101112131415public void set(Object var1, Object var2) throws IllegalArgumentException, IllegalAccessException &#123; if (this.isFinal) &#123; this.throwFinalFieldIllegalAccessException(var2); &#125; if (var2 == null) &#123; this.throwSetIllegalArgumentException(var2); &#125; if (var2 instanceof Character) &#123; unsafe.putChar(this.base, this.fieldOffset, (Character)var2); &#125; else &#123; this.throwSetIllegalArgumentException(var2); &#125;&#125; 从上面方法的代码得知，方法最终还是通过 Unsafe 类的 native 方法 putChar(Object var1, long var2, char var4) 来实现的，有关 Unsafe 类的介绍请看这篇文章（Java魔法类：Unsafe应用解析）。 Method 类 invoke 方法的实现Method 类的 invoke 方法用来在运行时动态调用对象的方法，我们进入到 Method 类的 invoke 方法中看看在 JDK 中到底是怎么做的，方法源码如下： 123456789101112131415public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); &#125; &#125; MethodAccessor ma = methodAccessor; // read volatile if (ma == null) &#123; ma = acquireMethodAccessor(); &#125; return ma.invoke(obj, args);&#125; 从以上方法代码我们可以看到，和上文说的的 Field 类一样，首先也是先根据 override 进行了一些权限检查，最后调用的是 MethodAccessor 的 invoke 方法进行处理，这个方法访问器 MethodAccessor 是一个接口，它只有一个操作方法调用的 invoke 方法，它有如下三个实现类： 要想知道 ma.invoke 具体调用的是哪个类的方法，我们需要看看方法 acquireMethodAccessor 返回的对象是哪个，该方法的源码如下： 123456789101112131415private MethodAccessor acquireMethodAccessor() &#123; // First check to see if one has been created yet, and take it // if so MethodAccessor tmp = null; if (root != null) tmp = root.getMethodAccessor(); if (tmp != null) &#123; methodAccessor = tmp; &#125; else &#123; // Otherwise fabricate one and propagate it up to the root tmp = reflectionFactory.newMethodAccessor(this); setMethodAccessor(tmp); &#125; return tmp;&#125; 从以上方法 acquireMethodAccessor 的源码可以看出，首先会先先判断是否已经存在了对应的 MethodAccessor 对象，如果有就会复用这个对象，否则就调用工厂 reflectionFactory 的 newMethodAccessor 方法生成一个 MethodAccessor 对象出来。那么我们就需要进入到方法 newMethodAccessor 中，方法源码如下： 1234567891011public MethodAccessor newMethodAccessor(Method var1) &#123; checkInitted(); if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) &#123; return (new MethodAccessorGenerator()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers()); &#125; else &#123; NativeMethodAccessorImpl var2 = new NativeMethodAccessorImpl(var1); DelegatingMethodAccessorImpl var3 = new DelegatingMethodAccessorImpl(var2); var2.setParent(var3); return var3; &#125;&#125; 从方法 newMethodAccessor 的代码可以看到，方法首先是使用 Method 对象作为入参生成了 NativeMethodAccessorImpl 对象，然后再使用 NativeMethodAccessorImpl 对象作为入参生成了 DelegatingMethodAccessorImpl 对象。这个使用了代理模式，将 NativeMethodAccessorImpl 交给了 DelegatingMethodAccessorImpl 类进行了代理，进入到代理类 DelegatingMethodAccessorImpl 中可以看到： 从上面的红色方框可以看到，在类 DelegatingMethodAccessorImpl 的构造方法中将参数赋值给类中的 delegate 属性，所有上所说的 ma.invoke 最终会进入到 DelegatingMethodAccessorImpl 代理类的 invoke，方法里调用的是 delegate 属性的 invoke 方法，该属性声明的类型为抽象类 MethodAccessorImpl，它有如下两个实现类： 按照上文所说的，这里的 delegate 属性是 NativeMethodAccessorImpl 对象，那么就进入到 NativeMethodAccessorImpl 的 invoke 方法中，方法源码如下： 12345678public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException &#123; if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) &#123; MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers()); this.parent.setDelegate(var3); &#125; return invoke0(this.method, var1, var2);&#125; 类 NativeMethodAccessorImpl 的 invoke 方法会先判断此次调用是否超过 ReflectionFactory.inflationThreshold() 方法返回的阈值（PS：默认的阈值大小为 15），如果超过了该阈值，则使用方法访问生成器重新生成一个 MethodAccessorImpl，并将 DelegatingMethodAccessorImpl 的 delegate 属性指向这个新生成的 MethodAccessorImpl 对象。从 Reflectionfactory 工厂类的一下注释： 可以得知 JVM 初次加载字节码实现反射的时候，使用 Method.invoke 和 Constructor.newInstance 方式加载所花费的时间是使用原生代码加载所花费的时间的 3 - 4 倍。这也就是我们平常说为什么频繁使用反射的应用需要花费更多的时间。JVM 作者们为了避免这种花费较长的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。正如注释所述，在 MethodAccessor 接口的实现中，有两个不同的版本，一个 Java 实现的，一个是 Native 实现的。Java 版本实现的版本在初始化的时需要比较多的时间，但长久来说性能会更好一些；而 Native 版本则正好相反，在初始化时相对较快，但是在运行一段时间之后性能就不如 Java 版本的了。为了权衡两种版本的特性，sun 公司的 JDK 使用了 inflation 机制，让 Java 方法在被反射调用时，开头的几次调用使用 native 版，等反射调用次数超过阈值时则生成一个专用的 MethodAccessor 实现类，生成其中的 invoke 方法的字节码，以后对该 Java 方法的反射调用就会使用 Java 版。 总结本文主要介绍反射调用 set(Object obj, Object value) 方法和 invoke(Object obj, Object... args) 方法的底层实现，由于水平有限本人暂时还没有能力分析 JVM 的实现，这里只分析到最终 native 方法的调用。底层会依赖到 Unsafe 类来执行一些低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。对于属性反射的方法 setXXX 和 getXXX 的实现分别对应 Unsafe 类的 putXXX 和 getXXX 方法，也就是说完全依赖 Unsafe 类中的 native 方法来实现的；对于方法反射的方法 invoke 底层调用的是 NativeMethodAccessorImpl 类的 invoke0 的 native 方法来实现的。对于反射构造器调用的实现，读者可以自己进入其源码进行分析，大体上和反射方法调用的实现类似。 参考文章 JAVA深入研究——Method的Invoke方法。]]></content>
      <categories>
        <category>Java</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射机制（一）]]></title>
    <url>%2Fpost%2F102cd3d9.html</url>
    <content type="text"><![CDATA[前言在 Java 中有两种方式可以让我们在运行时识别对象和类的信息。一种是 RTTI（运行时类型识别：Run-Time Type Identification），它假定了我们在编译时已经知道了所有的类型；另一种是我们本文要说的反射机制，它允许我们在运行时获取和使用类的信息。无论是 RTTI 还是反射，其本质都是一样的，都是去动态的获取类的信息。它们唯一不同的是，RTTI 在编译时期知道要解析的类型，而反射是在运行时才知道要解析的类型。 反射概述反射就是把 Java 类中的各个部分（属性、方法、构造方法等）映射成一个个对象。Class 类与 java.lang.reflect 类库一起对反射的概念提供了支持，类库中包含了 Field、Method 及 Constructor 类，每个类都实现了 Member 接口。这些类型的对象都是由 JVM 运行时创建的，用来表示未知类里对应的成员。这样我们就可以使用 Constructor 创建新的对象，用 get 和 set 方法读取和修改类中与 Field 对象关联的字段，用 invoke 方法调用类中与 Method 对象关联的方法等。Java 反射机制是在运行状态中的，对于任意一个类我们可以通过反射获取这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。重要的是，要认识到反射机制并没有什么特别之处，当我们通过反射和一个未知类型的对象打交道时，JVM 只是简单的对这个对象做检查，看它属于哪个类，在用它做其它事情之前必须先加载那个类 Class 对象。所以那个类的字节码文件对象对于 JVM 来说必须是可获取的，要么在本地机器上，要么通过网络获取。 反射 API 的使用想要通过反射获取一个类的信息之前，首先要先获取这个类的 Class 对象，在 Java 中所有类型都有与之关联的 Class 对象。 获取类的 Class 对象在 Java 中获取一个类的 Class 对象有三种方式：第 ① 种 使用 Class 类的 forName 静态方法，当我们知道一个类的全路径时，可以通过 Class.forName 方法获取类的 Class 对象。 12Class stringClass = Class.forName("java.lang.String");System.out.println(stringClass); 运行结果 1class java.lang.String 第 ② 种 使用 .class 获取，这种方式只适合在编译前就已经知道了要操作的 Class。 12Class stringClass = String.class;System.out.println(stringClass); 运行结果 1class java.lang.String 第 ③ 种 使用 getClass() 方法获取 12Class stringClass = "mghio".getClass();System.out.println(stringClass); 运行结果 1class java.lang.String 通过反射创建类对象通过反射创建类对象有两种方式： 第 ① 种 通过调用 Class 对象的 newInstance() 方法创建 12Class&lt;Person&gt; personClass = Person.class;Person person = personClass.newInstance(); 第 ② 种 通过调用 Constructor 对象的 newInstance() 方法创建 123Class&lt;Person&gt; personClass = Person.class;Constructor personConstructor = personClass.getConstructor();Person person = (Person) personConstructor.newInstance(); 两者的区别是，通过 Class 的 newInstance 方法只能通过无参构造方法创建，这就要求这个类必须有一个无参的构造方法，而通过 Constructor 的 newInstance 可以指定参数来选择特定的构造方法来创建对象。以下代码就是指定参数然后通过特定的构造方法创建对象的。 123Class&lt;Person&gt; personClass = Person.class;Constructor personConstructor = personClass.getConstructor();Person person = (Person) personConstructor.newInstance("mghio", "中国上海"); 通过反射获取类的属性Class 类提供了两种方式获取一个类的属性。第 ① 种 是通过 Class 对象的 getFields 方法获取类的属性，该方法只能获取类的 public 属性。 123Class&lt;Person&gt; personClass = Person.class;Field[] fields = personClass.getFields();System.out.println(Arrays.toString(fields)); 运行结果 12[public java.lang.String cn.mghio.blogmghiocode.reflect.Person.id, public java.lang.String cn.mghio.blogmghiocode.reflect.Person.name] 第 ② 种 是通过 Class 对象的 getDeclaredFields 方法获取类的属性，该方法可以获取类的所有属性（包括 private 修饰的属性）。 123Class&lt;Person&gt; personClass = Person.class;Field[] fields = personClass.getDeclaredFields();System.out.println(Arrays.toString(fields)); 运行结果 1234[public java.lang.String cn.mghio.blogmghiocode.reflect.Person.id, public java.lang.String cn.mghio.blogmghiocode.reflect.Person.name, protected java.lang.Integer cn.mghio.blogmghiocode.reflect.Person.age, private java.lang.String cn.mghio.blogmghiocode.reflect.Person.address] 通过反射获取类的方法Class 也提供了两种方式获取类的方法。第 ① 种 是通过 Class 对象的 getMethods 方法获取类的方法（包括继承而得的方法）。 123Class&lt;Person&gt; personClass = Person.class;Method[] methods = personClass.getMethods();System.out.println(Arrays.toString(methods)); 运行结果 12345[public java.lang.String cn.mghio.blogmghiocode.reflect.Person.toString(), public java.lang.String cn.mghio.blogmghiocode.reflect.Person.getAddress(), ...public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify()] 第 ② 种 是通过 Class 对象的 getDeclaredMethods 方法获取类的方法（只包含类中定义的方法，不包含继承而来的方法）。 123Class&lt;Person&gt; personClass = Person.class;Method[] methods = personClass.getDeclaredMethods();System.out.println(Arrays.toString(methods)); 运行结果 12345[public java.lang.String cn.mghio.blogmghiocode.reflect.Person.toString(), public java.lang.String cn.mghio.blogmghiocode.reflect.Person.getAddress(), ... protected void cn.mghio.blogmghiocode.reflect.Person.protectedMethod(), private void cn.mghio.blogmghiocode.reflect.Person.privateMethod()] 从以上结果可以看出这个方法只获取当前类中定义的方法，包含 private 方法，不会获取从父类中继承而来的方法。 通过反射获取类的构造方法Class 也提供了两种方式获取类的构造方法。第 ① 种 是通过 Class 对象的 getConstructors 方法获取类的构造方法（只能获取当前类的 public 构造方法）。 123Class&lt;Person&gt; personClass = Person.class;Constructor[] constructors = personClass.getConstructors();System.out.println(Arrays.toString(constructors)); 运行结果 1[public cn.mghio.blogmghiocode.reflect.Person(java.lang.String,java.lang.String,java.lang.Integer,java.lang.String)] 第 ② 种 是通过 Class 对象的 getDeclaredConstructors 方法获取类的构造方法（只包含类中定义的所有构造方法）。 123Class&lt;Person&gt; personClass = Person.class;Constructor[] constructors = personClass.getDeclaredConstructors();System.out.println(Arrays.toString(constructors)); 运行结果 123[public cn.mghio.blogmghiocode.reflect.Person(java.lang.String,java.lang.String,java.lang.Integer,java.lang.String), protected cn.mghio.blogmghiocode.reflect.Person(java.lang.String,java.lang.String), private cn.mghio.blogmghiocode.reflect.Person()] 通过反射获取类的类名Class 类提供了两种方式获取类的类名。第 ① 种 是通过 getName 方法获取类的全限定名（包含包名）。 123Class&lt;Person&gt; personClass = Person.class;String fullPersonClassName = personClass.getName();System.out.println(fullPersonClassName); 运行结果 1cn.mghio.blogmghiocode.reflect.Person 第 ② 种 是通过 Class 对象的 getSimpleName 方法获取类的类名（不包含包名）。 123 Class&lt;Person&gt; personClass = Person.class;String fullPersonClassName = personClass.getSimpleName();System.out.println(fullPersonClassName); 运行结果 1Person 通过反射获取类的修饰符可以通过 Class 类来获取一个类的修饰符，也就是我们熟知的 public、protected、private 等关键字，通过调用 getModifiers 方法来获取一个类的修饰符。 123Class&lt;Person&gt; personClass = Person.class;int modifyInt = personClass.getModifiers();System.out.println(modifyInt); 运行结果 11 返回 1 表示类 Person 的修饰符为 public，修饰符在 Modifier 类中都被包装成一个 int 类型的数字，部分修饰符定义如下 1234567891011121314151617/** * The &#123;@code int&#125; value representing the &#123;@code public&#125; * modifier. */public static final int PUBLIC = 0x00000001;/** * The &#123;@code int&#125; value representing the &#123;@code private&#125; * modifier. */public static final int PRIVATE = 0x00000002;/** * The &#123;@code int&#125; value representing the &#123;@code protected&#125; * modifier. */public static final int PROTECTED = 0x00000004; 通过反射获取类的包信息Class 对象通过 getPackage 方法获取类的包相关信息，可以使用 Class 对象通过如下的方式获取包信息 123Class&lt;Person&gt; personClass = Person.class;Package packageClazz = personClass.getPackage();System.out.println(packageClazz.getName()); 运行结果 1cn.mghio.blogmghiocode.reflect 通过反射获取类的父类可以通过 Class 类来获取一个类的父类，通过调用 getModifiers 方法来获取一个类的父类。 123Class&lt;Person&gt; personClass = Person.class;Class superclass = personClass.getSuperclass();System.out.println(superclass.getName()); 运行结果 1java.lang.Object 以上运行结果表示 Person 类的父类是 Object 类，可以看到 superclass 对象其实就是一个 Class 类的实例，所以也可以继续在这个对象上进行反射操作。 通过反射获取类的实现接口可以通过 Class 类来获取一个类的父类，通过调用 getInterfaces 方法来获取一个类实现的接口。 123Class&lt;Person&gt; personClass = Person.class;Class&lt;?&gt;[] interfaces = personClass.getInterfaces();System.out.println(Arrays.toString(interfaces)); 运行结果 1[interface cn.mghio.blogmghiocode.reflect.IPerson] 在 Java 中一个类可以实现多个接口，因此 getInterfaces 方法返回一个 Class 数组，在 Java 中接口也同样有对应的 Class 对象。这个方法需要注意的是，getInterfaces 方法仅仅只返回当前类所实现的接口。当前类的父类如果实现了接口，这些接口是不会在返回的 Class 集合中的，尽管实际上当前类其实已经实现了父类接口。 通过反射获取泛型信息当我们在声明一个类或者接口的时候可以指定它可以参数化，常用的 List 接口就是一个参数化接口的例子。比如想要检查 List 接口的参数化类型，我们是没有办法能知道它具体的参数化类型是什么。这个类型就可以是一个应用中所有的类型。但是，当你检查一个使用了被参数化的类型的变量或者方法，你可以获得这个被参数化类型的具体参数。第 ① 种 泛型方法返回类型 当你获得了 Method 对象，那么就可以获取到这个方法的泛型返回类型信息。如果方法是在一个被参数化类型之中（例如: T foo()），那么将无法获得它的具体类型，但是如果方法返回的是一个泛型类（例如：List foo()），那么就可以获得这个泛型类的具体参数化类型。下面这个例子中的类定义了一个返回类型是泛型的方法。 12345678910111213141516/** * @author mghio * @date: 2019-12-29 * @version: 1.0 * @description: 通过反射获取泛型信息 * @since JDK 1.8 */public class ReflectGenericDemo &#123; protected List&lt;Integer&gt; stringList = Arrays.asList(2, 55, 3, 90, 81); public List&lt;Integer&gt; getStringList()&#123; return this.stringList; &#125;&#125; 我们可以获取上面这个类 ReflectGenericDemo 的方法 getStringList 的泛型返回类型。 1234567891011121314151617181920212223242526/** * @author mghio * @date: 2019-12-29 * @version: 1.0 * @description: 通过反射获取泛型信息 * @since JDK 1.8 */public class ReflectGenericDemoTests &#123; @Test public void testMethodReturnGenericType() throws NoSuchMethodException &#123; Class&lt;ReflectGenericDemo&gt; reflectClass = ReflectGenericDemo.class; Method method = reflectClass.getMethod("getStringList", (Class&lt;?&gt;) null); Type returnType = method.getGenericReturnType(); if (returnType instanceof ParameterizedType) &#123; ParameterizedType type = (ParameterizedType) returnType; Type[] typeArguments = type.getActualTypeArguments(); for (Type typeArgument : typeArguments) &#123; Class typeArgumentClass = (Class) typeArgument; System.out.println("typeArgumentClass = " + typeArgumentClass); &#125; &#125; &#125;&#125; 运行结果 1typeArgumentClass = class java.lang.Integer typeArguments 数组只有一个值，这个数组中唯一的值是 Integer 的 Class 类的实例，同时 Class 类也实现了 Type 接口。 第 ② 种 泛型方法返回类型 泛型方法参数类型，我们也可以通过反射来获取方法参数的泛型类型。 12345678910111213141516/** * @author mghio * @date: 2019-12-29 * @version: 1.0 * @description: 通过反射获取泛型信息 * @since JDK 1.8 */public class ReflectGenericDemo &#123; protected List&lt;Integer&gt; stringList = Arrays.asList(2, 55, 3, 90, 81); public void setStringList(List&lt;Integer&gt; stringList) &#123; this.stringList = stringList; &#125;&#125; 可以通过以下方式获取方法参数的泛型类型。 12345678910111213141516171819202122232425262728/** * @author mghio * @date: 2019-12-29 * @version: 1.0 * @description: 通过反射获取泛型信息 * @since JDK 1.8 */public class ReflectGenericDemoTests &#123; @Test public void testMethodParameterGenericType() throws NoSuchMethodException &#123; Class&lt;ReflectGenericDemo&gt; reflectClass = ReflectGenericDemo.class; Method method = reflectClass.getMethod("setStringList", List.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); for (Type genericParameterType : genericParameterTypes) &#123; if (genericParameterType instanceof ParameterizedType) &#123; ParameterizedType parameterizedType = (ParameterizedType) genericParameterType; Type[] parameterArgTypes = parameterizedType.getActualTypeArguments(); for (Type parameterArgType : parameterArgTypes) &#123; Class parameterArgClass = (Class) parameterArgType; System.out.println("parameterArgClass = " + parameterArgClass); &#125; &#125; &#125; &#125;&#125; 运行结果 1parameterArgClass = class java.lang.Integer 第 ③ 种 泛型变量类型 可以通过反射来访问类中定义变量的泛型类型，不管这个变量是一个类的静态成员变量或是实例成员变量。 123456789101112/** * @author mghio * @date: 2019-12-29 * @version: 1.0 * @description: 通过反射获取泛型信息 * @since JDK 1.8 */public class ReflectGenericDemo &#123; private List&lt;Integer&gt; stringList = Arrays.asList(2, 55, 3, 90, 81);&#125; 我们可以通过以下代码来获取类 ReflectGenericDemo 的私有变量 stringList 的泛型变量类型。 1234567891011121314151617181920212223242526/** * @author mghio * @date: 2019-12-29 * @version: 1.0 * @description: 通过反射获取泛型信息 * @since JDK 1.8 */public class ReflectGenericDemoTests &#123; @Test public void testFieldGenericType() throws NoSuchFieldException &#123; Class&lt;ReflectGenericDemo&gt; reflectClass = ReflectGenericDemo.class; Field field = reflectClass.getDeclaredField("stringList"); Type type = field.getGenericType(); if (type instanceof ParameterizedType) &#123; ParameterizedType fieldGenericType = (ParameterizedType) type; Type[] fieldGenericTypes = fieldGenericType.getActualTypeArguments(); for (Type genericType : fieldGenericTypes) &#123; Class fieldGenericTypeClass = (Class) genericType; System.out.println(fieldGenericTypeClass); &#125; &#125; &#125;&#125; 运行结果 1class java.lang.Integer 数组 fieldGenericTypes 只有一个元素，它代表类 Integer 的 Class 类的实例。我们可以得出通过反射获取泛型信息的套路都是先获取 Class 类对象，然后通过该对象获取相应的类，如果是要获取变量的泛型信息就先获取到 Field 类，如果是要获取方法的泛型信息就先获取到 Method 类，最后再通过是否是 ParameterizedType 的实例来判断是否是泛型类型。 总结我们介绍了 Java 泛型的基本使用，反射可能在我们日常的工作中不怎么接触到，但是，在很多框架中都有运用，比如，Spring 的 IOC/DI 也是反射；还有 JDBC 的 classForName 也是反射。所有深入了解 Java 反射机制很有必要。 方法 描述 Constructor getConstructor(Class[] params) 根据构造方法的参数，返回一个 public 类型的构造方法 Constructor getConstructors() 返回所有 public 类型的构造方法数组 Constructor getDeclaredConstructor(Class[] params) 根据构造方法的参数，返回一个具体的构造方法（所有的类型） Constructor getDeclaredConstructors() 返回该类中所有的构造方法数组（所有的类型） Method getMethod(String name, Class[] params) 根据方法名和参数，返回一个 public 类型的方法 Method[] getMethods() 返回所有 public 类型的方法数组 Method getDeclaredMethod(String name, Class[] params) 根据方法名和参数，返回一个具体的方法（所有的类型） Method[] getDeclaredMethods() 返回该类中的所有的方法数组（所有的类型） Field getField(String name) 根据变量名，返回一个 public 类型的成员变量 Field[] getFields() 返回 public 类型的成员变量的数组 Field getDeclaredField(String name) 根据变量名，返回一个成员变量（所有的类型） Field[] getDelcaredField() 返回所有成员变量组成的数组（所有的类型）]]></content>
      <categories>
        <category>Java</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用命令]]></title>
    <url>%2Fpost%2F817c7d82.html</url>
    <content type="text"><![CDATA[1.1 前言作为 Java 后端开发的我们，开发的项目绝大部分都是部署在 Linux 系统上的，因此熟练使用一些常用的 Linux 命令不管是对于日常开发、服务部署或者查找问题都非常有用。以下整理了一些常用的 Linux 常用命令。 1.2 文件管理1.2.1 ls 命令ls 命令是 Linux 最常用的命令之一，其功能是列出指定目录下的内容及其相关属性信息。默认状态下，ls 命令会列出当前目录的内容，它也可以带上一些参数来实现更多的功能。语法格式：ls [选项] [文件]常用参数 参数 描述 -a 显示所有文件及目录（包括以 . 开头的隐藏文件） -l 使用长格式列出文件及目录 -r 将文件以相反次序显示（默认按照英文字母次序） -t 根据最后的修改时间排序 -A 同 -a，但是不列出 .（当前目录）以及 ..（父级目录） -S 根据文件大小排序 -R 递归列出所有子目录 Examples 12345ls -a # 列出所有文件（包括隐藏文件）ls -l # 列出文件的详细信息ls / # 列出根目录（/）下的所有目录ls -ltr s* # 列出当前目录下所有名称是 s 开头的文件ls -AS # 列出当前目录下所有文件及目录并以文件大小进行排序 1.2.2 chown 命令Linux 是一种多用户多任务的操作系统，所有的文件都有一个拥有者。chown 命令就是用来将指定文件的拥有者改为指定的用户或者组（PS：用户和组都可以是名称或者其 ID），文件是以空格分开的要改变权限的文件列表，支持通配符。语法格式：chown [参数]常用参数 参数 描述 -R 对当前目录下的所有文件与子目录进行相同的拥有者变更 -c 若该文件拥有者确实已经更改，才显示其更改动作 -f 若该文件拥有者无法更改也不显示错误信息 -v 显示拥有者变更的详细信息 –version 显示版本 Examples 123456789101112131415# 将 change_usergroup_and_user_demo.txt 文件用户组与用户都改为 mghio[root@mghio ~]# ll change_usergroup_and_user_demo.txt-rw-r--r-- 1 root root 56 Dec 21 10:17 change_usergroup_and_user_demo.txt[root@mghio ~]# chown mghio:mghio change_usergroup_and_user_demo.txt[root@mghio ~]# ll change_usergroup_and_user_demo.txt-rw-r--r-- 1 mghio mghio 56 Dec 21 10:17 change_usergroup_and_user_demo.txt# 显示其更改动作[root@mghio ~]# ll change_usergroup_and_user_demo.txt-rw-r--r-- 1 root root 45 Dec 21 10:30 change_usergroup_and_user_demo.txt[root@mghio ~]# chown -c mghio:mghio change_usergroup_and_user_demo.txtchanged ownership of 'change_usergroup_and_user_demo.txt' to mghio:mghio 1.2.3 cp 命令cp 命令为英文单词 copy 的缩写，功能为复制文件或目录。cp 命令可以将多个文件复制到一个具体的文件名或者一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。语法格式：cp [参数] [文件]常用参数 参数 描述 -f 若目标文件已经存在，则直接覆盖原文件 -i 若目标文件已经存在，则会询问是否覆盖 -p 保留原文件或者目录的属性 -r 递归复制文件和目录 -d 当复制符号链接时，把目标文件或者目录也建立符号链接，并指向和原文件或目录连接的原始文件或目录 -l 对原文件建立连接，而非复制文件 -s 对原文件建立符合连接，而非复制文件 -b 覆盖已经存在的文件目标前将目标文件备份 -v 详细显示 cp 命令的执行过程 Examples 12345678# 复制目录cp -R source_dir1 dest_dir2/# 将文件 demo1.txt 改名为 demo2.txtcp -f demo1.txt demo2.txt# 复制多个文件cp -r file1 file2 file3 dest_dir 1.2.4 mkdir 命令mkdir 命令是 make directories 的缩写，其功能是用来创建目录。默认状态下，如果要创建的目录如果已经存在，则提示已存在，而不会继续创建目录。所有我们在创建目录时，应该要保证新建的目录与它所在的目录下的文件没有重名，同时该命令还可以一次性创建多个目录。语法格式：mkdir [参数] [目录]常用参数 参数 描述 -p 递归创建多级目录 -m 建立目录的同时设置目录的权限 -v 显示目录的常见过程 Examples 1234567891011# 在当前目录下，创建一个名为 dir 的子目录mkdir dir# 在目录 /usr/mghio 下建立子目录 dir，并且设置文件属主有读（4）、写（2）和执行（1）权限，其它用户无法访问mkdir -m 700 /usr/mghio/dir# 一次性创建目录 dir1、dir2、dir3mkdir dir1 dir2 dir3# 递归创建目录mkdir -p /mghio/dir 1.2.5 mv 命令mv 命令为英文单词 move 的缩写，功能为移动文件或者对文件重新命名。mv 与 cp 命令的结果不同。mv 命令是将文件整个移走，文件名发生改变，但是个数没有增加。而 cp 命令是对文件进行复制操作，文件个数增加。语法格式：mv [参数]常用参数 参数 描述 -i 若存在同名文件，则会询问是否覆盖 -f 覆盖已经存在的文件时，不进行任何提示 -b 当文件存在时，覆盖前为其创建一个备份 -u 当原文件比目标文件新或者目标文件不存在时，才会执行 Examples 12345678# 将文件 file1 重命名为 file2mv file1 file2# 将文件 file 移动到目录 dest_dirmv file /dest_dir# 将目录 dir 下的所有文件移到当前目录mv /dir/* . 1.3 文档编辑1.3.1 cat 命令在 Linux 系统中有很多用于查看文件内容的命令，cat 命令就是用来查看内容较少的纯文本内容文件的。当文件内容较大时，文本内容会在屏幕上快速滚屏，我们通常都看不到所显示的内容。对于较长文件内容可以按 Ctrl+S 键来停止滚屏，以及 Ctrl+Q 键来恢复滚屏，按 Ctrl+C（中断）键则可以终止该命令的执行。对于大文件，推荐使用下文说的 more 命令。语法格式：cat [参数] [文件]常用参数 参数 描述 -n 显示行数（一个空行显示一个编号） -s 显示行数（多个空行只算一个编号） -b 显示行数（空行不编号） -E 每行结束显示 $ 符号 -T 将 TAB 字符显示为 ^| 符号 –version 显示版本信息 Examples 1234567891011121314151617# 查看文件内容 cat demo.txt# 查看文件内容，并显示行号cat -n demo.txt# 产查看文件的内容，并添加行数编号后输出到另外一个文件中cat -n mghio.log &gt; mghio_with_line_number.log# 清空文件内容cat /dev/null &gt; /mghio/demo.txt# 持续写入文件内容，直到碰到 `EOF` 符号后结束并保存cat &gt; demo.txt &lt;&lt; EOF&gt; Hello, World&gt; mghio&gt; EOF 1.3.2 more 命令more 命令用于将内容较长的文本文件内容（无法在一屏显示完）进行分屏显示，并且支持显示时定位关键字。对于内容比较少的文本内容推荐使用 cat 命令查看。语法格式：more [参数] [文件]常用参数 参数 描述 -num 指定每屏显示的内容行数 -l more 在通常情况下把 ^L 当遇到这个字符就会暂停，这个参数可以屏蔽这个特性 -f 计算实际的行数，而非自动换行的行数 -p 先清除屏幕在显示文本文件的剩余内容 -c 与 -p 相似，不滚屏，先显示内容在清除内容 -s 多个空行压缩成一行显示 -u 禁止下划线 +/pattern 在每个文档显示前搜寻该字（pattern），然后该字串之后开始显示 +num 从第 num 行开始显示 查看时的命令操作 命令 描述 Space 键 显示文本的下一屏内容 Enter 键 向下 n 行，需要定义，默认为 1 行 \ 键 接着输入一个模式，可以在文本中寻找下一个相匹配的模式 H 键 显示帮助屏 B 键 显示上一屏内容 Q 键 退出 more 命令 Ctrl + F、空格键 向下滚动一屏 Ctrl + B 返回上一屏 = 输出当前的行号 :f 输出文件名和当前的行号 V 调用 vi 编辑器 ! 调用 Shell， 并执行命令 Examples 1234567891011# 显示文件 demo.txt 的内容和已显示的百分比，显示之前先清屏more -dc demo.txt# 显示文件 demo.txt 的内容，每 10 行显示一次，而且在显示之前先清屏more -c -10 demo.txt# 显示文件 demo.txt 的内容，每 5 行显示一次，而且在显示之后再清屏more -p -5 demo.txt# 从第 20 行开始显示文件 demo.txt 的内容more +20 demo.txt 1.3.3 tail 命令tial 命令用于显示文件尾部的内容，默认在屏幕上显示指定文件的末尾 10 行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题，如果没有指定文件或者文件名为 -，则读取标准输入。语法格式：tail [参数]常用参数 命令 描述 –retry 即是在 tail 命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与 —f 一起使用 -c 输出文件尾部的 N（N 为整数） 个字节内容 -f 显示文件最新追加的内容 -n 输出文件的尾部 N（N 为整数） 行内容 Examples 12345678# 显示文件 demo.txt 的最后 10 行tail demo.txt# 显示文件 demo.txt 的内容，从第 20 行至文件末尾tail +20 demo.txt# 显示文件 demo.txt 的最后 10 个字符tail -c 10 demo.txt 1.3.4 grep 命令grep 是英文 global search regular expression and print out the line 的简称。是全面搜索正则表达式，并将其打印出来。这个命令可以结合正则表达式使用，使用非常广泛。grep 命令的选项用于对搜索过程的补充，而其命令的模式十分灵活，可以是变量、字符串、正则表达式，需要注意的是，当我们的模式中包含了空格的话，要使用双引号将其引起来。语法格式：grep [参数]参数列表 命令 描述 -i 搜索时，忽略大小写 -c 只输出匹配行的数量 -l 只列出符合匹配的文件名，不列出具体匹配行 -n 列出所有匹配行，显示行号 -h 查询多文件时不显示文件名 -s 不显示不存在、没有匹配文本的错误信息 -v 显示不包含匹配文本的所有行 -w 匹配整词 -x 匹配整行 -r 递归搜索 -q 禁止输出任何结果，已退出状态表示搜索是否成功 -b 打印匹配行距文件头部的偏移量（以字节为单位） -o 与 -b 结合使用，打印匹配的词距文件头部的偏移量（以字节为单位） Examples 12345678910111213141516171819# 支持多文件查询并支持使用通配符[root@mghio ~]# grep mghio file_* /usr/demofile_1:mghiofile_1:mghioddkjflkdjfdlkfjlsdkjfile_2:mghiofile_4:dkfjlmghioejfkdsfile_4:mghio djftgffile_4:twetmghioedkfgj# 列出所有的匹配行，并显示行号[root@mghio ~]# grep mghio file_* /usr/demofile_1:1:mghiofile_1:3:mghioddkjflkdjfdlkfjlsdkjfile_2:4:mghiofile_4:8:dkfjlmghioejfkdsfile_4:11:mghio djftgffile_4:20:twetmghioedkfgj 1.3.5 echo 命令echo 命令用于在终端设备上输出字符串或者变量提取后的值，这是在 Linux 系统中最常用的几个命令之一，在 Linux 系统中，人们一般使用在变量前加上 $ 符号的方式提取出变量的值，例如：$PATH，然后再用 echo 命令予以输出。或者直接使用 echo 命令输出一段字符串到屏幕上，起到给用户提示的作用。语法格式：echo [参数] [字符串]常用参数 命令 描述 -n 不输出结尾的换行符 -e”\a” 发出警告音 -e”\b” 删除前面的一个字符 -e”\c” 结尾不加换行符 -e”\f” 换行，光标仍然停留在原来的坐标位置 -e”\n” 换行，光标移至行首 -e”\r” 光标移至首行，但是不换行 -E 禁止反斜杠转义，与 -e 参数功能相反 Examples 123456789101112131415# 输出一段字符串[root@mghio ~]# echo "mghio.cn" mghio.cn# 输出变量提取后的值[root@mghio ~]# echo $PATH/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin# 对内容进行转义，不让$符号的提取变量值功能生效[root@mghio ~]# echo \$PATH$PATH# 使用反引号符执行命令，并输出其结果到终端[root@mghio ~]# echo `date`Sat Dec 21 15:30:24 CST 2019 1.4 网络通讯1.4.1 ssh 命令ssh 命令是 openssh 套件中的客户端连接工具，可以给予 ssh 加密协议实现安全的远程登录服务器，实现对服务器的管理。语法格式：ssh [参数] [主机]常用参数 命令 描述 -1 强制使用 ssh 协议版本 1 -2 强制使用 ssh 协议版本 2 -4 强制使用 IPv4 地址 -6 强制使用 IPv6 地址 -A 开启认证代理连接转发功能 -a 关闭认证代理连接转发功能 -b&lt;IP地址&gt; 使用本机指定的地址作为对位连接的源 IP 地址 -C 请求压缩所有数据 -F&lt;配置文件&gt; 指定 ssh 指令的配置文件，默认的配置文件为 /etc/ssh/ssh_config -f 后台执行 ssh指令 -g 允许远程主机连接本机的转发端口 -i&lt;身份文件&gt; 指定身份文件（即私钥文件） -l&lt;登录名&gt; 指定连接远程服务器的登录用户名 -N 不执行远程指令 -o&lt;选项&gt; 指定配置选项 -p&lt;端口&gt; 指定远程服务器上的端口 -q 静默模式，所有的警告和诊断信息被禁止输出 Examples 12345# 登录远程服务器[root@mghio ~]# ssh 112.67.239.127# 用 mghio 用户连接远程服务器[root@linuxcool ~]# ssh -l mghio 112.67.239.127 1.4.2 sftp 命令sftp 命令全称是 Secure File Transfer Protocol。是一个交互式的文件传输程序，sftp 命令的运行和使用与 ftp 相似，但是 sftp 命令对传输的所有信息使用 ssh 加密 ，它还支持公钥认证和压缩等功能。语法格式：sftp [参数] [IP或主机名]常用参数 命令 描述 -B 指定传输文件缓冲区的大小 -l 使用 ssh 协议版本 1 -b 指定批处理文件 -C 使用压缩 -o 指定 ssh 选项 -F 指定 ssh 配置文件 -R 指定一次可以容忍多少请求数 Examples 12345678# 使用 sftp 命令连接到服务器[root@mghio ~]# sftp 112.67.239.127# 指定传输文件是缓冲区大小[root@mghio ~]# sftp -B 256 112.67.239.127# 在传输过程中使用压缩[root@linuxcool ~]# sftp -C 112.67.239.127 1.4.3 telnet 命令telnet 命令的功能是远端登入，执行 telnet 指令开启终端机阶段作业，并登入远端主机。telnet 命令可以帮助你从这台路由器远程登陆到远端开启了 telnet 服务的设备，包括路由器、交换机、Linux 服务器等，并且配置当前路由器的 telnet 服务。语法格式：telnet [参数]常用参数 命令 描述 -8 允许使用 8 位字符资料，包括输入与输出 -a 尝试自动登入远端系统 -b 使用别名指定远端主机名称 -c 不读取用户专属目录里的 .telnetrc 文件 -d 启动排错模式 -e 设置脱离字符 -E 滤除脱离字符 -f 此参数的效果和指定 -F 参数相同 -F 使用 Kerberos V5 认证时，加上此参数可把本地主机的认证数据上传到远端主机 -k 使用 Kerberos 认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名 -K 不自动登入远端主机 -l 指定要登入远端主机的用户名称 -L 允许输出8位字符资料 -n 指定文件记录相关信息 -r 使用类似 rlogin 指令的用户界面 -S 设置 telnet 连线所需的 IP TOS 信息 -x 假设主机有支持数据加密的功能，就使用它 -X 关闭指定的认证形态 Examples 12345# 登录远程主机[root@mghio ~]# telnet 112.67.239.127# 连接本地主机，端口号为 23[root@mghio ~]# telnet localhost 23 1.4.4 netstat 命令netstat 命令用于显示各种网络相关信息，如网络连接、路由表、接口状态、多播成员等。从整体上看，netstat 的输出结果为两部分：一个是 Active Internet connections 称为 有源 TCP 连接，其中 Recv-Q 和 Send-Q 指 %OA 的是接收队列和发送队列。另一个是 Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。语法格式：netstat [参数]常用参数 命令 描述 -a 显示所有连线中的 Socket -p 显示正在使用 Socket 的程序识别码和程序名称 -u 显示 UDP 传输协议的连线状况 -i 显示网络界面信息表单 -n 直接使用 IP 地址，不通过域名服务器 Examples 123456789101112# 显示详细的网络状况[root@mghio ~]# netstat -a# 显示当前 UDP 连接状况[root@mghio ~]# netstat -nu# 显示网卡列表[root@mghio ~]# netstat -iKernel Interface table Iface MTU Met RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flg eth0 1500 0 181864 0 0 0 141278 0 0 0 BMRU lo 16436 0 3362 0 0 0 3362 0 0 0 LRU]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>Linux笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程基础（二）]]></title>
    <url>%2Fpost%2F4ea48fa7.html</url>
    <content type="text"><![CDATA[简介在上篇 Java 多线程基础（一） 我们提到了一些线程的常用方法，这篇我们具体看看其中一些方法的使用以及方法的区别，让我们在工作中更好的使用。 wait 方法与 notify 方法在 Object 类中定义了 wait 方法和 notify 方法，wait 方法的作用是让当前线程进入等待状态，将当前线程置入 预执行队列，会在 wait 方法所在代码处停止执行，直到被通知或者被中断，在调用 wait 方法之前，线程必须获取该对象的锁，因此只能在同步方法或者同步代码块中调用 wait 方法，并且该方法会释放当前线程锁持有的锁。notify 方法是唤醒在当前对象上等待的单个线程，如果有多个线程等待，那么线程调度器会挑出一个 wait 的线程，对其发出 notify ，并使它等待获取该对象的对象锁，这意味着，即使收到了通知，线程也不会立即获取到对象锁，必须等待 notify 方法的线程释放锁才可以。和 wait 方法一样，notify 方法也只能在同步方法或者同步代码块中调用。它还有个相似的方法 notifyAll，它的作用是唤醒在当前对象上等待的所有线程。 下面通过一个生产者消费者来说明 wait 方法和 notify 方法的使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @author mghio * @date: 2019-12-14 * @version: 1.0 * @description: 线程 wait() 和 notify() 方法使用示例 * @since JDK 1.8 */public class ThreadWaitAndNotifyDemo &#123; public static void main(String[] args) &#123; Producer producer = new Producer(); producer.start(); new Consumer("Consumer One", producer).start(); new Consumer("Consumer Two", producer).start(); new Consumer("Consumer Three", producer).start(); new Consumer("Consumer Four", producer).start(); &#125; static class Producer extends Thread &#123; List&lt;String&gt; messageList = new ArrayList&lt;&gt;(2); @Override public void run() &#123; try &#123; while (true) &#123; Thread.sleep(2000); synchronized (messageList) &#123; String message = String.format("producer message [create time:%s]", LocalDateTime.now()); messageList.add(message); System.out.println("Producer " + getName() + " producer a msg: " + message); messageList.notify(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; String getMessage() &#123; synchronized (messageList) &#123; if (messageList.size() == 0) &#123; try &#123; messageList.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return messageList.remove(0); &#125; &#125; &#125; static class Consumer extends Thread &#123; private Producer producer; public Consumer(String name, Producer producer) &#123; super(name); this.producer = producer; &#125; @Override public void run() &#123; while (true) &#123; String message = producer.getMessage(); System.out.println("Consumer " + getName() + " get a msg: " + message); &#125; &#125; &#125;&#125; 输出结果如下： 12345678Producer Thread-0 producer a msg: producer message [create time:2019-12-14T22:45:42.319]Consumer Consumer One get a msg: producer message [create time:2019-12-14T22:45:42.319]Producer Thread-0 producer a msg: producer message [create time:2019-12-14T22:45:44.324]Consumer Consumer Two get a msg: producer message [create time:2019-12-14T22:45:44.324]Producer Thread-0 producer a msg: producer message [create time:2019-12-14T22:45:46.325]Consumer Consumer Three get a msg: producer message [create time:2019-12-14T22:45:46.325]Producer Thread-0 producer a msg: producer message [create time:2019-12-14T22:45:48.328]Consumer Consumer Four get a msg: producer message [create time:2019-12-14T22:45:48.328] 消费者线程循环调用生产者的 getMessage 方法获取消息，如果消息列表 messageList 为空，则调用消息列表的 wait 方法让线程进入等待状态，生产者每隔 2 秒生成消息并放入消息列表 messageList 中，放入成功后调用 notify 方法唤醒一个处于 wait 状态的线程去消费消息，需要注意的是，在调用 wait 和 notify 方法时必须要先获得该对象的锁，上面的示例中是在 synchronized 代码块中调用的。 sleep 方法与 wait、notify 方法不同，sleep 方法定义在 Thread 类中，从方法名也可以知道，这个方法的作用就是让当前线程休眠，即调用该方法后当前线程会从运行状态(Running）状态进入到阻塞（休眠）状态（Blocked），同时该方法必须指定休眠的时间，当前线程的休眠时间会大于或者等于这个指定的休眠时间。当线程重新被唤醒时，线程会由阻塞状态（Blocked）变成就绪状态（Runnable），然后等待 CPU 的调度执行。sleep 方法的示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author mghio * @date: 2019-12-14 * @version: 1.0 * @description: 线程 sleep() 方法使用示例 * @since JDK 1.8 */public class ThreadSleepDemo &#123; private static Object object = new Object(); public static void main(String[] args) &#123; MyThread myThreadOne = new MyThread("t1"); MyThread myThreadTwo = new MyThread("t2"); myThreadOne.start(); myThreadTwo.start(); &#125; static class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized (object) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(String.format("%s: %d", this.getName(), i)); if (i % 2 == 0) &#123; Thread.sleep(2000); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 输出结果如下： 12345678910t1: 0t1: 1t1: 2t1: 3t1: 4t2: 0t2: 1t2: 2t2: 3t2: 4 我们启动了两个线程 t1 和 t2，两个线程的 run 方法引用了同一个对象 object 的同步锁（synchronized (object)），虽然在第一个线程 t1 中当 i 被 2 整除时会调用 Thread.sleep(2000) 让当前线程休眠 2 s，但是此时线程 t2 也不会得到 cpu 的执行权去执行，因为 t1 线程调用 sleep 方法并没有释放object所持有的同步锁。如果我们注释掉 synchronized (object) 后再次执行该程序，线程 t1 和 t2 是可以交替执行的，注释之后的输出结果如下： 12345678910t2: 0t1: 0t1: 1t2: 1t1: 2t2: 2t2: 3t1: 3t2: 4t1: 4 yield 方法yield 方法定义在 Thread 类中，是线程特有的方法。此方法的主要作用是让步，它会使当前线程从运行状态（Running）变为就绪状态（Runnable），从而让其他具有同样优先级的处于就绪状态的线程获取到 CPU 执行权(PS: CPU 会从众多的处于就绪状态的线程里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到)，但是，也并不能保证在当前线程调用 yield 之后，其它哪些具有相同优先级的线程就一定能获得执行权，也有可能是当前线程又进入到运行状态（Running）继续运行。yield 方法的示例代码如下： 123456789101112131415161718192021222324252627282930313233/** * @author mghio * @date: 2019-12-14 * @version: 1.0 * @description: 线程 yield() 方法使用示例 * @since JDK 1.8 */public class ThreadYieldDemo &#123; public static void main(String[] args) &#123; MyThread myThreadOne = new MyThread("t1"); MyThread myThreadTwo = new MyThread("t2"); myThreadOne.start(); myThreadTwo.start(); &#125; static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(String.format("%s [%d] ---&gt; %d", this.getName(), this.getPriority(), i)); if (i % 2 == 0) &#123; yield(); &#125; &#125; &#125; &#125;&#125; 输出结果如下： 1234567891011121314151617181920t1 [5] ---&gt; 0t2 [5] ---&gt; 0t1 [5] ---&gt; 1t1 [5] ---&gt; 2t1 [5] ---&gt; 3t1 [5] ---&gt; 4t1 [5] ---&gt; 5t1 [5] ---&gt; 6t1 [5] ---&gt; 7t1 [5] ---&gt; 8t1 [5] ---&gt; 9t2 [5] ---&gt; 1t2 [5] ---&gt; 2t2 [5] ---&gt; 3t2 [5] ---&gt; 4t2 [5] ---&gt; 5t2 [5] ---&gt; 6t2 [5] ---&gt; 7t2 [5] ---&gt; 8t2 [5] ---&gt; 9 从以上输出结果可以看出，线程 t1 中的变量 i 在被 2 整除的时候，并没有切换到线程 t2 去执行，这也验证了我们上文说的，yield 方法虽然可以让线程由运行状态变成就绪状态，但是，它不一定会让其它线程获取 CPU 执行权从而进入到运行状态，即使这个其它线程和当前具有相同的优先级，yield 方法不会释放锁（证明方法只需将上面这个示例的 run 方法里面加上 synchronized (obj) 即可，此时 t2 线程会等到线程 t1 执行完毕后才会执行）。 join 方法在有些场景中我们需要在子线程去执行一些耗时的任务，但是我们的主线程又必须等待子线程执行完毕之后才能结束，那么此时就可以使用 join 方法了，该方法定义在 Thread 类中，方法的作用是：让主线程等待子线程执行结束之后才能继续执行，下面我们通过一个例子来看看： 123456789101112131415161718192021222324252627282930313233343536373839/** * @author mghio * @date: 2019-12-15 * @version: 1.0 * @description: 线程 join() 方法使用示例 * @since JDK 1.8 */public class ThreadJoinDemo &#123; public static void main(String[] args) &#123; try &#123; MyThread myThread = new MyThread("t1"); myThread.start(); myThread.join(); System.out.println(String.format("%s ---&gt; %s finish", LocalDateTime.now(), Thread.currentThread().getName())); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class MyThread extends Thread &#123; MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; System.out.println(String.format("%s ---&gt; %s start", LocalDateTime.now(), this.getName())); // 模拟耗时操作 try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(String.format("%s ---&gt; %s finish", LocalDateTime.now(), this.getName())); &#125; &#125;&#125; 输出结果如下： 1232019-12-15T00:22:55.971 ---&gt; t1 start2019-12-15T00:22:57.984 ---&gt; t1 finish2019-12-15T00:22:57.985 ---&gt; main finish 在主线程 main 中通过 new MyThread(&quot;t1&quot;) 新建线程 t1。 接着，通过 t1.start() 启动线程 t1，在执行 t1.join()之后， 主线程会进入阻塞状态等待 t1 运行结束。子线程 t1 结束之后，会唤醒主线程，主线程重新获取 CPU 执行权，主线程继续往下运行。在使用了 join 方法之后主线程会等待子线程结束之后才会结束。 总结以上是线程一些常用的方法介绍和具体使用知识总结。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程基础（一）]]></title>
    <url>%2Fpost%2F7eb2637f.html</url>
    <content type="text"><![CDATA[简介在接触多线程之前，在我们程序中在任意时刻都只能执行一个步骤，称之为单线程。在单线程开发的程序中所有的程序路径都是顺序执行的，前面的必须先执行，后面的才会执行。单线程的优点也很明显，相对于多线程来说更加稳定、扩展性更强、程序开发相对比较容易。但是由于每次都要等上一个任务执行完成后才能开始新的任务，导致其效率比多线程低，甚至有时候应用程序会出现假死的现象。使用多线程有利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。多线程是 Java 学习的非常重要的方面，是每个 Java 程序员必须掌握的基本技能。本文是有关 Java 多线程的一些基础知识总结。 进程与线程的区别进程进程是操作系统资源分配的基本单位，它是操作系统的基础，是一个程序及其数据在处理机上顺序执行时所发生的活动。一个程序进入内存运行，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立功能。进程的实质就是程序在操作系统中的一次执行过程，它是动态产生的、动态销毁的，拥有自己的生命周期和各种不同的运行状态。同时，进程还具有并发性，它可以同其他进程一起并发执行，按各自独立的、不可预知的速度向前推进（PS：并发性和并行性是不同的概念，并行指的是同一时刻，两个及两个以上的指令在多个处理器上同时执行。而并发指的是同一时刻只有一条指令执行，但是多个进程可以被 CPU 快速交换执行，给我们感觉好像是多个执行在同时执行一样）。 线程线程是任务调度和执行的基本单位，也被称为轻量级进程，线程由线程 ID，当前指令指针(PC），寄存器集合和堆栈组成。线程不拥有系统资源，它只会拥有一点儿在运行时必不可少的资源，但是它可以与同属于同一进程的线程共享该进程所拥有的所有资源。一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 二者的区别 调度 线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 并发性 不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 拥有资源 进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源 系统开销 在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销 创建线程的方式在 Java 中使用 Thread 类代表线程，所有的线程对象都必须是 Thread 类或者其子类的实例，Java 中创建线程主要有以下三种方式： 方式一 继承 Thread 类step 1 定义一个类继承自 Thread 类，然后重写该类的 run 方法，这个方法的内容表示线程要完成的任务step 2 创建线程对象，即创建 Thread 类子类的实例step 3 调用步骤二中创建出来的对象的 start 方法来启动线程 12345678910111213141516171819202122232425/** * @author mghio * @date: 2019-12-07 * @version: 1.0 * @description: 通过继承 Thread 类的方式创建线程 * @since JDK 1.8 */public class CreateThreadByExtendsThread extends Thread &#123; @Override public void run() &#123; IntStream.rangeClosed(1, 10).forEach(i -&gt; System.out.println(Thread.currentThread().getName() + " " + i)); &#125; public static void main(String[] args) &#123; CreateThreadByExtendsThread threadOne = new CreateThreadByExtendsThread(); CreateThreadByExtendsThread threadTwo = new CreateThreadByExtendsThread(); CreateThreadByExtendsThread threadThree = new CreateThreadByExtendsThread(); threadOne.start(); threadTwo.start(); threadThree.start(); &#125;&#125; 方式二 实现 Runnable 接口step 1 定义一个类实现 Runnable 接口，然后实现该接口的 run 方法，这个方法的内容同样也表示线程要完成的任务step 2 创建 Runnable 接口实现类的实例，并使用该实例作为 Thraed 构造方法的参数创建 Thread 类的对象，该对象才是真正的线程对象step 3 调用线程对象的 start 方法来启动该线程 12345678910111213141516171819202122/** * @author mghio * @date: 2019-12-07 * @version: 1.0 * @description: 通过实现 Runnable 接口的方式创建线程 * @since JDK 1.8 */public class CreateThreadByImplementsRunnable implements Runnable &#123; @Override public void run() &#123; IntStream.rangeClosed(1, 10).forEach(i -&gt; System.out.println(Thread.currentThread().getName() + " " + i)); &#125; public static void main(String[] args) &#123; CreateThreadByImplementsRunnable target = new CreateThreadByImplementsRunnable(); new Thread(target, "thread-one").start(); new Thread(target, "thread-two").start(); new Thread(target, "thread-three").start(); &#125;&#125; 方式三 实现 Callable 接口step 1 定义一个类实现 Callable 接口，然后实现该接口的 call 方法，这个方法的内容同样也表示线程要完成的任务，并且有返回值step 2 创建 Callable 接口实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了 Callable 对象的 call 方法的返回值step 3 并使用 FutureTask 对象作为 Thraed 构造方法的参数创建 Thread 对象，并调用该对象的 start 方法启动线程step 4 调用 FutureTask 对象的 get 方法获取线程执行结束后的返回值 123456789101112131415161718192021222324252627282930313233343536373839/** * @author mghio * @date: 2019-12-07 * @version: 1.0 * @description: 通过实现 Callable 接口的方式创建线程 * @since JDK 1.8 */public class CreateThreadByImplementsCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() &#123; AtomicInteger count = new AtomicInteger(); IntStream.rangeClosed(0, 10).forEach(i -&gt; &#123; System.out.println(Thread.currentThread().getName() + " " + i); count.getAndIncrement(); &#125;); return count.get(); &#125; public static void main(String[] args) &#123; CreateThreadByImplementsCallable target = new CreateThreadByImplementsCallable(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(target); IntStream.rangeClosed(0, 10).forEach(i -&gt; &#123; System.out.println(Thread.currentThread().getName() + " 的循环变量 i 的值" + i); if (i == 8) &#123; new Thread(futureTask, "有返回值的线程").start(); &#125; &#125;); try &#123; System.out.println("有返回值线程的返回值：" + futureTask.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 通过以上可以看出，其实通过实现 Runnable 接口和实现 Callable 接口这两种方式创建线程基本相同，采用实现 Runnable 和 Callable 接口的方式创建线程时，线程类只是实现接口，还可以继承其它类（PS：Java 单继承决定）。在这种方式下，多个线程可以共享同一个 target对象，所以非常适合多个相同线程来处理同一份资源的情况。还有一点就是，使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。，在实际项目中如果使用这三种方式创建线程，如果创建关闭频繁会消耗系统资源影响性能，而使用线程池可以不用线程的时候放回线程池，用的时候再从线程池取，所以在我们项目开发中主要还是使用线程池，有关线程池的可以看看这两篇 Java 线程池（一）、Java 线程池（二）。 线程的几种状态线程是一个动态执行的过程，它也有一个从产生到死亡的过程，在 Java 中一个线程完整的生命周期一共包含以下五种状态：新建状态（New）当使用 new 关键字和 Thread 类或其子类创建一个线程对象后，那么线程就进入了新建状态，此时它和其它的 Java 对象一样，仅仅由 JVM 分配了内存，并初始化其成员变量值，它会一直保持这个状态直到调用该对象的 start 方法。 就绪状态（Runnable）当线程对象调用了 start 方法之后，该线程就进入了就绪状态。就绪状态的线程会放在一个就绪队列中，等待 JVM 里的调度器进行调度。处于就绪状态的线程，随时可能被 CPU 调度执行。 运行状态（Running）如果就绪状态的执行被 CPU 调度执行，就可以执行 run 方法，此时线程就处于线程状态。处于运行状态的线程最复杂，它可以变为阻塞状态、就绪状态和死亡状态。需要注意一点，线程变为运行状态之前的状态只能是就绪状态。 阻塞状态（Blocked）线程变为阻塞状态是因为某种原因放弃 CPU 的使用权，暂时停止运行，如果执行了 sleep、suspend 等方法，释放了所占用的资源之后，线程就从运行状态进入阻塞状态。等待睡眠时间结束或者获得设备资源之可以重新进入就绪状态。阻塞可以分为以下三种： 等待阻塞 处于运行状态的线程调用wait方法，会使线程进入等待阻塞状态 同步阻塞 当线程获取 synchronized 同步锁因为同步锁被其他线程占用而失败后，会使线程进入同步阻塞 其它阻塞 通过调用线程的sleep或join发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep状态超时，join等待线程终止或超时，或者 I/O 处理完毕，线程重新回到就绪状态。 死亡状态（Dead）一个处于运行状态的线程执行完了 run 方法或者因为其它终止条件发生时，线程就会进入到死亡状态，该线程结束生命周期。以上线程各种状态的流转用一张图表示如下： 线程常用方法线程中常用的方法按照来源可以分为两类，一类是继承自 Object 类的方法，如下所示： 方法 描述 public final native void notify() 唤醒在此对象监视器上等待的单个线程，使其进入就绪状态 public final native void notifyAll() 唤醒在此对象监视器上等待的所有线程，使其进入就绪状态 public final void wait() 让当前线程处于·等待阻塞状态，直到其他线程调用此对象的notify方法或notifyAll方法，当前线程被唤醒，会释放它所持有的锁 public final native void wait(long timeout) 让当前线程处于·等待阻塞状态，直到其他线程调用此对象的notify方法或notifyAll方法，当前线程被唤醒 public final void wait(long timeout, int nanos) 让当前线程处于·等待阻塞状态，直到其他线程调用此对象的notify方法或notifyAll方法或者其他某个线程中断当前线程，或者已超过某个实际时间量，当前线程被唤醒 另一类是 Thread 类定义的方法，如下所示： 方法 描述 public static native void yield() 暂停当前正在执行的线程对象，并执行其他线程，yield 方法不会释放锁 public static native void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），sleep 方法不会释放锁 public final void join() 当某个程序执行流中调用其他线程的 join 方法时，调用线程将被阻塞，直到被 join 的线程执行完毕 public void interrupt() 用于中断本线程，这个方法被调用时，会立即将线程的中断标志设置为 true public static boolean interrupted() Thread 类的一个静态方法，它返回一个布尔类型指明当前线程是否已经被中断，interrupted 方法除了返回中断标记之外，它还会清除中断标记(即将中断标记设为 false) public boolean isInterrupted() Thread 类的一个实例方法，它返回一个布尔类型指明当前线程是否已经被中断，isInterrupted 方法仅仅返回中断标记，不会清楚终端标记 线程的优先级每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 线程的优先级是一个整数，其取值范围是1（Thread.MIN_PRIORITY ）~ 10（Thread.MAX_PRIORITY ）。默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源，Thread 类提供了 setPriority 和 getPriority 方法来更改和获取线程优先级（需要注意的是: 线程优先级不能保证线程执行的顺序，而且非常依赖于平台）。 参考文章 进程和线程的区别 Java多线程系列–“基础篇”05之 线程等待与唤醒]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程池（二）]]></title>
    <url>%2Fpost%2Fab706eb5.html</url>
    <content type="text"><![CDATA[简介在上篇 Java 线程池（一） 我们介绍了线程池中一些的重要参数和具体含义，这篇我们看一看在 Java 中是如何去实现线程池的，要想用好线程池，只知其然是远远不够的，我们需要深入实现源码去了解线程池的具体实现细节，这样才能更好的使用到我们的工作中，当出现问题时能快速找到问题根源所在。 线程池如何处理提交的任务我们向线程池提交任务有两种方式，分别是通过 submit 方法提交和通过 execute 方法提交，这两种方式的区别为 execute 只能提交 Runnable 类型的任务并且没有返回值，而 submit 既能提交 Runnable 类型的任务也能提交 Callable（JDK 1.5+）类型的任务并且会有一个类型 Future 的返回值，我们知道 Runnable 是没有返回值的，所以只有当提交 Callable 类型的任务时才会有返回值，而提交 Runnable 的返回值是 null。 execute 执行任务时，如果此时遇到异常会直接抛出，而 submit 不会直接抛出，只有在使用 Future 的 get 方法获取任务的返回结果时，才会抛出异常。通过查看 ThreadPoolExecutor 的源码我们发现，其 submit 方法是继承自其抽象父类 AbstractExecutorService 而来的，有三个重载的方法，分别可以提交 Runnable 类型和 Callable 类型的任务。无论是哪个 submit 方法最终还是调用了 execute 方法来实现的。方法源码如下： 1234567891011121314151617181920public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); execute(ftask); return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask;&#125; 首先对提交的任务进行判非空指针后，三个方法都是调用 newTaskFor 方法把任务统一封装成 RunnableFuture 对象，然后把封装好的对象作为 execute 方法的入参去执行，而此时 execute 方法还未实现，这个方法是在 AbstractExecutorService 的继承类 ThreadPoolExecutor 中实现。下面看看 newTaskFor 方法是如何封装我们提交的任务的，两个重载方法的源码如下： 1234567protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value);&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable);&#125; 那么这个 FutureTask 是个什么东东呢，进入其源码发现它实现了 RunnableFuture 接口，而 RunnableFuture 接口的作用正如其名，它是 Runnable 和 Future 的结合体，表示一个能异步返回结果的线程。我们知道 Runnable 是不能返回结果的，所以上面第一个 newTaskFor(Runnable runnable, T value) 方法的第二个参数 value 的作用就是指定返回结果。其实最后也是通过 RunnableAdapter 把 Runnable 和 value 封装成 Callable 的。下面我们看看 execute 方法是怎么处理的，方法源码如下： 第 ① 步 获取当前的 ctl 值，在上篇 Java 线程池（一） 中说过，变量 ctl 存储了线程池的工作状态 runState 和线程池中正在运行的线程数 workerCount。第 ② 步 通过 workerCountOf 方法取出线程池中当前正在运行的线程数( ctl 低 29 位的值)，如果线程池当前工作线程数小于核心线程数 corePoolSize，则进行第 ③ 步。第 ③ 步 通过 addWorker 方法新建一个线程加到线程池中，addWorker 方法的第二个参数如果为 true 则限制添加线程的数量是根据 corePoolSize 来判断，反之则根据 maximumPoolSize 来判断，并把任务添加到该线程中。第 ④ 步 如果添加失败，则重新获取 ctl 的值。第 ⑤ 步 如果当前线程池的状态是运行状态（state &lt; SHUTDOWN）并且把任务成功添加到队列中。第 ⑥ 步 重新获取 ctl 的值，再次判断线程池的运行状态，如果不是运行状态，要从队列中移除任务，因为到这一步了，意味着之前已经把任务成功添加到队列中了，所以需要从队列移除。移除成功后调用拒绝策略对任务进行处理，整个 execute 方法结束（PS：为什么不在入队列之前就先判断线程池的状态呢？因为判断一个线程池工作处于运行状态到执行入队列操作这段时间，线程池可能已经被其它线程关闭了，所以提前判断其实毫无意义）。第 ⑦ 步 通过 workerCountOf 方法取出线程池中当前正在运行的线程数( ctl 低 29 位的值)，如果是 0 则执行 addWorker(null, false) 方法，第一个参数传 null 表示只是在线程池中创建一个线程出来，但是没有立即启动，因为我们创建线程池时可能要求核心线程数量为 0。第二个参数为 false 表示限制添加线程时根据 maximumPoolSize 来判断，如果当前线程池中正在运行线程数量大于 0 ，则直接返回，因为在上面第 ⑤ 步已经把任务成功添加到队列 workQueue 中，它会在将来的某个时刻执行到。第 ⑧ 步 如果执行到这个地方，只有两种情况，一种是线程池的状态已经不是运行状态了，另一种是线程池是运行状态，但是此时线程池的工作线程数大于等于核心线程数（workerCount &gt;= corePoolSize）并且队列 workQueue 已满。这时会再次调用 addWorker 方法，第二个参数传的 false，意味着限制添加线程的数量是根据 maximumPoolSize 来判断的，如果失败则调用拒绝策略对任务进行处理，整个 execute 方法结束。上面的 execute 方法中多次调用 addWorker，该方法的主要作用就是创建一个线程来执行任务。addWorker 的方法签名如下： 1addWorker(Runnable firstTask, boolean core) 第一个参数 firstTask 如果不为 null，则创建的线程首先执行 firstTask 任务，然后才会从队列中获取任务，否则会直接从队列中获取任务。第二个参数如果为 true，则表示限制添加线程时根据 corePoolSize 来判断，否则根据maximumPoolSize 来判断。我们看看 addWorker 方法的源码，方法源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 方法首先获取线程池 ctl 属性的值，该属性包含了线程池的运行状态和工作线程数，通过 runStateOf 获取线程池的运行状态，然后执行下面这个比较复杂的条件判断 第 ① 个条件表示此时线程池已经不再接受新任务了，接下来的 ②、③、④ 三个判断条件只要有一个不满足，那么方法就会返回 false，方法结束。第 ② 个条件表示线程池为关闭状态，处于关闭状态的线程池不会处理新提交的任务，但会处理完已处理的任务，第 ③ 个条件为 firstTask 为 null，第 ④ 个条件为队列不为空。我们看看如果线程池此时为关闭状态的情况，这种情况线程池不会接受新提交的任务，所以此时如果传入的 firstTask 不为 null，则会直接返回 false；然后如果 firstTask 为 null，并且队列 workQueue 为空，此时也会返回 false，因为此时队列里已经没有任务了，那么也不需要再添加线程了，然后接下来会进入一个循环。 第 ① 步 调用 workerCountOf 方法获取当前线程池的工作线程数第 ② 步 如果当前线程池的工作数大于 CAPACITY 也就是 ctl 的低 29 位的最大值，则返回 false，如果不大于 CAPACITY，然后根据 core （该方法的第二个参数）来判断是和 corePoolSize 比较还是和 maximumPoolSize 比较，如果比这个值大则返回 false。第 ③ 步 使用 ctl 的 compareAndSet 原子方法尝试把工作线程数 workerCount + 1，如果增加成功，退出第一层循环。第 ④ 步 如果增加线程池工作线程数失败，则重新获取 ctl 的值。第 ⑤ 步 调用 runStateOf 获取线程池的状态，如果不等于方法前面获取的 rs，说明线程池的状态已经改变了，回到第一层循环继续执行。接下来会启动线程执行任务，源码如下： 第 ① 步 根据 firstTask 创建 Worker 对象，每一个 Worker 对象都会创建一个线程，然后会使用重入锁 ReentrantLock 进行加锁操作。第 ② 步 调用 runStateOf 获取线程池的状态，然后进行一个条件判断，第一个 rs &lt; SHUTDOWN 表示线程池是运行状态。如果线程池是运行状态或者线程池是关闭状态并且 firstTask 为 null，那么就往线程池中加入线程（因为当线程池是 SHUTDOWN 状态时不会再向线程池添加新的任务，但会执行队列 workQueue 中的任务）。这里的 workers 是一个 HashSet，所以其 add 方法不是线程安全的，所以需要加锁操作。然后修改线程池中出现过的最大线程数量 largestPoolSize 记录和把是否添加成功标记 workerAdded 为 true。如果 workerAdded 为 true 那么会启动线程并把线程是否启动标记 workerStarted 改为 true。第 ③ 步 根据线程是否启动 workerStarted 标记来判断是否需要进行失败的操作。包含从 workers 移除当前的 worker、线程池的工作线程数减 1、尝试终端线程池。 线程池中线程是如何执行的线程池的线程执行是调用 Worker 的 thread 属性的 start 方法，而 thread 的 run 方法实际上调用了 Worker 类的 runWorker 方法，所以我们直接来看看 runWorker 方法的源码： 第 ① 步 获取第一个任务，while 循环不断地通过 getTask 方法从队列中获取任务。第 ② 步 这个判断条件目的是要保证如果线程池正在停止，要保证当前线程是中断状态，如果是的话，要保证当前线程不是终端状态。第 ③ 步 方法 beforeExecute 方法在类 ThreadPoolExecutor 中没有做任何操作，是留给子类去自定义在线程执行之前添加操作的方法。第 ④ 步 执行 task.run() 执行任务（PS：这里为什么是调用 run 方法而不是调用 start 方法呢？我们知道当调用了 start 方法后操作系统才会给我们创建一个独立的线程来运行，而调用 run 方法只是一个普通的方法调用，而线程池正好就是需要它是一个普通的方法才能进行任务的调度。我们可以想象一下，假如这里是调用的 Runnable 的 start 方法，那么会是什么结果呢。如果我们往一个核心线程数、最大线程数为 3 的线程池里丢了 500 个任务，那么它会额外的创建 500 个线程，同时每个任务都是异步执行的，结果一下子就执行完毕了，根本无法对任务进行调度。从而没法做到由这 3 个 Worker 线程来调度这 1000 个任务，而只有当做一个普通的 run 方法调用时才能满足线程池的这个要求）。第 ⑤ 步 方法 afterExecute 方法在类 ThreadPoolExecutor 中没有做任何操作，是留给子类去自定义在线程执行之后添加操作的方法。completedAbruptly 变量是用来表示在执行任务过程中是否出现了异常，processWorkerExit 方法中会对该变量的值进行判断。接下来我们看看 getTask 方法是如何从队列中获取任务的，方法源码如下： 第 ① 步 如果线程池不是运行状态，则判断线程池是否正在停止或者当前队列为空，如果条件满足将线程池的工作线程数减一并返回 null。因为如果当前线程池状态的值是 SHUTDOWN 或以上时，就不允许再向队列中添加任务了。第 ② 步 这里的 timed 变量用来标记是否需要线程进行超时控制，allowCoreThreadTimeOut 默认是 false，也就是核心线程不允许进行超时。wc &gt; corePoolSize 表示当前线程池中的工作线程数量大于核心线程数量，对于超过核心线程数量的这些线程，需要进行超时控制。第 ③ 步 第一个判断 wc &gt; maximumPoolSize 如果成立是因为可能在此方法执行阶段同时执行了线程池的 setMaximumPoolSize 方法；第二个判断 timed &amp;&amp; timedOut 如果成立表示当前操作需要进行超时控制，并且上次从队列中获取任务发生了超时（timeOut 变量的值表示上次从阻塞队列中取任务时是否超时）；第三个判断 wc &gt; 1 || workQueue.isEmpty() 如果线程池中工作线程数量大于 1，或者队列是空的，那么尝试将 workerCount 减一，如果减一失败，则返回重试。如果 wc == 1 时，也就说明当前线程是线程池中唯一的一个线程了。第 ④ 步 根据 timed 来判断，如果为 true，则通过阻塞队列的 poll 方法进行超时控制，如果在 keepAliveTime 时间内没有获取到任务，则返回 null，否则通过 take 方法，如果这时队列为空，则 take 方法会阻塞直到队列不为空。如果 r == null，说明已经超时，timedOut 设置为 true。第 ⑤ 步 如果获取任务时当前线程发生了中断，则设置 timedOut 为 false 并重新循环重试。 关闭线程池线程池的关闭一般都是使用 shutdown 方法和 shutdownNow 方法，两者的区别是前面的 shutdown 方法不会执行新的任务，但是会执行完当前正在执行的任务，而后面的 shutdownNow 方法会立即停止当前线程池，不管当前是否有线程在执行。一般都是使用 shutdown 方法来停止线程池，其方法源码如下： 12345678910111213public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();&#125; advanceRunState(SHUTDOWN) 方法的作用是通过 CAS 原子操作将线程池的状态更改为关闭状态。interruptIdleWorkers 方法是对空闲的线程进行中断，其实是调用重载带参数的函数 interruptIdleWorkers(false)。然后 onShutdown 方法和上文提到的 beforeExecute、afterExecute 方法一样，在类 ThreadPoolExecutor 是空实现，也是个钩子函数。我们看看 interruptIdleWorkers 的实现源码： 123456789101112131415161718192021private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; for (Worker w : workers) &#123; Thread t = w.thread; if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; w.unlock(); &#125; &#125; if (onlyOne) break; &#125; &#125; finally &#123; mainLock.unlock(); &#125;&#125; 先进行加锁操作，然后遍历 workers 容器，也就是遍历线程池中的线程，对每个线程进行 tryLock 操作，如果成功说明线程空闲，则设置其中断标志位。而线程是否响应中断则交给我们定义任务的人来决定。 总结本文比较详细的分析了线程池任务的提交、线程的执行、线程池的关闭的工作流程。通过学习线程池相关的源码后，看到了在其内部用运用了很多多线程的解决方法，有如下几个方式： 通过定义重入锁 ReentrantLock 变量 mainLock 来解决并发多线程的安全问题 利用等待机制来实现线程之间的通讯问题除了内置的功能外，ThreadPoolExecutor 也向外提供了两个接口供我们自己扩展满足我们需求的线程池，这两个接口分别是：beforeExecute 任务执行前执行的方法，afterExecute 任务执行结束后执行的方法。]]></content>
      <categories>
        <category>Java</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程池（一）]]></title>
    <url>%2Fpost%2Fbc557e1a.html</url>
    <content type="text"><![CDATA[线程池简介使用线程池可以很好的提高性能，线程池在运行之初就会创建一定数量的空闲线程，我们将一个任务提交给线程池，线程池就会使用一个空闲的线程来执行这个任务，该任务执行完后，该线程不会死亡，而是再次变成空闲状态返回线程池，等待下一个任务的到来。在使用线程池时，我们把要执行的任务提交给整个线程池，而不是提交给某个线程，线程池拿到提交的任务后，会在内部寻找是否还有空闲的线程，如果有，就将这个任务提交给某个空闲的线程，虽然一个线程同一时刻只能执行一个任务，但是我们可以向线程池提交多个任务。合理使用线程池有以下几个优点：① 降低资源消耗 多线程运行期间，系统不断的启动和关闭新线程，成本高，会过度消耗系统资源，通过重用存在的线程，减少对象创建、消亡的开销② 提高响应速度 当有任务到达时，任务可以不需要等待线程的创建，可以直接从线程池中取出空闲的线程来执行任务③ 方便线程管理 线程对计算机来说是很稀缺的资源，如果让他无限制创建，它不仅消耗系统的资源，还会降低系统的稳定性，我们使用线程池后可以统一进行分配和监控谈到线程池就会想到池化技术，核心思想就是把宝贵的资源放到一个池子中，每次要使用都从池子里面取，用完之后又放回池子让别人用。那么线程池在 Java 中是如何实现的呢？ Java 四种线程池在 Java 中 Executors 工具类给我们提供了四种不同使用场景的线程池的创建方法，分别为： newSingleThreadExecutor 只有一个线程来执行任务，适用于有顺序的任务的应用场景。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，它可以保证任务按照指定顺序（FIFO，LIFO）执行，它还有可以指定线程工厂（ThreadFactory）的重载方法，可以自定义线程的创建行为 newFixedThreadPool 固定线程数的线程池，只有核心线程，核心线程的即为最大的线程数量，没有非核心线程。每次提交一个任务就创建一个线程，直到达到线程池的最大大小。线程池一旦达到最大值就会保持不变，如果当中的某个线程因为异常而结束，那么线程池会新建一个线程加入到线程池中。它还可以控制线程的最大并发数，超出的线程会在阻塞队列（LinkedBlockingQueue）中等待，同样它也有可以指定线程工厂（ThreadFactory）的重载方法，可以自定义线程的创建行为。 newCachedThreadPool 创建一个可缓存线程池，最大的线程个数为 2^31 - 1（Integer.MAX_VALUE），可以认为是无限大，若无可回收，则新建线程，如果线程池的大小超出了处理任务所需要的线程，那么就会回收部分空闲（60s 不执行任务）的线程。 newScheduledThreadPool 周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大（Integer.MAX_VALUE：2^31 - 1），适用于执行周期性的任务。 Java 线程池参数详解上文说到的 Executors 工具类提供的四种适用于不同场景的线程池，通过查看源码可以发现最终都是调用 ThreadPoolExecutor 类来实现的，我们接下来深入了解这个类一些成员变量的具体含义。首先是ctl，其声明如下： 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 这个成员变量 ctl 主要用于存储线程池的工作状态以及线程池正在运行的线程数。很显然，要在一个整型变量中存储两部分数据，只能将其一分为二。其中的高 3bit 用于存储线程的状态，低 29bit 用于存储线程池中正在执行的线程数。 线程池的状态在 ThreadPoolExecutor 定义了线程池的五种状态（注意，这里说的是线程池状态，不是池中的线程的状态），当创建一个线程池时的状态为 RUNNING。 12345private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 线程池状态 含义 RUNNING 允许提交并处理任务 SHUTDOWN 不会处理新提交的任务，但会处理完已处理的任务 STOP 不会处理新提交的任务，也不会处理阻塞队列中未执行的任务，并设置正在执行任务的中断标志位 TIDYING 所有任务执行完毕，线程池中工作的线程数为 0，等待执行 terminated() 钩子方法 TERMINATED terminated() 钩子方法执行完毕 调用线程池的 shutdown 方法，将线程池由 RUNNING 状态转为 SHUTDOWN 状态。调用 shutdownNow 方法，将线程池由 RUNNING 状态转为 STOP 状态。SHUTDOWN 状态和 STOP 状态都会先变为 TIDYING 状态，最终都会变为 TERMINATED 状态。用图表示为： ThreadPoolExecutor 同时提供了以下三个方法来查看线程池的状态和池中正在执行的线程数 123private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; ThreadPoolExecutor 的构造函数该类参数最全的构造方法如下，这个方法决定了创建出来的线程池的各种属性： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 各个参数的含义：corePoolSize 线程池中核心线程数的最大值maximumPoolSize 线程池中最多能拥有的线程数keepAliveTime 空闲线程存活时间unit 空闲线程存活时间的单位workQueue 用于存放任务的阻塞队列threadFactory 创建线程工厂handler 当 workQueue 已满，并且池中的线程数达到 maximumPoolSize 时，线程池继续添加新任务时采取的策略 下面通过一张图来更形象的理解线程池的这几个参数： corePoolSize、maximumPoolSize、workQueue 三者的关系，通过向线程池添加新的任务来说明着三者之间的关系： 如果没有空闲的线程执行该任务，并且池中运行的线程数小于corePoolSize时，则创建新的线程执行该任务 如果没有空闲的线程执行该任务，并且当池中正在执行的线程数大于corePoolSize时，新添加的任务进入workQueue排队（如果workQueue长度允许），等待空闲线程来执行 如果没有空闲的线程执行该任务，并且阻塞队列已满同时池中的线程数小于maximumPoolSize，则创建新的线程执行该任务 如果没有空闲的线程执行该任务，并且阻塞队列已满同时池中的线程数等于maximumPoolSize，则根据构造函数中的handler指定的策略来拒绝新添加的任务 在线程池中并没有标记出哪些线程是核心线程，哪些非核心线程，线程池它只关心核心线程的数量。下面这个是网上看到的一个形象的比喻： 如果把线程池比作一个单位的话，corePoolSize就表示正式工，线程就可以表示一个员工。当我们向单位委派一项工作时，如果单位发现正式工还没招满，单位就会招个正式工来完成这项工作。随着我们向这个单位委派的工作增多，即使正式工全部满了，工作还是干不完，那么单位只能按照我们新委派的工作按先后顺序将它们找个地方搁置起来，这个地方就是workQueue，等正式工完成了手上的工作，就到这里来取新的任务。如果不巧，年末了，各个部门都向这个单位委派任务，导致workQueue已经没有空位置放新的任务，于是单位决定招点临时工吧（临时工：又是我！）。临时工也不是想招多少就找多少，上级部门通过这个单位的maximumPoolSize确定了你这个单位的人数的最大值，换句话说最多招maximumPoolSize – corePoolSize个临时工。当然，在线程池中，谁是正式工，谁是临时工是没有区别，完全同工同酬。 keepAliveTime 和 unit 单位keepAliveTime 表示那些超出corePoolSize数量之外的线程的空闲时间大于keepAliveTime后就被清除了。 workQueue 任务队列workQueue决定了缓存任务的排队策略，对于不同的任务场景我们可以采取不同的策略，这个队列需要一个实现了BlockingQueue接口的任务等待队列。从ThreadPoolExecutor的文档中得知，官方一共给我们推荐了三种队列，分别是：SynchronousQueue、LinkedBlockingQueue、ArrayBlockingQueue。其中SynchronousQueue和ArrayBlockingQueue属于有限队列，LinkedBlockingQueue属于无限队列，具体作用如下： SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等待另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 ArrayBlockingQueue：有界阻塞队列。一个由数组支持的有界阻塞队列。此队列按FIFO（先进先出）原则对元素进行排序。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞，试图从空队列中提取元素将导致类似阻塞。 LinkedBlockingQueue：链表结构的阻塞队列，尾部插入元素，头部取出元素。LinkedBlockingQueue是我们在ThreadPoolExecutor线程池中常用的等待队列。它可以指定容量也可以不指定容量。由于它具有“无限容量”的特性，实际上任何无限容量的队列/栈都是有容量的，这个容量就是Integer.MAX_VALUE。LinkedBlockingQueue的实现是基于链表结构，而不是类似ArrayBlockingQueue那样的数组。但实际使用过程中，不需要关心它的内部实现，如果指定了LinkedBlockingQueue的容量大小，那么它反映出来的使用特性就和ArrayBlockingQueue类似了。 threadFactory 创建线程的工厂其实像ThreadPoolExecutor有的没有threadFactory参数的构造方法中使用的创建线程的工厂就是默认的工厂，比如下面这个构造方法： 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 在这个构造方法中，创建线程的工厂的方法使用Executors.defaultThreadFactory()的工厂和ThreadPoolExecutor中的defaultHandler默认抛弃策略。使用 Executors.defaultThreadFactory创建的线程同属于相同的线程组，具有同为Thread.NORM_PRIORITY的优先级，以及名为pool-poolNumber.getAndIncrement()-thread-的线程名（poolNumber.getAndIncrement() 为线程池顺序序号），且创建的线程都是非守护进程。 handler 拒绝策略表示当workQueue已满，池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略。从文档中得知，handler一般可以取以下四种值： 拒绝策略 含义 AbortPolicy 抛出 RejectedExecutionException 异常 CallerRunsPolicy 由向线程池提交任务的线程来执行该任务 DiscardPolicy 直接丢弃当前的任务 DiscardOldestPolicy 抛弃最旧的任务（最先提交而没有得到执行的任务） 个人觉得最优雅的方式还是AbortPolicy提供的处理方式：抛出异常，由开发人员进行处理。ThreadPoolExecutor默认的拒绝方式defaultHandler就是ThreadPoolExecutor.AbortPolicy。 合理配置线程池最后，我们要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析： 任务的性质任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。IO 密集型任务则由于需要等待 IO 操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的 CPU 个数。 任务的优先级优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。 任务的执行时间执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。 任务的依赖性依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，如果等待的时间越长 CPU 空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用 CPU。建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行 SQL 变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。 参考文章：JAVA 线程池的分析和使用ThreadPoolExecutor 的 workQueue 任务队列详解]]></content>
      <categories>
        <category>Java</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深挖 HashMap]]></title>
    <url>%2Fpost%2F99ea2970.html</url>
    <content type="text"><![CDATA[1.1 前言做过 java 开发的朋友们相信都很熟悉 HashMap 这个类，它是一个基于 hashing 原理用于存储 Key-Value 键值对的集合，其中的每一个键也叫做 Entry，这些键分别存储在一个数组当中，系统会根据 hash 方法来计算出 Key-Value 的存储位置，可以通过 key 快速存取 value。HashMap 基于 hashing 原理，当我们将一个键值对（Key-Value） 传入 put 方法时，它将调用这个 key 的 hashcode 方法计算出 key 的 hashcode 值，然后根据这个 hashcode 值来定位其存放数组的位置来存储对象（HashMap 使用链表来解决碰撞问题，当其发生碰撞了，对象将会存储在链表的下一个节点中，在链表的每个节点中存储 Entry 对象，在 JDK 1.8+ 中，当链表的节点个数超过一定值时会转为红黑树来进行存储），当通过 get 方法传入一个 key 来获取其对应的值时，也是先通过 key 的 hashcode 方法来定位其存储在数组的位置，然后通过键对象的 eqauls 方法找到对应的 value 值。接下来让我们看看其内部的一些实现细节。（PS：以下代码分析都是基于 JDK 1.8） 1.2 为什么容量始终是 2 的整数次幂因为获取 key 在数组中对应的下标是通过 key 的哈希值与数组的长度减一进行与运算来确定的（tab[(n - 1) &amp; hash]）。当数组的长度 n 为 2 的整数次幂，这样进行 n - 1 运算后，之前为 1 的位后面全是 1 ，这样就能保证 (n - 1) &amp; hash 后相应位的值既可能是 1 又可能是 0 ，这完全取决于 key 的哈希值，这样就能保证散列的均匀，同时与运算（位运算）效率高。如果数组的长度 n 不是 2 的整数次幂，会造成更多的 hash 冲突。HashMap 提供了如下四个重载的构造方法来满足不同的使用场景： 无参构造：HashMap()，使用该方法表示全部使用 HashMap 的默认配置参数 指定容量初始值构造：HashMap(int initialCapacity)，在初始化 HashMap 时指定其容量大小 指定容量初始值和扩容因子构造：HashMap(int initialCapacity, float loadFactor)，使用自定义初始化容量和扩容因子 通过 Map 来构造 HashMap：HashMap(Map&lt;? extends K, ? extends V&gt; m)，使用默认的扩容因子，其容量大小有传入的 Map 大小来决定 前三个构造方法最终都是调用第三个即自定义容量初始值和扩容因子构造 HashMap(int initialCapacity, float loadFactor)，其源码实现如下123456789101112public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; 从源码实现可以看出，如果我们传入的初始容量值大于 MAXIMUM_CAPACITY 时，就设置容量为 MAXIMUM_CAPACITY，其值如下： 123456/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 也就是容量的最大值为 2 的 30 次方（1 &lt;&lt; 30）。我们知道，HashMap 的容量始终是 2 的整数次幂，不管我们传入的初始容量是什么，它都会使用最接近这个值并且是 2 的整数次幂作为 HashMap 的初始容量，这一步处理是通过 tableSizeFor 方法来实现的，我们看看它的源码： 通过方法的注释我们也可以知道（英语对于从事技术开发的人太重要了~~~），此方法的返回值始终是 2 的整数次幂，它是如何做到的呢？接下来我们通过一个例子一步一步来看，假设我们传入的初始容量大小 cap 的值 cap 为 15。 第 ① 步：将 cap - 1 后，n 的值为 14（15 - 1）。 第 ② 步：将 n 的值先右移 1 位后与 n 进行 或运算（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程： 第 ③ 步：将 n 的值先右移 2 位后与 n 进行 或运算（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程： 第 ④ 步：将 n 的值先右移 4 位后与 n 进行 或运算（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程： 第 ⑤ 步：将 n 的值先右移 8 位后与 n 进行 或运算（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程： 第 ⑥ 步：将 n 的值先右移 16 位后与 n 进行 或运算（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程： 最后如果 n 的值小于 0，则返回 1，如果大于最大值 MAXIMUM_CAPACITY 则返回 MAXIMUM_CAPACITY，否则返回 n + 1。 现在 n 为 15，所以返回 n + 1（16），而 16 正好是 2 的 4 次幂。有的朋友可能会问，刚刚上文假设的初始容量大小 cap 是 15，本来就不是 2 的整数次幂，如果我传入初始容量的就是 2 的整数次幂那会怎么样呢？现在假设传的初始容量大小为 32（2 的 5 次方）看看结果是什么。 第 ① 步：将 cap - 1 后，n 的值为 31（32 - 1）。 第 ② 步：将 n 的值先右移 1 位后与 n 进行 或运算（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程： 第 ③ 步：将 n 的值先右移 2 位后与 n 进行 或运算（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程： 第 ④ 步：将 n 的值先右移 4 位后与 n 进行 或运算（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程： 第 ⑤ 步：将 n 的值先右移 8 位后与 n 进行 或运算（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程： 第 ⑥ 步：将 n 的值先右移 16 位后与 n 进行 或运算（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程： 经过以上 6 步计算后得出 n 的值为 31，大于 0 小于 MAXIMUM_CAPACITY 返回 n + 1，所以经过计算后的初始容量大小为 32。稍微总结一下，我们可以得出：如果我们传入的初始容量大小不是 2 的整数次幂，那么经过计算后的初始容量大小为大于我们传入初始容量值的最小值并且是 2 的整数次幂。细心的朋友会发现，为什么第一步要进行 cap - 1 的操作呢？那是因为，如果不进行 - 1 运算的话，当我们传入的初始容量大小为 2 的整数次幂的时候，通过以上步骤计算出来的结果值为传入值的 2 倍。假设我们传入的初始容量大小为 32，此时没有第 ① 步（cap - 1）的操作，那么依次通过以上 ②、③、④、⑤、⑥ 后为 63，最后再进行 n + 1 操作，结果为 64 是 传入值 32 的 2 倍，显然和预期结果（32）不符。这个计算初始容量的算法还是很巧妙的，先进行了 -1 的操作，保证传入初始容量值为 2 的整数次幂的时候，返回传入的原始值。 1.3 hash 方法是如何实现的不管是通过 get 方法获取 key 对应的 Value 值或者通过 put 方法存储 Key-Value 键值对时，都会先根据 key 的哈希值定位到数组的位置，我们看看 HashMap 里的 hash 方法是如何实现的，源码如下： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 当 key 为 null 时，返回 0，否则进行 h = key.hashCode()) ^ (h &gt;&gt;&gt; 16 运算，先调用 key 的 hashCode 方法获取 key 的哈希值，然后与 key 的哈希值右移 16 位后的值进行异或运算（相同为 0，不同为 1，简称 同假异真），为什么获取 key 的哈希值还要再进行异或运算，直接返回 key 的哈希值好像也没什么问题，如果没有后面的异或运算，直接返回哈希值，我们假设数组的长度为 16，现在要往 HashMap 存入的三个键值对的 key 的哈希值分别为 32831、33554495、2097215，根据 hash 方法返回值定位到数组的位置（(n - 1) &amp; hash），以上三个值和 15（16 - 1）进行 &amp; 运算（都为 1 才为 1，其它情况都为 0） 如下： 可以发现以上三个哈希值都定位的数组下标为 15 的位置上。所以 hash 如果方法没有后面与哈希值右移 16 位后的值进行异或运算的话，当数组长度比较小时很容易造成 哈希碰撞，即多个 key（不同的哈希值）都会定位到数组上的同一个位置，也就是说会放入到同一个链表或者红黑树中，因为此时 key 的哈希值只有低位的才会参与运算，显然和我们的预期不符合。可见 hash 方法将 key 的哈希值与其右移 16 位后进行异或运算能减少哈希碰撞的次数，把高位和低位都参与了运算，提高了分散性。 1.4 总结HashMap 其实还有很多值得我们深入研究的点，看懂了上面两个方法后，不得不佩服作者的代码设计能力，JDK 中有很多优秀源码都值得我们好好品味，看代码的时候一定要多看几遍多问几个为什么，特别是经典的源代码，然后将这些思想运用到我们的实际工作中。]]></content>
      <categories>
        <category>Java</category>
        <category>原理</category>
      </categories>
      <tags>
        <tag>Java, 原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步工具类]]></title>
    <url>%2Fpost%2Fee27c07f.html</url>
    <content type="text"><![CDATA[1.1 前言同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。在容器中，有些也可以作为同步工具类，其它类型的同步工具类还包括闭锁（Latch）、信号量（Semaphore）以及栅栏（Barrier）。阻塞队列（eg: BlockQueue）是一种独特的类：它们不仅能作为保存对象的容器，还能协调生产者和消费者之间的控制流，因为它提供的 take 和 put 等方法将会阻塞，直到队列达到期望的状态。所有的同步工具类都包含一些特定的属性：它们封装了一些状态，这些状态将决定同步工具类的线程是继续执行还是等待，此外还提供了一些方法对其状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。 1.2 闭锁闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有线程通过。当闭锁到达结束状态后，将不会再次改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其它活动都完成后才继续执行。比如： 确保某个计算机在其需要的所有资源初始化后才能继续执行。 确保某个服务在其依赖的所有服务都已经启动后才启动。 等待直到某个操作的所有参与者都就绪后再继续执行。 1.2.1 CountDownLatchCountDownLatch 是一种灵活的闭锁实现，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待事件的数量。countDown() 方法递减计数器，表示有一个事件已经发生了，而 await() 方法等待计数器达到 0 ，这表示所有需要等待的事件都已经发生。如果计数器的值非 0 ，那么 await() 方法会一直阻塞到计数器的值为 0 ，或者等待线程中断，或者等待超时。CountDownLatch 被用来同步一个或多个任务，强制它们等待由其它任务执行的一组操作完成。你可以向 CountDownLatch 对象设置一个初始计数值，任何在这个对象上调用 await() 的方法都将阻塞，直到这个计数值到达 0。其它任务在结束工作时，可以在该对象上调用 countDown() 方法来减小这个计数值。CountDownLatch 被设计为只触发一次，计数值不能重置。如果你需要重置计数值的版本，请看下文的 CyclicBarrier。把大象放入冰箱的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author mghio * @date: 2019-11-03 * @version: 1.0 * @description: 同步工具类 —— CountDownLatch * @since JDK 1.8 */public class CountDownLatchDemo &#123; private static CountDownLatch countDownLatch1 = new CountDownLatch(1); private static CountDownLatch countDownLatch2 = new CountDownLatch(1); public static void main(String[] args) &#123; final Thread thread1 = new Thread(() -&gt; &#123; System.out.println("step 1：打开冰箱门..."); // 对 countDownLatch1 倒计时 -1 countDownLatch1.countDown(); &#125;); final Thread thread2 = new Thread(() -&gt; &#123; try &#123; // 等待 countDownLatch1 倒计时，计时为 0 则往下运行 countDownLatch1.await(); System.out.println("step 2：把大象放入冰箱..."); // 对 countDownLatch2 倒计时 -1 countDownLatch2.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); final Thread thread3 = new Thread(() -&gt; &#123; try &#123; // 对 countDownLatch2 倒计时，计时为 0 则往下进行 countDownLatch2.await(); System.out.println("step 3：关上冰箱门..."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println("------- 把大象放入冰箱 --------"); thread3.start(); thread1.start(); thread2.start(); &#125;&#125; 以上代码输出结果： 1234------- 把大象放入冰箱 --------step 1：打开冰箱门...step 2：把大象放入冰箱...step 3：关上冰箱门... 1.2.2 FutureTaskFutureTask 也可以用作闭锁。它实现了 Future 的语义，表示一种抽象可生成结果的计算。 FutureTask 表示的计算是通过 Callable 来实现的，相当于一种可生成结果的 Runnable ，并且可以处于这三种状态：等待运行（Waiting to run）、正在运行（Running）和运行完成（Completed）。其中执行完成表示计算的所有可能结束方式，包括正常结束、由于取消结束和由于异常结束等。当 FutureTask 进入完成状态后，它就会永远停在这个状态上。get() 方法的行为取决于任务的状态。如果此时任务已经完成，那么 get() 方法会立即返回结果，否则将会阻塞直到任务进入到完成状态，然后返回结果或者抛出异常。FutureTask 将计算结果从执行计算的线程传递到获取这个结果的线程，而 FutureTask 的规范确保了这种传递过程能实现结果的安全发布。FutureTask 在 Executor 框架中表示异步任务，除此之外还可以用来表示一些耗时比较长的计算，这些计算可以在使用计算结果之前启动。以下示例使用其执行一个异步任务： 1234567891011121314151617181920212223242526272829303132/** * @author mghio * @date: 2019-11-03 * @version: 1.0 * @description: 同步工具类 —— FutureTask * @since JDK 1.8 */public class FutureTaskDemo &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; System.out.println("--------- 进入主线程执行任务"); ExecutorService threadPool = Executors.newCachedThreadPool(); System.out.println("--------- 提交异步任务"); FutureTask&lt;String&gt; future = new FutureTask&lt;&gt;(() -&gt; "成功获取 future 异步任务结果"); threadPool.execute(future); System.out.println("--------- 提交异步任务之后，立马返回到主线程继续往下执行"); Thread.sleep(1000); System.out.println("--------- 此时需要获取上面异步任务的执行结果"); boolean flag = true; while (flag) &#123; if (future.isDone() &amp;&amp; !future.isCancelled()) &#123; String futureResult = future.get(); System.out.println("--------- 异步任务返回的结果是：" + futureResult); flag = false; &#125; &#125; if (!threadPool.isShutdown()) &#123; threadPool.shutdown(); &#125; &#125;&#125; 以上代码输出结果为： 12345--------- 进入主线程执行任务--------- 提交异步任务--------- 提交异步任务之后，立马返回到主线程继续往下执行--------- 此时需要获取上面异步任务的执行结果--------- 异步任务返回的结果是：成功获取 future 异步任务结果 1.4 信号量计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行指定操作的数量。计数信号量还可以用来实现某种资源池或者对容器施加边界。Semaphore 中管理着一组虚拟的许可（permit），许可的初始数量可以通过构造函数来指定，在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，那么 acquire() 将阻塞直到有许可或者直到终端或者直到超时。release() 方法将返回一个许可给信号量。Semaphore 可以用于实现资源池，例如数据库连接池。我们可以构造一个固定长度的资源池，当池为空时，请求资源将会失败，但你真正希望看到的行为是阻塞而不是失败，并且当池非空时解除阻塞。如果将 Semaphore 的计数值初始化为池的大小，并在从池中获取一个资源之前首先调用 acquire() 方法获取一个许可，在将资源返回给池之后调用 release() 方法释放许可，那么 acquire() 方法将一直阻塞直到资源池不为空。以下示例将使用 Semaphore 将 HashSet 容器变成有界的阻塞容器，信号量的计数值会初始化为容器容量的最大值。add 操作在向底层容器添加一个元素之前，首先要获取一个许可。如果 add 操作没有添加任何元素，那么会立刻释放许可。同样 remove 操作会释放一个许可，使更多的元素能够添加到容器中。底层的 Set 实现并不知道关于边界的任何信息。 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author maguihai * @date: 2019-11-03 * @version: 1.0 * @description: 同步工具类 —— Semaphore * @since JDK 1.8 */public class BoundedHashSet&lt;T&gt; &#123; private final Set&lt;T&gt; set; private final Semaphore sem; public BoundedHashSet(int bound) &#123; this.set = Collections.synchronizedSet(new HashSet&lt;&gt;()); this.sem = new Semaphore(bound); &#125; public boolean add(T o) throws InterruptedException &#123; sem.acquire(); boolean wasAdded = false; try &#123; wasAdded = set.add(o); return wasAdded; &#125; finally &#123; if (!wasAdded) &#123; sem.release(); &#125; &#125; &#125; public boolean remove(T o) &#123; boolean wasRemoved = set.remove(o); if (wasRemoved) &#123; sem.release(); &#125; return wasRemoved; &#125;&#125; 1.5 栅栏我们已经看到通过闭锁来启动一组相关的操作，或者等待一组相关的操作结束。闭锁是一次性对象，一旦进入终止状态，就不能被重置。栅栏（Barrier）类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于：所有线程都必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其它线程。栅栏用于实现一些协议，例如几个家庭决定在某个地方集合：“所有人 6:00 在 KFC 碰头，到了以后要等其它人，之后再讨论下一步要做的事情”。CyclicBarrier 适用于这样的情况：你希望创建一组任务，他们并行执行工作，然后再运行下一个步骤之前等待，知道所有任务都完成（有点儿像线程的 join 方法）。它使得所有的并行任务都将处于栅栏处列队，因此可以一致的向前移动。这和上文的 CountDownLatch 非常像，只是 CountDownLatch 只是触发一次的事件，而 CyclicBarrier 可以重复使用。CyclicBarrier 可以使一定数量的参与方反复地在栅栏位置汇聚，它在并行迭代算法中非常有用：这种算法通常将一个问题拆分成一系列相互独立的子问题。当线程达到栅栏位置时将调用 await() 方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有栅栏都到达栅栏了位置，那么栅栏将打开，此时所有的线程都被释放，而栅栏将被重置以便下次使用。如果对 await() 方法调用超时，或者线程被中断，那么栅栏就认为是被打破了，所有阻塞 await() 的调用都将终止并抛出 BrokenBarrierException。如果成功通过栅栏，那么 await() 将为每一个线程返回一个唯一的到达索引号，我们可以利用这些索引来“选举”产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。CyclicBarrier 还可以使你将一个栅栏操作传递给构造函数，这个一个 Runnable ，当成功通过栅栏时会（在一个子任务线程中）执行它，但是它在阻塞线程被释放前是不能执行的。使用示例： 123456789101112131415161718192021222324252627282930313233343536/** * @author mghio * @date: 2019-11-03 * @version: 1.0 * @description: 同步工具类 —— CyclicBarrier * @since JDK 1.8 */public class CyclicBarrieDemo &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); // 创建 CyclicBarrier 对象并设置 3 个公共屏障点 final CyclicBarrier cb = new CyclicBarrier(3); for (int i = 0; i &lt; 3; i++) &#123; Runnable runnable = () -&gt; &#123; try &#123; Thread.sleep((long) (Math.random() * 10000)); System.out.println("线程 " + Thread.currentThread().getName() + " 即将到达集合地点1，当前已有 " + cb.getNumberWaiting() + " 个已经到达，正在等候"); // 到此如果没有达到公共屏障点，则该线程处于等待状态，如果达到公共屏障点则所有处于等待的线程都继续往下运行 cb.await(); Thread.sleep((long) (Math.random() * 10000)); System.out.println("线程 " + Thread.currentThread().getName() + " 即将到达集合地点2，当前已有 " + cb.getNumberWaiting() + " 个已经到达，正在等候"); cb.await(); Thread.sleep((long) (Math.random() * 10000)); System.out.println("线程 " + Thread.currentThread().getName() + " 即将到达集合地点3，当前已有 " + cb.getNumberWaiting() + " 个已经到达，正在等候"); cb.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;; service.execute(runnable); &#125; service.shutdown(); &#125;&#125; 以上代码运行结果： 123456789线程 pool-1-thread-3 即将到达集合地点1，当前已有 0 个已经到达，正在等候线程 pool-1-thread-1 即将到达集合地点1，当前已有 1 个已经到达，正在等候线程 pool-1-thread-2 即将到达集合地点1，当前已有 2 个已经到达，正在等候线程 pool-1-thread-3 即将到达集合地点2，当前已有 0 个已经到达，正在等候线程 pool-1-thread-2 即将到达集合地点2，当前已有 1 个已经到达，正在等候线程 pool-1-thread-1 即将到达集合地点2，当前已有 2 个已经到达，正在等候线程 pool-1-thread-3 即将到达集合地点3，当前已有 0 个已经到达，正在等候线程 pool-1-thread-2 即将到达集合地点3，当前已有 1 个已经到达，正在等候线程 pool-1-thread-1 即将到达集合地点3，当前已有 2 个已经到达，正在等候]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java, 并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 运行时数据区域]]></title>
    <url>%2Fpost%2F8a061473.html</url>
    <content type="text"><![CDATA[1.1 为什么要进行内存区域划分JVM规范 规定，JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间，有的区域随着虚拟机进程的启动就存在了，而有些区域则依赖用户线程的启动和结束而建立和销毁。JVM 规范对 JVM 定义了运行时统一的内存划分规范，统一了标准，类似于 JDBC 规范一样。JVM 也有许多厂商的不同产品。比如下面的这些： 厂商 JVM Oracle-SUN Hotspot Oracle JRocket IBM J9 JVM 阿里 Taobao JVM 其内存区域划分规范对于 JVM 的含义类似于我们 Java 中的接口，都是起到了规范的作用，JVM 是一台可以运行 Java 应用程序的抽象的计算机。在 JVM 中存在三个重要的概念： JVM 规范：它定义了虚拟机运行的规范，但是由 Oracle（SUN）或者其它厂商实现 Java 运行时环境(JRE：Java Runtime Environment)：它是 JVM 规范的具体实现 JVM 实例：编写好 Java 代码之后，运行 Java 程序，此时就会创建 JMV 实例 对于 Java 程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个对象去编写内存释放的代码，不要像 C 或者 C++ 要时刻注意着内存泄漏和内存溢出的问题，这种由虚拟机去管理一切看起来都很美好。不过，也正是因为 Java 设计者把内存控制全部交给了 JVM，一旦出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎么分配运行时内存的，那么排查错误将是一项非常艰难的工作。 1.2 运行时数据区域的组成为什么我们经常把运行时数据区叫做 Java 内存模型（JMM：Java Memory Model），是因为运行时数据区太过于分散，没有联系，所以才会有 JVM 内存模型这个词，让我们把这些东西联系起来，方便记忆。JVM 运行时数据区中有些数据是一直存在的，被所有线程所共享。而有些区域则是线程私有的，伴随着线程的开始而创建，线程的结束而销毁。所以我们可以把JMM 分为两类：线程共享的、线程私有的。根据 JVM 虚拟机规范的规定，JVM 虚拟机运行时数据区划分如下图所示： 运行时数据区主要分为以下几个部分： 方法区 虚拟机栈 本地方法栈 堆 程序计数器 其中，按照线程在各个区域的数据是否共享划分为： 线程共享部分：方法区、Java 堆以及运行时常量池（归属于方法区） 线程私有部分：虚拟机栈、本地方法栈、程序计数器 接下来看看 Java 运行时数据区中各个部分的用途和特点： 方法区 1.1 什么是方法区在 JVM 中，方法区是可供各个线程共享运行时的内存区域。方法区与传统语言中的编译代码存储区或者操作系统进程的正文段的作用非常类似，它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、类的构造函数和普通方法的字节码内容、还包括一些类、实例、接口初始化的时候用到的特殊方法。在 Hotspot 虚拟机中，JDK 1.7 版本称作永久代（Permanent Generation），而在 JDK 1.8 则称为 元空间（Metapace）。方法区有个别名叫做非堆（Non-Heap），用于区别于 Java 堆区。默认最小值为 16 MB，最大值为 64 MB，可通过 -XX:PermSize 和 -XX:MaxPermSize 参数设置方法的大小。JDK 1.7 及之前的版本设置为： 12-XX:PermSize=10m-XX:MaxPermSize=55m JDK 1.8 及之后的版本设置为： 12-XX:MetaspaceSize=10m-XX:MaxMetaspaceSize=55m 1.2 方法区的特点 线程共享：方法区是堆的一个逻辑部分，因此和对一样是线程共享的。整个虚拟机中只有一个方法区。 永久代：方法区中的信息一般要长期存在，而且它又是堆的逻辑部分，因此用堆的划分方法，我们把方法区称作永久代（方法区是规范，永久代是实现）。 内存回收低：方法区中的信息一般需要长期存在，回收一遍内存之后可能之后少量信息无效。对方法区的内存回收主要是 对常量池的回收和对类型的卸载。 JVM 规范对方法区的定义比较宽松：和堆一样，允许固定大小，也允许可扩展大小，还允许不实现垃圾回收。 方法区是所有都线程共享的，在一定的条件下它也会被 GC，当方法区域需要使用的内存超过其允许的大小时，会抛出 OOM（OutOfMemory）错误信息。 1.3 运行时常量池类加载后，Class 文件结构中常量池中的数据将被存储在运行时常量池中。我们一般在一个类中通过 public static final 来声明一个常量或者声明一个字符串 String str = &quot;abc&quot;。这个类编译后产生的 Class 文件，这个类的所有信息都存储在这个 class 文件中，当这个类被 JVM 加载之后，class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池添加新的常量。比如，String 类的 intern() 方法就能在运行期间向常量池中添加新的常量。当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用时，那么就需要垃圾收集器回收。JVM 为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。其包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用。即字面量和符号引用，其中字面量指的是整个类中的字面量。包含成员变量、静态方法、非静态方法等中的字面量。池中的数据和数组一样通过索引访问。 虚拟机栈 1.1 什么是虚拟机栈Java 虚拟机栈是描述 Java 方法运行过程的内存模型。Java 虚拟机栈会为每一个即将运行的方法创建一块叫做 栈帧 的区域，这块区域用于存储用于方法在运行时所需要的一些信息，这些信息具体包括： 局部变量表 操作数栈 动态链接 方法出口信息 其它信息 当一个方法即将被运行时，Java 虚拟机栈首先会在 Java 虚拟机栈中为该方法创建一块”栈帧”，栈帧中包含局部变量表，操作数栈，动态链接，方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。Java 虚拟机栈上数据都是私有的，其他线程都不能访问该线程的栈数据。在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。当在一段代码块中定义一个变量时，Java 就会在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java 会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 1.2 Java 虚拟机栈的特点 局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。局部变量表的大小在程序的编译期间就确定下来了，在创建的时候需要事先指定好大小，在方法运行的过程中局部变量表的大小是不会发生改变的。 Java虚拟机栈会出现两种错误（StackOverFlowError 和 OutOfMemoryError），StackOverFlowError：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候就会抛出 StackOverFlowError。OutOfMemoryError：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展了，此时就会抛出 StackOverFlowError。 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 栈中的数据在线程内部是共享的，要注意这种数据的共享与两个对象引用同 时指向一个对象的这种共享是不同的。它是由编译器完成的，它有利于节省空间。 本地方法栈 本地方法指的是使用 Java 以外的其他语言编写的代码，因为有些时候 Java 无法直接操作一些底层资源，只能通过 C 或汇编操作。因此需要通过本地方法来实现。而本地方法栈就是设计用来调用这些非 Java 语言方法的。会存放对应的局部变量信息、返回结果等。本地方法栈和 Java 虚拟机栈实现的功能类似，只不过本地方法栈是本地方法运行的内存模型。区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则是为虚拟机用到的 Native 方法服务，本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接以及出口信息等。方法执行完毕后相应的栈帧也会出栈并释放内存空间。也会抛出两种错误，StackOverFlowError 和 OutOfMemoryError。 堆 1.1 什么是堆堆是用来存放对象（类、接口、数组）的内存空间。几乎所有的对象都存储在堆中（实例创建后，成员变量也随对象存在堆中，随着垃圾回收进行释放）。堆是一个运行时数据区，在程序运行时动态分配内存。在堆中产生了一个数组对对象后，还可以在栈中定义一个特殊的变量，让栈用这个变量的取值等于数组或对象在堆地址内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组和对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中数组或对象。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域外后释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码之外，数组和对象本身占据的内存空间不会被释放，数组和对象在没有引用指向它的时候才会变为垃圾，不能再被使用。仍然占据内存空间不放，在随后的一个不确定的时期被 GC 垃圾回收收走。这也是 Java 比较占用内存的原因之一，实际上，栈中的变量指向堆内存的变量，这就是 Java 中的指针。 1.2 堆的特点 线程共享：整个 JVM 只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。 在虚拟机启动的时候创建。 垃圾回收的主要场所。 堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的。 堆可以分为：新生代和老年代新生代：新生代程序新创建的对象都在新生代分配的，新生代由 Eden Space 和两块大小相同的 Survivor Space（通常又称 S0 和 S1或 FROM 和 To ）构成，可通过 -Xmn 参数来指定新生代的大小，也可以通过 -XX:SurvivorRation 来调整 Eden Space 及 Survivor Space 的大小，因此新生代又可被分为：Eden，From Survivor，To Survivor。老年代：老年代用户存放经过多次新生代垃圾回收仍然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代。主要有两种情况：一种是 大对象，可通过启动参数设置 -XX:PretenureSizeThreshold=1024（单位为字节，默认为 0）来代表超过多大时就不再在新生代分配，而是直接在老年代分配。另一种是 大的数组对象，且数组中无引用外部对象。老年代所占的内存大小为 -Xmx 对应的值减去 -Xmn（新生代）对应的值。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更加高效。 JDK 1.8 及之后版本堆的内存空间分配老年代：三分之二的堆空间年轻代：三分之一的堆空间 eden 区： 十分之八的年轻代空间 survivor 0：十分之一的年轻代空间 survivor 1：十分之一的年轻代空间 程序计数器 1.1 什么是程序计数器程序计数器是一块比较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。当然，程序计数器是线程私有的。但是，如果当前线程执行的是一个线程本地的方法，那么此时这个线程的程序计数器为空。 本地方法为 Native Method，即由 native 修饰的方法。在定义一个 native 方法时，并不提供实现（类似 Java 中的接口或者抽象方法），因为其实现往往是由外面的 C 或者 C++ 等非 Java 语言实现的。 1.2 程序计数器的作用程序计数器主要有两个作用： 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如顺序执行、选择、循环、异常处理等。 在多线程的条件下，程序计数器用来记录当前线程执行的位置，从而当线程被切换回来的时候能够知道这个线程上次运行到哪个地方了。 1.3 程序计数器的特点 是一块比较小的存储空间 是线程私有的，即每一个线程都有一个独立程序计数器 是唯一一个不会出现 OOM（OutOfMemoryError）的内存区域 声明周期随着线程的开始而创建，随着线程的终止而结束 方法区、永久代和元空间 1.1 方法区和永久代的关系涉及到内存模型，往往都会提到永久代，那么它和方法区又是什么关系呢？JVM 虚拟机规范 只是规定了有方法区这个概念和它的作用，并没有规定如何实现它。那么，在不同 JVM 上方法区的实现肯定是不同的。同时大多数公司用的 JVM 都是 Oracle 公司的 HotSpot。在 HotSpot 上把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区。因此，我们可以得到结论，永久代是 HotSpot 的概念，方式区是 JVM 规范的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。其它的虚拟机实现并没有永久代这么一说。在 JDK 1.7 及之前的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC 分代来实现方法区内存回收，可以使用以下参数来调准方法区的大小： 12-XX:PermSize # 方法区初始大小-XX:MaxPermSize # 方法区最大大小（超过这个值会抛出 OutOfMemoryError 异常：java.lang.OutOfMemoryError：PermGen） 1.2 元空间对于 Java 8，HotSpot 取消了永久代，那么是不是也就没有方法了吗？当然不是，方法区是一个规范，规范没变，它就会一直在。那么取代永久代的就是元空间。它和永久代有什么不同呢？ 存储位置不同，永久代物理上是堆的一部分，和新生代、老年代地址是连续的，而元空间属于本地内存 存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。 1.3 总结1.1 JVM 内存模型一共有两个“栈”，分别是 Java 虚拟机栈和本地方法栈两个“栈”功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是方法私有的。只不过 Java 虚拟机栈描述的是 Java 方法运行过程的内存模型，而本地方法栈是描述 Java 本地方法运行过程的内存模型。 1.2 JVM 内存模型中一共有两个“堆”，分别是原本的堆和方法区方法区本质上还是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量，即时编译器编译后的代码等。 1.3 堆是 JVM 中最大的一块内存区域，也是垃圾收集器主要工作的地方在创建对象的时候，非静态成员会被加载到堆内存中，并完成成员变量的初始化。也就是说所有的非静态成员（成员变量、成员方法、构造方法、构造代码块和普通代码块）都是保存在堆内存中的。但是方法调用的时候，调用的方法会在栈内存中执行，构造代码块也会在栈内存中执行。 1.4 线程私有与共享Java 虚拟机栈、程序计数器和本地方法栈都是线程私有的，也就是说每个线程都是各自的程序计数器、Java 虚拟机栈和本地方法栈。他们的生命周期和线程的生命周期一样。而堆、方法区则是线程共享的，在 JVM 中只有一个堆，一个方法区。并在 JVM 启动的时候就创建，直到 JVM 停止的时候才销毁。 参考文章 Java Memory Management for Java Virtual Machine (JVM) The Java® Virtual Machine Specification（Java SE 8 Edition）]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发之 ThreadLocal]]></title>
    <url>%2Fpost%2Fbfcdfeaf.html</url>
    <content type="text"><![CDATA[1.1 什么是 ThreadLocalThreadLocal 简单理解 Thread 即线程，Local 即本地，结合起来理解就是 每个线程都是本地独有的。在早期的计算机中不包含操作系统，从头到尾只执行一个程序，并且这个程序能访问计算中的所有资源，这对于计算机资源来说是一种浪费。要想充分发挥多处理器的强大计算能力，最简单的方式就是使用多线程。与串行程序相比，在并发程序中存在更多容易出错的地方。当访问共享数据时，通常需要使用同步来控制并发程序的访问。一种避免使用同步的方式就是让这部分共享数据变成不共享的，试想一下，如果只是在单个线程内对数据进行访问，那么就可以不用同步了，这种技术称为线程封闭（Thread Confinement），它是实现线程安全最简单的方式之一。当某个对象封闭在一个单个线程中时，这种用法会自动实现了线程安全，因为只有一个线程访问数据，从根本上避免了共享数据的线程安全问题，即使被封闭的对象本身不是线程安全的。要保证线程安全，并不是一定就需要同步，两者没有因果关系，同步只是保证共享数据征用时正确性的手段，如果一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证正确性。而维持线程封闭的一种规范用法就是使用 ThreadLoal，这个类能使当前线程中的某个值与保存的值关联起来。ThreadLocal 提供了 get() 与 set(T value) 等方法，set 方法为每个使用了该变量的线程都存有一份独立的副本，因此当我们调用 get 方法时总是返回由当前线程在调用 set 方法的时候设置的最新值。 1.2 ThreadLocal 的用法接下来通过一个示例代码说明 ThreadLocal 的使用方式，该示例使用了三个不同的线程 Main Thread、Thread-1 和 Thread-2 分别对同一个 ThreadLocal 对象中存储副本。 12345678910111213141516171819202122232425262728293031/** * @author mghio * @date: 2019-10-20 * @version: 1.0 * @description: Java 并发之 ThreadLocal * @since JDK 1.8 */public class ThreadLocalDemoTests &#123; private ThreadLocal&lt;String&gt; boolThreadLocal = ThreadLocal.withInitial(() -&gt; ""); @Test public void testUseCase() &#123; boolThreadLocal.set("main-thread-set"); System.out.printf("Main Thread: %s\n", boolThreadLocal.get()); new Thread("Thread-1") &#123; @Override public void run() &#123; boolThreadLocal.set("thread-1-set"); System.out.printf("Thread-1: %s\n", boolThreadLocal.get()); &#125; &#125;.start(); new Thread("Thread-2") &#123; @Override public void run() &#123; System.out.printf("Thread-2: %s\n", boolThreadLocal.get()); &#125; &#125;.start(); &#125;&#125; 打印的输出结果如下所示： 123Main Thread: main-thread-setThread-1: thread-1-setThread-2: 我们从输出结果可以看出，ThreadLocal 把不同的线程的数据进行隔离，互不影响，Thread-2 的线程因为我们没有重新设置值会使用 withInitial 方法设置的默认初始值 &quot;&quot;，在不同的线程对同一个 ThreadLocal 对象设置值，对不同的线程取出来的值不一样。接下来我们来分析一下源码，看看它是如何实现的。 1.3 ThreadLocal 的实现原理既然要对每个访问 ThreadLocal 变量的线程都要有自己的一份本地独立副本。我们很容易想到可以用一个 Map 结构去存储，它的键就是我们当前的线程，值是它在该线程内的实例。然后当我们使用该 ThreadLocal 的 get 方法获取实例值时，只需要使用 Thread.currentThread() 获取当前线程，以当前线程为键，从我们的 Map 中获取对应的实例值即可。结构示意图如下所示：上面这个方案可以满足前文所说的每个线程本地独立副本的要求。每个新的线程访问该 ThreadLocal 的时候，就会向 Map 中添加一条映射记录，而当线程运行结束时，应该从 Map 中清除该条记录，那么就会存在如下问题： 因为新增线程或者线程执行完都要操作这个 Map，所以需要保证 Map 是线程安全的。虽然可以使用 JDK 提供的 ConcurrentHashMap 来保证线程安全，但是它还是要通过使用锁来保证线程安全的。 当一个线程运行结束时要及时移除 Map 中对应的记录，不然可能会发生 内存泄漏 问题。 由于存在锁的问题，所有最终 JDK 并没有采用这个方案，而是使用无锁的 ThreadLocal。上述方案出现锁的原因是因为有两一个以上的线程同时访问同一个 Map 导致的。我们可以换一种思路来看这个问题，如果将这个 Map 由每个 Thread 维护，从而使得每个 Thread 只访问自己的 Map，那样就不会存在线程安全的问题，也不会需要锁了，因为是每个线程自己独有的，其它线程根本看不到其它线程的 Map 。这个方案如下图所示： 这个方案虽然不存在锁的问题，但是由于每个线程访问 ThreadLocal 变量后，都会在自己的 Map 内维护该 ThreadLoal 变量与具体存储实例的映射，如果我们不手动删除这些实例，可能会造成内存泄漏。我们进入到 Thread 的源码内可以看到其内部定义了一个 ThreadLocalMap 成员变量，如下图所示： ThreadLoalMap 类是一个类似 Map 的类，是 ThreadLocal 的内部类。它的 key 是 ThreadLocal ，一个 ThreadLocalMap 可以存储多个 key（ThreadLocal），它的 value 就对应着在 ThreadLocal 存储的 value。因此我们可以看出：每一个 Thread 都对应自己的一个 ThreadLocalMap ，而 ThreadLocalMap 可以存储多个以 ThreadLocal 为 key 的键值对。这里也解释了为什么我们使用多个线程访问同一个 ThreadLocal ，然后 get 到的确是不同数值。 上面对 ThreadLocal 进行了一些解释，接下来我们看看 ThreadLocal 具体是如何实现的。先看一下 ThreadLocal 类提供的几个常用方法： 1234567protected T initialValue() &#123; ... &#125;public void set(T value) &#123; ... &#125;public T get() &#123; ... &#125;public void remove() &#123; ... &#125; initialValue 方法是一个 protected 方法，一般是用来使用时进行重写，设置默认初始值的方法，它是一个延迟加载的方法，在。 set 方法是用来设置当前线程的变量副本的方法 get 方法是用获取 ThreadLocal 在当前线程中保存的变量副本 remove 方法是 JDK1.5+ 才提供的方法，是用来移除当前线程中的变量副本 initialValue 方法是在 setInitialValue 方法被调用的，由于 setInitialValue 方法是 private 方法，所以我们只能重写 initialValue 方法，我们看看 setInitialValue 的具体实现： 12345678910111213141516/** * Variant of set() to establish initialValue. Used instead * of set() in case user has overridden the set() method. * * @return the initial value */ private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; &#125; 通过以上代码我们知道，会先调用 initialValue 获取初始值，然后使用当前线程从 Map 中获取线程对应 ThreadLocalMap，如果 map 不为 null，就设置键值对，如果为 null，就再创建一个 Map。首先我们看下在 getMap 方法中干了什么： 12345678910/** * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; 可能大家没有想到的是，在 getMap 方法中，是调用当期线程 t，返回当前线程 t 中的一个成员变量 threadLocals 。那么我们继续到 Thread 类中源代码中看一下成员变量 threadLocals 到底是什么： 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 它实际上就是一个 ThreadLocalMap ，这个类型是 ThreadLocal 类内定义的一个内部类，我们看一下 ThreadLocalMap 的实现： 123456789101112131415161718192021222324252627282930313233/** * ThreadLocalMap is a customized hash map suitable only for * maintaining thread local values. No operations are exported * outside of the ThreadLocal class. The class is package private to * allow declaration of fields in class Thread. To help deal with * very large and long-lived usages, the hash table entries use * WeakReferences for keys. However, since reference queues are not * used, stale entries are guaranteed to be removed only when * the table starts running out of space. */ static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as "stale entries" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; ... &#125; 我们可以看到 ThreadLocalMap 的 Entry 继承了 WeakReference (弱引用)，并且使用 ThreadLocal 作为键值。 下面我们看下 createMap 方法的具体实现： 12345678910/** * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map */ void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 直接 new 一个 ThreadLoalMap 对象，然后赋值给当前线程的 threadLocals 属性。 然后我们看一下 set 方法的实现： 1234567891011121314151617/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */ public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 首先获取当前线程，然后从线程的属性 threadLocals 获取当前线程对应的 ThreadLocalMap 对象，如果不为空，就以 this (ThreadLocal) 而不是当前线程 t 为 key，添加到 ThreadLocalMap 中。如果为空，那么就先创建后再加入。ThreadLocal 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏。 接下来我们看一下 get 方法的实现： 123456789101112131415161718192021/** * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */ public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; 先获取当前线程，然后通过 getMap 方法传入当前线程获取到 ThreadLocalMap 。然后接着获取 Entry (key，value) 键值对，这里传入的是 this，而不是当前线程 t ，如果获取成功，则返回对应的 value，如果没有获取到，返回空，则调用 setInitialValue 方法返回 value。 至此，我们总结一下 ThreadLocal 是如何为每个线程创建变量副本的：首先，在每个线程 Thread 内部有个 ThreadLocal.ThreadLocalMap 类型的成员变量 threadLocals，这个 threadLocals 变量就是用来存储实际变量的副本的，它的键为当前 ThreadLocal ，value 为变量副本（即 T 类型的变量）。初始时，在 Thread 类里面， threadLocals 为 null，当通过 ThreadLocal 调用 set 或者 get 方法时，如果此前没有对当前线程的 threadLocals 进行过初始化操作，那么就会以当前 ThreadLocal 变量为键值，以 ThreadLocal 要保存的副本变量为 value，存到当前线程的 threadLocals 变量中。以后在当前线程中，如果要用到当前线程的副本变量，就可以通过 get 方法在当前线程的 threadLocals 变量中查找了。 1.4 总结ThreadLocal 设计的目的就是为了能够在当前线程中有属于自己的变量，并不是为了解决并发或者共享变量的问题。 通过 ThreadLocal 创建的副本是存储在每个线程自己的 threadLocals 变量中的 为何 threadLocals 的类型 ThreadLocalMap 的键值为 ThreadLocal 对象，因为每个线程中可有多个 threadLocal 变量，就像前文图片中的 ThreadLocal 和 ThreadLocal ，就是一个线程存在两个 threadLocal 变量 在进行 get 之前，必须先 set ，否则会报空指针异常，如果想在 get 之前不需要调用 set 就能正常访问的话，必须重写 initialValue 方法 ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景 另外，内存泄漏的问题请参考博文：ThreadLocal 内存泄漏问题]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 字符串 split 踩坑记]]></title>
    <url>%2Fpost%2F8bd965a0.html</url>
    <content type="text"><![CDATA[1.1 split 的坑前几天在公司对通过 FTP 方式上传的数据文件按照事先规定的格式进行解析后入库，代码的大概实现思路是这样的：先使用流进行文件读取，对文件的每一行数据解析封装成一个个对象，然后进行入库操作。本以为很简单的一个操作，然后写完代码后自己测试发现对文件的每一行进行字符串分割的时候存在问题，在这里做个简单的记录总结。在 Java 中使用 split 方法对字符串进行分割是经常使用的方法，经常在一些文本处理、字符串分割的逻辑中，需要按照一定的分隔符进行分割拆解。这样的功能，大多数情况下我们都会使用 String 中的 split 方法。关于这个方法，稍不注意很容易踩坑。 （1）split 的参数是正则表达式首先一个常见的问题，就是忘记了 String 的 split 方法的参数不是普通的字符串，而是正则表达式，例如下面的这两种使用方式都达不到我们的预期： 12345678910111213141516/** * @author mghio * @date: 2019-10-13 * @version: 1.0 * @description: Java 字符串 split 踩坑记 * @since JDK 1.8 */ public class JavaStringSplitTests &#123; @Test public void testStringSplitRegexArg() &#123; System.out.println(Arrays.toString("m.g.h.i.o".split("."))); System.out.println(Arrays.toString("m|g|h|i|o".split("|"))); &#125; &#125; 以上代码的结果输出为： 12[][m, |, g, |, h, |, i, |, o] 上面出错的原因是因为 . 和 | 都是正则表达式，应该用转义字符进行处理： 12"m.g.h.i.o".split("\\.")"m|g|h|i|o".split("\\|") 在 String 类中还有其它的和这个相似的方法，例如：replaceAll。 （2）split 会忽略分割后的空字符串大多数情况下我们都只会使用带一个参数的 split 方法，但是只带一个参数的 split 方法有个坑：就是此方法只会匹配到最后一个有值的地方，后面的会忽略掉，例如： 1234567891011121314151617/** * @author mghio * @date: 2019-10-13 * @version: 1.0 * @description: Java 字符串 split 踩坑记 * @since JDK 1.8 */ public class JavaStringSplitTests &#123; @Test public void testStringSplitSingleArg() &#123; System.out.println(Arrays.toString("m_g_h_i_o".split("_"))); System.out.println(Arrays.toString("m_g_h_i_o__".split("_"))); System.out.println(Arrays.toString("m__g_h_i_o_".split("_"))); &#125; &#125; 以上代码输出结果为： 123[m, g, h, i, o][m, g, h, i, o][m, , g, h, i, o] 像第二、三个输出结果其实和我们的预期是不符的，因为像一些文件上传其实有的字段通常是可以为空的，如果使用单个参数的 split 方法进行处理就会有问题。通过查看 API 文档 后，发现其实 String 中的 split 方法还有一个带两个参数的方法。第二个参数是一个整型类型变量，代表最多匹配上多少个，0 表示只匹配到最后一个有值的地方，单个参数的 split 方法的第二个参数其实就是 0，要想强制匹配可以选择使用负数（通常传入 -1 ），换成以下的写法，输出结果就和我们的预期一致了。 123"m_g_h_i_o".split("_", -1) // [m, g, h, i, o]"m_g_h_i_o__".split("_", -1) // [m, g, h, i, o, , ]"m__g_h_i_o_".split("_", -1) // [m, , g, h, i, o, ] （3）JDK 中字符串切割的其它 API在 JDK 中还有一个叫做 StringTokenizer 的类也可以对字符串进行切割，用法如下所示： 123456789101112131415161718/** * @author mghio * @date: 2019-10-13 * @version: 1.0 * @description: Java 字符串 split 踩坑记 * @since JDK 1.8 */ public class JavaStringSplitTests &#123; @Test public void testStringTokenizer() &#123; StringTokenizer st = new StringTokenizer("This|is|a|mghio's|blog", "|"); while (st.hasMoreElements()) &#123; System.out.println(st.nextElement()); &#125; &#125; &#125; 不过，我们从源码的 javadoc 上得知，这是从 JDK 1.0 开始就已经存在了，属于历史遗留的类，并且推荐使用 String 的 split 方法。 1.2 JDK 源码探究通过查看 JDK 中 String 类的源码，我们得知在 String 类中单个参数的 split 方法（split(String regex)）里面调用了两个参数的 split 方法（split(String regex, int limit)），两个参数的 split 方法，先根据传入第一个参数 regex 正则表达式分割字符串，第二个参数 limit 限定了分割后的字符串个数，超过数量限制的情况下前limit-1个子字符串正常分割，最后一个子字符串包含剩下所有字符。单个参数的重载方法将 limit 设置为 0。源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public String[] split(String regex, int limit) &#123; char ch = 0; if (((regex.value.length == 1 &amp;&amp; ".$|()[&#123;^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; int off = 0; int next = 0; boolean limited = limit &gt; 0; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((next = indexOf(ch, off)) != -1) &#123; if (!limited || list.size() &lt; limit - 1) &#123; list.add(substring(off, next)); off = next + 1; &#125; else &#123; // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; &#125; &#125; // If no match was found, return this if (off == 0) return new String[]&#123;this&#125;; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) &#123; while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) &#123; resultSize--; &#125; &#125; String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); &#125; return Pattern.compile(regex).split(this, limit);&#125; 接下来让我们一起看看 String 的 split 方法是如何实现的。 （1）特殊情况判断 123456789(((regex.value.length == 1 &amp;&amp; ".$|()[&#123;^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) 第一个参数 regex 为单个字符时，将其赋值给 ch，并判断是否在元字符：「.$|()[{^?*+\」中 第一个参数 regex 为两个字符时，第一个字符为 \\（要表示一个\需要用两个\转义得到），第二个字符不在数字、大小写字母和 Unicode 编码 Character.MIN_HIGH_SURROGATE（’\uD800’）和 Character.MAX_LOW_SURROGATE（’\uDBFF’）之间。 （2）字符串分割第一次分割时，使用 off 和 next，off 指向每次分割的起始位置，next 指向分隔符的下标，完成一次分割后更新 off 的值，当 list 的大小等于 limit - 1 时，直接添加剩下的子字符串。 如果字符串不含有分隔符，则直接返回原字符串 如果字符串进行完第一次分割后，数量没有达到 limit - 1 的话，则剩余的字符串在第二次添加 如果传入的第二个参数 limit 等于 0 ，则从最后的字符串往前移动，将所有的空字符串（”“）全部清除 （3）正则匹配String 的 split 方法在不是上面的特殊情况下，会使用两个类 Pattern 与 Matcher 进行分割匹配处理，而且 Strig 中涉及正则的操作都是调用这两个类进行处理的。 Pattern 类我们可以将其理解为模式类，它主要是用来创建一个匹配模式，它的构造方法是私有的，不能直接创建该对象，可以通过 Pattern.complie(String regex) 简单的工厂方法创建一个正则表达式。 Matcher 类我们可以将其理解为匹配器类，它是用来解释 Pattern 类对字符串执行匹配操作的引擎，它的构造方法也是私有的，不能直接创建该对象，可以通过 Pattern.matcher(CharSequence input) 方法得到该类的实例。String 类的双参数 split 方法最后使用 Pattern 类的 compile 和 split 方法，如下：1return Pattern.compile(regex).split(this, limit); 首先调用 Pattern 类的静态方法 compile 获取 Pattern 模式类对象 123public static Pattern compile(String regex) &#123; return new Pattern(regex, 0);&#125; 接着调用 Pattern 的 split(CharSequence input, int limit) 方法，在这个方法中调 matcher(CharSequence input) 方法返回一个 Matcher 匹配器类的实例 m，与 String 类中 split 方法的特殊情况有些类似。 使用 m.find()、m.start()、m.end() 方法 每找到一个分割符，则更新 start 和 end 的位置 然后处理没找到分隔符、子字符串数量小于 limit 以及 limit = 0 的情况 1.3 其它的字符串分割方式 方式一：使用 org.apache.commons.lang3.StringUtils#split，此方法使用完整的字符串作为参数，而不是正则表达式。底层调用 splitWorker 方法（注意：此方法会忽略分割后的空字符串）12345678910111213141516/** * @author mghio * @date: 2019-10-13 * @version: 1.0 * @description: Java 字符串 split 踩坑记 * @since JDK 1.8 */ public class JavaStringSplitTests &#123; @Test public void testApacheCommonsLangStringUtils() &#123; System.out.println(Arrays.toString(StringUtils.split("m.g.h.i.o", "."))); System.out.println(Arrays.toString(StringUtils.split("m__g_h_i_o_", "_"))); &#125; &#125; 输出结果： 12[m, g, h, i, o][m, g, h, i, o] 方式二：使用 com.google.common.base.Splitter，使用 Google Guava 包中提供的分割器 splitter，它提供了更加丰富的分割结果处理的方法，比如对结果前后去除空格，去除空字符串等12345678910111213141516171819/** * @author mghio * @date: 2019-10-13 * @version: 1.0 * @description: Java 字符串 split 踩坑记 * @since JDK 1.8 */ public class JavaStringSplitTests &#123; @Test public void testApacheCommonsLangStringUtils() &#123; Iterable&lt;String&gt; result = Splitter.on("_").split("m__g_h_i_o_"); List&lt;String&gt; resultList = Lists.newArrayList(); result.forEach(resultList::add); System.out.println("stringList's size: " + resultList.size()); result.forEach(System.out::println); &#125; &#125; 输出结果： 1234567stringList's size: 7mghio 1.4 总结String 类中除了 split 方法外，有正则表达式接口的方法都是调用 Pattern（模式类）和 Matcher（匹配器类）进行实现的。JDK 源码的每一个如 final、private 的关键字都设计的十分严谨，多读类和方法中的javadoc，多注意这些细节对于阅读代码和自己写代码都有很大的帮助。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 字节码]]></title>
    <url>%2Fpost%2F192cb539.html</url>
    <content type="text"><![CDATA[1.1 什么是字节码？Java 在刚刚诞生之时曾经提出过一个非常著名的口号: “一次编写，到处运行（write once，run anywhere）”，这句话充分表达了软件开发人员对冲破平台界限的渴求。“与平台无关”的理想最终实现在操作系统的运用层上: 虚拟机提供商开发了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写到处运行”。各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—字节码（ByteCode），因此，可以看出字节码对 Java 生态的重要性。之所以被称为字节码，是因为字节码是由十六进制组成的，而 JVM（Java Virtual Machine）以两个十六进制为一组，即以字节为单位进行读取。在 Java 中使用 javac 命令把源代码编译成字节码文件，一个 .java 源文件从编译成 .class 字节码文件的示例如图 1 所示:图 1 对于从事基于 JVM 的语言的开发人员来说，比如: Java，了解字节码可以更准确、更直观的理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观的看到 volatile 关键字如何在字节码上生效。另外，字节码增强技术在各种 ORM 框架、Spring AOP、热部署等一些应用中经常使用，深入理解其原理对于我们来说大有裨益。由于 JVM 规范的存在，只要最终生成了符合 JVM 字节码规范的文件都可以在 JVM 上运行，因此，这个也给其它各种运行在 JVM 上的语言（如: Scala、Groovy、Kotlin）提供了一个机会，可以扩展 Java 没有实现的特性或者实现一些语法糖。接下来就让我们就一起看看这个字节码文件结构到底是什么样的。 1.2 Java 字节码结构Java 源文件通过用 javac 命令编译后就会得到 .class 结尾的字节码文件，比如一个简单的 JavaCodeCompilerDemo 类如图 2 所示:图 2编译后生成的 .class 字节码文件，打开后是一堆 十六进制 数，如图 3 所示:图 3在上节提过，JVM 对于字节码规范是有要求的，打开编译后的字节码文件看似混乱无章，其实它是符合一定的结构规范的，JVM 规范要求每一个字节码文件都要由十部分固定的顺序组成的，接下来我们将一一介绍这部分，整体的组成结构如图 4 所示:图 4 （1）魔数（Magic Number）每个字节码文件的头 4 个字节称为 魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如 gif 或者 jpg 等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意改动。魔数的固定值为: 0xCAFEBABE，魔数放在文件头，JVM 可以根据文件的开头来判断这个文件是否可能是一个字节码文件，如果是，才会进行之后的操作。 有趣的是，魔数的固定值是 Java 之父 James Gosling 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡。 （2）版本号（Version）版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version），上图 3 中版本号为: “00 00 00 34”，次版本号转化为十进制为 0，主版本号转化为十进制 52（3 * 16^1 + 4 * 16^0 = 52），在 Oracle 官网中查询序号 52 对应的 JDK 版本为 1.8，所以编译该源代码文件的 Java 版本为 1.8.0。 （3）常量池（Constant Pool）紧接着主版本号之后的字节是常量池入口。常量池中存储两种类型常量: 字面量和符号运用。字面量为代码中声明为 final 的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。常量池整体上分为两部分: 常量池计数器和常量池数据区，如图 5 所示：图 5常量池计数器（constant_pool_count）: 由于常量池的数量不固定，所以需要先放置两个字节来表示常量池容量计数值，图 2 示例代码的字节码的前十个字节如下图 6 所示，将十六进制的 17 转为十进制的值为 33 (1 * 16^1 + 7 * 16^0 = 33)，排除下标 0，也就是说这个类文件有 32 个常量。图 6常量池数据区: 数据区是由（constant_pool_count - 1）个 cp_info 结构组成，一个 cp_info 的结构对应一个常量。在字节码中共有 14 种类型的 cp_info ，每种类型的结构都是固定的，如图 7 所示:图 7以 CONSTANT_Utf8_info 为例，它的结构如表 1 所示: 名称 长度 值 tag 1 字节 01 对应图 7 中 CONSTANT_Utf8_info 的标志栏中的值 length 2 字节 该 utf8 字符串的长度 bytes length 字节 length 个字节的具体数据 表 1 首先第一个字节 tag，它的取值对应图 7 中的 Tag，由于它的类型是 CONSTANT_Utf8_info，所以值为 01（十六进制）。接下来两个字节标识该字符串的长度 length，然后 length 个字节为这个字符串具体的值。从图 3 的字节码中摘取一个 cp_info 结构，将它翻译过来后，其含义为: 该常量为 utf8 字符串，长度为 7 字节，数据为: numberA，如图 8 所示: 图 8其它类型的 cp_info 结构在本文不在细说，和 CONSTANT_Utf8_info 的结构大同小异，都是先通过 tag 来标识类型，然后后续的 n 个字节来描述长度和数据。等我们对这些结构比较了解了之后，我们可以通过: javap -verbose JavaCodeCompilerDemo 命令查看 JVM 反编译后的完整常量池，可以看到反编译结果可以将每一个 cp_info 结构的类型和值都很明确的呈现出来，如图 9 所示:图 9 （4）访问标志（access_flag）常量池结束之后的两个字节，描述该 Class 是类还是接口，以及是否被 Public、Abstract、Final 等修饰符修饰。JVM 规范规定了如下表 2 所示的 9 种访问标志。需要注意的是，JVM 并没有穷举所有的访问标志，而是使用 按位或 操作来进行描述的，比如某个类的修饰符为 public final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010 = 0x0011。 标志名称 标志值 含义 ACC_PUBLIC 0x0001 字段是否为 public ACC_PRIVATE 0x0002 字段是否为 private ACC_PROTECTED 0x0004 字段是否为 protected ACC_STATIC 0x0008 字段是否为 static ACC_FINAL 0x0010 字段是否为 final ACC_VOLATILE 0x0040 字段是否为 volatile ACC_TRANSIENT 0x0080 字段是否为 transient ACC_SYNCHETIC 0x1000 字段是否为编译器自动产生 ACC_ENUM 0x4000 字段是否为 enum 表 2 （5）当前类名（this_class）访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。 （6）父类名称（super_class）当前类名的后两个字节，描述父类的全限定名。这两个字节保存的值也是在常量池中的索引值，根据索引值就能在常量池中找到这个类的父类的全限定名。 （7）接口信息（interfaces）父类名称后的两个字节，描述这个类的接口计数器，即: 当前类或父类实现的接口数量。紧接着的 n 个字节是所有的接口名称的字符串常量在常量池的索引值。 （8）字段表（field_table）字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的 局部变量。字段表也分为两部分，第一部分是两个字节，描述字段个数，第二部分是每个字段的详细信息 field_info。字段表结构如图 10 所示:图 10以图 3 中的字节码字段表为例，如下图 11 所示。其中字段的访问标志查表 2，002 对应为 Private，通过索引下标在图 9 中常量池分别得到字段名为: numberA，描述符为: I（在JVM 中的I代表 Java 中的 int）。综上，就可以唯一确定出类 JavaCodeCompilerDemo 中声明的变量为: private int numberA 。图 11 （9）方法表（method_table）字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数，第二个部分为每个方法的详细信息。方法的详细信息包括：方法的访问标志、方法名、方法的描述符以及方法的属性，如图 12 所示:图 12方法的权限修饰符依然可以通过图 9 的值查询到，方法名和方法的描述符都是常量池的索引值，可以通过索引值在常量池中查询得到。而方法属性这个部分比较复杂，我们可以借助 javap -verbose 将其反编译为人们可读的信息进行解读。如图 13 所示。我们可以看到属性中包含三个部分: Code 区: 源代码对应的 JVM 指令操作码，我们在字节码增强的时候重点操作的就是这个部分。 LineNumberTable: 行号表，将 Code 区的操作码和源代码的行号对应，Debug 时会起到作用（即: 当源代码向下走一行，相应的需要走几个 JVM 指令操作码）。 LocalVariableTable: 本地变量表，包含 this 和局部变量，之所以可以在每一个非 static 的方法内部都可以调用到 this，是因为 JVM 将 this 作为每个方法的第一个参数隐式进行传入。图 13 （10）附加属性表（additional_attribute_table）字节码的最后一部分，存放了在文件中类或接口所定义的属性的基本信息。 1.3 Java 字节码操作集合在图 13 中，Code 区的编号是 0 ~ 10，就是 .java 源文件的方法源代码编译后让 JVM 真正执行的操作码。为了帮助人们理解，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码和助记符的对应关系，以及每个操作码的具体作用可以查看 Oracle 官网，在需要的时候查阅即可。比如上图 13 的助记符为 iconst_2，对应图 3 中的字节码 0x05，作用是将 int 值 2 压入操作数栈中。以此类推，对 0 ~ 10 的助记符理解后就是整个 sum() 方法的操作数码实现。 1.4 查看字节码工具如果我们每次反编译都要使用 javap 命令的话，确实比较繁琐，这里我推荐大家一个 IDEA 插件: jclasslib。使用效果如图 14 所示: 代码编译后在菜单栏: View -&gt; Show Bytecode With jclasslib，可以很直观地看到当前字节码文件的类信息、常量池、方法区等信息，非常方便。图 14 1.5 总结Java 中字节码文件是 JVM 执行引擎的数据入口，也是 Java 技术体系的基础构成之一。了解字节码文件的组成结构对后面进一步了解虚拟机和深入学习 Java 有很重要的意义。本文较为详细的讲解了字节码文件结构的各个组成部分，以及每个部分的定义、数据结构和使用方法。强烈建议自己动手分析一下，会理解得更加深入。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2Fpost%2Fb1d4025b.html</url>
    <content type="text"><![CDATA[1234567public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World ~~~"); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
