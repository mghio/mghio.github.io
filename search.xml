<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 字符串 split 踩坑记]]></title>
    <url>%2Fpost%2F8bd965a0.html</url>
    <content type="text"><![CDATA[1.1 split 的坑前几天在公司对通过 FTP 方式上传的数据文件按照事先规定的格式进行解析后入库，代码的大概实现思路是这样的：先使用流进行文件读取，对文件的每一行数据解析封装成一个个对象，然后进行入库操作。本以为很简单的一个操作，然后写完代码后自己测试发现对文件的每一行进行字符串分割的时候存在问题，在这里做个简单的记录总结。在 Java 中使用 split 方法对字符串进行分割是经常使用的方法，经常在一些文本处理、字符串分割的逻辑中，需要按照一定的分隔符进行分割拆解。这样的功能，大多数情况下我们都会使用 String 中的 split 方法。关于这个方法，稍不注意很容易踩坑。 （1）split 的参数是正则表达式首先一个常见的问题，就是忘记了 String 的 split 方法的参数不是普通的字符串，而是正则表达式，例如下面的这两种使用方式都达不到我们的预期： 12345678910111213141516/** * @author mghio * @date: 2019-10-13 * @version: 1.0 * @description: Java 字符串 split 踩坑记 * @since JDK 1.8 */ public class JavaStringSplitTests &#123; @Test public void testStringSplitRegexArg() &#123; System.out.println(Arrays.toString("m.g.h.i.o".split("."))); System.out.println(Arrays.toString("m|g|h|i|o".split("|"))); &#125; &#125; 以上代码的结果输出为： 12[][m, |, g, |, h, |, i, |, o] 上面出错的原因是因为 . 和 | 都是正则表达式，应该用转义字符进行处理： 12"m.g.h.i.o".split("\\.")"m|g|h|i|o".split("\\|") 在 String 类中还有其它的和这个相似的方法，例如：replaceAll。 （2）split 会忽略分割后的空字符串大多数情况下我们都只会使用带一个参数的 split 方法，但是只带一个参数的 split 方法有个坑：就是此方法只会匹配到最后一个有值的地方，后面的会忽略掉，例如： 1234567891011121314151617/** * @author mghio * @date: 2019-10-13 * @version: 1.0 * @description: Java 字符串 split 踩坑记 * @since JDK 1.8 */ public class JavaStringSplitTests &#123; @Test public void testStringSplitSingleArg() &#123; System.out.println(Arrays.toString("m_g_h_i_o".split("_"))); System.out.println(Arrays.toString("m_g_h_i_o__".split("_"))); System.out.println(Arrays.toString("m__g_h_i_o_".split("_"))); &#125; &#125; 以上代码输出结果为： 123[m, g, h, i, o][m, g, h, i, o][m, , g, h, i, o] 像第二、三个输出结果其实和我们的预期是不符的，因为像一些文件上传其实有的字段通常是可以为空的，如果使用单个参数的 split 方法进行处理就会有问题。通过查看 API 文档 后，发现其实 String 中的 split 方法还有一个带两个参数的方法。第二个参数是一个整型类型变量，代表最多匹配上多少个，0 表示只匹配到最后一个有值的地方，单个参数的 split 方法的第二个参数其实就是 0，要想强制匹配可以选择使用负数（通常传入 -1 ），换成以下的写法，输出结果就和我们的预期一致了。 123"m_g_h_i_o".split("_", -1) // [m, g, h, i, o]"m_g_h_i_o__".split("_", -1) // [m, g, h, i, o, , ]"m__g_h_i_o_".split("_", -1) // [m, , g, h, i, o, ] （3）JDK 中字符串切割的其它 API在 JDK 中还有一个叫做 StringTokenizer 的类也可以对字符串进行切割，用法如下所示： 123456789101112131415161718 /** * @author mghio * @date: 2019-10-13 * @version: 1.0 * @description: Java 字符串 split 踩坑记 * @since JDK 1.8 */public class JavaStringSplitTests &#123; @Test public void testStringTokenizer() &#123; StringTokenizer st = new StringTokenizer("This|is|a|mghio's|blog", "|"); while (st.hasMoreElements()) &#123; System.out.println(st.nextElement()); &#125; &#125;&#125; 不过，我们从源码的 javadoc 上得知，这是从 JDK 1.0 开始就已经存在了，属于历史遗留的类，并且推荐使用 String 的 split 方法。 1.2 JDK 源码探究通过查看 JDK 中 String 类的源码，我们得知在 String 类中单个参数的 split 方法（split(String regex)）里面调用了两个参数的 split 方法（split(String regex, int limit)），两个参数的 split 方法，先根据传入第一个参数 regex 正则表达式分割字符串，第二个参数 limit 限定了分割后的字符串个数，超过数量限制的情况下前limit-1个子字符串正常分割，最后一个子字符串包含剩下所有字符。单个参数的重载方法将 limit 设置为 0。源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public String[] split(String regex, int limit) &#123; char ch = 0; if (((regex.value.length == 1 &amp;&amp; ".$|()[&#123;^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; int off = 0; int next = 0; boolean limited = limit &gt; 0; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((next = indexOf(ch, off)) != -1) &#123; if (!limited || list.size() &lt; limit - 1) &#123; list.add(substring(off, next)); off = next + 1; &#125; else &#123; // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; &#125; &#125; // If no match was found, return this if (off == 0) return new String[]&#123;this&#125;; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) &#123; while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) &#123; resultSize--; &#125; &#125; String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); &#125; return Pattern.compile(regex).split(this, limit);&#125; 接下来让我们一起看看 String 的 split 方法是如何实现的。 （1）特殊情况判断 123456789(((regex.value.length == 1 &amp;&amp; ".$|()[&#123;^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) 第一个参数 regex 为单个字符时，将其赋值给 ch，并判断是否在元字符：「.$|()[{^?*+\」中 第一个参数 regex 为两个字符时，第一个字符为 \\（要表示一个\需要用两个\转义得到），第二个字符不在数字、大小写字母和 Unicode 编码 Character.MIN_HIGH_SURROGATE（’\uD800’）和 Character.MAX_LOW_SURROGATE（’\uDBFF’）之间。 （2）字符串分割第一次分割时，使用 off 和 next，off 指向每次分割的起始位置，next 指向分隔符的下标，完成一次分割后更新 off 的值，当 list 的大小等于 limit - 1 时，直接添加剩下的子字符串。 如果字符串不含有分隔符，则直接返回原字符串 如果字符串进行完第一次分割后，数量没有达到 limit - 1 的话，则剩余的字符串在第二次添加 如果传入的第二个参数 limit 等于 0 ，则从最后的字符串往前移动，将所有的空字符串（”“）全部清除 （3）正则匹配String 的 split 方法在不是上面的特殊情况下，会使用两个类 Pattern 与 Matcher 进行分割匹配处理，而且 Strig 中涉及正则的操作都是调用这两个类进行处理的。 Pattern 类我们可以将其理解为模式类，它主要是用来创建一个匹配模式，它的构造方法是私有的，不能直接创建该对象，可以通过 Pattern.complie(String regex) 简单的工厂方法创建一个正则表达式。 Matcher 类我们可以将其理解为匹配器类，它是用来解释 Pattern 类对字符串执行匹配操作的引擎，它的构造方法也是私有的，不能直接创建该对象，可以通过 Pattern.matcher(CharSequence input) 方法得到该类的实例。String 类的双参数 split 方法最后使用 Pattern 类的 compile 和 split 方法，如下：1return Pattern.compile(regex).split(this, limit); 首先调用 Pattern 类的静态方法 compile 获取 Pattern 模式类对象 123public static Pattern compile(String regex) &#123; return new Pattern(regex, 0);&#125; 接着调用 Pattern 的 split(CharSequence input, int limit) 方法，在这个方法中调 matcher(CharSequence input) 方法返回一个 Matcher 匹配器类的实例 m，与 String 类中 split 方法的特殊情况有些类似。 使用 m.find()、m.start()、m.end() 方法 每找到一个分割符，则更新 start 和 end 的位置 然后处理没找到分隔符、子字符串数量小于 limit 以及 limit = 0 的情况 1.3 其它的字符串分割方式 方式一：使用 org.apache.commons.lang3.StringUtils#split，此方法使用完整的字符串作为参数，而不是正则表达式。底层调用 splitWorker 方法（注意：此方法会忽略分割后的空字符串）12345678910111213141516/** * @author mghio * @date: 2019-10-13 * @version: 1.0 * @description: Java 字符串 split 踩坑记 * @since JDK 1.8 */ public class JavaStringSplitTests &#123; @Test public void testApacheCommonsLangStringUtils() &#123; System.out.println(Arrays.toString(StringUtils.split("m.g.h.i.o", "."))); System.out.println(Arrays.toString(StringUtils.split("m__g_h_i_o_", "_"))); &#125; &#125; 输出结果： 12[m, g, h, i, o][m, g, h, i, o] 方式二：使用 com.google.common.base.Splitter，使用Google Guava包中提供的分割器splitter，它提供了更加丰富的分割结果处理的方法，比如对结果前后去除空格，去除空字符串等12345678910111213141516171819/** * @author mghio * @date: 2019-10-13 * @version: 1.0 * @description: Java 字符串 split 踩坑记 * @since JDK 1.8 */ public class JavaStringSplitTests &#123; @Test public void testApacheCommonsLangStringUtils() &#123; Iterable&lt;String&gt; result = Splitter.on("_").split("m__g_h_i_o_"); List&lt;String&gt; resultList = Lists.newArrayList(); result.forEach(resultList::add); System.out.println("stringList's size: " + resultList.size()); result.forEach(System.out::println); &#125; &#125; 输出结果： 1234567stringList's size: 7mghio 1.4 总结String 类中除了 split 方法外，有正则表达式接口的方法都是调用 Pattern（模式类）和 Matcher（匹配器类）进行实现的。JDK 源码的每一个如 final、private 的关键字都设计的十分严谨，多读类和方法中的javadoc，多注意这些细节对于阅读代码和自己写代码都有很大的帮助。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 字节码]]></title>
    <url>%2Fpost%2F192cb539.html</url>
    <content type="text"><![CDATA[1.1 什么是字节码？Java 在刚刚诞生之时曾经提出过一个非常著名的口号: “一次编写，到处运行（write once，run anywhere）”，这句话充分表达了软件开发人员对冲破平台界限的渴求。“与平台无关”的理想最终实现在操作系统的运用层上: 虚拟机提供商开发了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写到处运行”。各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—字节码（ByteCode），因此，可以看出字节码对 Java 生态的重要性。之所以被称为字节码，是因为字节码是由十六进制组成的，而 JVM（Java Virtual Machine）以两个十六进制为一组，即以字节为单位进行读取。在 Java 中使用 javac 命令把源代码编译成字节码文件，一个 .java 源文件从编译成 .class 字节码文件的示例如图 1 所示:图 1 对于从事基于 JVM 的语言的开发人员来说，比如: Java，了解字节码可以更准确、更直观的理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观的看到 volatile 关键字如何在字节码上生效。另外，字节码增强技术在各种 ORM 框架、Spring AOP、热部署等一些应用中经常使用，深入理解其原理对于我们来说大有裨益。由于 JVM 规范的存在，只要最终生成了符合 JVM 字节码规范的文件都可以在 JVM 上运行，因此，这个也给其它各种运行在 JVM 上的语言（如: Scala、Groovy、Kotlin）提供了一个机会，可以扩展 Java 没有实现的特性或者实现一些语法糖。接下来就让我们就一起看看这个字节码文件结构到底是什么样的。 1.2 Java 字节码结构Java 源文件通过用 javac 命令编译后就会得到 .class 结尾的字节码文件，比如一个简单的 JavaCodeCompilerDemo 类如图 2 所示:图 2编译后生成的 .class 字节码文件，打开后是一堆 十六进制 数，如图 3 所示:图 3在上节提过，JVM 对于字节码规范是有要求的，打开编译后的字节码文件看似混乱无章，其实它是符合一定的结构规范的，JVM 规范要求每一个字节码文件都要由十部分固定的顺序组成的，接下来我们将一一介绍这部分，整体的组成结构如图 4 所示:图 4 （1）魔数（Magic Number）每个字节码文件的头 4 个字节称为 魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如 gif 或者 jpg 等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意改动。魔数的固定值为: 0xCAFEBABE，魔数放在文件头，JVM 可以根据文件的开头来判断这个文件是否可能是一个字节码文件，如果是，才会进行之后的操作。 有趣的是，魔数的固定值是 Java 之父 James Gosling 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡。 （2）版本号（Version）版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version），上图 3 中版本号为: “00 00 00 34”，次版本号转化为十进制为 0，主版本号转化为十进制 52（3 * 16^1 + 4 * 16^0 = 52），在 Oracle 官网中查询序号 52 对应的 JDK 版本为 1.8，所以编译该源代码文件的 Java 版本为 1.8.0。 （3）常量池（Constant Pool）紧接着主版本号之后的字节是常量池入口。常量池中存储两种类型常量: 字面量和符号运用。字面量为代码中声明为 final 的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。常量池整体上分为两部分: 常量池计数器和常量池数据区，如图 5 所示：图 5常量池计数器（constant_pool_count）: 由于常量池的数量不固定，所以需要先放置两个字节来表示常量池容量计数值，图 2 示例代码的字节码的前十个字节如下图 6 所示，将十六进制的 17 转为十进制的值为 33 (1 * 16^1 + 7 * 16^0 = 33)，排除下标 0，也就是说这个类文件有 32 个常量。图 6常量池数据区: 数据区是由（constant_pool_count - 1）个 cp_info 结构组成，一个 cp_info 的结构对应一个常量。在字节码中共有 14 种类型的 cp_info ，每种类型的结构都是固定的，如图 7 所示:图 7以 CONSTANT_Utf8_info 为例，它的结构如表 1 所示: 名称 长度 值 tag 1 字节 01 对应图 7 中 CONSTANT_Utf8_info 的标志栏中的值 length 2 字节 该 utf8 字符串的长度 bytes length 字节 length 个字节的具体数据 表 1 首先第一个字节 tag，它的取值对应图 7 中的 Tag，由于它的类型是 CONSTANT_Utf8_info，所以值为 01（十六进制）。接下来两个字节标识该字符串的长度 length，然后 length 个字节为这个字符串具体的值。从图 3 的字节码中摘取一个 cp_info 结构，将它翻译过来后，其含义为: 该常量为 utf8 字符串，长度为 7 字节，数据为: numberA，如图 8 所示: 图 8其它类型的 cp_info 结构在本文不在细说，和 CONSTANT_Utf8_info 的结构大同小异，都是先通过 tag 来标识类型，然后后续的 n 个字节来描述长度和数据。等我们对这些结构比较了解了之后，我们可以通过: javap -verbose JavaCodeCompilerDemo 命令查看 JVM 反编译后的完整常量池，可以看到反编译结果可以将每一个 cp_info 结构的类型和值都很明确的呈现出来，如图 9 所示:图 9 （4）访问标志（access_flag）常量池结束之后的两个字节，描述该 Class 是类还是接口，以及是否被 Public、Abstract、Final 等修饰符修饰。JVM 规范规定了如下表 2 所示的 9 种访问标志。需要注意的是，JVM 并没有穷举所有的访问标志，而是使用 按位或 操作来进行描述的，比如某个类的修饰符为 public final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010 = 0x0011。 标志名称 标志值 含义 ACC_PUBLIC 0x0001 字段是否为 public ACC_PRIVATE 0x0002 字段是否为 private ACC_PROTECTED 0x0004 字段是否为 protected ACC_STATIC 0x0008 字段是否为 static ACC_FINAL 0x0010 字段是否为 final ACC_VOLATILE 0x0040 字段是否为 volatile ACC_TRANSIENT 0x0080 字段是否为 transient ACC_SYNCHETIC 0x1000 字段是否为编译器自动产生 ACC_ENUM 0x4000 字段是否为 enum 表 2 （5）当前类名（this_class）访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。 （6）父类名称（super_class）当前类名的后两个字节，描述父类的全限定名。这两个字节保存的值也是在常量池中的索引值，根据索引值就能在常量池中找到这个类的父类的全限定名。 （7）接口信息（interfaces）父类名称后的两个字节，描述这个类的接口计数器，即: 当前类或父类实现的接口数量。紧接着的 n 个字节是所有的接口名称的字符串常量在常量池的索引值。 （8）字段表（field_table）字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的 局部变量。字段表也分为两部分，第一部分是两个字节，描述字段个数，第二部分是每个字段的详细信息 field_info。字段表结构如图 10 所示:图 10以图 3 中的字节码字段表为例，如下图 11 所示。其中字段的访问标志查表 2，002 对应为 Private，通过索引下标在图 9 中常量池分别得到字段名为: numberA，描述符为: I（在JVM 中的I代表 Java 中的 int）。综上，就可以唯一确定出类 JavaCodeCompilerDemo 中声明的变量为: private int numberA 。图 11 （9）方法表（method_table）字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数，第二个部分为每个方法的详细信息。方法的详细信息包括：方法的访问标志、方法名、方法的描述符以及方法的属性，如图 12 所示:图 12方法的权限修饰符依然可以通过图 9 的值查询到，方法名和方法的描述符都是常量池的索引值，可以通过索引值在常量池中查询得到。而方法属性这个部分比较复杂，我们可以借助 javap -verbose 将其反编译为人们可读的信息进行解读。如图 13 所示。我们可以看到属性中包含三个部分: Code 区: 源代码对应的 JVM 指令操作码，我们在字节码增强的时候重点操作的就是这个部分。 LineNumberTable: 行号表，将 Code 区的操作码和源代码的行号对应，Debug 时会起到作用（即: 当源代码向下走一行，相应的需要走几个 JVM 指令操作码）。 LocalVariableTable: 本地变量表，包含 this 和局部变量，之所以可以在每一个非 static 的方法内部都可以调用到 this，是因为 JVM 将 this 作为每个方法的第一个参数隐式进行传入。图 13 （10）附加属性表（additional_attribute_table）字节码的最后一部分，存放了在文件中类或接口所定义的属性的基本信息。 1.3 Java 字节码操作集合在图 13 中，Code 区的编号是 0 ~ 10，就是 .java 源文件的方法源代码编译后让 JVM 真正执行的操作码。为了帮助人们理解，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码和助记符的对应关系，以及每个操作码的具体作用可以查看 Oracle 官网，在需要的时候查阅即可。比如上图 13 的助记符为 iconst_2，对应图 3 中的字节码 0x05，作用是将 int 值 2 压入操作数栈中。以此类推，对 0 ~ 10 的助记符理解后就是整个 sum() 方法的操作数码实现。 1.4 查看字节码工具如果我们每次反编译都要使用 javap 命令的话，确实比较繁琐，这里我推荐大家一个 IDEA 插件: jclasslib。使用效果如图 14 所示: 代码编译后在菜单栏: View -&gt; Show Bytecode With jclasslib，可以很直观地看到当前字节码文件的类信息、常量池、方法区等信息，非常方便。图 14 1.5 总结Java 中字节码文件是 JVM 执行引擎的数据入口，也是 Java 技术体系的基础构成之一。了解字节码文件的组成结构对后面进一步了解虚拟机和深入学习 Java 有很重要的意义。本文较为详细的讲解了字节码文件结构的各个组成部分，以及每个部分的定义、数据结构和使用方法。强烈建议自己动手分析一下，会理解得更加深入。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2Fpost%2Fb1d4025b.html</url>
    <content type="text"><![CDATA[1234567public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World ~~~"); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
