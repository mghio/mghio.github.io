<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mghio</title>
  
  <subtitle>Java 搬运工 &amp; 终身学习者。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mghio.cn/"/>
  <updated>2020-11-29T07:58:43.606Z</updated>
  <id>https://www.mghio.cn/</id>
  
  <author>
    <name>mghio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何实现一个简易版的 Spring - 如何实现 Setter 注入</title>
    <link href="https://www.mghio.cn/post/24cb2421.html"/>
    <id>https://www.mghio.cn/post/24cb2421.html</id>
    <published>2020-11-28T06:52:27.000Z</published>
    <updated>2020-11-29T07:58:43.606Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>之前在 <a href="https://www.mghio.cn/post/558ca0bd.html">上篇</a> 提到过会实现一个简易版的 <code>IoC</code> 和 <code>AOP</code>，今天它终于来了。。。相信对于使用 <code>Java</code> 开发语言的朋友们都使用过或者听说过 <code>Spring</code> 这个开发框架，绝大部分的企业级开发中都离不开它，通过 <a href="https://spring.io" target="_blank" rel="noopener">官网</a> 可以了解到其生态非常庞大，针对不同方面的开发提供了一些解决方案，可以说 <code>Spring</code> 框架的诞生是对 <code>Java</code> 开发人员的一大福利，自 <code>2004</code> 年发布以来，<code>Spring</code> 为了解决一些企业开发中的痛点先后引入了很多的特性和功能，其中最重要的就是我们经常听到的 <code>IoC</code> 和 <code>AOP</code> 特性，由于涉及到的知识和细节比较多，会分为几篇文章来介绍，今天这篇（也是第一篇）我们来看看如何实现基于 <code>XML</code> 配置方式的 <strong>Setter 注入</strong>。</p><a id="more"></a><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>既然是通过 <code>XML</code> 配置文件的方式，首先第一件事就是要读取 <code>XML</code> 文件然后转换为我们需要的数据结构，解析 <code>XML</code> 文件有但不限于这些方式（<a href="http://www.jdom.org" target="_blank" rel="noopener">JDOM</a>、<a href="http://www.xom.nu" target="_blank" rel="noopener">XOM</a>、<a href="https://dom4j.github.io" target="_blank" rel="noopener">dom4j</a>），这里使用的是简单易上手的 <a href="https://dom4j.github.io" target="_blank" rel="noopener">dom4j</a>，所你得对其基础知识有一些简单了解，其实都是一些很简单的方法基础使用而已，第二个就是你要有一些 <code>Spring</code> 框架的使用经验，这里实现的简易版本质上是对 <code>Spring</code> 的一个精简后的核心部分的简单实现，是的，没错，你只需要有了这些基础预备知识就可以了。</p><h4 id="基础数据结构抽象"><a href="#基础数据结构抽象" class="headerlink" title="基础数据结构抽象"></a>基础数据结构抽象</h4><p>在开始编码实现前先要做一些简单的构思和设计，首先在 <code>Spring</code> 中把一个被其管理的对象称之为 <code>Bean</code>，然后其它的操作都是围绕这个 <code>Bean</code> 来展开设计的，所以为了能在程序中统一并且规范的表示一个 <code>Bean</code> 的定义，于是第一个接口 <code>BeanDefinition</code> 就出来了，本次需要的一些基本信息包含 <code>Bean</code> 的名称、所属类名称、是否单例、作用域等，如下所示：</p><p><img src="https://i.loli.net/2020/11/28/1UGMFCPVfwgl3D7.png" alt="spring-injection-beandefinition-1.png"></p><p>现在 <code>BeanDefinition</code> 有了，接下来就是要根据这个 <code>BeanDefinition</code> 去创建出对应的 <code>Bean</code> 实例了，很显然这需要一个 <code>Factory</code> 工厂接口去完成这个创建的工作，这个创建 <code>Bean</code> 的接口命名为 <code>BeanFactory</code>，其提供根据不同条件去创建相对应的 <code>Bean</code> 实例功能（比如 <code>beanId</code>），但是创建的前提是需要先注册这个 <code>BeanDefinition</code>，然后根据一定条件再从中去获取 <code>BeanDefinition</code>，根据 <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank" rel="noopener">单一职责</a> 原则，这个功能应该由一个新的接口去完成，主要是做注册和获取 <code>BeanDefinition</code> 的工作，故将其命名为 <code>BeanDefinitionRegistry</code>，我们需要的 <code>BeanDefinition</code> 要从哪里获取呢？很显然我们是基于 <code>XML</code> 配置的方式，当然是从 <code>XML</code> 配置文件中获取到的，同样根据单一职责原则，也需要一个类去完成这个事情，将其命名为 <code>XMLBeanDefinitionReader</code>，这部分的整体结构如下所示：</p><p><img src="https://i.loli.net/2020/11/28/YnDv6MqHVNwTAg5.png" alt="spring-injection-beanfactory-2.png"></p><p>接下来面临的一个问题就是，像 <code>XML</code> 这种配置文件资源要如何表示呢，这些配置对于程序来说是一种资源，可以统一抽象为 <code>Resource</code>，然后提供一个返回资源对应流（<code>InputStream</code>）对象接口，这种资源可以从项目中获取、本地文件获取甚至是从远程获取，它们都是一种 <code>Resource</code>，结构如下：</p><p><img src="https://i.loli.net/2020/11/29/GBP2M3aZLhbfcm5.png" alt="spring-injection-resource-3.png"></p><p>最后就是要一个提供去组合调用上面的那些类去完成 <code>XML</code> 配置文件解析为 <code>BeanDefinition</code> 并注入到容器中了的功能，担任这程序上下文的职责，将其命名为 <code>ApplicationContext</code>，这里同样也可以根据 <code>Resource</code> 的类型分为多种不同的类，比如：<code>FileSystmXmlApplicationContext</code>、<code>ClassPathXmlApplicationContext</code> 等，这些内部都有一个将配置文件转换为 <code>Resource</code> 的过程，可以使用 <a href="https://en.wikipedia.org/wiki/Template_method_pattern" target="_blank" rel="noopener">模板方法</a> 抽象出一个公共父类抽象类，如下所示:</p><p><img src="https://i.loli.net/2020/11/29/ux1cEOAGQoqD9h8.png" alt="spring-injection-applicationcontext.png"></p><p>总结以上分析结果，得出初步类图设计如下：</p><p><img src="https://i.loli.net/2020/11/29/wOijZNT8cAlMY1r.png" alt="spring-injection-all-4.png"></p><p>最终要实现 <code>Setter</code> 注入这个目标，可以将其分解为以下两个步骤：</p><ol><li>将 <code>XML</code> 配置文件中的 <code>&lt;bean&gt;</code> 标签解析为 <code>BeanDefinition</code> 并注入到容器中</li><li>实现 <code>Setter</code> 注入</li></ol><p>下面我们分为这两个部分来分别讲述如何实现。</p><h4 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h4><p>假设有如下内容的配置文件 <code>applicationcontext-config1.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.e3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.service.version1.OrderService"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终需要解析出一个 <code>id</code> 为 <code>orderService</code> 类型为 <code>cn.mghio.service.version1.OrderService</code> 的 <code>BeanDefinition</code>，翻译成测试类的话也就是需要让如下测试类可以运行通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line">    <span class="keyword">private</span> DefaultBeanFactory beanFactory;</span><br><span class="line">    <span class="keyword">private</span> XmlBeanDefinitionReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeEach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"applicationcontext-config1.xml"</span>);</span><br><span class="line">        beanFactory = <span class="keyword">new</span> DefaultBeanFactory();</span><br><span class="line">        reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBeanFromXmlFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reader.loadBeanDefinition(resource);</span><br><span class="line">        BeanDefinition bd = beanFactory.getBeanDefinition(<span class="string">"orderService"</span>);</span><br><span class="line"></span><br><span class="line">        assertEquals(<span class="string">"cn.mghio.service.version1.OrderService"</span>, bd.getBeanClassNam());</span><br><span class="line">        OrderService orderService = (OrderService) beanFactory.getBean(<span class="string">"orderService"</span>);</span><br><span class="line">        assertNotNull(orderService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBeanFromXmlFileWithInvalidBeanId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertThrows(BeanCreationException.class, () -&gt; beanFactory.getBean(<span class="string">"notExistsBeanId"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetFromXmlFilWithFileNotExists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"notExists.xml"</span>);</span><br><span class="line">        assertThrows(BeanDefinitionException.class, () -&gt; reader.loadBeanDefinition(resource));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里面的关键就是如何去实现 <code>XmlBeanDefinitionReader</code> 类的 <code>loadBeanDefinition</code> 从配置中加载和注入 <code>BeanDefinition</code>，思考分析后不然发现这里主要是两步，第一步是解析 <code>XML</code> 配置转换为 <code>BeanDefinition</code>，这就需要上文提到的 <code>dom4j</code> 提供的能力了，第二步将解析出来的 <code>BeanDefinition</code> 注入到容器中，通过组合使用 <code>BeanDefinitionRegistry</code> 接口提供注册 <code>BeanDefinition</code> 的能力来完成。读取 <code>XML</code> 配置的类 <code>XmlBeanDefinitionReader</code> 的代码实现很快就可以写出来了，该类部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_ID_ATTRIBUTE = <span class="string">"id"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_CLASS_ATTRIBUTE = <span class="string">"class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registry = registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinition</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = resource.getInputStream()) &#123;</span><br><span class="line">            SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = saxReader.read(is);</span><br><span class="line">            Element root = document.getRootElement();  <span class="comment">// &lt;beans&gt;</span></span><br><span class="line">            Iterator&lt;Element&gt; iterator = root.elementIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Element element = iterator.next();</span><br><span class="line">                String beanId = element.attributeValue(BEAN_ID_ATTRIBUTE);</span><br><span class="line">                String beanClassName = element.attributeValue(BEAN_CLASS_ATTRIBUTE);</span><br><span class="line">                BeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition(beanId, beanClassName);</span><br><span class="line">                <span class="keyword">this</span>.registry.registerBeanDefinition(beanId, bd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException | IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionException(<span class="string">"IOException parsing XML document:"</span> + configurationFile, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后当调用 <code>BeanFactory</code> 的 <code>getBean</code> 方法时就可以根据 <code>Bean</code> 的全限定名创建一个实例出来了(PS：暂时不考虑实例缓存)，方法实现主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">    BeanDefinition bd = getBeanDefinition(beanId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == bd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(<span class="string">"BeanDefinition does not exists, beanId:"</span> + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    ClassLoader classLoader = <span class="keyword">this</span>.getClassLoader();</span><br><span class="line">    String beanClassName = bd.getBeanClassNam();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(beanClassName);</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(<span class="string">"Created bean for "</span> + beanClassName + <span class="string">" fail."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里配置文件解析方面的工作已完成，接下来看看要如何实现 <code>Setter</code> 注入。</p><h4 id="如何实现-Setter-注入"><a href="#如何实现-Setter-注入" class="headerlink" title="如何实现 Setter 注入"></a>如何实现 Setter 注入</h4><p>首先实现基于 <code>XML</code> 配置文件的 <code>Setter</code> 注入本质上也是解析 <code>XML</code> 配置文件，然后再调用对象属性的 <code>setXXX</code> 方法将配置的值设置进去，配置文件 <code>applicationcontext-config2.xml</code> 如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.e3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"stockDao"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.dao.version2.StockDao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tradeDao"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.dao.version2.TradeDao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.service.version2.OrderService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"stockDao"</span> <span class="attr">ref</span>=<span class="string">"stockDao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tradeDao"</span> <span class="attr">ref</span>=<span class="string">"tradeDao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"num"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"owner"</span> <span class="attr">value</span>=<span class="string">"mghio"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orderTime"</span> <span class="attr">value</span>=<span class="string">"2020-11-24 18:42:32"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们之前使用了 <code>BeanDefinition</code> 去抽象了 <code>&lt;bean&gt;</code> 标签，这里面临的第一个问题就是要如何去表达配置文件中的 <code>&lt;property&gt;</code> 标签，其中 <code>ref</code> 属性表示一个 <code>beanId</code>、<code>value</code> 属性表示一个值（值类型为：<code>Integer</code>、<code>String</code>、<code>Date</code> 等）。观察后可以发现，<code>&lt;property&gt;</code> 标签本质上是一个 <code>K-V</code> 格式的数据（<code>name</code> 作为 <code>Key</code>，<code>ref</code> 和 <code>value</code> 作为 <code>Value</code>），将这个类命名为 <code>PropertyValue</code>，很明显一个 <code>BeanDefinition</code> 会有多个 <code>PropertyValue</code>，结构如下：</p><p><img src="https://i.loli.net/2020/11/29/CK8HgDEuWTIFU45.png" alt="spring-injection-setter-property-1.png"></p><p>这里的 <code>value</code> 有两种不同的类型，一种是表示 <code>Bean</code> 的 <code>id</code> 值，运行时会解析为一个 <code>Bean</code> 的引用，将其命名为 <code>RuntimeBeanReference</code>，还有一种是 <code>String</code> 类型，运行时会解析为不同的类型，将其命名为 <code>TypeStringValue</code>。第二个问题就是要如何将一个类型转换为另一个类型呢？比如将上面配置中的字符串 <code>2</code> 转换为整型的 <code>2</code>、字符串 <code>2020-11-24 18:42:32</code> 转换为日期，这类通用的问题前辈们已经开发好了类库处理了，这里我们使用 <a href="https://commons.apache.org/proper/commons-beanutils" target="_blank" rel="noopener">commons-beanutils</a> 库提供的 <code>BeanUtils.copyProperty(final Object bean, final String name, final Object value)</code> 方法即可。然后只需在之前 <code>XmlBeanDefinitionReader</code> 类的 <code>loadBeanDefinition</code> 方法解析 <code>XML</code> 配置文件的时解析 <code>&lt;bean&gt;</code> 标签下的 <code>&lt;property&gt;</code> 标签并设置到 <code>BeanDefinition</code> 的 <code>propertyValues</code> 属性中；<code>DefaultBeanFactory</code> 中的 <code>getBean</code> 方法分为实例化 <code>Bean</code> 和读取向实例化完成的 <code>Bean</code> 使用 <code>Setter</code> 注入配置文件中配置属性对应的值。<code>XmlBeanDefinitionReader</code> 的 <code>loadBeanDefinition()</code> 方法代码修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinition</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream is = resource.getInputStream()) &#123;</span><br><span class="line">        SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = saxReader.read(is);</span><br><span class="line">        Element root = document.getRootElement();  <span class="comment">// &lt;beans&gt;</span></span><br><span class="line">        Iterator&lt;Element&gt; iterator = root.elementIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Element element = iterator.next();</span><br><span class="line">            String beanId = element.attributeValue(BEAN_ID_ATTRIBUTE);</span><br><span class="line">            String beanClassName = element.attributeValue(BEAN_CLASS_ATTRIBUTE);</span><br><span class="line">            BeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition(beanId, beanClassName);</span><br><span class="line">            parsePropertyElementValue(element, bd);  <span class="comment">// parse &lt;property&gt;</span></span><br><span class="line">            <span class="keyword">this</span>.registry.registerBeanDefinition(beanId, bd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DocumentException | IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionException(<span class="string">"IOException parsing XML document:"</span> + resource, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parsePropertyElementValue</span><span class="params">(Element element, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Element&gt; iterator = element.elementIterator(PROPERTY_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Element propertyElement = iterator.next();</span><br><span class="line">        String propertyName = propertyElement.attributeValue(NAME_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(propertyName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object value = parsePropertyElementValue(propertyElement, propertyName);</span><br><span class="line">        PropertyValue propertyValue = <span class="keyword">new</span> PropertyValue(propertyName, value);</span><br><span class="line">        bd.getPropertyValues().add(propertyValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">parsePropertyElementValue</span><span class="params">(Element propertyElement, String propertyName)</span> </span>&#123;</span><br><span class="line">    String elementName = (propertyName != <span class="keyword">null</span>) ?</span><br><span class="line">            <span class="string">"&lt;property&gt; element for property '"</span> + propertyName + <span class="string">"' "</span> : <span class="string">"&lt;constructor-arg&gt; element"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasRefAttribute = propertyElement.attribute(REF_ATTRIBUTE) != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasValueAttribute = propertyElement.attribute(VALUE_ATTRIBUTE) != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasRefAttribute) &#123;</span><br><span class="line">        String refName = propertyElement.attributeValue(REF_ATTRIBUTE);</span><br><span class="line">        RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;</span><br><span class="line">        String value = propertyElement.attributeValue(VALUE_ATTRIBUTE);</span><br><span class="line">        TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(value);</span><br><span class="line">        <span class="keyword">return</span> valueHolder;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(elementName + <span class="string">" must specify a ref or value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultBeanFactory</code> 的 <code>getBean</code> 方法也增加 <code>Bean</code> 属性注入操作，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">    BeanDefinition bd = getBeanDefinition(beanId);</span><br><span class="line">    <span class="comment">// 1. instantiate bean</span></span><br><span class="line">    Object bean = instantiateBean(bd);</span><br><span class="line">    <span class="comment">// 2. populate bean</span></span><br><span class="line">    populateBean(bd, bean);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">instantiateBean</span><span class="params">(BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoader = <span class="keyword">this</span>.getClassLoader();</span><br><span class="line">    String beanClassName = bd.getBeanClassName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(beanClassName);</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(<span class="string">"Created bean for "</span> + beanClassName + <span class="string">" fail."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(BeanDefinition bd, Object bean)</span> </span>&#123;</span><br><span class="line">    List&lt;PropertyValue&gt; propertyValues = bd.getPropertyValues();</span><br><span class="line">    <span class="keyword">if</span> (propertyValues == <span class="keyword">null</span> || propertyValues.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinitionResolver resolver = <span class="keyword">new</span> BeanDefinitionResolver(<span class="keyword">this</span>);</span><br><span class="line">    SimpleTypeConverted converter = <span class="keyword">new</span> SimpleTypeConverted();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : propertyValues) &#123;</span><br><span class="line">            String propertyName = propertyValue.getName();</span><br><span class="line">            Object originalValue = propertyValue.getValue();</span><br><span class="line">            Object resolvedValue = resolver.resolveValueIfNecessary(originalValue);</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperty(bean, propertyName, resolvedValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(<span class="string">"Failed to obtain BeanInfo for class ["</span> + bd.getBeanClassName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，简单的 <code>Setter</code> 注入功能已完成。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简单概述了基于 <code>XML</code> 配置文件方式的 <code>Setter</code> 注入简单实现过程，整体实现 <code>Setter</code> 注入的思路就是先设计一个数据结构去表达 <code>XML</code> 配置文件中的标签数据（比如上面的 <code>PropertyValue</code>），然后再解析配置文件填充数据并利用这个数据结构完成一些功能（比如 <code>Setter 注入等</code>）。感兴趣的朋友可以到这里 <a href="https://github.com/mghio/mghio-spring" target="_blank" rel="noopener">mghio-spring</a> 查看完整代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;之前在 &lt;a href=&quot;https://www.mghio.cn/post/558ca0bd.html&quot;&gt;上篇&lt;/a&gt; 提到过会实现一个简易版的 &lt;code&gt;IoC&lt;/code&gt; 和 &lt;code&gt;AOP&lt;/code&gt;，今天它终于来了。。。相信对于使用 &lt;code&gt;Java&lt;/code&gt; 开发语言的朋友们都使用过或者听说过 &lt;code&gt;Spring&lt;/code&gt; 这个开发框架，绝大部分的企业级开发中都离不开它，通过 &lt;a href=&quot;https://spring.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt; 可以了解到其生态非常庞大，针对不同方面的开发提供了一些解决方案，可以说 &lt;code&gt;Spring&lt;/code&gt; 框架的诞生是对 &lt;code&gt;Java&lt;/code&gt; 开发人员的一大福利，自 &lt;code&gt;2004&lt;/code&gt; 年发布以来，&lt;code&gt;Spring&lt;/code&gt; 为了解决一些企业开发中的痛点先后引入了很多的特性和功能，其中最重要的就是我们经常听到的 &lt;code&gt;IoC&lt;/code&gt; 和 &lt;code&gt;AOP&lt;/code&gt; 特性，由于涉及到的知识和细节比较多，会分为几篇文章来介绍，今天这篇（也是第一篇）我们来看看如何实现基于 &lt;code&gt;XML&lt;/code&gt; 配置方式的 &lt;strong&gt;Setter 注入&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
      <category term="IoC" scheme="https://www.mghio.cn/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>Spring 是如何造出一个 Bean 的</title>
    <link href="https://www.mghio.cn/post/558ca0bd.html"/>
    <id>https://www.mghio.cn/post/558ca0bd.html</id>
    <published>2020-10-08T07:26:10.000Z</published>
    <updated>2020-10-08T07:31:37.322Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>使用 <code>Java</code> 作为第一开发语言的朋友们，相信大家或多或少的都使用过 <code>Spring</code> 这个开发框架，可以说 <code>Spring</code> 框架真是我们 <code>Java</code> 程序员的春天，在 <code>Spring</code> 中 <code>Bean</code> 是其中最重要的概念之一，是学习其它高级知识的基础，<code>Bean</code> 本质上其实就是一个被 <code>Spring</code> 框架管理的对象，今天我们来看看 <code>Bean</code> 在 <code>Spring</code> 中是如何被造出来的。</p><a id="more"></a><h4 id="1-Bean-要如何定义"><a href="#1-Bean-要如何定义" class="headerlink" title="1. Bean 要如何定义"></a>1. Bean 要如何定义</h4><p>假如你有如下这样的一个 <code>Programmer</code> 类，这个程序员类有三个属性： <code>姓名(name)</code>、<code>年龄(age)</code>、<code>是否有女朋友(hasGirlFriend)</code>（P.S. 正常情况下 <code>hasGirlFriend</code> 属性应该都是 <code>false</code>），还有一个显示个人资料的方法 <code>showMaterial</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-10-05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Programmer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean hasGirlFriend;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMaterial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + name + <span class="string">", age: "</span> + age + <span class="string">", hasGirlFriend: "</span> + hasGirlFriend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在请你思考一下，如果让你来设计该如何在一个 <code>Spring</code> 容器中描述这样的一个 <code>Programmer</code> 对象呢？</p><p>无非就是需要如下这些信息：</p><h5 id="1-1-类名"><a href="#1-1-类名" class="headerlink" title="1.1 类名"></a>1.1 类名</h5><p>首先类名肯定是需要的，这样到时候才能通过类名加载到这个类。</p><h5 id="1-2-实例别名"><a href="#1-2-实例别名" class="headerlink" title="1.2 实例别名"></a>1.2 实例别名</h5><p>当我们在一个容器中如果一个类有多个实例或者不想通过一个类名来描述一个实例时，这时通过设置一个别名就可以很方便的描述该实例了。</p><h5 id="1-3-构造函数"><a href="#1-3-构造函数" class="headerlink" title="1.3 构造函数"></a>1.3 构造函数</h5><p>我们知道 <code>Java</code> 中创建一个类的实例首先就会调用该类的构造函数，当有多个构造函数时，需要明确的描述要使用哪个构造函数来创建对象，比如通过传入不同的参数类型来选择不同的构造函数。</p><h5 id="1-4-类的属性设置"><a href="#1-4-类的属性设置" class="headerlink" title="1.4 类的属性设置"></a>1.4 类的属性设置</h5><p>当我们没有在构造函数中传入属性，比如上面的 <code>Programmer</code> 可以直接通过无参构造函数就可以创建出来了，后面如果需要设置实例的属性则需要调用其设置属性的方式来进行设置，所以属性方法也是必要的。</p><h5 id="1-5-初始化方法"><a href="#1-5-初始化方法" class="headerlink" title="1.5 初始化方法"></a>1.5 初始化方法</h5><p>有时候我们需要在一个实例化完成之后做一些我们自定义的业务逻辑，比如想让上面例子中的 <code>Programmer</code> 在实例化完成之后就显示个人资料（调用 <code>showMaterial()</code> 方法），这种场景使用初始化方法就很合适了。</p><h5 id="1-6-销毁方法"><a href="#1-6-销毁方法" class="headerlink" title="1.6 销毁方法"></a>1.6 销毁方法</h5><p>说到销毁，大家可能都会想到和资源有关，比如一个共识就是大家一般都把资源释放类的工作放在 <code>finally</code> 代码块中确保资源可以得到释放，同样当一个 <code>Bean</code> 之后连接使用了某些资源时，当销毁后想要对这些资源进行释放，这时候就可以通过其 <code>销毁方法</code> 来释放资源。</p><h5 id="1-7-作用域"><a href="#1-7-作用域" class="headerlink" title="1.7 作用域"></a>1.7 作用域</h5><p>有些 <code>Bean</code> 可能需要在整个容器中只有一个，也就是<code>单例</code>，而有些可能要求每一次请求对应的 <code>Bean</code> 都不一样，这时可以通过一个 <code>作用域</code> 的概念，来区分不同要求的 <code>Bean</code>，当容器发现这个类是 <code>单例</code> 的，就会复用已存在的 <code>Bean</code>，否则才重新创建。</p><p>当然这里只是列举一些个人觉得比较重要的属性，还有其它的一些属性需要增加。在 <code>Spring</code> 框架中 <code>Bean</code> 的定义是通过一个 <code>BeanDefinition</code> 类来描述的。</p><p><img src="https://i.loli.net/2020/09/13/XrgQn5FCYuzvBx2.jpg" alt="spring-bean-create-1.jpg"></p><p>在没有使用 <code>SpringBoot</code> 之前我们都是通过 <code>XML</code> 配置然后 <code>Spring</code> 来解析生成 <code>Bean</code> 的，同时我们也可以通过代码方式使用 <code>BeanDefinitionBuilder</code> 生成 <code>Bean</code>，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: guihai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020-10-05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgrammerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Programmer().showMaterial();</span><br><span class="line"></span><br><span class="line">        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(Programmer.class);</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">"name"</span>, <span class="string">"mghio"</span>);</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">"age"</span>, <span class="number">18</span>);</span><br><span class="line">        beanDefinitionBuilder.addPropertyValue(<span class="string">"hasGirlFriend"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">"programmer"</span>, beanDefinitionBuilder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">        Programmer programmer = (Programmer) beanFactory.getBean(<span class="string">"programmer"</span>);</span><br><span class="line">        programmer.showMaterial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://i.loli.net/2020/09/13/wTzyFQvsXd8qAnj.jpg" alt="spring-bean-create-2.jpg"></p><p>在使用 <code>XML</code> 方式时一般是通过调用 <code>ClassPathXmlApplicationContext</code> 来注册 <code>Bean</code> 的，其构造函数可以传入具体的 <code>XMl</code>配置文件的路径，可以是一个或者多个，甚至还可以是通配符。在构造函数内部就会调用熟悉的 <code>refresh</code> 方法了。</p><p><img src="https://i.loli.net/2020/09/13/tedJ51ApwlcsHCM.jpg" alt="spring-bean-create-3.jpg"></p><p>深入 <code>refresh</code> 方法可以发现，在该方法中调用了 <code>obtainFreshBeanFactory</code> 方法来获取生成的 <code>Bean</code>，这个方法实际上是调用了抽象实现类 <code>AbstractRefreshableApplicationContext</code> 的 <code>refreshBeanFactory</code> 方法，该方法首先会先判断此时是否还有 <code>beanFactory</code> ，如果有的话会先销毁 <code>beanFactory</code>，然后再重新创建一个 <code>BeanFactory</code>（实际上是 <code>DefaultListableBeanFactory</code> 类型)，最后会调用 <code>loadBeanDefinitions</code> 加载我们定义的 <code>XMl</code> 配置，方法使用的是 <code>XmlBeanDefinitionReader</code> 来读取的 <code>XMl</code> 配置，下面一起来深入的了解一下 <code>Spring</code> 生成 <code>Bean</code> 的过程。 </p><h4 id="2-创建-Bean-的过程"><a href="#2-创建-Bean-的过程" class="headerlink" title="2. 创建 Bean 的过程"></a>2. 创建 Bean 的过程</h4><p>首先我们看看 <code>BeanFactory</code> 类图，如下所示：</p><p><img src="https://i.loli.net/2020/09/13/V7eoDtFdXuvQSyz.png" alt="spring-bean-create-4.jpg"></p><p><code>Bean</code> 的整体创建流程如下所示：</p><p><img src="https://i.loli.net/2020/10/08/8PUkYIGbFoJxVSq.png" alt="spring-create-bean.png"></p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>本文简要的讲述了 <code>Spring</code> 创建 <code>Bean</code> 的主要流程，还有许多细节的地方需要深入研读源码才能了解，在这里先给自己一个小目标，后续会自己实现一个简易版本的 <code>Spring</code>（<code>IOC</code>、<code>AOP</code>），预知后事如何，请看下篇博文。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;使用 &lt;code&gt;Java&lt;/code&gt; 作为第一开发语言的朋友们，相信大家或多或少的都使用过 &lt;code&gt;Spring&lt;/code&gt; 这个开发框架，可以说 &lt;code&gt;Spring&lt;/code&gt; 框架真是我们 &lt;code&gt;Java&lt;/code&gt; 程序员的春天，在 &lt;code&gt;Spring&lt;/code&gt; 中 &lt;code&gt;Bean&lt;/code&gt; 是其中最重要的概念之一，是学习其它高级知识的基础，&lt;code&gt;Bean&lt;/code&gt; 本质上其实就是一个被 &lt;code&gt;Spring&lt;/code&gt; 框架管理的对象，今天我们来看看 &lt;code&gt;Bean&lt;/code&gt; 在 &lt;code&gt;Spring&lt;/code&gt; 中是如何被造出来的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Spring/"/>
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Spring/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>从 CPU 缓存看缓存的套路</title>
    <link href="https://www.mghio.cn/post/fa75f5d7.html"/>
    <id>https://www.mghio.cn/post/fa75f5d7.html</id>
    <published>2020-09-24T15:07:50.000Z</published>
    <updated>2020-09-24T15:15:59.031Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>不同存储技术的访问时间差异很大，从 <code>计算机层次结构</code> 可知，通常情况下，从高层往底层走，存储设备变得更慢、更便宜同时体积也会更大，<code>CPU</code> 和内存之间的速度存在着巨大的差异，此时就会想到计算机科学界中一句著名的话：<code>计算机科学的任何一个问题，都可以通过增加一个中间层来解决。</code></p><h4 id="二、引入缓存层"><a href="#二、引入缓存层" class="headerlink" title="二、引入缓存层"></a>二、引入缓存层</h4><p>为了解决速度不匹配问题，可以通过引入一个缓存中间层来解决问题，但是也会引入一些新的问题。现代计算机系统中，从硬件到操作系统、再到一些应用程序，绝大部分的设计都用到了著名的<strong>局部性原理</strong>，局部性通常有如下两种不同的形式：</p><blockquote><p>时间局部性：在一个具有良好的时间局部性的程序当中，被引用过一次的内存位置，在将来一个不久的时间内很可能会被再次引用到。</p></blockquote><blockquote><p>空间局部性：在一个具有良好的空间局部性的程序当中，一个内存位置被引用了一次，那么在不久的时间内很可能会引用附近的位置。</p></blockquote><a id="more"></a><p>有上面这个<code>局部性</code>原理为理论指导，为了解决二者速度不匹配问题就可以在 <code>CPU</code> 和内存之间加一个缓存层，于是就有了如下的结构：</p><p><img src="https://i.loli.net/2020/08/16/B9RQlyUMg18HxOT.jpg" alt="Xnip2020-08-16_22-51-12.jpg"></p><h4 id="三、何时更新缓存"><a href="#三、何时更新缓存" class="headerlink" title="三、何时更新缓存"></a>三、何时更新缓存</h4><p>在 <code>CPU</code>  中引入缓存中间层后，虽然可以解决和内存速度不一致的问题，但是同时也面临着一个问题：<strong>当 CPU 更新了其缓存中的数据之后，要什么时候去写入到内存中呢？</strong>，比较容易想到的一个解决方案就是，<code>CPU</code> 更新了缓存的数据之后就立即更新到内存中，也就是说当 <code>CPU</code> 更新了缓存的数据之后就会从上到下更新，直到内存为止，英文称之为<code>write through</code>，这种方式的优点是比较简单，但是缺点也很明显，由于每次都需要访问内存，所以速度会比较慢。还有一种方法就是，当 <code>CPU</code> 更新了缓存之后并不马上更新到内存中去，在<code>适当的时候</code>再执行写入内存的操作，因为有很多的缓存只是存储一些中间结果，没必要每次都更新到内存中去，英文称之为<code>write back</code>，这种方式的优点是 <code>CPU</code> 执行更新的效率比较高，缺点就是实现起来会比较复杂。</p><p>上面说的<code>在适当的时候写入内存</code>，如果是单核 <code>CPU</code> 的话，可以在缓存要被新进入的数据取代时，才更新内存，但是在多核 <code>CPU</code> 的情况下就比较复杂了，由于 <code>CPU</code> 的运算速度超越了 1 级缓存的数据 <code>I\O</code> 能力，<code>CPU</code> 厂商又引入了多级的缓存结构，比如常见的 L1、L2、L3 三级缓存结构，L1 和 L2 为 <code>CPU</code> 核心独有，L3 为 <code>CPU</code> 共享缓存。</p><p><img src="https://i.loli.net/2020/08/16/zlioMu1W8naRJH2.jpg" alt="Xnip2020-08-16_23-39-28.jpg"></p><p>如果现在分别有两个线程运行在两个不同的核  <code>Core 1</code> 和 <code>Core 2</code> 上，内存中 <code>i</code> 的值为 1，这两个分别运行在两个不同核上的线程要对 <code>i</code> 进行加 1 操作，如果不加一些限制，两个核心同时从内存中读取 <code>i</code> 的值，然后进行加 1 操作后再分别写入内存中，可能会出现相互覆盖的情况，解决的方法相信大家都能想得到，第一种是只要有一个核心修改了缓存的数据之后，就立即把内存和其它核心更新。第二种是当一个核心修改了缓存的数据之后，就把其它同样复制了该数据的 <code>CPU</code> 核心失效掉这些数据，等到合适的时机再更新，通常是下一次读取该缓存的时候发现已经无效，才从内存中加载最新的值。</p><h4 id="四、缓存一致性协议"><a href="#四、缓存一致性协议" class="headerlink" title="四、缓存一致性协议"></a>四、缓存一致性协议</h4><p>不难看出第一种需要频繁访问内存更新数据，执行效率比较低，而第二种会把更新数据推迟到最后一刻才会更新，读取内存，效率高（类似于<code>懒加载</code>）。 <strong>缓存一致性协议(MESI)</strong> 就是使用第二种方案，该协议主要是保证缓存内部数据的一致，不让系统数据混乱。<code>MESI</code> 是指 4 种状态的首字母。每个缓存存储数据单元（Cache line）有 4 种不同的状态，用 2 个 bit 表示，状态和对应的描述如下：</p><table><thead><tr><th align="left">状态</th><th>描述</th><th>监听任务</th></tr></thead><tbody><tr><td align="left"><strong>M</strong> 修改 (Modified)</td><td>该 Cache line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中</td><td>Cache line 必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成 S（共享）状态之前被延迟执行</td></tr><tr><td align="left"><strong>E</strong> 独享、互斥 (Exclusive)</td><td>该 Cache line 有效，数据和内存中的数据一致，数据只存在于本 Cache 中</td><td>Cache line 必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成 S（共享）状态</td></tr><tr><td align="left"><strong>S</strong> 共享 (Shared)</td><td>该 Cache line 有效，数据和内存中的数据一致，数据存在于很多 Cache 中</td><td>Cache line 必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该 Cache line 变成无效</td></tr><tr><td align="left"><strong>I</strong> 无效 (Invalid)</td><td>该 Cache line 无效</td><td>无监听任务</td></tr></tbody></table><p>下面看看基于<code>缓存一致性协议</code>是如何进行读取和写入操作的， 假设现在有一个双核的 <code>CPU</code>，为了描述方便，简化一下只看其逻辑结构：</p><p><img src="https://i.loli.net/2020/08/17/8Zi1SKb4nAdEtgo.jpg" alt="Xnip2020-08-17_08-44-37.jpg"></p><p><strong>单核读取步骤</strong>：<code>Core 0</code> 发出一条从内存中读取 a 的指令，从内存通过  <code>BUS</code> 读取 a 到 <code>Core 0</code> 的缓存中，因为此时数据只在 <code>Core 0</code> 的缓存中，所以将 <code>Cache line</code> 修改为 <strong>E</strong> 状态（独享），该过程用示意图表示如下：</p><p><img src="https://s1.ax1x.com/2020/08/17/dnmKYQ.jpg" alt="dnmKYQ.jpg"></p><p><strong>双核读取步骤</strong>：首先 <code>Core 0</code> 发出一条从内存中读取 a 的指令，从内存通过 <code>BUS</code> 读取 a 到 <code>Core 0</code> 的缓存中，然后将 <code>Cache line</code> 置为 <strong>E</strong> 状态，此时 <code>Core 1</code> 发出一条指令，也是要从内存中读取 a，当 <code>Core 1</code> 试图从内存读取 a 的时候， <code>Core 0</code> 检测到了发生地址冲突（其它缓存读主存中该缓存行的操作），然后 <code>Core 0</code> 对相关数据做出响应，a 存储于这两个核心 <code>Core 0</code> 和 <code>Core 1</code> 的缓存行中，然后设置其状态为 <strong>S</strong> 状态（共享），该过程示意图如下：</p><p><a href="https://imgchr.com/i/dnQsoV" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/17/dnQsoV.jpg" alt="dnQsoV.jpg"></a></p><p>假设此时 <code>Core 0</code> 核心需要对 <code>a</code> 进行修改了，首先 <code>Core 0</code> 会将其缓存的 <code>a</code> 设置为 <strong>M</strong>（修改）状态，然后通知其它缓存了 <code>a</code> 的其它核 <code>CPU</code>（比如这里的 <code>Core 1</code>）将内部缓存的 <code>a</code> 的状态置为 <strong>I</strong>（无效）状态，最后才对 <code>a</code> 进行赋值操作。该过程如下所示：</p><p><img src="https://s1.ax1x.com/2020/08/17/dnQxeI.jpg" alt="dnQxeI.jpg"></p><p>细心的朋友们可能已经注意到了，上图中内存中 <code>a</code> 的值（值为 <code>1</code>）并不等于 <code>Core 0</code> 核心中缓存的最新值（值为 <code>2</code>），那么要什么时候才会把该值更新到内存中去呢？就是当 <code>Core 1</code> 需要读取 <code>a</code> 的值的时候，此时会通知 <code>Core 0</code> 将 <code>a</code> 的修改后的最新值同步到内存（<code>Memory</code>）中去，在这个同步的过程中 <code>Core 0</code> 中缓存的 <code>a</code> 的状态会置为 <strong>E</strong>（独享）状态，同步完成后将 <code>Core 0</code> 和 <code>Core 1</code> 中缓存的 <code>a</code> 置为 <strong>S</strong>（共享）状态，示意图描述该过程如下所示：</p><p><img src="https://s1.ax1x.com/2020/08/17/dn8HHA.jpg" alt="dn8HHA.jpg"></p><p>至此，变量 <code>a</code> 在 <code>CPU</code> 的两个核 <code>Core 0</code> 和 <code>Core 1</code> 中回到了 <strong>S</strong>（共享）状态了，以上只是简单的描述了一下大概的过程，实际上这些都是在 <code>CPU</code> 的硬件层面上去保证的，而且操作比较复杂。</p><h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>现在很多一些实现缓存功能的应用程序都是基于这些思想设计的，缓存把数据库中的数据进行缓存到速度更快的内存中，可以加快我们应用程序的响应速度，比如我们使用常见的 <code>Redis</code> 数据库可能是采用下面这些策略：① 首先应用程序从缓存中查询数据，如果有就直接使用该数据进行相应操作后返回，如果没有则查询数据库，更新缓存并且返回。② 当我们需要更新数据时，先更新数据库，然后再让缓存失效，这样下次就会先查询数据库再回填到缓存中去，可以发现，实际上底层的一些思想都是相通的，不同的只是对于特定的场景可能需要增加一些额外的约束。基础知识才是技术这颗大树的根，我们先把根栽好了，剩下的那些枝和叶都是比较容易得到的东西了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h4&gt;&lt;p&gt;不同存储技术的访问时间差异很大，从 &lt;code&gt;计算机层次结构&lt;/code&gt; 可知，通常情况下，从高层往底层走，存储设备变得更慢、更便宜同时体积也会更大，&lt;code&gt;CPU&lt;/code&gt; 和内存之间的速度存在着巨大的差异，此时就会想到计算机科学界中一句著名的话：&lt;code&gt;计算机科学的任何一个问题，都可以通过增加一个中间层来解决。&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;二、引入缓存层&quot;&gt;&lt;a href=&quot;#二、引入缓存层&quot; class=&quot;headerlink&quot; title=&quot;二、引入缓存层&quot;&gt;&lt;/a&gt;二、引入缓存层&lt;/h4&gt;&lt;p&gt;为了解决速度不匹配问题，可以通过引入一个缓存中间层来解决问题，但是也会引入一些新的问题。现代计算机系统中，从硬件到操作系统、再到一些应用程序，绝大部分的设计都用到了著名的&lt;strong&gt;局部性原理&lt;/strong&gt;，局部性通常有如下两种不同的形式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间局部性：在一个具有良好的时间局部性的程序当中，被引用过一次的内存位置，在将来一个不久的时间内很可能会被再次引用到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;空间局部性：在一个具有良好的空间局部性的程序当中，一个内存位置被引用了一次，那么在不久的时间内很可能会引用附近的位置。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="缓存" scheme="https://www.mghio.cn/categories/Java/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="缓存" scheme="https://www.mghio.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合类 List 的那些坑</title>
    <link href="https://www.mghio.cn/post/d7d0fc76.html"/>
    <id>https://www.mghio.cn/post/d7d0fc76.html</id>
    <published>2020-08-23T06:20:29.000Z</published>
    <updated>2020-08-23T06:22:47.888Z</updated>
    
    <content type="html"><![CDATA[<p>现在的一些高级编程语言都会提供各种开箱即用的数据结构的实现，像 Java 编程语言的集合框架中就提供了各种实现，集合类包含 Map 和 Collection 两个大类，其中 Collection 下面的 List 列表是我们经常使用的集合类之一，很多的业务代码都离不开它，今天就来看看 List 列表的一些坑。 </p><h4 id="第一个坑：Arrays-asList-方法返回的-List-不支持增加、删除操作"><a href="#第一个坑：Arrays-asList-方法返回的-List-不支持增加、删除操作" class="headerlink" title="第一个坑：Arrays.asList 方法返回的 List 不支持增加、删除操作"></a>第一个坑：Arrays.asList 方法返回的 List 不支持增加、删除操作</h4><p>例如我们执行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"m"</span>, <span class="string">"g"</span>);</span><br><span class="line">strings.add(<span class="string">"h"</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>会抛出 <code>java.lang.UnsupportedOperationException</code> 异常，此时你内心 OS <code>what？明明返回的 ArrayList 为啥不能往里面增加元素，这以后还能好好的增加元素吗？</code>，然后果断开启 <code>Debug</code> 大法：</p><p><img src="https://i.loli.net/2020/08/16/KmfHqv7Nbp8nLUo.jpg" alt="list-pit-one.jpg"></p><p>发现返回的 <code>ArrayList</code> 并不是我们常用的 <code>java.util.ArrayList</code>，而是 <code>Arrays</code> 的内部类 <code>java.util.Arrays.ArrayList</code>。进入方法 <code>Arrays.asList</code> 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法返回的是 <code>Arrays</code> 的静态内部类 <code>java.util.Arrays.ArrayList</code>，该类虽然和 <code>java.util.ArrayList</code> 也继承自抽象类 <code>java.util.AbstractList</code> ，但是通过该类的源码发现它并没有对抽象父类<code>AbstractList</code>的 <code>add</code> 方法默认就是抛出 <code>java.lang.UnsupportedOperationException</code> 异常。</p><p><img src="https://i.loli.net/2020/08/16/s39KntxwCBhOI7o.jpg" alt="list-pit-two.jpg"></p><p>这个坑的根本原因是我们调用返回的 <code>strings</code> 的 <code>add</code> 方法是继承自抽象父类的 <code>add</code> 方法，而抽象父类的方法默认就是抛出 <code>java.lang.UnsupportedOperationException</code> 这个异常。</p><h4 id="第二个坑，Arrays-asList-方法返回的新-List-和该方法原始入参数组修改会相互影响"><a href="#第二个坑，Arrays-asList-方法返回的新-List-和该方法原始入参数组修改会相互影响" class="headerlink" title="第二个坑，Arrays.asList 方法返回的新 List 和该方法原始入参数组修改会相互影响"></a>第二个坑，Arrays.asList 方法返回的新 List 和该方法原始入参数组修改会相互影响</h4><p><code>Arrays.asList</code>  方法除了上面这个 <strong>不支持增加、删除元素</strong> 这个坑之外，还有另外一个坑：</p><p><img src="https://i.loli.net/2020/08/16/znEUbRDO51YpiWe.jpg" alt="list-pit-three.jpg"></p><p>从以上代码可以发现，对原始数组的修改会影响我们通过 <code>Arrays.asList</code>方法获得的新 <code>List</code>，深入 <code>java.util.Arrays.ArrayList</code> 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2764017481108945198L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">        ArrayList(E[] array) &#123;</span><br><span class="line">            a = Objects.requireNonNull(array);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>可以发现是直接使用了原始的数组，所有当我们使用 <code>Arrays.asList</code> 方式获得的 <code>List</code> 时要特别注意，因为共享了数组，相互修改时可能产生一些意想不到的 Bug。标准的姿势之一是将其作为 <code>ArrayList</code> 构造方法的参数重新 <code>new</code> 一个 <code>List</code> 出来即可（e.g. <code>List&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(arrays))</code>）或者通过 <code>Guava</code> 库中的 <code>Lists.newArrayList</code> ，将返回的新 <code>List</code> 和原始的数组解耦，就不会再互相影响了。</p><h4 id="第三个坑，直接遍历-List-集合删除元素会报错"><a href="#第三个坑，直接遍历-List-集合删除元素会报错" class="headerlink" title="第三个坑，直接遍历 List 集合删除元素会报错"></a>第三个坑，直接遍历 List 集合删除元素会报错</h4><p>在直接遍历集合元素时增加、删除元素会报错，比如执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Lists.newArrayList(<span class="string">"m"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : stringList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Arrays.asList(<span class="string">"m"</span>, <span class="string">"h"</span>).contains(s)) &#123;</span><br><span class="line">        stringList.remove(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以正常编译通过，但是执行时会抛出 <code>java.util.ConcurrentModificationException</code> 异常，查看其源码可以发现，删除元素方法 <code>remove</code> 会使集合结构发生修改，也就是 <code>modCount（</code>集合实际修改的次数）会修改，在循环过程中，会比较当前 <code>List</code> 的集合实际修改的次数 <code>modCount</code> 与迭代器修改的次数 <code>expectedModCount</code> ，而 <code>expectedModCount</code> 是初始化时的 <code>modCount</code>， 二者不相等，就会报 <code>ConcurrentModificationException</code> 异常。解决方法主要有两种方式，1.使用 <code>ArrayList</code> 的迭代器方式遍历，然后调用其中的方法。2.在 JDK 1.8+ 可以使用 <code>removeIf</code> 方法进行删除操作。</p><p>最后扎心一问：调用 <code>ArrayList</code> 的 <code>remove</code> 方法传入 <code>int</code> 基本类型的数字和 <code>Integer</code> 包装类型的数字，执行结果是不是一样的？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的一些高级编程语言都会提供各种开箱即用的数据结构的实现，像 Java 编程语言的集合框架中就提供了各种实现，集合类包含 Map 和 Collection 两个大类，其中 Collection 下面的 List 列表是我们经常使用的集合类之一，很多的业务代码都离不开它，今天就来看看 List 列表的一些坑。 &lt;/p&gt;
&lt;h4 id=&quot;第一个坑：Arrays-asList-方法返回的-List-不支持增加、删除操作&quot;&gt;&lt;a href=&quot;#第一个坑：Arrays-asList-方法返回的-List-不支持增加、删除操作&quot; class=&quot;headerlink&quot; title=&quot;第一个坑：Arrays.asList 方法返回的 List 不支持增加、删除操作&quot;&gt;&lt;/a&gt;第一个坑：Arrays.asList 方法返回的 List 不支持增加、删除操作&lt;/h4&gt;&lt;p&gt;例如我们执行以下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; strings = Arrays.asList(&lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;g&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;strings.add(&lt;span class=&quot;string&quot;&gt;&quot;h&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="List" scheme="https://www.mghio.cn/categories/Java/List/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="List" scheme="https://www.mghio.cn/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 基础概念进阶</title>
    <link href="https://www.mghio.cn/post/f92758d8.html"/>
    <id>https://www.mghio.cn/post/f92758d8.html</id>
    <published>2020-08-09T14:28:00.000Z</published>
    <updated>2020-08-09T14:44:05.879Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇 <a href="https://www.mghio.cn/post/c34b451f.html">RabbitMQ 入门之基础概念</a> 介绍了 RabbitMQ 的一些基础概念，本文再来介绍其中的一些细节和其它的进阶的概念。</p><h4 id="消息生产者发送的消息不可达时如何处理"><a href="#消息生产者发送的消息不可达时如何处理" class="headerlink" title="消息生产者发送的消息不可达时如何处理"></a>消息生产者发送的消息不可达时如何处理</h4><p>RabbitMQ 提供了消息在传递过程中无法发送到一个队列（比如根据自己的类型和路由键没有找到匹配的队列）时将消息回传给消息发送方的功能，使用 RabbitMQ 的客户端提供 <code>channel.basicPublish</code> 方法的两个参数 <code>mandatory</code> 和 <code>immediate</code> (RabbitMQ 3.0 以下版本)，除此之外还提供了一个备份交换器可以将无法发送的消息存储起来处理，不用重新传回给发送方。</p><a id="more"></a><h5 id="1-1-mandatory-参数"><a href="#1-1-mandatory-参数" class="headerlink" title="1.1 mandatory 参数"></a>1.1 mandatory 参数</h5><p>mandatory 被定义在 RabbitMQ 提供的客户端的 <code>channel.basicPublish</code> 方法中，如下所示：</p><p><img src="https://i.loli.net/2020/08/09/iZ5cOLFDSmXQ2JI.png" alt="rabbitmq_advanced_1.png"></p><p>当把方法的 mandatory 参数设置为 <code>true</code> 时，那么会在交换器无法根据自身的类型和路由键找到一个符合要求的队列时，RabbitMQ 会自动调用 <code>Basic.Return</code> 把该消息回传给发送方也就是我们的消息生产者。反之，如果设置为 <code>false</code> 的话，消息就会被直接丢弃掉。那么问题来了，我们要如何去获取这些没有被发送出去的消息呢？RabbitMQ 给我们提供了事件监听机制来获取这种消息，可以通过 <code>addReturnListener</code> 方法添加一个 <code>ReturnListener</code> 来获取这种未发送到队列的消息，如下所示：</p><p><img src="https://i.loli.net/2020/08/09/euBVbRUdAymOW26.png" alt="rabbitmq_advanced_2.png"></p><p>通过查看 ReturnListener 接口的源码可以看到，该接口只有一个方法，如果是 JDK8+ 的版本的话可以使用 Lambda 表达式来简化一些代码。</p><p>可以看出，当设置了 mandatory 参数时，还必须为生产者同时添加 ReturnListener 监听器的编程逻辑，这样就会使得生产者的代码变得更加复杂了，为了处理这种情况，RabbitMQ 提供了 <code>备份交换器</code> 来将没有成功路由出去的消息存储起来，当我们需要的时候再去处理即可。</p><h5 id="1-2-immediate-参数"><a href="#1-2-immediate-参数" class="headerlink" title="1.2 immediate 参数"></a>1.2 immediate 参数</h5><p>该的参数同样也是在<code>channel.basicPublish</code> 方法中定义的，其官方描述如下：</p><blockquote><p>This flag tells the server how to react if the message cannot be routed to a queue consumer immediately. If this flag is set, the server will return an undeliverable message with a Return method. If this flag is zero, the server will queue the message, but with no guarantee that it will ever be consumed.</p></blockquote><p>当把 immediate 参数设置为 true 时，如果交换器根据其类型和路由键找到符合要求的队列时，发现所有队列上没有任何消费者，则该消息并不会存入到队列中，会通过 Basic.Return 命令把消息回传给生产者。简而言之也就是说，当设置了 immediate 参数时，该消息关联的队列上存在消费者时，会立即发送消息到该队列中，反之如果匹配的队列上不存在任何消费者，则直接把消息回传给生产者。这里有一点需要注意的是：从 RabbitMQ 3.0 + 已经去除了该参数。</p><h4 id="如何对消息和队列设置过期时间-（TTL）"><a href="#如何对消息和队列设置过期时间-（TTL）" class="headerlink" title="如何对消息和队列设置过期时间 （TTL）"></a>如何对消息和队列设置过期时间 （TTL）</h4><p>TTL 是 time to live 首字母的简称，RabbitMQ 中可以设置消息和队列的过期时间，我们先来看看要如何设置消息的过期时间。</p><h5 id="1-1-消息-TTL-设置"><a href="#1-1-消息-TTL-设置" class="headerlink" title="1.1 消息 TTL 设置"></a>1.1 消息 TTL 设置</h5><p>RabbitMQ 提供了两种设置消息的过期时间，第一种是通过队列的属性设置，该方式的特点就是队列中所有消息的过期时间都一致。还有一种是更小粒度的设置，就是对每条消息单独设置过期时间，这种方式更加灵活，每条消息的过期时间都可以不一样。这是你可能会问，如果同时设置了队列的过期属性和消息本身的过期属性，最终以哪个为准呢？结果是 RabbitMQ 会比较这两个 TTL 的值大小，以较小的那个为准。很容易想到，通过队列的属性的方式设置过期时间的话是在声明队列的时候指定，对应到客户端就是其提供的 <code>channel.queueDeclare</code> 方法的参数 arguments 指定，示例代码如下：</p><p><img src="https://i.loli.net/2020/08/09/Fm54eid7fY3x2LA.png" alt="rabbitmq_advanced_3.png"></p><p>需要注意的是 <code>x-message-ttl</code> 参数的单位是毫秒。如果不设置 TLL，则表示该消息不会过期，如果将 TTL 设置为 0，表示除非此时可以把消息直接发送投递到消费者端去，否则就会直接丢弃该消息。</p><p>准对每条消息设置 TTL 的方法是在发送消息的时候设置的，对应到客户端方法是 <code>channel.basicPublish</code> 的 expiration 属性参数，具体设置代码如下：</p><p><img src="https://i.loli.net/2020/08/09/1Qbye6RUlTuIrWh.png" alt="rabbitmq_advanced_4.png"></p><p>这种设置方式，即使队列过期也不会立即从队列中移除，因为每条消息是否过期的判定是在发送到消费者是才进行的，如果此时发现已经过期才会删除消息。而对于第一种方式则会把已经过期的消息移到队列头部，然后 RabbitMQ 只要定期的从头开始扫描是否存在过期的消息即可。</p><h5 id="1-2-队列-TTL-设置"><a href="#1-2-队列-TTL-设置" class="headerlink" title="1.2 队列 TTL 设置"></a>1.2 队列 TTL 设置</h5><p>设置队列的过期时间使用的是客户端的 <code>channel.queueDeclare</code> 方法参数中的 <code>x-expires</code> 参数，其单位同样也是毫秒，不过需要注意的是它不能设置为 0。设置队列过期的代码如下所示：</p><p><img src="https://i.loli.net/2020/08/09/9gNDI4QMmByiCPj.png" alt="rabbitmq_advanced_5.png"></p><p>上面代码创建了一个过期时间为 15 分钟的队列。</p><h4 id="死信队列介绍"><a href="#死信队列介绍" class="headerlink" title="死信队列介绍"></a>死信队列介绍</h4><p>死信交换器（DLX）的全称是 <code>Dead-Letter-Exchange</code> ，也称之为死信邮箱。简单来说就是当一个消息由于 <code>消息被拒绝</code> 、 <code>消息过期</code> 、 <code>队列达到最大长度</code> 时，变成死信（dead message）之后，会被重新发送到一个交换器中，这个交换器就是死信交换器，绑定在这个交换器上的队列就称之为死信队列。死信交换器实际上就是平常的交换器，可以在任何队列上指定，当在一个队列上设置死信交换器后，如果该队列出现死信时就会被 RabbitMQ 把死信消息重新发送到死信交换器上去，然后路由到死信队列中，我们可以监听这个队列来处理那些死信消息。为一个队列设置死信交换器是在生产者的声明队列的方法中设置 <code>x-dead-letter-message</code> 参数来实现的，如下所示：</p><p><img src="https://i.loli.net/2020/08/09/alscN4d8ujVhrC5.png" alt="rabbitmq_advanced_6.png"></p><p>同时也可以通过 <code>x-dead-letter-routing-key</code> 参数设置死信交互器的路由键，不设置默认使用原始度列的路由键。可以到 RabbitMQ 的后台管理界面，有 <code>DLX</code> 标志的就是死信队列。</p><p><img src="https://i.loli.net/2020/08/09/43pOqmvoZaujzli.png" alt="rabbitmq_advanced_7.png"></p><p>RabbitMQ 提供的 DLX 是个比较实用的功能特性，它可以在我们消息不能被消费者正确消费的情况下放入到死信队列，后续我们可以通过这个死信队列的内容来查看异常情况来改造和优化系统。</p><h4 id="延迟队列介绍"><a href="#延迟队列介绍" class="headerlink" title="延迟队列介绍"></a>延迟队列介绍</h4><p>顾名思义，延迟队列存储的是哪些需要等待指定时间后才能拿到的延迟消息，一个比较典型的场景就是订单 30 分钟后未支付取消订单。这里需要注意的是，在 RabbitMQ 中并没有直接提供延迟队列的功能，而是需要通过上面介绍的过期时间（TTL）和死信队列一起来实现，比如超时取消订单这个场景，我们可以让消费者订阅死信队列，设置正常的那个队列的超时时间为 30 分钟并绑定到该死信队列上，当消息超过 30 分钟未被处理后消息就会把发送到死信队列中，然后死信队列的消费者就可以在 30 分钟后成功的消费到该消息了。</p><p><img src="https://i.loli.net/2020/08/09/XcrHLAsvFnk2RMV.png" alt="rabbitmq_advanced_8.png"></p><p>同时当我们有其它的超时配置需求时也很方便扩展，比如可以在生产者发送消息的时候通过设置不同的路由键，通过路由键来将消息发送到与交换器绑定的不同队列中，然后这些队列分别设置不同的过期时间和与之相对应的死信队列，当消息过期时就会被 RabbitMQ 转发到相应的死信队列中，这样就可以去订阅相应的死信队列即可。</p><h4 id="交换器、消息和队列持久化"><a href="#交换器、消息和队列持久化" class="headerlink" title="交换器、消息和队列持久化"></a>交换器、消息和队列持久化</h4><p>持久化可以提高可靠性，可以防止宕机或者重启等异常下数据的丢失，RabbitMQ 的持久化从组成结构上可以分为三个部分，即交换器持久化、消息持久化和队列持久化。</p><h5 id="1-1-交换器持久化"><a href="#1-1-交换器持久化" class="headerlink" title="1.1 交换器持久化"></a>1.1 交换器持久化</h5><p>交换器持久化是在声明交换器时将 durable 参数设置为 true 来实现的。如果不设置持久化属性的话，当 RabbitMQ 服务重启后交换器的数据就会丢失，需要注意的是，是交换器的数据丢失，消息不会丢失，只是不能将消息发送到这个交换器中了，一般生产环境使用都会把该属性设置为持久化。</p><h5 id="1-2-消息持久化"><a href="#1-2-消息持久化" class="headerlink" title="1.2 消息持久化"></a>1.2 消息持久化</h5><p>交换器的持久化仅仅只是保证了交换器本身的元数据不会丢失，无法保证其存储的消息不会丢失，如果需要其内部存储的消息不丢失，则需要设置消息的持久化，通过将消息的投递模式(deliveryMode)设置为 2 即可实现消息的持久化，如下所示：</p><p><img src="https://i.loli.net/2020/08/09/Y3594Xw1IdzWxSV.png" alt="rabbitmq_advanced_9.png"></p><p>需要消息持久化的前提是其所在的队列也要设置持久化，假如仅仅只设置消息的持久化的话，RabbitMQ 重启之后队列消失，然后消息也会丢失。这里有点需要注意一下，虽然持久化可以提高可靠性，但是持久化是将数据存储到硬盘上，比直接操作内存要慢很多，所以对于哪些可靠性要求不高的业务不需要进行持久化。</p><h5 id="1-3-队列持久化"><a href="#1-3-队列持久化" class="headerlink" title="1.3 队列持久化"></a>1.3 队列持久化</h5><p>队列的持久化的设置和交换器持久化类似，同样也是在声明的时候通过 durable 参数设置为 true 实现的，如果不设置，当 RabbitMQ 重启后，相关的队列元数据也会丢失，相应的其存储的消息也会随之丢失掉。</p><p>将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗？其实无法保证百分之百数据不丢失。比如消费者在订阅消费队列时将自动应答（autoAck）参数设置为 true 的话，在接收到消息后还没来得及处理就挂了，这时需要把自动应答设置 false，进行手动 ack 应答即可。还有一个就是由于不是实时持久化存盘，当消息存盘的过程中 RabbitMQ 宕机了，此时也会发生数据丢失，此时需要通过 RabbitMQ 的 <code>镜像队列机制</code> 来处理了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍了一些参数具体使用时的设置细节和死信队列、延迟队列以及持久化等，还有一些比较重要的点没有涉及到，比如消息确认机制。“纸上得来终觉浅，绝知此事要躬行”，在了解一些基础的概念之后还是需要通过具体编码实践才能对其更加理解深刻。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇 &lt;a href=&quot;https://www.mghio.cn/post/c34b451f.html&quot;&gt;RabbitMQ 入门之基础概念&lt;/a&gt; 介绍了 RabbitMQ 的一些基础概念，本文再来介绍其中的一些细节和其它的进阶的概念。&lt;/p&gt;
&lt;h4 id=&quot;消息生产者发送的消息不可达时如何处理&quot;&gt;&lt;a href=&quot;#消息生产者发送的消息不可达时如何处理&quot; class=&quot;headerlink&quot; title=&quot;消息生产者发送的消息不可达时如何处理&quot;&gt;&lt;/a&gt;消息生产者发送的消息不可达时如何处理&lt;/h4&gt;&lt;p&gt;RabbitMQ 提供了消息在传递过程中无法发送到一个队列（比如根据自己的类型和路由键没有找到匹配的队列）时将消息回传给消息发送方的功能，使用 RabbitMQ 的客户端提供 &lt;code&gt;channel.basicPublish&lt;/code&gt; 方法的两个参数 &lt;code&gt;mandatory&lt;/code&gt; 和 &lt;code&gt;immediate&lt;/code&gt; (RabbitMQ 3.0 以下版本)，除此之外还提供了一个备份交换器可以将无法发送的消息存储起来处理，不用重新传回给发送方。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="https://www.mghio.cn/categories/RabbitMQ/"/>
    
      <category term="Java" scheme="https://www.mghio.cn/categories/RabbitMQ/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="RabbitMQ" scheme="https://www.mghio.cn/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 入门之基础概念</title>
    <link href="https://www.mghio.cn/post/c34b451f.html"/>
    <id>https://www.mghio.cn/post/c34b451f.html</id>
    <published>2020-07-18T09:00:51.000Z</published>
    <updated>2020-07-18T10:10:37.869Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是消息队列（MQ）"><a href="#什么是消息队列（MQ）" class="headerlink" title="什么是消息队列（MQ）"></a>什么是消息队列（MQ）</h4><p>消息是在不同应用间传递的数据。这里的消息可以非常简单，比如只包含字符串，也可以非常复杂，包含多个嵌套的对象。消息队列（Message Queue）简单来说就是一种应用程序间的通讯方式，消息发送后立即返回，然后由消息系统保证消息的可靠性传输，消息生产者只需要把消息发到 MQ 中就可以了，不需要关心消息的消费，同样，消息消费者只管从 MQ 中拉取消息而不管是谁生产的消息，通过这样的一个“互相不知道对象存在”模式，将消息的生产者和消息的消费者解耦了。</p><h4 id="什么场景下考虑使用消息队列"><a href="#什么场景下考虑使用消息队列" class="headerlink" title="什么场景下考虑使用消息队列"></a>什么场景下考虑使用消息队列</h4><p>从上面可以知道，消息队列是一种应用间的异步协作机制，那么我们什么时候需要用到 MQ 呢？以常见的订单系统为例，当用户点击「下单」后的业务逻辑可能包括：扣减库存、生成相应订单数据、发短信通知等。在项目和业务发展初期上面这些逻辑可能放在一起执行，随着业务的发展订单量的增加，需要提升系统服务的性能，此时就可以将一些不需要立即生效的操作拆分出来异步执行，比如发送短信通知等。这种场景下就可以使用 MQ ，在下单主流程（比如扣减库存、生成订单数据等）完成之后发送一条消息到 MQ 让主流程快速走完，然后由另外一个线程拉取 MQ 的消息，执行相应的业务逻辑。这里的例子主要是用消息队列来解耦。</p><a id="more"></a><h4 id="RabbitMQ-的特点"><a href="#RabbitMQ-的特点" class="headerlink" title="RabbitMQ 的特点"></a>RabbitMQ 的特点</h4><p>RabbitMQ 是一个由 Relang 语言开发的 AMQP 的开源实现。AMQP（Advanced Message Queue：高级消息队列协议）它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。RabbitMQ 最初起源于消息系统，用于在分布式系统中存储转发消息，具体有如下一些特点：</p><ul><li><strong>可靠性：</strong> RabbitMQ 使用一些机制来保证可靠性，比如持久化、传输确认机制（ack）和发布确认等。</li><li><strong>灵活的路由策略：</strong> 在消息进入队列之前，通过 Exchange 来路由消息，对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对复杂的路由功能，可以将多个 Exchange 绑在一起，也通过插件机制实现自己的 Exchange。</li><li><strong>消息集群：</strong> 多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker。</li><li><strong>高可用：</strong> 队列可以在集群中的集群上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li><li><strong>多种协议：</strong> RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等。</li><li><strong>多语言客户端：</strong> RabbitMQ 几乎支持多有常用的语言，比如：Java、.NET 等</li><li><strong>管理界面：</strong> RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li></ul><h4 id="RabbitMQ-安装（mac）和运行"><a href="#RabbitMQ-安装（mac）和运行" class="headerlink" title="RabbitMQ 安装（mac）和运行"></a>RabbitMQ 安装（mac）和运行</h4><p><strong>1、安装</strong><br>因为 RabbitMQ 依赖于 Erlang 语言，所以在安装 RabbitMQ 之前需要先安装 Erlang 环境，但是由于是 Mac 环境，可以使用 HomeBrew 安装，安装前先更新 brew：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update</span><br></pre></td></tr></table></figure><p>接着安装 RabbitMQ 即可，安装过程中会自动安装其所依赖的 Erlang。</p><p><img src="https://i.loli.net/2020/07/18/OoSVmkX3v6jf7dC.jpg" alt="rabbitmq-base-7.jpeg"></p><p><strong>2、运行</strong><br>RabbitMQ 的启动运行很简单，找到其安装目录后（使用 Homwbrew 安装的默认目录为：/usr/local/Cellar/rabbitmq），进入到目录的 sbin 目录下，可以看到有 6 个<br>以 rabbitmq 开头的可执行文件，直接执行 rabbitmq-server 即可。</p><p><img src="https://i.loli.net/2020/07/18/pRksb1wcINlM2zF.jpg" alt="rabbitmq-base-8.jpeg"></p><p>启动正常的话可以看到启动过程的日志信息和最后的 completed with 6 plugins，这也说明启动的时候默认加载了 6 个插件。</p><p><img src="https://i.loli.net/2020/07/18/Mr8h2labI7fyovW.jpg" alt="rabbitmq-base-9.jpeg"></p><p>此时通过浏览器访问 <a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672</a> 可以看到其管理界面（默认用户名和密码都是 guest），可以在 admin 选项卡页面新增用户，管理界面如下：</p><p><img src="https://i.loli.net/2020/07/18/Dd9mAj34BuiERrk.jpg" alt="rabbitmq-base-10.jpeg"></p><p><strong>PS：</strong> 以上方式不是后台启动，如果想让 RabbitMQ 后台守护进程的方式启动的话，可以在启动的时候加上 -detached 参数。</p><p><img src="https://i.loli.net/2020/07/18/VDIkLgZ2QuR8liz.jpg" alt="rabbitmq-base-11.jpeg"></p><p><strong>3、查询服务器状态</strong><br>在安装目录的 sbin 下面有个可执行文件 rabbitmqctl ，它提供了 RabbitMQ 管理需要的几乎一站式解决方案，绝大部分的运维命令它都可以提供。查询 RabbitMQ 服务器的状态信息可以用参数 status。</p><p><img src="https://i.loli.net/2020/07/18/4lukrMOYfIhaFmJ.jpg" alt="rabbitmq-base-12.jpeg"></p><h4 id="RabbitMQ-中的基础概念"><a href="#RabbitMQ-中的基础概念" class="headerlink" title="RabbitMQ 中的基础概念"></a>RabbitMQ 中的基础概念</h4><p><strong>1、消息模型</strong> 几乎所有的 MQ 抽象来说都是一样的过程：消费者订阅某个队列，生产者生产消息，然后发布到队列中，最后将消息发送到监听该队列的消费者那里。如下图所示：</p><p><img src="https://i.loli.net/2020/07/18/gopHO9vEchYbmSG.jpg" alt="rabbitmq-base-1.jpeg"></p><p><strong>2、基本概念</strong> 上面上一个消息队列的抽象概述，具体到 RabbitMQ 有一些特有的概念，RabbitMQ 是 AMQP 协议的一个开源实现，其内部概念大都是 AMQP 协议的一些概念。</p><p><img src="https://i.loli.net/2020/07/18/LpzNB6Vyo4CdDJW.jpg" alt="rabbitmq-base-2.jpeg"></p><table><thead><tr><th align="center"><strong>名称</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">Message 消息</td><td align="center">消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则是由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其它消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</td></tr><tr><td align="center">Publisher 消息生产者</td><td align="center">一个向交换机发送消息的客户端应用程序。</td></tr><tr><td align="center">Exchange 交换器</td><td align="center">用来接收生产者发送过来的消息，并将这些消息发送给服务器中的队列。</td></tr><tr><td align="center">Binding 绑定</td><td align="center">用于消息队列和交换器之间的关联，一个绑定就是一个基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</td></tr><tr><td align="center">Queue 消息队列</td><td align="center">用来保存消息直到发送给消费者，它是消息的容器，也是消息的终点，一个消息可投入一个或多个队列，消息一直在队列里面，等待消费者连接到这个队列并将其取走。</td></tr><tr><td align="center">Connection 网络连接</td><td align="center">比如一个 TCP 连接。</td></tr><tr><td align="center">Channel 信道</td><td align="center">多路复用连接中的一条独立双向数据流通道，信道是建立在真实 TCP 连接内的虚拟连接，AMQP 命令都是通过信道发送出去的，不管是发布消息、订阅消息还是接收消息，这些动作都是通过信道完成的。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</td></tr><tr><td align="center">Consumer 消息的消费者</td><td align="center">一个从消息队列中获取消息的客户端应用程序。</td></tr><tr><td align="center">Virtual Host 虚拟主机</td><td align="center">表示一批交换器、消息队列和相关对象。虚拟主机是共享相同身份认证和加密环境的对服务器域。每个 vhost 本质上是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</td></tr></tbody></table><p><strong>3、AMQP 中的消息路由</strong> AMQP 中消息路由过程和 Java 开发者熟悉的 JMS 存在一些差别，AMQP 中增加了 Exchange 和 Binding 的角色。生产者把消息发送到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发到哪个队列。</p><p><img src="https://i.loli.net/2020/07/18/sORwrQAXati3F5H.jpg" alt="rabbitmq-base-3.jpeg"></p><p><strong>4、Exchange 类型</strong> Exchange 分发消息时根据类型的不同分发策略略有区别，目前共有四种类型：direct、fanout、topic、headers。headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型即可。</p><p><strong>4.1、direct 类型</strong> </p><p><img src="https://i.loli.net/2020/07/18/7amFw9g5VnkRlJO.jpg" alt="rabbitmq-base-4.jpeg"></p><p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致，交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为 “dog”，则只转发 routing key 标记为 “dog” 的消息，不会转发 “dog.puppy”，也不会转发 “dog.guard” 等等。它是完全匹配、单播的模式。</p><p><strong>4.2、fanout 类型</strong></p><p><img src="https://i.loli.net/2020/07/18/8IADrG5voFPEqSb.jpg" alt="rabbitmq-base-5.jpeg"></p><p>每个发到 fanout 类型交换机的消息都会发到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得一份复制的消息。fanout 类型转发消息是最快的。</p><p><strong>3、topic 类型</strong></p><p><img src="https://i.loli.net/2020/07/18/D8Wy2mT3FrVzOdg.jpg" alt="rabbitmq-base-6.jpeg"></p><p>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上，它将路由键和绑定的字符串切分成单词，这些单词之间用点隔开。它同样也识别两个通配符：符号 “#” 和符号 “*”。# 符号匹配 0 个或多个单词，* 符号匹配不多不少一个单词。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要讲了关于 RabbitMQ 的安装以及基础概念的相关介绍，由于它是基于 Erlang 语言开发，可能对于部分 Java 开发者想了解其底层实现细节以及排查比较复杂的问题时不是很友好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是消息队列（MQ）&quot;&gt;&lt;a href=&quot;#什么是消息队列（MQ）&quot; class=&quot;headerlink&quot; title=&quot;什么是消息队列（MQ）&quot;&gt;&lt;/a&gt;什么是消息队列（MQ）&lt;/h4&gt;&lt;p&gt;消息是在不同应用间传递的数据。这里的消息可以非常简单，比如只包含字符串，也可以非常复杂，包含多个嵌套的对象。消息队列（Message Queue）简单来说就是一种应用程序间的通讯方式，消息发送后立即返回，然后由消息系统保证消息的可靠性传输，消息生产者只需要把消息发到 MQ 中就可以了，不需要关心消息的消费，同样，消息消费者只管从 MQ 中拉取消息而不管是谁生产的消息，通过这样的一个“互相不知道对象存在”模式，将消息的生产者和消息的消费者解耦了。&lt;/p&gt;
&lt;h4 id=&quot;什么场景下考虑使用消息队列&quot;&gt;&lt;a href=&quot;#什么场景下考虑使用消息队列&quot; class=&quot;headerlink&quot; title=&quot;什么场景下考虑使用消息队列&quot;&gt;&lt;/a&gt;什么场景下考虑使用消息队列&lt;/h4&gt;&lt;p&gt;从上面可以知道，消息队列是一种应用间的异步协作机制，那么我们什么时候需要用到 MQ 呢？以常见的订单系统为例，当用户点击「下单」后的业务逻辑可能包括：扣减库存、生成相应订单数据、发短信通知等。在项目和业务发展初期上面这些逻辑可能放在一起执行，随着业务的发展订单量的增加，需要提升系统服务的性能，此时就可以将一些不需要立即生效的操作拆分出来异步执行，比如发送短信通知等。这种场景下就可以使用 MQ ，在下单主流程（比如扣减库存、生成订单数据等）完成之后发送一条消息到 MQ 让主流程快速走完，然后由另外一个线程拉取 MQ 的消息，执行相应的业务逻辑。这里的例子主要是用消息队列来解耦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="https://www.mghio.cn/categories/RabbitMQ/"/>
    
      <category term="Java" scheme="https://www.mghio.cn/categories/RabbitMQ/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="RabbitMQ" scheme="https://www.mghio.cn/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Java 中队列同步器 AQS（AbstractQueuedSynchronizer）实现原理</title>
    <link href="https://www.mghio.cn/post/4b00e13c.html"/>
    <id>https://www.mghio.cn/post/4b00e13c.html</id>
    <published>2020-06-13T12:48:00.000Z</published>
    <updated>2020-06-13T10:59:03.430Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在 <code>Java</code> 中通过 <code>锁</code> 来控制多个线程对共享资源的访问，使用 <code>Java</code> 编程语言开发的朋友都知道，可以通过 <code>synchronized</code> 关键字来实现锁的功能，它可以隐式的获取锁，也就是说我们使用该关键字并不需要去关心锁的获取和释放过程，但是在提供方便的同时也意味着其灵活性的下降。例如，有这样的一个场景，先获取锁 A，然后再获取锁 B，当锁 B 获取到之后，释放锁 A 同时获取锁 C，当获取锁 C 后，再释放锁 B 同时获取锁 D，依次类推，像这种比较复杂的场景，使用 <code>synchronized</code> 关键字就比较难实现了。<br>在 <code>Java SE 5</code> 之后，新增加了 <code>Lock</code> 接口和一系列的实现类来提供和 <code>synchronized</code> 关键字一样的功能，它需要我们显示的进行锁的获取和释放，除此之外还提供了可响应中断的锁获取操作以及超时获取锁等同步特性。<code>JDK</code> 中提供的 <code>Lock</code> 接口实现类大部分都是聚合一个同步器 AQS 的子类来实现多线程的访问控制的，下面我们看看这个构建锁和其它同步组件的基础框架——<code>队列同步器 AQS（AbstractQueuedSynchronizer）</code>。</p><a id="more"></a><h4 id="AQS-基础数据结构"><a href="#AQS-基础数据结构" class="headerlink" title="AQS 基础数据结构"></a>AQS 基础数据结构</h4><h5 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h5><p><code>队列同步器 AQS</code>（下文简称为同步器）主要是依赖于内部的一个 FIFO（first-in-first-out）双向队列来对同步状态进行管理的，当线程获取同步状态失败时，同步器会将当前线程和当前等待状态等信息封装成一个内部定义的节点 <code>Node</code>，然后将其加入队列，同时阻塞当前线程；当同步状态释放时，会将同步队列中首节点唤醒，让其再次尝试去获取同步状态。同步队列的基本结构如下：</p><p><img src="https://i.loli.net/2020/06/08/SqjNuvfcPeahUGi.png" alt="AQS_QUEUE.png"></p><h5 id="队列节点-Node"><a href="#队列节点-Node" class="headerlink" title="队列节点 Node"></a>队列节点 Node</h5><p>同步队列使用同步器中的静态内部类 <code>Node</code> 用来保存获取同步状态的线程的引用、线程的等待状态、前驱节点和后继节点。</p><p><img src="https://i.loli.net/2020/06/08/PUCzYpAOEByiLrQ.png" alt="AQS_inner_class_node.png"></p><p>同步队列中 <code>Node</code> 节点的属性名称和具体含义如下表所示：</p><table><thead><tr><th align="center">属性类型和名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">volatile int waitStatus</td><td align="center">当前节点在队列中的等待状态</td></tr><tr><td align="center">volatile Node prev</td><td align="center">前驱节点，当节点加入同步队列时被赋值(使用尾部添加方式)</td></tr><tr><td align="center">volatile Node next</td><td align="center">后继节点</td></tr><tr><td align="center">volatile Thread thread</td><td align="center">获取同步状态的线程</td></tr><tr><td align="center">Node nextWaiter</td><td align="center">等待队列中的后继节点，如果当前节点是共享的，则该字段是一个 <code>SHARED</code> 常量</td></tr></tbody></table><p>每个节点线程都有两种锁模式，分别为 <code>SHARED</code> 表示线程以共享的模式等待锁，<code>EXCLUSIVE</code> 表示线程以独占的方式等待锁。同时每个节点的等待状态 <code>waitStatus</code> 只能取以下表中的枚举值：</p><table><thead><tr><th align="center">枚举值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SIGNAL</td><td align="center">值为 -1，表示该节点的线程已经准备完毕，等待资源释放</td></tr><tr><td align="center">CANCELLED</td><td align="center">值为 1，表示该节点线程获取锁的请求已经取消了</td></tr><tr><td align="center">CONDITION</td><td align="center">值为 -2，表示该节点线程等待在 <code>Condition</code> 上，等待被其它线程唤醒</td></tr><tr><td align="center">PROPAGATE</td><td align="center">值为 -3，表示下一次共享同步状态获取会无限进行下去，只在 <code>SHARED</code> 情况下使用</td></tr><tr><td align="center">0</td><td align="center">值为 0，初始状态，初始化的默认值</td></tr></tbody></table><h5 id="同步状态-state"><a href="#同步状态-state" class="headerlink" title="同步状态 state"></a>同步状态 state</h5><p>同步器内部使用了一个名为 <code>state</code> 的 <code>int</code> 类型的变量表示同步状态，同步器的主要使用方式是通过继承，子类通过继承并实现它的抽象方法来管理同步状态，同步器给我们提供了如下三个方法来对同步状态进行更改。</p><table><thead><tr><th align="center">方法签名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">protected final int getState()</td><td align="center">获取当前同步状态</td></tr><tr><td align="center">protected final void setState(int newState)</td><td align="center">设置当前同步状态</td></tr><tr><td align="center">protected final boolean compareAndSetState(int expect, int update)</td><td align="center">使用 <code>CAS</code> 设置当前状态，该方法能够保证状态设置的原子性</td></tr></tbody></table><p>在独享锁中同步状态 <code>state</code> 这个值通常是 0 或者 1（如果是重入锁的话 <code>state</code> 值就是重入的次数），在共享锁中 <code>state</code> 就是持有锁的数量。</p><h4 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h4><p>同步器中提供了 <code>acquire(int arg)</code> 方法来进行独占式同步状态的获取，获取到了同步状态也就是获取到了锁，该方法源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法首先会调用 <code>tryAcquire</code> 方法尝试去获取锁，查看方法的源码可以发现，同步器并未对该方法进行实现（只是抛出一个不支持操作异常 <code>UnsupportedOperationException</code>），这个方法是需要后续同步组件的开发人员自己去实现的，如果方法返回 <code>true</code> 则表示当前线程成功获取到锁，调用 <code>selfInterrupt()</code> 中断当前线程（PS：<code>这里留给大家一个问题：为什么获取了锁以后还要中断线程呢？</code>），方法结束返回，如果方法返回 <code>false</code> 则表示当前线程获取锁失败，也就是说有其它线程先前已经获取到了锁，此时就需要把当前线程以及等待状态等信息添加到同步队列中，下面来看看同步器在线程未获取到锁时具体是如何实现。<br>通过源码发现，当获取锁失败时，会执行判断条件与操作的后半部分 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>，首先指定锁模式为 <code>Node.EXCLUSIVE</code> 调用 <code>addWaiter</code> 方法，该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过方法参数指定的锁模式（共享锁 or 独占锁）和当前线程构造出一个 <code>Node</code> 节点，如果同步队列已经初始化，那么首先会进行一次从尾部加入队列的尝试，使用 <code>compareAndSetTail</code> 方法保证原子性，进入该方法源码可以发现是基于 <code>sun.misc</code> 包下提供的 <code>Unsafe</code> 类来实现的。如果首次尝试加入同步队列失败，会再次调用 <code>enq</code> 方法进行入队操作，继续跟进 <code>enq</code> 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过其源码可以发现和第一次尝试加入队列的代码类似，只是该方法里面加了同步队列初始化判断，使用 <code>compareAndSetHead</code> 方法保证设置头节点的原子性，同样它底层也是基于 <code>Unsafe</code> 类，然后外层套了一个 <code>for (;;)</code> 死循环，循环唯一的退出条件是从队尾入队成功，也就是说如果从该方法成功返回了就表示已经入队成功了，至此，<code>addWaiter</code> 执行完毕返回当前 <code>Node</code> 节点。然后以该节点作为 <code>acquireQueued</code> 方法的入参继续进行其它步骤，该方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该方法本质上也是通过一个死循环（自旋）去获取锁并且支持中断，在循环体外面定义两个标记变量，<code>failed</code> 标记是否成功获取到锁，<code>interrupted</code> 标记在等待的过程中是否被中断过。方法首先通过 <code>predecessor</code> 获取当前节点的前驱节点，当当前节点的前驱节点是 <code>head</code> 头节点时就调用 <code>tryAcquire</code> 尝试获取锁，也就是第二个节点则尝试获取锁，这里为什么要从第二个节点才尝试获取锁呢？是因为同步队列本质上是一个<code>双向链表</code>，在双向链表中，第一个节点并不存储任何数据是虚节点，只是起到一个占位的作用，真正存储数据的节点是从第二个节点开始的。如果成功获取锁，也就是 <code>tryAcquire</code> 方法返回 <code>true</code> 后，将 <code>head</code> 指向当前节点并把之前找到的头节点 <code>p</code> 从队列中移除，修改是否成功获取到锁标记，结束方法返回中断标记。<br>如果当前节点的前驱节点 <code>p</code> 不是头节点或者前驱节点 <code>p</code> 是头节点但是获取锁操作失败，那么会调用 <code>shouldParkAfterFailedAcquire</code> 方法判断当前 <code>node</code> 节点是否需要被阻塞，这里的阻塞判断主要是为了防止长时间自旋给 <code>CPU</code> 带来非常大的执行开销，浪费资源。该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">          * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">          * indicate retry.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">          * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">          * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法参数为当前节点的前驱节点以及当前节点，主要是靠前驱节点来判断是否需要进行阻塞，首先获取到前驱节点的等待状态 <code>ws</code>，如果节点状态 <code>ws</code> 为 <code>SIGNAL</code>，表示前驱节点的线程已经准备完毕，等待资源释放，方法返回 <code>true</code> 表示可以阻塞，如果 <code>ws &gt; 0</code>，通过上文可以知道节点只有一个状态 <code>CANCELLED（值为 1）</code> 满足该条件，表示该节点线程获取锁的请求已经取消了，会通过一个 <code>do-while</code> 循环向前查找 <code>CANCELLED</code> 状态的节点并将其从同步队列中移除，否则进入 <code>else</code> 分支，使用 <code>compareAndSetWaitStatus</code> 原子操作将前驱节点的等待状态修改为 <code>SIGNAL</code>，以上这两种情况都不需要进行阻塞方法返回 <code>false</code>。<br>当经过判断后需要阻塞的话，也就是 <code>compareAndSetWaitStatus</code> 方法返回 <code>true</code> 时，会通过 <code>parkAndCheckInterrupt</code> 方法阻塞挂起当前线程，并返回当前线程的中断标识。方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程阻塞是通过 <code>LockSupport</code> 这个工具类实现的，深入其源码可以发现它底层也是基于 <code>Unsafe</code> 类实现的。如果以上两个方法都返回 <code>true</code> 的话就更新中断标记。这里还有一个问题就是什么时候会将一个节点的等待状态 <code>waitStatus</code> 修改为 <code>CANCELLED</code> 节点线程获取锁的请求取消状态呢？细心的朋友可能已经发现了，在上文贴出的 <code>acquireQueued</code> 方法源码中的 <code>finally</code> 块中会根据 <code>failed</code> 标记来决定是否调用 <code>cancelAcquire</code> 方法，这个方法就是用来将节点状态修改为 <code>CANCELLED</code> 的，方法的具体实现留给大家去探索。至此 <code>AQS</code> 独占式同步状态获取锁的流程就完成了，下面通过一个流程图来看看整体流程：</p><p><img src="https://i.loli.net/2020/06/09/qXP56i3JgYTufko.png" alt="AQS_acquire.png"></p><hr><p>下面再看看独占式锁释放的过程，同步器使用 <code>release</code> 方法来让我们进行独占式锁的释放，其方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 <code>tryRelease</code> 方法尝试进行锁释放操作，继续跟进该方法发现同步器只是抛出了一个不支持操作异常 <code>UnsupportedOperationException</code>，这里和上文独占锁获取中 <code>tryAcquire</code> 方法是一样的套路，需要开发者自己定义锁释放操作。</p><p><img src="https://i.loli.net/2020/06/09/l93fx5haFmQLzpI.png" alt="AQS_tryrelease.png"></p><p>通过其 <code>JavaDoc</code> 可以得知，如果返回 <code>false</code>，则表示释放锁失败，方法结束。该方法如果返回 <code>true</code>，则表示当前线程释放锁成功，需要通知队列中等待获取锁的线程进行锁获取操作。首先获取头节点 <code>head</code>，如果当前头节点不为 <code>null</code>，并且其等待状态不是初始状态（0），则解除线程阻塞挂起状态，通过 <code>unparkSuccessor</code> 方法实现，该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">      * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">      * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">      * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">      * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">      * non-cancelled successor.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取头节点的等待状态 <code>ws</code>，如果状态值为负数（Node.SIGNAL or Node.PROPAGATE），则通过 CAS 操作将其改为初始状态（0），然后获取头节点的后继节点，如果后继节点为 <code>null</code> 或者后继节点状态为 <code>CANCELLED</code>（获取锁请求已取消），就从队列尾部开始寻找第一个状态为非 <code>CANCELLED</code> 的节点，如果该节点不为空则使用 <code>LockSupport</code> 的 <code>unpark</code> 方法将其唤醒，该方法底层是通过 <code>Unsafe</code> 类的 <code>unpark</code> 实现的。这里需要从队尾查找非 <code>CANCELLED</code> 状态的节点的原因是，在之前的获取独占锁失败时的入队 <code>addWaiter</code> 方法实现中，该方法如下：</p><p><img src="https://i.loli.net/2020/06/09/dXMSofuRgi3pahe.png" alt="AQS_unparkSuccessor.png"></p><p>假设一个线程执行到了上图中的 ① 处，② 处还没有执行，此时另一个线程恰好执行了 <code>unparkSuccessor</code> 方法，那么就无法通过从前向后查找了，因为节点的后继指针 <code>next</code> 还没赋值呢，所以需要从后往前进行查找。至此，独占式锁释放操作就结束了，同样的，最后我们也通过一个流程图来看看整个锁释放的过程：</p><p><img src="https://upload-images.jianshu.io/upload_images/13482422-21a10972726df6ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AQS_release.png"></p><h4 id="独占式可中断同步状态获取"><a href="#独占式可中断同步状态获取" class="headerlink" title="独占式可中断同步状态获取"></a>独占式可中断同步状态获取</h4><p>同步器提供了 <code>acquireInterruptibly</code> 方法来进行可响应中断的获取锁操作，方法实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法首先检查当前线程的中断状态，如果已中断，则直接抛出中断异常 <code>InterruptedException</code> 即响应中断，否则调用 <code>tryAcquire</code> 方法尝试获取锁，如果获取成功则方法结束返回，获取失败调用 <code>doAcquireInterruptibly</code> 方法，跟进该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察可以发现该方法实现源码和上文中 <code>acquireQueued</code> 方法的实现基本上类似，只是这里把入队操作 <code>addWaiter</code> 放到了方法里面了，还有一个区别就是当在循环体内判断需要进行中断时会直接抛出异常来响应中断，两个方法的对比如下：</p><p><img src="https://i.loli.net/2020/06/09/DwHVCAzUjbBtNI1.png" alt="AQS_acquirequeued_interruptibly_compare.png"></p><p>其它步骤和独占式锁获取一致，流程图大体上和不响应中断的锁获取差不多，只是在最开始多了一步线程中断状态检查和循环是会抛出中断异常而已。</p><h4 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h4><p>同步器提供了 <code>tryAcquireNanos</code> 方法可以超时获取同步状态（也就是<code>锁</code>），该方法提供了之前 <code>synchronized</code> 关键字不支持的超时获取的特性，通过该方法我们可以在指定时间段 <code>nanosTimeout</code> 内获取锁，如果获取到锁则返回 <code>true</code>，否则，返回 <code>false</code>。方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会调用 <code>tryAcquire</code> 方法尝试获取一次锁，如果获取锁成功则立即返回，否则调用 <code>doAcquireNanos</code> 方法进入超时获取锁流程。通过上文可以得知，同步器的 <code>acquireInterruptibly</code> 方法在等待获取同步状态时，如果当前线程被中断了，会抛出中断异常 <code>InterruptedException</code> 并立刻返回。超时获取锁的流程其实是在响应中断的基础上增加了超时获取的特性，<code>doAcquireNanos</code> 方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上方法实现源码可以看出，针对超时获取这里主要实现思路是：先使用当前时间加上参数传入的超时时间间隔 <code>deadline</code> 计算出超时的时间点，然后每次进行循环的时候使用超时时间点 <code>deadline</code> 减去当前时间得到剩余的时间 <code>nanosTimeout</code>，如果剩余时间小于 0 则证明当前获取锁操作已经超时，方法结束返回 <code>false</code>，反如果剩余时间大于 0。<br>可以看到在里面执行自旋的时候和上面独占式同步获取锁状态 <code>acquireQueued</code> 方法那里是一样的套路，即当当前节点的前驱节点为头节点时调用 <code>tryAcquire</code> 尝试获取锁，如果获取成功则返回。</p><p><img src="https://i.loli.net/2020/06/09/QqUlTD3OG8HxCP9.png" alt="AQS_acquireQueued_doAcquireNanos_compare.png"></p><p>除了超时时间计算那里不同外，还有个不同的地方就是在超时获取锁失败之后的操作，如果当前线程获取锁失败，则判断剩余超时时间 <code>nanosTimeout</code> 是否小于 0，如果小于 0 则表示已经超时方法立即返回，反之则会判断是否需要进行阻塞挂起当前线程，如果通过 <code>shouldParkAfterFailedAcquire</code> 方法判断需要挂起阻塞当前线程，还要进一步比较超时剩余时间 <code>nanosTimeout</code> 和 <code>spinForTimeoutThreshold</code> 的大小，如果小于等于 <code>spinForTimeoutThreshold</code> 值（1000 纳秒）的话，将不会使当前线程进行超时等待，而是再次进行自旋过程。<br>加后面这个判断的主要原因在于，在非常短（小于 1000 纳秒）的时间内的等待无法做到十分精确，如果这时还进行超时等待的话，反而会让我们指定 <code>nanosTimeout</code> 的超时从整体上给人感觉反而不太精确，因此，在剩余超时时间非常短的情况下，同步器会再次自旋进行超时获取锁的过程，独占式超时获取锁整个过程如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/13482422-9a7cea5cd098de92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AQS_tryAcquireNanos_flow.png"></p><h4 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h4><p><code>共享锁</code>顾名思义就是可以多个线程共用一个锁，在同步器中使用 <code>acquireShared</code> 来获取共享锁（同步状态），方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 <code>tryAcquireShared</code> 尝试获取共享锁，该方法是一个模板方法在同步器中只是抛出一个不支持操作异常，需要开发人员自己去实现，同时方法的返回值有三种不同的类型分别代表三种不同的状态，其含义如下：</p><ol><li><strong>小于 0</strong> 表示当前线程获取锁失败</li><li><strong>等于 0</strong> 表示当前线程获取锁成功，但是之后的线程在没有锁释放的情况下获取锁将失败，也就是说这个锁是共享模式下的最后一把锁了</li><li><strong>大于 0</strong> 表示当前线程获取锁成功，并且还有剩余的锁可以获取</li></ol><p>当方法 <code>tryAcquireShared</code> 返回值小于 0 时，也就是获取锁失败，将会执行方法 <code>doAcquireShared</code>，继续跟进该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法首先调用 <code>addWaiter</code> 方法封装当前线程和等待状态为共享模块的节点并将其添加到等待同步队列中，可以发现在共享模式下节点的 <code>nextWaiter</code> 属性是固定值 <code>Node.SHARED</code>。然后循环获取当前节点的前驱节点，如果前驱节点是头节点的话就尝试获取共享锁，如果返回值大于等于 0 表示获取共享锁成功，则调用 <code>setHeadAndPropagate</code> 方法，更新头节点同时如果有可用资源，则向后传播，唤醒后继节点，接下来会检查一下中断标识，如果已经中断则中断当前线程，方法结束返回。如果返回值小于 0，则表示获取锁失败，需要挂起阻塞当前线程或者继续自旋获取共享锁。下面看看 <code>setHeadAndPropagate</code> 方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">        *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">        *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">        *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">        *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">        *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">        * and</span></span><br><span class="line"><span class="comment">        *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">        *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">        * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">        * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">        * anyway.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将当前获取到锁的节点设置为头节点，然后方法参数 <code>propagate &gt; 0</code> 时表示之前 <code>tryAcquireShared</code> 方法的返回值大于 0，也就是说当前还有剩余的共享锁可以获取，则获取当前节点的后继节点并且后继节点是共享节点时唤醒节点去尝试获取锁，<code>doReleaseShared</code> 方法是同步器共享锁释放的主要逻辑。</p><hr><p>同步器提供了 <code>releaseShared</code> 方法来进行共享锁的释放，方法源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 <code>tryReleaseShared</code> 方法尝试释放共享锁，方法返回 <code>false</code> 代表锁释放失败，方法结束返回 <code>false</code>，否则就表示成功释放锁，然后执行 <code>doReleaseShared</code> 方法，进行唤醒后继节点并检查它是否可以向后传播等操作。继续跟进该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">        * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">        * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">        * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">        * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">        * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">        * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">        * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">        * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到和独占式锁释放不同的是，在共享模式下，状态同步和释放可以同时执行，其原子性由 <code>CAS</code> 来保证，如果头节点改变了也会继续循环。每次共享节点在共享模式下唤醒时，头节点都会指向它，这样就可以保证可以获取到共享锁的所有后续节点都可以唤醒了。</p><h4 id="如何自定义同步组件"><a href="#如何自定义同步组件" class="headerlink" title="如何自定义同步组件"></a>如何自定义同步组件</h4><p>在 <code>JDK</code> 中基于同步器实现的一些类绝大部分都是聚合了一个或多个继承了同步器的类，使用同步器提供的模板方法自定义内部同步状态的管理，然后通过这个内部类去实现<code>同步状态管理</code>的功能，其实这从某种程度上来说使用了 <code>模板模式</code>。比如 <code>JDK</code> 中可重入锁 <code>ReentrantLock</code>、读写锁 <code>ReentrantReadWriteLock</code>、信号量 <code>Semaphore</code> 以及同步工具类 <code>CountDownLatch</code> 等，其源码部分截图如下：</p><p><img src="https://i.loli.net/2020/06/10/uWSsLgIhDxn5Bzm.png" alt="AQS_use_in_jdk_examples.png"></p><p>通过上文可以知道，我们基于同步器可以分别自定义独占锁同步组件和共享锁同步组件，下面以实现一个在同一个时刻最多只允许 3 个线程访问，其它线程的访问将被阻塞的同步工具 <code>TripletsLock</code> 为例，很显然这个工具是共享锁模式，主要思路就是去实现一个 <code>JDk</code> 中的 <code>Lock</code> 接口来提供面向使用者的方法，比如，调用 <code>lock</code> 方法获取锁，使用 <code>unlock</code> 来对锁进行释放等，在 <code>TripletsLock</code> 类内部有一个自定义同步器 <code>Sync</code> 继承自同步器 AQS，用来对线程的访问和同步状态进行控制，当线程调用 <code>lock</code> 方法获取锁时，自定义同步器 <code>Sync</code> 先计算出获取到锁后的同步状态，然后使用 <code>Unsafe</code> 类操作来保证同步状态更新的原子性，由于同一时刻只能 3 个线程访问，这里我们可以将同步状态 <code>state</code> 的初始值设置为 3，表示当前可用的同步资源数量，当有线程成功获取到锁时将同步状态 <code>state</code> 减 1，有线程成功释放锁时将同步状态加 <code>1</code>，同步状态的取值范围为 0、1、2、3，同步状态为 0 时表示没有可用同步资源，这个时候如果有线程访问将被阻塞。下面来看看这个自定义同步组件的实现代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-06-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TripletsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sync</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">      setState(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">        <span class="keyword">int</span> currentState = getState();</span><br><span class="line">        <span class="keyword">int</span> newState = currentState - reduceCount;</span><br><span class="line">        <span class="keyword">if</span> (newState &lt; <span class="number">0</span> || compareAndSetState(currentState, newState)) &#123;</span><br><span class="line">          <span class="keyword">return</span> newState;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">        <span class="keyword">int</span> currentState = getState();</span><br><span class="line">        <span class="keyword">int</span> newState = currentState + count;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(currentState, newState)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireShared(<span class="number">1</span>) &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面启动 20 个线程测试看看自定义同步同步工具类 <code>TripletsLock</code> 是否达到我们的预期。测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-06-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TripletsLockTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> TripletsLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTripletsLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动 20 个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      Thread worker = <span class="keyword">new</span> Runner();</span><br><span class="line">      worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">      worker.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      second(<span class="number">2</span>);</span><br><span class="line">      System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          second(<span class="number">1</span>);</span><br><span class="line">          System.out.println(dateFormat.format(<span class="keyword">new</span> Date()) + <span class="string">" ----&gt; "</span> + Thread.currentThread().getName());</span><br><span class="line">          second(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://i.loli.net/2020/06/10/fhGQElDjSNeC8zn.png" alt="AQS_TripletsLock_Test_Result.png"></p><p>从以上测试结果可以发现，同一时刻只有三个线程可以获取到锁，符合预期，这里需要明确的是这个锁获取过程是非公平的。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要是对同步器中的基础数据结构、独占式与共享式同步状态获取与释放过程做了简要分析，由于水平有限如有错误之处还请留言讨论。队列同步器 <code>AbstractQueuedSynchronizer</code> 是 <code>JDK</code> 中很多的一些多线程并发工具类的实现基础框架，对其深入学习理解有助于我们更好的去使用其特性和相关工具类。</p><hr><p>参考文章</p><p><a href="https://book.douban.com/subject/26591326" target="_blank" rel="noopener">Java并发编程的艺术</a><br><a href="https://www.programmersought.com/article/419045559/" target="_blank" rel="noopener">Java Synchronizer - AQS Learning</a><br><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">从 ReentrantLock 的实现看 AQS 的原理及应用</a><br><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;Java&lt;/code&gt; 中通过 &lt;code&gt;锁&lt;/code&gt; 来控制多个线程对共享资源的访问，使用 &lt;code&gt;Java&lt;/code&gt; 编程语言开发的朋友都知道，可以通过 &lt;code&gt;synchronized&lt;/code&gt; 关键字来实现锁的功能，它可以隐式的获取锁，也就是说我们使用该关键字并不需要去关心锁的获取和释放过程，但是在提供方便的同时也意味着其灵活性的下降。例如，有这样的一个场景，先获取锁 A，然后再获取锁 B，当锁 B 获取到之后，释放锁 A 同时获取锁 C，当获取锁 C 后，再释放锁 B 同时获取锁 D，依次类推，像这种比较复杂的场景，使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字就比较难实现了。&lt;br&gt;在 &lt;code&gt;Java SE 5&lt;/code&gt; 之后，新增加了 &lt;code&gt;Lock&lt;/code&gt; 接口和一系列的实现类来提供和 &lt;code&gt;synchronized&lt;/code&gt; 关键字一样的功能，它需要我们显示的进行锁的获取和释放，除此之外还提供了可响应中断的锁获取操作以及超时获取锁等同步特性。&lt;code&gt;JDK&lt;/code&gt; 中提供的 &lt;code&gt;Lock&lt;/code&gt; 接口实现类大部分都是聚合一个同步器 AQS 的子类来实现多线程的访问控制的，下面我们看看这个构建锁和其它同步组件的基础框架——&lt;code&gt;队列同步器 AQS（AbstractQueuedSynchronizer）&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="进阶" scheme="https://www.mghio.cn/categories/Java/%E5%B9%B6%E5%8F%91/%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>一文让你快速上手 Mockito 单元测试框架</title>
    <link href="https://www.mghio.cn/post/24042edf.html"/>
    <id>https://www.mghio.cn/post/24042edf.html</id>
    <published>2020-05-30T11:27:50.000Z</published>
    <updated>2020-06-03T08:03:59.893Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在计算机编程中，单元测试是一种软件测试方法，通过该方法可以测试源代码的各个单元功能是否适合使用。为代码编写单元测试有很多好处，包括可以及早的发现代码错误，促进更改，简化集成，方便代码重构以及许多其它功能。使用 <code>Java</code> 语言的朋友应该用过或者听过 <code>Junit</code> 就是用来做单元测试的，那么为什么我们还需要 <a href="https://site.mockito.org" target="_blank" rel="noopener">Mockito</a> 测试框架呢？想象一下这样的一个常见的场景，当前要测试的类依赖于其它一些类对象时，如果用 <code>Junit</code> 来进行单元测试的话，我们就必须手动创建出这些依赖的对象，这其实是个比较麻烦的工作，此时就可以使用 <code>Mockito</code> 测试框架来模拟那些依赖的类，这些被模拟的对象在测试中充当真实对象的虚拟对象或克隆对象，而且 <code>Mockito</code> 同时也提供了方便的测试行为验证。这样就可以让我们更多地去关注当前测试类的逻辑，而不是它所依赖的对象。</p><a id="more"></a><h4 id="生成-Mock-对象方式"><a href="#生成-Mock-对象方式" class="headerlink" title="生成 Mock 对象方式"></a>生成 Mock 对象方式</h4><p>要使用 <code>Mockito</code>，首先需要在我们的项目中引入 <code>Mockito</code> 测试框架依赖，基于 <code>Maven</code> 构建的项目引入如下依赖即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.3&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>如果是基于 <code>Gradle</code> 构建的项目，则引入如下依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testCompile group: <span class="string">'org.mockito'</span>, name: <span class="string">'mockito-core'</span>, version: <span class="string">'3.3.3'</span></span><br></pre></td></tr></table></figure><p>使用 <code>Mockito</code> 通常有两种常见的方式来创建 <code>Mock</code> 对象。</p><h5 id="1、使用-Mockito-mock-clazz-方式"><a href="#1、使用-Mockito-mock-clazz-方式" class="headerlink" title="1、使用 Mockito.mock(clazz) 方式"></a>1、使用 Mockito.mock(clazz) 方式</h5><p>通过 <code>Mockito</code> 类的静态方法 <code>mock</code> 来创建 <code>Mock</code> 对象，例如以下创建了一个 <code>List</code> 类型的 <code>Mock</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; mockList = Mockito.mock(ArrayList.class);</span><br></pre></td></tr></table></figure><p>由于 <code>mock</code> 方法是一个静态方法，所以通常会写成静态导入方法的方式，即 <code>List&lt;String&gt; mockList = mock(ArrayList.class)</code>。</p><h5 id="2、使用-Mock-注解方式"><a href="#2、使用-Mock-注解方式" class="headerlink" title="2、使用 @Mock 注解方式"></a>2、使用 @Mock 注解方式</h5><p>第二种方式就是使用 <code>@Mock</code> 注解方式来创建 <code>Mock</code> 对象，使用该方式创需要注意的是要在运行测试方法前使用 <code>MockitoAnnotations.initMocks(this)</code> 或者单元测试类上加上 <code>@ExtendWith(MockitoExtension.class)</code> 注解，如下所示代码创建了一个 <code>List</code> 类型的 <code>Mock</code> 对象(<code>PS: @BeforeEach 是 Junit 5 的注解，功能类似于 Junit 4 的 @Before 注解。</code>)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mock</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; mockList;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@BeforeEach</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeEach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证性测试"><a href="#验证性测试" class="headerlink" title="验证性测试"></a>验证性测试</h4><p><code>Mockito</code> 测试框架中提供了 <code>Mockito.verify</code> 静态方法让我们可以方便的进行验证性测试，比如方法调用验证、方法调用次数验证、方法调用顺序验证等，下面看看具体的代码。</p><h6 id="验证方法单次调用"><a href="#验证方法单次调用" class="headerlink" title="验证方法单次调用"></a>验证方法单次调用</h6><p>验证方法单次调用的话直接 <code>verify</code> 方法后加上待验证调用方法即可，以下代码的功能就是验证 <code>mockList</code> 对象的 <code>size</code> 方法被调用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(MockitoExtension.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoVerifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mock</span></span><br><span class="line">  List&lt;String&gt; mockList;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">verify_SimpleInvocationOnMock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mockList.size();</span><br><span class="line">    verify(mockList).size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="验证方法调用指定次数"><a href="#验证方法调用指定次数" class="headerlink" title="验证方法调用指定次数"></a>验证方法调用指定次数</h6><p>除了验证单次调用，我们有时候还需要验证一些方法被调用多次或者指定的次数，那么此时就可以使用 <code>verify</code> + <code>times</code> 方法来验证方法调用指定次数，同时还可以结合 <code>atLeast</code> + <code>atMost</code> 方法来提供调用次数范围，同时还有 <code>never</code> 等方法验证不被调用等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(MockitoExtension.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoVerifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mock</span></span><br><span class="line">  List&lt;String&gt; mockList;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">verify_NumberOfInteractionsWithMock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mockList.size();</span><br><span class="line">    mockList.size();</span><br><span class="line"></span><br><span class="line">    verify(mockList, times(<span class="number">2</span>)).size();</span><br><span class="line">    verify(mockList, atLeast(<span class="number">1</span>)).size();</span><br><span class="line">    verify(mockList, atMost(<span class="number">10</span>)).size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="验证方法调用顺序"><a href="#验证方法调用顺序" class="headerlink" title="验证方法调用顺序"></a>验证方法调用顺序</h6><p>同时还可以使用 <code>inOrder</code> 方法来验证方法的调用顺序，下面示例验证 <code>mockList</code> 对象的 <code>size</code>、<code>add</code> 和 <code>clear</code> 方法的调用顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(MockitoExtension.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoVerifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mock</span></span><br><span class="line">  List&lt;String&gt; mockList;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">verify_OrderedInvocationsOnMock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mockList.size();</span><br><span class="line">    mockList.add(<span class="string">"add a parameter"</span>);</span><br><span class="line">    mockList.clear();</span><br><span class="line"></span><br><span class="line">    InOrder inOrder = inOrder(mockList);</span><br><span class="line"></span><br><span class="line">    inOrder.verify(mockList).size();</span><br><span class="line">    inOrder.verify(mockList).add(<span class="string">"add a parameter"</span>);</span><br><span class="line">    inOrder.verify(mockList).clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只是列举了一些简单的验证性测试，还有验证测试方法调用超时以及更多的验证测试可以通过相关官方文档探索学习。</p><h4 id="验证方法异常"><a href="#验证方法异常" class="headerlink" title="验证方法异常"></a>验证方法异常</h4><p>异常测试我们需要使用 <code>Mockito</code> 框架提供的一些调用行为定义，<code>Mockito</code> 提供了 <code>when(...).thenXXX(...)</code> 来让我们定义方法调用行为，以下代码定义了当调用 <code>mockMap</code> 的 <code>get</code> 方法无论传入任何参数都会抛出一个空指针 <code>NullPointerException</code> 异常，然后通过 <code>Assertions.assertThrows</code> 来验证调用结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(MockitoExtension.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoExceptionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mock</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, Integer&gt; mockMap;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenConfigNonVoidReturnMethodToThrowEx_thenExIsThrown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    when(mockMap.get(anyString())).thenThrow(NullPointerException.class);</span><br><span class="line"></span><br><span class="line">    assertThrows(NullPointerException.class, () -&gt; mockMap.get(<span class="string">"mghio"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时 <code>when(...).thenXXX(...)</code> 不仅可以定义方法调用抛出异常，还可以定义调用方法后的返回结果，比如 <code>when(mockMap.get(&quot;mghio&quot;)).thenReturn(21);</code> 定义了当我们调用 <code>mockMap</code> 的 <code>get</code> 方法并传入参数 <code>mghio</code> 时的返回结果是 <code>21</code>。这里有一点需要注意，使用以上这种方式定义的 <code>mock</code> 对象测试实际并不会影响到对象的内部状态，如下图所示：</p><p><img src="https://i.loli.net/2020/05/30/VncOvo3tm8b7CyT.png" alt="mockito_mock_object_thennoaffect.png"></p><p>虽然我们已经在 <code>mockList</code> 对象上调用了 <code>add</code> 方法，但是实际上 <code>mockList</code> 集合中并没有加入 <code>mghio</code>，这时候如果需要对 <code>mock</code> 对象有影响，那么需要使用 <code>spy</code> 方式来生成 <code>mock</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; mockList = spy(ArrayList.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add_spyMockList_thenAffect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mockList.add(<span class="string">"mghio"</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">0</span>, mockList.size());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点后可以发现当使用 <code>spy</code> 方法创建出来的 <code>mock</code> 对象调用 <code>add</code> 方法后，<code>mghio</code> 被成功的加入到 <code>mockList</code> 集合当中。</p><p><img src="https://i.loli.net/2020/05/30/xTAY1noigGcQ5vU.png" alt="mockito_mock_object_thenhasaffect.png"></p><h4 id="与-Spring-框架集成"><a href="#与-Spring-框架集成" class="headerlink" title="与 Spring 框架集成"></a>与 Spring 框架集成</h4><p><code>Mockito</code> 框架提供了 <code>@MockBean</code> 注解用来将 <code>mock</code> 对象注入到 <code>Spring</code> 容器中，该对象会替换容器中任何现有的相同类型的 <code>bean</code>，该注解在需要模拟特定<code>bean</code>（例如外部服务）的测试场景中很有用。如果使用的是 <code>Spring Boot 2.0+</code> 并且当前容器中已有相同类型的 <code>bean</code> 的时候，需要设置 <code>spring.main.allow-bean-definition-overriding</code> 为 <code>true</code>（默认为 <code>false</code>）允许 <code>bean</code> 定义覆盖。下面假设要测试通过用户编码查询用户的信息，有一个数据库操作层的 <code>UserRepository</code>，也就是我们等下要 <code>mock</code> 的对象，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">findUserById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有用户操作的相关服务 <code>UserService</code> 类，其定义如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.findUserById(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中使用 <code>@MockBean</code> 来标注 <code>UserRepository</code> 属性表示这个类型的 <code>bean</code> 使用的是 <code>mock</code> 对象，使用 <code>@Autowired</code> 标注表示 <code>UserService</code> 属性使用的是 <code>Spring</code> 容器中的对象，然后使用 <code>@SpringBootTest</code> 启用 <code>Spring</code> 环境即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceUnitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MockBean</span></span><br><span class="line">  <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenUserIdIsProvided_thenRetrievedNameIsCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User expectedUser = <span class="keyword">new</span> User(<span class="number">9527L</span>, <span class="string">"mghio"</span>, <span class="string">"18288888880"</span>);</span><br><span class="line">    when(userRepository.findUserById(<span class="number">9527L</span>)).thenReturn(expectedUser);</span><br><span class="line">    User actualUser = userService.findUserById(<span class="number">9527L</span>);</span><br><span class="line">    assertEquals(expectedUser, actualUser);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mockito-框架的工作原理"><a href="#Mockito-框架的工作原理" class="headerlink" title="Mockito 框架的工作原理"></a>Mockito 框架的工作原理</h4><p>通过以上介绍可以发现， <code>Mockito</code> 非常容易使用并且可以方便的验证一些方法的行为，相信你已经看出来了，使用的步骤是先创建一个需要 <code>mock</code> 的对象 <code>Target</code> ，该对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">foo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"Hello, %s"</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们直接使用 <code>Mockito.mock</code> 方法和 <code>when(...).thenReturn(...)</code> 来生成 <code>mock</code> 对象并指定方法调用时的行为，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String expectedResult = <span class="string">"Mocked mghio"</span>;</span><br><span class="line">  when(mockTarget.foo(<span class="string">"mghio"</span>)).thenReturn(expectedResult);</span><br><span class="line">  String actualResult = mockTarget.foo(<span class="string">"mghio"</span>);</span><br><span class="line">  assertEquals(expectedResult, actualResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察以上 <code>when(mockTarget.foo(&quot;mghio&quot;)).thenReturn(expectedResult)</code> 这行代码，首次使用我也觉得很奇怪，<code>when</code> 方法的入参竟然是方法的返回值 <code>mockTarget.foo(&quot;mghio&quot;)</code>，觉得正确的代码应该是这样 <code>when(mockTarget).foo(&quot;mghio&quot;)</code>，但是这个写法实际上无法进行编译。既然 <code>Target.foo</code> 方法的返回值是 <code>String</code> 类型，那是不是可以使用如下方式呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mockito.when(<span class="string">"Hello, I am mghio"</span>).thenReturn(<span class="string">"Mocked mghio"</span>);</span><br></pre></td></tr></table></figure><p>结果是编译通过，但是在运行时报错：</p><p><img src="https://i.loli.net/2020/05/30/9zc3GyJoeQ8gB5v.png" alt="mockito_when_method_runtime_error.png"></p><p>从错误提示可以看出，<code>when</code> 方法需要一个方法调用的参数，实际上它只需要 <code>mock</code> 对象方法调用在 <code>when</code> 方法之前就行，我们看看下面这个测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_mockitoWhenMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String expectedResult = <span class="string">"Mocked mghio"</span>;</span><br><span class="line">  mockTarget.foo(<span class="string">"mghio"</span>);</span><br><span class="line">  when(<span class="string">"Hello, I am mghio"</span>).thenReturn(expectedResult);</span><br><span class="line">  String actualResult = mockTarget.foo(<span class="string">"mghio"</span>);</span><br><span class="line">  assertEquals(expectedResult, actualResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以正常测试通过，结果如下：</p><p><img src="https://i.loli.net/2020/05/30/njTsc6QCgFSreYi.png" alt="mockito_mock_when_method_pass.png"></p><p>为什么这样就可以正常测试通过？是因为当我们调用 <code>mock</code> 对象的 <code>foo</code> 方法时，<code>Mockito</code> 会拦截方法的调用然后将方法调用的详细信息保存到 <code>mock</code> 对象的上下文中，当调用到 <code>Mockito.when</code> 方法时，实际上是从该上下文中获取最后一个注册的方法调用，然后把 <code>thenReturn</code> 的参数作为其返回值保存，然后当我们的再次调用 <code>mock</code> 对象的该方法时，之前已经记录的方法行为将被再次回放，该方法触发拦截器重新调用并且返回我们在 <code>thenReturn</code> 方法指定的返回值。以下是 <code>Mockito.when</code> 方法的源码：</p><p><img src="https://i.loli.net/2020/05/30/Q7mVFiKrg8Zd2Ov.png" alt="mockito_when_sourcecode.png"></p><p>该方法里面直接使用了 <code>MockitoCore.when</code> 方法，继续跟进，该方法源码如下：</p><p><img src="https://i.loli.net/2020/05/30/U6nTHWx7YDQ3uLe.png" alt="mockito_when_method_mockitocore_sourcecode.png"></p><p>仔细观察可以发现，在源码中并没有用到参数 <code>methodCall</code>，而是从 <code>MockingProgress</code> 实例中获取 <code>OngoingStubbing</code> 对象，这个 <code>OngoingStubbing</code> 对象就是前文所提到的上下文对象。个人感觉是 <code>Mockito</code> 为了提供简洁易用的 <code>API</code> 然后才制造了 <code>when</code> 方法调用的这种“幻象”，简而言之，<code>Mockito</code> 框架通过方法拦截在上下文中存储和检索方法调用详细信息来工作的。</p><h4 id="如何实现一个微型的-Mock-框架"><a href="#如何实现一个微型的-Mock-框架" class="headerlink" title="如何实现一个微型的 Mock 框架"></a>如何实现一个微型的 Mock 框架</h4><p>知道了 <code>Mockito</code> 的运行原理之后，接下来看看要如何自己去实现一个类似功能的 <code>mock</code> 框架出来，看到<code>方法拦截</code>这里我相信你已经知道了，其实这就是 <code>AOP</code> 啊，但是通过阅读其源码发现 <code>Mockito</code> 其实并没有使用我们熟悉的 <code>Spring AOP</code> 或者 <code>AspectJ</code> 做的方法拦截，而是通过运行时增强库 <a href="https://bytebuddy.net" target="_blank" rel="noopener">Byte Buddy</a> 和反射工具库 <a href="http://objenesis.org" target="_blank" rel="noopener">Objenesis</a> 生成和初始化 <code>mock</code> 对象的。<br>现在，通过以上分析和源码阅读可以定义出一个简单版本的 <code>mock</code> 框架了，将自定义的 <code>mock</code> 框架命名为 <code>imock</code>。这里有一点需要注意的是，<code>Mockito</code> 有一个好处是，它不需要进行初始化，可以直接通过其提供的静态方法来立即使用它。在这里我们也使用相同名称的静态方法，通过 <code>Mockito</code> 源码：</p><p><img src="https://i.loli.net/2020/05/30/waKFURI1tvhi5Ex.png" alt="mockito_delegate_mockitocore.png"></p><p>很容易看出 <code>Mockito</code> 类最终都是委托给 <code>MockitoCore</code> 去实现的功能，而其只提供了一些面向使用者易用的静态方法，在这里我们也定义一个这样的代理对象 <code>IMockCore</code>，这个类中需要一个创建 <code>mock</code> 对象的方法 <code>mock</code> 和一个给方法设定返回值的 <code>thenReturn</code> 方法，同时该类中持有一个方法调用详情 <code>InvocationDetail</code> 集合列表，这个类是用来记录方法调用详细信息的，然后 <code>when</code> 方法仅返回列表中的最后一个 <code>InvocationDetail</code>，这里列表可以直接使用 <code>Java</code> 中常用的 <code>ArrayList</code> 即可，这里的 <code>ArrayList</code> 集合列表就实现了 <code>Mockito</code> 中的 <code>OngoingStubbing</code> 的功能。<br>根据方法的三要素<code>方法名</code>、<code>方法参数</code>和<code>方法返回值</code>很容易就可以写出 <code>InvocationDetail</code> 类的代码，为了对方法在不同类有同名的情况区分，还需要加上类全称字段和重写该类的 <code>equals</code> 和 <code>hashCode</code> 方法（判断是否在调用方法集合列表时需要根据该方法判断），代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationDetail</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String attachedClassName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object[] arguments;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T result;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InvocationDetail</span><span class="params">(String attachedClassName, String methodName, Object[] arguments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.attachedClassName = attachedClassName;</span><br><span class="line">    <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenReturn</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.result = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    InvocationDetail&lt;?&gt; behaviour = (InvocationDetail&lt;?&gt;) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(attachedClassName, behaviour.attachedClassName) &amp;&amp;</span><br><span class="line">        Objects.equals(methodName, behaviour.methodName) &amp;&amp;</span><br><span class="line">        Arrays.equals(arguments, behaviour.arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Objects.hash(attachedClassName, methodName);</span><br><span class="line">    result = <span class="number">31</span> * result + Arrays.hashCode(arguments);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是如何去创建我们的 <code>mock</code> 对象了，在这里我们也使用 <code>Byte Buddy</code> 和 <code>Objenesis</code> 库来创建 <code>mock</code> 对象，<code>IMockCreator</code> 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMockCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">createMock</span><span class="params">(Class&lt;T&gt; mockTargetClass, List&lt;InvocationDetail&gt; behaviorList)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类 <code>ByteBuddyIMockCreator</code> 使用 <code>Byte Buddy</code> 库在运行时动态生成 <code>mock</code> 类对象代码然后使用 <code>Objenesis</code> 去实例化该对象。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuddyIMockCreator</span> <span class="keyword">implements</span> <span class="title">IMockCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ObjenesisStd objenesisStd = <span class="keyword">new</span> ObjenesisStd();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">createMock</span><span class="params">(Class&lt;T&gt; mockTargetClass, List&lt;InvocationDetail&gt; behaviorList)</span> </span>&#123;</span><br><span class="line">    ByteBuddy byteBuddy = <span class="keyword">new</span> ByteBuddy();</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends T&gt; classWithInterceptor = byteBuddy.subclass(mockTargetClass)</span><br><span class="line">        .method(ElementMatchers.any())</span><br><span class="line">        .intercept(MethodDelegation.to(InterceptorDelegate.class))</span><br><span class="line">        .defineField(<span class="string">"interceptor"</span>, IMockInterceptor.class, Modifier.PRIVATE)</span><br><span class="line">        .implement(IMockIntercepable.class)</span><br><span class="line">        .intercept(FieldAccessor.ofBeanProperty())</span><br><span class="line">        .make()</span><br><span class="line">        .load(getClass().getClassLoader(), Default.WRAPPER).getLoaded();</span><br><span class="line"></span><br><span class="line">    T mockTargetInstance = objenesisStd.newInstance(classWithInterceptor);</span><br><span class="line">    ((IMockIntercepable) mockTargetInstance).setInterceptor(<span class="keyword">new</span> IMockInterceptor(behaviorList));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mockTargetInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于以上分析我们可以很容易写出创建 <code>mock</code> 对象的 <code>IMockCore</code> 类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMockCore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;InvocationDetail&gt; invocationDetailList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> IMockCreator mockCreator = <span class="keyword">new</span> ByteBuddyIMockCreator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">mock</span><span class="params">(Class&lt;T&gt; mockTargetClass)</span> </span>&#123;</span><br><span class="line">    T result = mockCreator.createMock(mockTargetClass, invocationDetailList);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">InvocationDetail&lt;T&gt; <span class="title">when</span><span class="params">(T methodCall)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentSize = invocationDetailList.size();</span><br><span class="line">    <span class="keyword">return</span> (InvocationDetail&lt;T&gt;) invocationDetailList.get(currentSize - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供给使用者的类 <code>IMock</code> 只是对 <code>IMockCore</code> 进行的简单调用而已，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IMockCore IMOCK_CORE = <span class="keyword">new</span> IMockCore();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">mock</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IMOCK_CORE.mock(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">InvocationDetail <span class="title">when</span><span class="params">(T methodCall)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IMOCK_CORE.when(methodCall);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上步骤，我们就已经实现了一个微型的 <code>mock</code> 框架了，下面来个实际例子测试一下，首先创建一个 <code>Target</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">foo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"Hello, %s"</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写其对应的测试类 <code>IMockTest</code> 类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_foo_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String exceptedResult = <span class="string">"Mocked mghio"</span>;</span><br><span class="line">    Target mockTarget = IMock.mock(Target.class);</span><br><span class="line"></span><br><span class="line">    IMock.when(mockTarget.foo(<span class="string">"mghio"</span>)).thenReturn(exceptedResult);</span><br><span class="line"></span><br><span class="line">    String actualResult = mockTarget.foo(<span class="string">"mghio"</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(exceptedResult, actualResult);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上测试的可以正常运行，达到了和 <code>Mockito</code> 测试框架一样的效果，运行结果如下：</p><p><img src="https://i.loli.net/2020/05/31/YnuEAzr7OpHPhVW.png" alt="mockito_imock_test_pass.png"></p><p>上面只是列出了一些关键类的源码，自定义 <code>IMock</code> 框架的所有代码已上传至 <code>Github</code> 仓库 <a href="https://github.com/mghio/imock" target="_blank" rel="noopener">imock</a>，感兴趣的朋友可以去看看。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文只是介绍了 <code>Mockito</code> 的一些使用方法，这只是该框架提供的最基础功能，更多高级的用法可以去官网阅读相关的文档，然后介绍了框架中 <code>when(...).thenReturn(...)</code> 定义行为方法的实现方式并按照其源码思路实现了一个相同功能的简易版的 <a href="https://github.com/mghio/imock" target="_blank" rel="noopener">imock</a> 。虽然进行单元测试有很多优点，但是也不可盲目的进行单元测试，在大部分情况下只要做好对项目中逻辑比较复杂、不容易理解的核心业务模块以及项目中公共依赖的模块的单元测试就可以了。</p><hr><p>参考文章</p><p><a href="https://github.com/mockito/mockito" target="_blank" rel="noopener">Mockito</a><br><a href="http://objenesis.org" target="_blank" rel="noopener">Objenesis</a><br><a href="https://bytebuddy.net" target="_blank" rel="noopener">Byte Buddy</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在计算机编程中，单元测试是一种软件测试方法，通过该方法可以测试源代码的各个单元功能是否适合使用。为代码编写单元测试有很多好处，包括可以及早的发现代码错误，促进更改，简化集成，方便代码重构以及许多其它功能。使用 &lt;code&gt;Java&lt;/code&gt; 语言的朋友应该用过或者听过 &lt;code&gt;Junit&lt;/code&gt; 就是用来做单元测试的，那么为什么我们还需要 &lt;a href=&quot;https://site.mockito.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mockito&lt;/a&gt; 测试框架呢？想象一下这样的一个常见的场景，当前要测试的类依赖于其它一些类对象时，如果用 &lt;code&gt;Junit&lt;/code&gt; 来进行单元测试的话，我们就必须手动创建出这些依赖的对象，这其实是个比较麻烦的工作，此时就可以使用 &lt;code&gt;Mockito&lt;/code&gt; 测试框架来模拟那些依赖的类，这些被模拟的对象在测试中充当真实对象的虚拟对象或克隆对象，而且 &lt;code&gt;Mockito&lt;/code&gt; 同时也提供了方便的测试行为验证。这样就可以让我们更多地去关注当前测试类的逻辑，而不是它所依赖的对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="unit test" scheme="https://www.mghio.cn/categories/Java/unit-test/"/>
    
      <category term="mockito" scheme="https://www.mghio.cn/categories/Java/unit-test/mockito/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="test" scheme="https://www.mghio.cn/tags/test/"/>
    
      <category term="mockito" scheme="https://www.mghio.cn/tags/mockito/"/>
    
  </entry>
  
  <entry>
    <title>如何在一台计算机上安装多个 JDK 版本</title>
    <link href="https://www.mghio.cn/post/51e5bd99.html"/>
    <id>https://www.mghio.cn/post/51e5bd99.html</id>
    <published>2020-05-16T12:52:22.000Z</published>
    <updated>2020-05-17T09:42:06.027Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>对于使用 <code>Java</code> 语言开发的朋友可能会遇到这种情况，有时想学习和探索 <code>Java</code> 的最新版本提供的一些新特性，比如 <code>Java 11</code>，但你无法将其安装在自己的计算机上，因为你的团队正在使用比这个旧的版本（我们目前用的 <code>Java 8</code>)，你并不想影响目前的项目。或者你目前是在维护和开发多个项目，而这些不同的项目使用的 <code>JDK</code> 版本不一样，比如那些维护的老项目使用的是 <code>JDK 8</code>，而新项目你打算使用比较新的版本 <code>JDK 11</code>，以上这些情况都需要在计算机上安装多个 <code>JDK</code>，并且应该能够在多个版本之间方便快速的切换。今天要介绍的主角 <a href="https://sdkman.io" target="_blank" rel="noopener">SDKMAN</a> 可以很好的解决上面这种问题，它提供了在同一台计算机上对多个版本的开发工具包管理。需要注意的是：这个工具只适用于类 <code>Unix</code> 的系统（比如：Mac OSX、Linux、Cygwin、Solaris、FreeBSD 等）。</p><a id="more"></a><h4 id="SDKMan-简介"><a href="#SDKMan-简介" class="headerlink" title="SDKMan 简介"></a>SDKMan 简介</h4><p>直接引用 <a href="https://sdkman.io" target="_blank" rel="noopener">SDKMan</a> 官网上的介绍如下：</p><blockquote><p>SDKMAN! is a tool for managing parallel versions of multiple Software Development Kits on most Unix based systems. It provides a convenient Command Line Interface (CLI) and API for installing, switching, removing and listing Candidates.</p></blockquote><p>简单来说就是其提供了管理多个版本开发工具包的能力，同时也提供了一些命令行接口让我们方便安装、版本切换、版本移除和显示版本列表。关于 <code>SDKMan</code> 还有几个要点如下：</p><ol><li><code>SDKMan</code> 是由开源社区开发的，免费使用，。</li><li><code>SDKMan</code> 是用 <code>bash</code> 编写的，它只需要您的系统上安装了 <code>curl</code> 和 <code>zip / unzip</code> 命令即可。</li><li><code>SDKMan</code> 可以为 <code>JVM</code> 安装大约 29 个软件开发包，比如 <code>Java</code>、<code>Groovy</code>、<code>Scala</code>、<code>Kotlin</code>、<code>Gradle</code>、<code>Maven</code>、<code>Spark</code>、<code>Spring Boot</code> 等。</li><li><code>SDKMan</code> 可以自动处理帮我们配置 <code>*_HOME(e.g.:JAVA_HOME)</code> 和 <code>PATH</code> 环境变量，因此我们不需要担心切换版本后这些环境变量的设置。</li></ol><h4 id="安装-SDKMan"><a href="#安装-SDKMan" class="headerlink" title="安装 SDKMan"></a>安装 SDKMan</h4><p><code>SDKMan</code> 可以运行在任何类 <code>Unix</code> 系统上，我们只需要在命令行输入以下命令即可安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s <span class="string">"https://get.sdkman.io"</span> | bash</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/16/ZKIvQfl4syq5S7J.png" alt="install-sdkman.png"></p><p>然后执行以下命令，加载文件 <code>sdkman-init.sh</code> 到当前环境，执行完该命令之后我们可以通过 <code>sdk version</code> 来验证是否安装成功，同时还可以通过 <code>sdk help</code> 命令显示有关 <code>sdk</code> 命令用法和帮助（<code>PS: 对于使用 Windows 环境的朋友可以安装 Cygwin 或 Git Bash 运行以上命令</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">"<span class="variable">$HOME</span>/.sdkman/bin/sdkman-init.sh"</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/16/xczL8U7qCfbwOrP.png" alt="verify-sdkman-install.png"></p><h4 id="使用-SDKMan-安装-JDK"><a href="#使用-SDKMan-安装-JDK" class="headerlink" title="使用 SDKMan 安装 JDK"></a>使用 SDKMan 安装 JDK</h4><p>前面已经介绍过，<code>SDKMan</code> 支持多达大约 29 个软件开发包管理，我们也可以使用 <code>sdk list</code> 命令来查看支持的完整列表，本文主要介绍 <code>Java</code> 相关的内容，可以通过命令 <code>sdk list java</code> 来查看支持安装的 <code>Java</code> 版本。</p><p><img src="https://i.loli.net/2020/05/16/BlFScVCmUDe8xNZ.png" alt="sdk-list-java.png"></p><p>使用以下命令安装 <code>Java 11</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk install java 11.0.7.hs-adpt</span><br></pre></td></tr></table></figure><p>该命令会花费一些时间，因为它会在我们的计算机上下载对应版本的 <code>JDK</code>，执行完成之后 <code>SDKman</code> 会自动给我们配置好 <code>JAVA_HOME</code> 和 <code>PATH</code> 等环境变量，可以通过 <code>Java -version</code> 命令验证。</p><p><img src="http://pic.cnw.me/imgs/2020/05/0ebcf0d26ce111fa.png" alt="sdk-install-jdk-11"></p><p>现在，如果检查 <code>Java</code> 版本和 <code>JAVA_HOME</code> 环境变量，可以看到当前 <code>Java</code> 的版本已更新为 <code>11.0.7</code>。</p><p><img src="http://pic.cnw.me/imgs/2020/05/a3a8fce8f227dbbb.png" alt="java-version-verify"></p><p>可以使用以下命令来设置默认使用的 <code>JDK</code> 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk default java 11.0.7.hs-adpt</span><br></pre></td></tr></table></figure><h4 id="将-SDKMan-指向已安装-Java-版本"><a href="#将-SDKMan-指向已安装-Java-版本" class="headerlink" title="将 SDKMan 指向已安装 Java 版本"></a>将 SDKMan 指向已安装 Java 版本</h4><p>如果在你安装 <code>SDKMan</code> 之前本地电脑已经安装了 <code>JDK</code> 版本，默认是无法识别到的，那么你需要进行以下配置才能让 <code>SDKMan</code> 识别已安装的版本，首先，第一步你要先找到你的 <code>Java</code> 安装目录，我本地 <code>Mac</code> 的安装目录是 <code>/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk</code>，然后使用命令 <code>ln -s</code> 来为 <code>Java</code> 安装目录建立符号链接。</p><p><img src="http://pic.cnw.me/imgs/2020/05/ff36347cb7a4dfe7.png" alt="point-sdkman-existing-installd-version.png"></p><h4 id="多个-JDK-版本切换示例"><a href="#多个-JDK-版本切换示例" class="headerlink" title="多个 JDK 版本切换示例"></a>多个 JDK 版本切换示例</h4><p><code>SDKMan</code> 提供了命令 <code>sdk use java &lt;version_want_to_use&gt;</code> 在多个版本之间进行切换，使用 <code>sdk use java jdk1.8.0_181.jdk</code> 命令来使用之前本地安装的 <code>Java 8</code>。</p><p><img src="http://pic.cnw.me/imgs/2020/05/412ed30ac2283fa0.png" alt="sdk-use-jdk8.png"></p><p>使用命令 <code>sdk use java 11.0.7.hs-adpt</code> 来设置版本为 <code>Java 11</code>。</p><p><img src="http://pic.cnw.me/imgs/2020/05/b28c67cf63ad28cb.png" alt="sdk-use-java11"></p><blockquote><p>需要注意的是：使用命令 <code>sdk use java &lt;version&gt;</code> 只在当前会话有效，如果你关闭终端并再次打开它，则将使用以前安装的版本，不会改变你本地使用的版本，此时可以使用 <code>sdk default java &lt;version&gt;</code> 来设置永久生效。</p></blockquote><h4 id="如何卸载指定的-JDK-版本"><a href="#如何卸载指定的-JDK-版本" class="headerlink" title="如何卸载指定的 JDK 版本"></a>如何卸载指定的 JDK 版本</h4><p>如果你想要卸载任何已安装的 <code>JDK</code> 版本，比如： <code>11.0.7.hs-adpt</code>，可以使用以下命令卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk uninstall java 11.0.7.hs-adpt</span><br></pre></td></tr></table></figure><p>此时，如果你想再次安装之前通过 <code>SDKMan</code> 卸载的版本，此时不会再次重新下载，会提示 <code>Found a previously downloaded java 11.0.7.hs-adpt archive. Not downloading it again...</code>，因为之前删除操作并没有真正的从你计算机上删除源压缩包文件。</p><h4 id="IntelliJ-IDEA-使用-SDMan-安装-JDK"><a href="#IntelliJ-IDEA-使用-SDMan-安装-JDK" class="headerlink" title="IntelliJ IDEA 使用 SDMan 安装 JDK"></a>IntelliJ IDEA 使用 SDMan 安装 JDK</h4><p><code>SDKMan</code> 所有安装的 <code>JDK</code> 都放在目录 <code>.sdkman/candidates/java/</code>，你可以在你当前用户的 <code>home</code> 文件夹下面看到该文件夹（注意是隐藏文件夹）。</p><p><img src="http://pic.cnw.me/imgs/2020/05/c37973b5619d90a3.png" alt="show-sdkman-directory.png"></p><p>在 <code>IntelliJ IDEA</code> 中打开任何一个 <code>Java</code> 项目后，您可以按 <code>Command + :</code> 快捷键打开项目结构窗口，在 <code>Project SDK</code> 模块选择新建一个 <code>JDK</code> 后输入你需要的 <code>JDK</code> 版本在 <code>SDKMan</code> 中的路径即可。</p><p><img src="http://pic.cnw.me/imgs/2020/05/6d3fb2245c19ecf2.png" alt="idea-set-jdk-version.png"></p><p>因为 <code>.sdkman</code> 是隐藏文件夹不太方便查找，可以使用以下命令创建一个非隐藏文件夹指向它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ~/.sdkman ~/sdkman</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;对于使用 &lt;code&gt;Java&lt;/code&gt; 语言开发的朋友可能会遇到这种情况，有时想学习和探索 &lt;code&gt;Java&lt;/code&gt; 的最新版本提供的一些新特性，比如 &lt;code&gt;Java 11&lt;/code&gt;，但你无法将其安装在自己的计算机上，因为你的团队正在使用比这个旧的版本（我们目前用的 &lt;code&gt;Java 8&lt;/code&gt;)，你并不想影响目前的项目。或者你目前是在维护和开发多个项目，而这些不同的项目使用的 &lt;code&gt;JDK&lt;/code&gt; 版本不一样，比如那些维护的老项目使用的是 &lt;code&gt;JDK 8&lt;/code&gt;，而新项目你打算使用比较新的版本 &lt;code&gt;JDK 11&lt;/code&gt;，以上这些情况都需要在计算机上安装多个 &lt;code&gt;JDK&lt;/code&gt;，并且应该能够在多个版本之间方便快速的切换。今天要介绍的主角 &lt;a href=&quot;https://sdkman.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDKMAN&lt;/a&gt; 可以很好的解决上面这种问题，它提供了在同一台计算机上对多个版本的开发工具包管理。需要注意的是：这个工具只适用于类 &lt;code&gt;Unix&lt;/code&gt; 的系统（比如：Mac OSX、Linux、Cygwin、Solaris、FreeBSD 等）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JDK" scheme="https://www.mghio.cn/categories/JDK/"/>
    
      <category term="Java" scheme="https://www.mghio.cn/categories/JDK/Java/"/>
    
      <category term="版本管理工具" scheme="https://www.mghio.cn/categories/JDK/Java/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="JDK" scheme="https://www.mghio.cn/tags/JDK/"/>
    
      <category term="版本管理工具" scheme="https://www.mghio.cn/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>看了你就懂的同步与异步、阻塞与非阻塞</title>
    <link href="https://www.mghio.cn/post/34755d6c.html"/>
    <id>https://www.mghio.cn/post/34755d6c.html</id>
    <published>2020-04-26T02:04:04.000Z</published>
    <updated>2020-04-26T06:08:55.551Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在网上看到过很多讲有关<code>同步与异步</code>、<code>阻塞与非阻塞</code>的文章，但是很多都是抛出一堆相关定义，看了之后还是云里雾里的，对这几个概念还是不能很好的去区分它们。本文通过通俗易懂的语言和相关例子让你深入理解其本质。</p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>首先我们要明确的是，<code>同步和异步都是针对两个或者两个以上的事物来说的</code>。比如当我们在网上购物看中一件物品，然后去浏览该商品详情的时候，首先页面会先发送一个请求，后台服务器查询对应商品的相关数据，然后前端详情页面才根据返回数据展示该商品的详细信息。而此时你的网速比较差，一个详情页面等了将近一分钟才全部展示完成，这时候你问这个请求是同步还是异步？答案显然是同步请求，它给我们最直观的表现形式就是页面一直显示在加载中，商品的详情页面渲染必须要等待后台服务器返回商品详情数据后才能进行。也就是说<code>下一个操作必须要等待上一个操作完成才能进行</code>，它依赖于上一个操作的返回结果。</p><a id="more"></a><p>你可能会问，在同步的情况下，当一个事物正在进行操作的时候，其它的事物此时在干嘛呢？这个实际上并没有明确的规定，其实同步更多的是关注事物一个一个的串行执行的过程，保证不会交叉执行，至于某个时刻处于什么状态并不关心。这在计算机中大部分时候其它事物都是处于一个<code>等待</code>的状态，而我们人则要灵活得多，在我们日常生活中常用的同步手段就是<code>排队</code>，比如我们上下班坐地铁进行安检的时候，需要依次排队安检进站乘车，但是你在排队的过程是在看手机、聊天还是什么也不做都可以，安检人员并不会在意你在做什么，这种就是由于安检<code>资源有限</code>导致的同步。</p><p><img src="https://i.loli.net/2020/04/26/IBynqeRC93Qg5MA.png" alt="sync-async.jpg"></p><p>对于同步这里有两个点需要注意，一是<code>同步的范围</code>，有时候并不需要全局的大范围的去同步，只需要在特定的操作同步即可，这样可以提升执行效率，比如 <code>Java</code> 语言中的同步方法和同步代码块。另一个是<code>同步的粒度</code>，并不是在一些大的操作粒度上才需要同步操作，小的粒度操作也需要同步操作，只是有的小粒度操作天然就已经是同步操作，并不需要我们人为的去添加同步操作控制。比如 <code>Java</code> 语言中的同步都是针对有两个或者两个以上线程的程序来说的，因为单线程的程序里它天然就是同步的。<br>而<code>异步</code>则完全相反，在异步情况下多个事务可以同时进行，互不影响，你进行你的，我进行我的，谁都不用关心谁。总的来说就是:</p><ul><li><strong>同步</strong> 两个事物相互依赖，并且一个事物必须以依赖于另一事物的执行结果。比如在事物 <code>A-&gt;B</code> 事件模型中，你需要先完成事物 A 才能执行事物 B。也就是说，同步调用在被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</li><li><strong>异步</strong> 两个事物完全独立，一个事物的执行不需要等待另外一个事物的执行。也就是说，异步调用可以返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式带着调用结果再做相关事情。</li></ul><p>可以看出同步与异步是从<code>行为角度</code>描述事物的，你品，你细品。（PS：<code>这里的多个事务可以指代不同的操作、不同的方法或者不同的代码语句等等</code>）</p><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>所谓<code>阻塞</code>，简单来说就是发出一个请求不能立刻返回响应，要等所有的逻辑全处理完才能返回响应。<code>非阻塞</code>反之，发出一个请求立刻返回应答，不用等处理完所有逻辑。阻塞与非阻塞指的是<code>单个线程内</code>遇到同步等待时，是否在原地不做任何操作。<br><code>堵车</code>就是阻塞与非阻塞最好的例子，在一线城市生活过的朋友应该都有体会，在交通正常的时候汽车可以正常通行，就是<code>非阻塞</code>，上下班高峰的时候经常发生堵车，交通正常的时候半个小时车程，高峰期可能需要二、三个小时才能到。。。而且一旦发生交通堵塞，所有马路上的车子都一动不动，只能在车子里等待，就是<code>阻塞</code>，当然大多数人不会选择干等，他们会玩手机或者和朋友聊天等等，同样的在计算机里，阻塞就意味着停止执行停下来等待，非阻塞表明操作可以继续向下执行，但是在发生阻塞的时候计算机可就没有像人这么灵活了，通常计算机的处理方式就是挂起当前线程，然后干等着，阻塞结束后才继续执行该线程。可以看出阻塞和非阻塞描述的<code>当前事物的状态</code>（等待调用结果时的状态）。</p><p><img src="https://i.loli.net/2020/04/26/APB7ZoWlzqbnXCR.jpg" alt="recv-wait.jpeg"></p><p>结合前面介绍的<code>同步与异步</code>，两两组合就会有四种情况，分别是<code>同步阻塞</code>、<code>同步非阻塞</code>、<code>异步阻塞</code>和<code>异步非阻塞</code>。下面通过车道的例子来形象的解释这几种状态：</p><ul><li><strong>同步阻塞</strong> 只有一个车道，不能超车，所有车子依次行使，一次只能通过一辆车，尴尬的是这个车道还堵车了。</li><li><strong>同步非阻塞</strong> 只有一个车道，不能超车，所有车子依次行使，一次只能通过一辆车，不过比较幸运这个车道没有堵车，可以正常通行。</li><li><strong>异步阻塞</strong> 有两个或两个以上车道，每条马路都可以通行，不同车道上的车子可以并行行使，尴尬的是所有的车道都堵车了。</li><li><strong>异步非阻塞</strong> 有两个或两个以上车道，每条马路都可以通行，不同车道上的车子可以并行行使，不过比较幸运的是没有一个车道堵车，都可以正常通行。</li></ul><p>对应到我们计算机里也是一样的，同步阻塞相当于只有一个线程，而且该线程处于阻塞（Blocked）状态，同步非阻塞相当于只有一个线程，而且该线程处于运行（Running）状态。异步阻塞相当于有多个线程，而且所有线程都处于阻塞（Blocked）状态，异步非阻塞相当于有多个线程，而且所有线程都在正常运行。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>很多程序思想都来源于生活，需要我们自己去寻找身边的场景多类比思考、总结归纳，这样才会理解得更深刻。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在网上看到过很多讲有关&lt;code&gt;同步与异步&lt;/code&gt;、&lt;code&gt;阻塞与非阻塞&lt;/code&gt;的文章，但是很多都是抛出一堆相关定义，看了之后还是云里雾里的，对这几个概念还是不能很好的去区分它们。本文通过通俗易懂的语言和相关例子让你深入理解其本质。&lt;/p&gt;
&lt;h4 id=&quot;同步与异步&quot;&gt;&lt;a href=&quot;#同步与异步&quot; class=&quot;headerlink&quot; title=&quot;同步与异步&quot;&gt;&lt;/a&gt;同步与异步&lt;/h4&gt;&lt;p&gt;首先我们要明确的是，&lt;code&gt;同步和异步都是针对两个或者两个以上的事物来说的&lt;/code&gt;。比如当我们在网上购物看中一件物品，然后去浏览该商品详情的时候，首先页面会先发送一个请求，后台服务器查询对应商品的相关数据，然后前端详情页面才根据返回数据展示该商品的详细信息。而此时你的网速比较差，一个详情页面等了将近一分钟才全部展示完成，这时候你问这个请求是同步还是异步？答案显然是同步请求，它给我们最直观的表现形式就是页面一直显示在加载中，商品的详情页面渲染必须要等待后台服务器返回商品详情数据后才能进行。也就是说&lt;code&gt;下一个操作必须要等待上一个操作完成才能进行&lt;/code&gt;，它依赖于上一个操作的返回结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="IO模型" scheme="https://www.mghio.cn/categories/Java/IO%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="IO模型" scheme="https://www.mghio.cn/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何在亿级数据中判断一个元素是否存在？</title>
    <link href="https://www.mghio.cn/post/fe76043.html"/>
    <id>https://www.mghio.cn/post/fe76043.html</id>
    <published>2020-04-19T06:50:53.000Z</published>
    <updated>2020-04-19T13:47:57.996Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在日常工作中，经常要判断一个元素是否在一个集合中。假设你要向浏览器添加一项功能，该功能可以通知用户输入的网址是否是恶意网址，此时你手上有大约 1000 万个恶意 URL 的数据集，你该如何实现该功能。按我之前的思维，要判断一个元素在不在当前的数据集中，首先想到的就是使用 <code>hash table</code>，通过哈希函数运行所有的恶意网址以获取其哈希值，然后创建出一个哈希表（数组）。这个方案有个明显的缺点，就是需要存储原始元素本身，内存占用大，而我们其实主要是关注 <code>当前输入的网址在不在我们的恶意 URL 数据集中</code>，也就是之前的恶意 URL 数据集的具体值是什么并不重要，通过吴军老师的《数学之美》了解到，对于这种场景大数据领域有个用于在海量数据情况下判断某个元素是否已经存在的算法很适合，关键的一点是该算法并不存储元素本身，这个算法就是 — 布隆过滤器(Bloom filter)。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>布隆过滤器是由巴顿.布隆于一九七零年提出的，在 <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">维基百科</a> 中的描述如下：</p><blockquote><p>A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set.</p></blockquote><a id="more"></a><p>布隆过滤器是一个数据结构，它可以用来判断某个元素是否在集合内，具有运行快速，内存占用小的特点，它由一个很长的二进制向量和一系列随机映射函数组成。而高效插入和查询的代价就是，它是一个基于概率的数据结构，只能告诉我们一个元素绝对不在集合内，布隆过滤器的好处在于快速，省空间，但是有一定的误判率。布隆过滤器的基础数据结构是一个比特向量，假设有一个长度为 16 的比特向量，下面我们通过一个简单的示例来看看其工作原理，：</p><p><img src="https://i.loli.net/2020/04/19/jpnTHrx42hG3MfI.png" alt="bloom-filter-bit-array.png"></p><p>上图比特向量中的每一个空格表示一个比特, 空格下面的数字表示当前位置的索引。只需要简单的对输入进行多次哈希操作，并把对应于其结果的比特置为 1，就完成了向 <code>Bloom filter</code> 添加一个元素的操作。下图表示向布隆过滤器中添加元素 <code>https://www.mghio.cn</code> 和 <code>https://www.abc.com</code> 的过程，它使用了 <code>func1</code> 和 <code>func2</code> 两个简单的哈希函数。</p><p><img src="https://i.loli.net/2020/04/19/6eJM1huLtsl8KUz.png" alt="bloom-filter-add-item.png"></p><p>当我们往集合里添加一个元素的时候, 可以检查该元素在应用对应哈希函数后的哈希值对比特向量的长度取余后的位置是否为 1，图中用 1 表示最新添加的元素对应位置。然后当我们要判断添加元素是否存在集合中的话，只需要简单的通过对该元素应用同样的哈希函数，然后看比特向量里对应的位置是否为 1 的方式来判断一个元素是否在集合里。如果不是，则该元素一定不再集合中，但是需要注意的是，如果是，你只知道元素可能在里面, 因为这些对应位置有可能恰巧是由其它元素或者其它元素的组合所引起的。以上就是布隆过滤器的实现原理。</p><h4 id="如何自己实现"><a href="#如何自己实现" class="headerlink" title="如何自己实现"></a>如何自己实现</h4><p>布隆过滤器的思想比较简单，首先在构造方法中初始化了一个指定长度的 <code>int</code> 数组，在添加元素的时候通过哈希函数 <code>func1</code> 和 <code>func2</code> 计算出对应的哈希值，对数组长度取余后将对应位置置为 1，判断元素是否存在于集合中时，同样也是对元素用同样的哈希函数进行两次计算，取到对应位置的哈希值，只要存在位置的值为 0，则认为元素不存在。下面使用 <code>Java</code> 语言实现了上面示例中简单版的布隆过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数组长度</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BloomFilter</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">this</span>.array = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstIndex = func1(item);</span><br><span class="line">    <span class="keyword">int</span> secondIndex = func2(item);</span><br><span class="line">    array[firstIndex % size] = <span class="number">1</span>;</span><br><span class="line">    array[secondIndex % size] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断数据 item 是否存在集合中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstIndex = func1(item);</span><br><span class="line">    <span class="keyword">int</span> secondIndex = func2(item);</span><br><span class="line">    <span class="keyword">int</span> firstValue = array[firstIndex % size];</span><br><span class="line">    <span class="keyword">int</span> secondValue = array[secondIndex % size];</span><br><span class="line">    <span class="keyword">return</span> firstValue != <span class="number">0</span> &amp;&amp; secondValue != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * hash 算法 func1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">7</span>;</span><br><span class="line">    hash += <span class="number">61</span> * hash + key.hashCode();</span><br><span class="line">    hash ^= hash &gt;&gt; <span class="number">15</span>;</span><br><span class="line">    hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">    hash += hash &lt;&lt; <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * hash 算法 func2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = key.length(); i &lt; len; i++) &#123;</span><br><span class="line">      hash += key.charAt(i);</span><br><span class="line">      hash += (hash &lt;&lt; <span class="number">7</span>);</span><br><span class="line">      hash ^= (hash &gt;&gt; <span class="number">17</span>);</span><br><span class="line">      hash += (hash &lt;&lt; <span class="number">5</span>);</span><br><span class="line">      hash ^= (hash &gt;&gt; <span class="number">13</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己实现虽然简单但是有一个问题就是检测的误判率比较高，通过其原理可以知道，可我们可以提高数组长度以及 <code>hash</code> 计算次数来降低误报率，但是相应的 <code>CPU</code>、内存的消耗也会相应的提高，这需要我们根据自己的业务需要去权衡选择。</p><h4 id="扎心一问"><a href="#扎心一问" class="headerlink" title="扎心一问"></a>扎心一问</h4><h5 id="哈希函数该如何设计？"><a href="#哈希函数该如何设计？" class="headerlink" title="哈希函数该如何设计？"></a>哈希函数该如何设计？</h5><p>布隆过滤器里的哈希函数最理想的情况就是需要尽量的<code>彼此独立且均匀分布</code>，同时，它们也需要尽可能的快 (虽然 <code>sha1</code> 之类的加密哈希算法被广泛应用，但是在这一点上考虑并不是一个很好的选择)。</p><h5 id="布隆过滤器应该设计为多大？"><a href="#布隆过滤器应该设计为多大？" class="headerlink" title="布隆过滤器应该设计为多大？"></a>布隆过滤器应该设计为多大？</h5><p>个人认为布隆过滤器的一个比较好特性就是我们可以修改过滤器的错误率。一个大的过滤器会拥有比一个小的过滤器更低的错误率。假设在布隆过滤器里面有 k 个哈希函数，m 个比特位（也就是位数组长度），以及 n 个已插入元素，错误率会近似于 (1-e<sup>kn/m</sup>)k，所以你只需要先确定可能插入的数据集的容量大小 n，然后再调整 k 和 m 来为你的应用配置过滤器。</p><h5 id="应该使用多少个哈希函数"><a href="#应该使用多少个哈希函数" class="headerlink" title="应该使用多少个哈希函数?"></a>应该使用多少个哈希函数?</h5><p>显然，布隆过滤器使用的哈希函数越多其运行速度就会越慢，但是如果哈希函数过少，又会遇到误判率高的问题。所以这个问题上需要认真考虑，在创建一个布隆过滤器的时候需要确定哈希函数的个数，也就是说你需要提前预估集合中元素的变动范围。然而你这样做了之后，你依然需要确定比特位个数和哈希函数的个数的值。看起来这似乎这是一个十分困难的优化问题，但幸运的是，对于给定的 m（比特位个数）和 n（集合元素个数），最优的 k（哈希函数个数）值为: (m/n)ln(2)（PS：<code>需要了解具体的推导过程的朋友可以参考维基百科</code>）。也就是我们可以通过以下步骤来确定布隆过滤器的哈希函数个数：</p><ol><li>确定 n（集合元素个数）的变动范围。</li><li>选定 m（比特位个数）的值。</li><li>计算 k（哈希函数个数）的最优值</li></ol><p>对于给定的 n、m 和 k 计算错误率，如果这个错误率不能接受的话，可以继续回到第二步。</p><h5 id="布隆过滤器的时间复杂度和空间复杂度"><a href="#布隆过滤器的时间复杂度和空间复杂度" class="headerlink" title="布隆过滤器的时间复杂度和空间复杂度?"></a>布隆过滤器的时间复杂度和空间复杂度?</h5><p>对于一个 m（比特位个数）和 k（哈希函数个数）值确定的布隆过滤器，添加和判断操作的时间复杂度都是 <code>O(k)</code>，这意味着每次你想要插入一个元素或者查询一个元素是否在集合中，只需要使用 k 个哈希函数对该元素求值，然后将对应的比特位标记或者检查对应的比特位即可。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>布隆过滤器的实际应用很广泛，特别是那些要在大量数据中判断一个元素是否存在的场景。可以看到，布隆过滤器的算法原理比较简单，但要实际做一个生产级别的布隆过滤器还是很复杂的，谷歌的开源库 <code>Guava</code> 的 <code>BloomFilter</code> 提供了 Java 版的实现，用法很简单。最后留给大家一个问题：布隆过滤器支持元素删除吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在日常工作中，经常要判断一个元素是否在一个集合中。假设你要向浏览器添加一项功能，该功能可以通知用户输入的网址是否是恶意网址，此时你手上有大约 1000 万个恶意 URL 的数据集，你该如何实现该功能。按我之前的思维，要判断一个元素在不在当前的数据集中，首先想到的就是使用 &lt;code&gt;hash table&lt;/code&gt;，通过哈希函数运行所有的恶意网址以获取其哈希值，然后创建出一个哈希表（数组）。这个方案有个明显的缺点，就是需要存储原始元素本身，内存占用大，而我们其实主要是关注 &lt;code&gt;当前输入的网址在不在我们的恶意 URL 数据集中&lt;/code&gt;，也就是之前的恶意 URL 数据集的具体值是什么并不重要，通过吴军老师的《数学之美》了解到，对于这种场景大数据领域有个用于在海量数据情况下判断某个元素是否已经存在的算法很适合，关键的一点是该算法并不存储元素本身，这个算法就是 — 布隆过滤器(Bloom filter)。&lt;/p&gt;
&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;布隆过滤器是由巴顿.布隆于一九七零年提出的，在 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bloom_filter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt; 中的描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Bloom filter" scheme="https://www.mghio.cn/categories/Java/Bloom-filter/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Bloom filter" scheme="https://www.mghio.cn/tags/Bloom-filter/"/>
    
  </entry>
  
  <entry>
    <title>字符串操作 — Google Guava</title>
    <link href="https://www.mghio.cn/post/3ae0ff4e.html"/>
    <id>https://www.mghio.cn/post/3ae0ff4e.html</id>
    <published>2020-04-12T07:15:39.000Z</published>
    <updated>2020-04-15T00:50:58.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>Java</code> 里字符串表示字符的不可变序列，创建后就不能更改。在我们日常的工作中，字符串的使用非常频繁，熟练的对其操作可以极大的提升我们的工作效率，今天要介绍的主角是 <code>Google</code> 开源的一个核心 <code>Java</code> 库 <a href="https://github.com/google/guava" target="_blank" rel="noopener">Guava</a>，它提供了集合类型、不可变的集合、并发、I / O、缓存、字符串等许多实用功能。在本文中，我们将学习使用 <code>Guava</code> 中的 <code>Strings</code> 和 <code>Splitter</code> 字符串操作工具类。</p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p><code>Google Guava</code> 会同步到 <a href="https://mvnrepository.com/" target="_blank" rel="noopener">Maven Central</a> 中，所以，如果你是 <code>Maven</code> 项目的话只需要在 <code>pom.xml</code> 文件中引入如下依赖即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;28.2-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>对于 <code>Gradle</code> 项目在 <code>build.gradle</code> 中引入如下依赖即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile group: <span class="string">'com.google.guava'</span>, name: <span class="string">'guava'</span>, version: <span class="string">'28.2-jre'</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>PS：<code>28.2-jre 是编写本文时的最新版本，你可以从</code> <a href="https://mvnrepository.com/" target="_blank" rel="noopener">Maven Central</a> <code>中查看当前的最新版本。</code></p><h4 id="为什么需要引入类库"><a href="#为什么需要引入类库" class="headerlink" title="为什么需要引入类库"></a>为什么需要引入类库</h4><p><code>Google Guava</code> 提供了很多实用的静态方法，这些可以解决开发人员在开发中所要完成的一些重复任务。当然，这个工作我们也可以自己做，但是引入类库它会降低错误发生的可能性，毕竟这些类库都是已经经过多年的生产验证。比如类库中 <code>Strings</code> 提供的一个方法 <code>commonPrefix</code>，它接受两个字符串并返回两个字符串之间的公共前缀（eg: <code>abcd</code> 和 <code>abef</code> 返回 <code>ab</code>）。你可以在脑子里想象一下在应用程序代码中面临这样的要求时，自己要如何编写代码来完成该操作，要自己实现这个功能，还是需要花费一些时间的，同时还需要考虑到各种边界异常情况。这就是类库提供给我们的最大价值之一，所以当我们需要的某种功能可以作为一种工具方法使用时，首先应该去寻找一些已存在的类库并去熟练使用的它们，而不是自己去实现。总结起来使用类库有如下几个原因：</p><ol><li><code>Google Guava</code> 类库有人已经对其进行了彻底的测试，<code>bug</code> 出现的概率会比我们自己实现的小很多。</li><li>作为 <code>Google Guava</code> 的一部分，已经存在各种测试用例，用于测试实用程序的实现。如果我们自己编写代码实现的话，可能还要去编写和维护它们的测试。</li></ol><h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><p><code>Google Guava</code> 有许多实用的工具类和方法，不可能在一篇文章中都有介绍完，在本文中，只会介绍和字符串操作相关的两个工具类。首先第一个是 <code>Strings</code> 类，该类提供了操作 <code>String</code> 和 <code>CharSequence</code> 的实用方法。</p><h5 id="nullToEmpty、emptyToNull-和-isNullOrEmpty"><a href="#nullToEmpty、emptyToNull-和-isNullOrEmpty" class="headerlink" title="nullToEmpty、emptyToNull 和 isNullOrEmpty"></a>nullToEmpty、emptyToNull 和 isNullOrEmpty</h5><p><code>nullToEmpty</code> 方法功能为：如果传入的字符串为 <code>null</code>，则返回一个空字符串 <code>&quot;&quot;</code>，否则按原样返回传入的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsOfNullToEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.nullToEmpty(<span class="string">"mghio"</span>));         <span class="comment">// mghio</span></span><br><span class="line">    System.out.println(Strings.nullToEmpty(<span class="string">""</span>));              <span class="comment">// ""</span></span><br><span class="line">    System.out.println(Strings.nullToEmpty(<span class="keyword">null</span>));            <span class="comment">// ""</span></span><br><span class="line">    System.out.println(Strings.nullToEmpty(<span class="keyword">null</span>).isEmpty());  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>emptyToNull</code> 方法功能为：它与 <code>nullToEmpty</code> 相反，如果传入了空字符串，则返回 <code>null</code>，否则返回原始字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsOfEmptyToNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.emptyToNull(<span class="string">"mghio"</span>));  <span class="comment">// mghio</span></span><br><span class="line">    System.out.println(Strings.emptyToNull(<span class="keyword">null</span>));     <span class="comment">// null</span></span><br><span class="line">    System.out.println(Strings.emptyToNull(<span class="string">""</span>));       <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isNullOrEmpty</code> 方法功能为：如果传入的字符串为 <code>null</code> 或为空，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsOfIsNullOrEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.isNullOrEmpty(<span class="string">"mghio"</span>));  <span class="comment">// false</span></span><br><span class="line">    System.out.println(Strings.isNullOrEmpty(<span class="string">""</span>));       <span class="comment">// true</span></span><br><span class="line">    System.out.println(Strings.isNullOrEmpty(<span class="keyword">null</span>));     <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="padStart-和-padEnd"><a href="#padStart-和-padEnd" class="headerlink" title="padStart 和 padEnd"></a>padStart 和 padEnd</h5><p>这两个方法有三个参数，分别为：输入字符串、最小长度和要填充的字符，它将字符根据需要多次插入到输入字符串的开头，以使输入字符串的长度等于传入的最小长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsOfPadStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.padStart(<span class="string">"9527"</span>, <span class="number">6</span>, <span class="string">'0'</span>));    <span class="comment">// 009527</span></span><br><span class="line">    System.out.println(Strings.padStart(<span class="string">"123456"</span>, <span class="number">6</span>, <span class="string">'0'</span>));  <span class="comment">// 123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一行代码中，将两次填充 <code>0</code> 以使最终的字符串长度等于我们传入的最小长度（6）。在第二行代码中，输入字符串长度本身具有所需的最小长度，因此未进行填充<code>padEnd</code> 方法和上面这个方法类似，只不过它是在字符的末尾而不是在开始处进行填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsOfPadEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.padEnd(<span class="string">"9527"</span>, <span class="number">6</span>, <span class="string">'0'</span>));    <span class="comment">// 952700</span></span><br><span class="line">    System.out.println(Strings.padEnd(<span class="string">"123456"</span>, <span class="number">6</span>, <span class="string">'0'</span>));  <span class="comment">// 123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h5><p>该方法需要传入一个字符串和一个重复次数 <code>count</code>，它返回一个由原始字符串组成的字符串，该字符串重复了 <code>count</code> 次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsRepeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.repeat(<span class="string">"mghio"</span>, <span class="number">3</span>));  <span class="comment">// mghiomghiomghio</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="commonPrefix-和-commonSuffix"><a href="#commonPrefix-和-commonSuffix" class="headerlink" title="commonPrefix 和 commonSuffix"></a>commonPrefix 和 commonSuffix</h5><p><code>commonPrefix</code> 方法返回传入的两个字符串之间最大的公共前缀，而 <code>commonSuffix</code> 方法返回传入两个字符串之间最大的公共后缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStrings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.commonPrefix(<span class="string">"mghio9527"</span>, <span class="string">"mghio666"</span>));  <span class="comment">// mghio</span></span><br><span class="line">    System.out.println(Strings.commonSuffix(<span class="string">"iammghio"</span>, <span class="string">"nicemghio"</span>));  <span class="comment">// mghio</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h4><p><code>Splitter</code> 类提供的功能正如其名（<code>PS:一个好的命名很重要</code>），它用于根据提供的分割符将字符串拆分为多个子字符串。我们可以通过传入一个分割符来获一个 <code>Splitter</code> 的实例，有了分割器之后，我们可以根据分割器的配置方式对字符串进行分割。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfSplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterable&lt;String&gt; result = Splitter.on(<span class="string">","</span>).split(<span class="string">"m,g,h,i,o"</span>);</span><br><span class="line">    System.out.println(result);  <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中使用逗号进行分割，因此，它将传入的字符串 <code>m,g,h,i,o</code> 拆分为一个 <code>Iterable &lt;String&gt;</code>，然后当我们对其进行迭代遍历时会输出 <code>[m, g, h, i, o]</code>。</p><h4 id="获取-Splitter-实例"><a href="#获取-Splitter-实例" class="headerlink" title="获取 Splitter 实例"></a>获取 Splitter 实例</h4><h5 id="on-和-onPattern"><a href="#on-和-onPattern" class="headerlink" title="on 和 onPattern"></a>on 和 onPattern</h5><p>现在，我们来看看获得一个分割器 <code>Splitter</code> 的各种方法。<code>on</code> 方法有各种不同的重载版本，它们以字符、字符串或正则表达式作为分隔符，我们还可以将 <code>Pattern</code> 实例作为字符串传递给 <code>onPattern</code> 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter wordSplitter = Splitter.on(<span class="string">":;"</span>);</span><br><span class="line">    <span class="comment">// 下面这行输出结果 [the, text, is, separated, by, colon, semicolon]</span></span><br><span class="line">    System.out.println(wordSplitter.split(<span class="string">"the:;text:;is:;separated:;by:;colon:;semicolon"</span>));</span><br><span class="line">    Splitter patternBasedSplitter = Splitter.on(Pattern.compile(<span class="string">"\\s+"</span>));</span><br><span class="line">    System.out.println(patternBasedSplitter.split(<span class="string">"abc   dmg hio"</span>));         <span class="comment">// [abc, dmg, hio]</span></span><br><span class="line">    System.out.println(Splitter.onPattern(<span class="string">"\\s+"</span>).split(<span class="string">"www   mghio cn"</span>));  <span class="comment">// [www, mghio, cn]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fixedLength"><a href="#fixedLength" class="headerlink" title="fixedLength"></a>fixedLength</h5><p><code>fixedLength</code> 也是最有用的方法之一，它可以将字符串分成给定长度的相等部分，需要注意的是，最后一个部分可能会小于给定的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfFixedLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter fixedLengthSplitter = Splitter.fixedLength(<span class="number">3</span>);</span><br><span class="line">    System.out.println(fixedLengthSplitter.split(<span class="string">"iammghiojava"</span>));          <span class="comment">// [iam, mgh, ioj, ava]</span></span><br><span class="line">    System.out.println(fixedLengthSplitter.split(<span class="string">"https://www.mghio.cn"</span>));  <span class="comment">// [htt, ps:, //w, ww., mgh, io., cn]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Splitter-修饰符方法"><a href="#Splitter-修饰符方法" class="headerlink" title="Splitter 修饰符方法"></a>Splitter 修饰符方法</h4><p><code>Splitter</code> 还提供了可以在更改或修改 <code>Splitter</code> 行为的常用方法。</p><h5 id="trimResults"><a href="#trimResults" class="headerlink" title="trimResults"></a>trimResults</h5><p>这个方法可以从生成的分割器的结果字符串中删除前面和末尾的空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfTrimResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter commaSplitter = Splitter.on(<span class="string">","</span>);</span><br><span class="line">    System.out.println(commaSplitter.split(<span class="string">"m, g, h, i, o"</span>));         <span class="comment">// [m,  g,  h,  i,  o]</span></span><br><span class="line">    Splitter commaSplitterWithTrim = commaSplitter.trimResults();</span><br><span class="line">    System.out.println(commaSplitterWithTrim.split(<span class="string">"m, g, h, i, o"</span>)); <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，第一个分割的结果在字符串 <code>g</code>、 <code>h</code>、<code>i</code>、<code>o</code> 之前有一个空格，使用 <code>trimResults</code> 方法后，将去除这些前导空格。</p><h5 id="omitEmptyStrings"><a href="#omitEmptyStrings" class="headerlink" title="omitEmptyStrings"></a>omitEmptyStrings</h5><p>这个方法会从结果中忽略所有空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfOmitEmptyStrings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter commaSplitter = Splitter.on(<span class="string">","</span>);</span><br><span class="line">    System.out.println(commaSplitter.split(<span class="string">"m,,g,h,i,o"</span>));                   <span class="comment">// [m, , g, h, i, o]</span></span><br><span class="line">    Splitter commaSplitterWithNoEmptyString = commaSplitter.omitEmptyStrings();</span><br><span class="line">    System.out.println(commaSplitterWithNoEmptyString.split(<span class="string">"m,,g,h,i,o"</span>));  <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>commaSplitterWithNoEmptyString</code> 会从输出中删除空字符串的结果。</p><h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>这个方法返回与原始分割器等效的分割器，但它会在达到指定的输入限制后将停止拆分，将后续剩余结果字符串作为一项输出，也就是说，我们可以通过的传入的参数指定结果中存在的最大项目数。需要注意的是：<code>该方法在省略空字符串时，省略的字符串不计算在内。</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter commaSplitter = Splitter.on(<span class="string">","</span>);</span><br><span class="line">    Splitter limitingCommaSplitter = commaSplitter.limit(<span class="number">3</span>);</span><br><span class="line">    System.out.println(limitingCommaSplitter.split(<span class="string">"i,m,g,h,i,o"</span>));  <span class="comment">// [i, m, g,h,i,o]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点需要注意，<code>Splitter</code> 是不可变的（这一点和 <code>String</code> 类似），因此，调用它的任何修饰符方法都将返回新的 <code>Splitter</code>，并且不会修改原始的 <code>Splitter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterImmutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter splitter = Splitter.on(<span class="string">'/'</span>);</span><br><span class="line">    System.out.println(<span class="string">"Before: "</span> + splitter);  <span class="comment">// Before: com.google.common.base.Splitter@33b37288</span></span><br><span class="line">    splitter.trimResults();                     <span class="comment">// do nothing</span></span><br><span class="line">    System.out.println(<span class="string">"First: "</span> + splitter);   <span class="comment">// First: com.google.common.base.Splitter@33b37288</span></span><br><span class="line">    splitter = splitter.trimResults();          <span class="comment">// the returned splitter to be assigned</span></span><br><span class="line">    System.out.println(<span class="string">"Second: "</span> + splitter);  <span class="comment">// Second: com.google.common.base.Splitter@77a57272</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="splitToList"><a href="#splitToList" class="headerlink" title="splitToList"></a>splitToList</h5><p>我们前面已经使用的 <code>split</code> 方法，它返回的是一个 <code>Iterable&lt;String&gt;</code> 对象。而这里的 <code>splitToList</code> 方法返回一个 <code>List&lt;String&gt;</code>。由于分割方法返回的是  <code>Iterable</code>，因此它是<code>惰性</code>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfSplitToList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter commaSplitter = Splitter.on(<span class="string">","</span>);</span><br><span class="line">    List&lt;String&gt; result = commaSplitter.splitToList(<span class="string">"m,g,h,i,o"</span>);</span><br><span class="line">    System.out.println(result);  <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MapSplitter"><a href="#MapSplitter" class="headerlink" title="MapSplitter"></a>MapSplitter</h4><p><code>MapSplitter</code> 顾名思义就是用来将一个将字符串拆分为 <code>Map</code> 对象的。我们可以使用 <code>withKeyValueSeparator</code> 方法从 <code>Splitter</code> 中获取 <code>MapSplitter</code> 对象，该方法接收一个字符、字符串或者 <code>Splitter</code> 对象作为参数。首先，根据原始的分割器将字符串分割为多个项，然后，使用传给 <code>withKeyValueSeparator</code> 方法的分割符将各个项分为 <code>Map</code> 键-值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfWithKeyValueSeparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter commaSplitter = Splitter.on(<span class="string">','</span>);</span><br><span class="line">    Splitter.MapSplitter keyValueSplitter = commaSplitter.withKeyValueSeparator(<span class="string">'='</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = keyValueSplitter.split(<span class="string">"name=mghio,blog=mghio.cn"</span>);</span><br><span class="line">    System.out.println(map);  <span class="comment">// &#123;name=mghio, blog=mghio.cn&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看到，它分割为两个 <code>entry</code> （<code>name=mghio</code> 与 <code>blog=mghio.cn</code>）项，还有一个点需要注意的是：<code>如果我们在原始的分割器上指定了任何修改器，则它们仅适用于该分割器，而不适用于 MapSplitter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfWithKeyValueSeparatorAndModifiers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter originalSplitter = Splitter.on(<span class="string">","</span>).trimResults();</span><br><span class="line">    Splitter.MapSplitter keyValueSplitter = originalSplitter.withKeyValueSeparator(<span class="string">'='</span>);</span><br><span class="line">    <span class="comment">// 输出结果：&#123;name  =mghio, blog=   mghio.cn&#125;</span></span><br><span class="line">    System.out.println(keyValueSplitter.split(<span class="string">"name  =mghio,   blog=   mghio.cn"</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上结果可以看出 <code>trimResults</code> 修饰方法仅适用于原始拆分器。因此，<code>blog</code> 开头的空格已被移除（使用 <code>,</code> 分割原始字符串时），但是，<code>mghio.cn</code> 开头的空格不会被移除（使用 <code>=</code> 分割成键值时）。</p><p>最后需要注意的是：<code>MapSplitter</code> 类被标记为 <code>@Beta</code>，这意味着类库中与 <code>MapSplitter</code> 相关的类和方法是实验性的，可以更改（以中断的方式），甚至将来版本可能删除。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在本文中，介绍了 <a href="https://github.com/google/guava" target="_blank" rel="noopener">Google Guava</a> 库以及在项目或应用程序中使用它的好处，如何将其导入到我们的应用程序中使用。然后，介绍了 <code>Guava</code> 库中对字符串操作工具类（<code>Strings</code> 和 <code>Splitter</code> ）的一些基本用法，当然，这只是冰山一角，<code>Guava</code> 库还提供了其它很多有用的基础功能，需要我们自己去查询相关文档学习了解，感兴趣的朋友可以去看看它的实现源码，这个库的代码写得很优雅。</p><hr><p>参考</p><ul><li><a href="https://github.com/google/guava/wiki/StringsExplained" target="_blank" rel="noopener">StringsExplained</a></li><li><a href="https://www.javaworld.com/article/2074448/guava-s-strings-class.html" target="_blank" rel="noopener">Guava’s Strings Class</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 里字符串表示字符的不可变序列，创建后就不能更改。在我们日常的工作中，字符串的使用非常频繁，熟练的对其操作可以极大的提升我们的工作效率，今天要介绍的主角是 &lt;code&gt;Google&lt;/code&gt; 开源的一个核心 &lt;code&gt;Java&lt;/code&gt; 库 &lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Guava&lt;/a&gt;，它提供了集合类型、不可变的集合、并发、I / O、缓存、字符串等许多实用功能。在本文中，我们将学习使用 &lt;code&gt;Guava&lt;/code&gt; 中的 &lt;code&gt;Strings&lt;/code&gt; 和 &lt;code&gt;Splitter&lt;/code&gt; 字符串操作工具类。&lt;/p&gt;
&lt;h4 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Google Guava&lt;/code&gt; 会同步到 &lt;a href=&quot;https://mvnrepository.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maven Central&lt;/a&gt; 中，所以，如果你是 &lt;code&gt;Maven&lt;/code&gt; 项目的话只需要在 &lt;code&gt;pom.xml&lt;/code&gt; 文件中引入如下依赖即可：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;28.2-jre&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;对于 &lt;code&gt;Gradle&lt;/code&gt; 项目在 &lt;code&gt;build.gradle&lt;/code&gt; 中引入如下依赖即可：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile group: &lt;span class=&quot;string&quot;&gt;&#39;com.google.guava&#39;&lt;/span&gt;, name: &lt;span class=&quot;string&quot;&gt;&#39;guava&#39;&lt;/span&gt;, version: &lt;span class=&quot;string&quot;&gt;&#39;28.2-jre&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Guava" scheme="https://www.mghio.cn/categories/Java/Guava/"/>
    
      <category term="String" scheme="https://www.mghio.cn/categories/Java/Guava/String/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Guava" scheme="https://www.mghio.cn/tags/Guava/"/>
    
      <category term="String" scheme="https://www.mghio.cn/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>如何编写优雅的异步代码 — CompletableFuture</title>
    <link href="https://www.mghio.cn/post/7b9ead86.html"/>
    <id>https://www.mghio.cn/post/7b9ead86.html</id>
    <published>2020-04-06T06:17:55.000Z</published>
    <updated>2020-04-06T11:11:53.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在我们的意识里，同步执行的程序都比较符合人们的思维方式，而异步的东西通常都不好处理。在异步计算的情况下，以回调表示的动作往往会分散在代码中，也可能相互嵌套在内部，如果需要处理其中一个步骤中可能发生的错误时，情况变得更加糟糕。Java 8 引入了很多的新特性，其中就包含了 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="noopener">CompletableFuture</a> 类的引入，这让我们编写清晰可读的异步代码变得更加容易，该类功能非常强大，包含了超过 50 多个方法。。。</p><h4 id="什么是-CompletableFuture"><a href="#什么是-CompletableFuture" class="headerlink" title="什么是 CompletableFuture"></a>什么是 CompletableFuture</h4><p><code>CompletableFuture</code> 类的设计灵感来自于 <code>Google Guava</code> 的 <a href="https://guava.dev/releases/21.0/api/docs/com/google/common/util/concurrent/ListenableFuture.html" target="_blank" rel="noopener">ListenableFuture</a> 类，它实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口并且新增了许多方法，它支持 lambda，通过回调利用非阻塞方法，提升了异步编程模型。它允许我们通过在与主应用程序线程不同的线程上（也就是异步）运行任务，并向主线程通知任务的进度、完成或失败，来编写非阻塞代码。</p><a id="more"></a><h4 id="为什么要引入-CompletableFuture"><a href="#为什么要引入-CompletableFuture" class="headerlink" title="为什么要引入 CompletableFuture"></a>为什么要引入 CompletableFuture</h4><p><code>Java</code> 的 1.5 版本引入了 <code>Future</code>，你可以把它简单的理解为运算结果的占位符，它提供了两个方法来获取运算结果。</p><ul><li><code>get()</code>：调用该方法线程将会无限期等待运算结果。</li><li><code>get(long timeout, TimeUnit unit)</code>：调用该方法线程将仅在指定时间 <code>timeout</code> 内等待结果，如果等待超时就会抛出 <code>TimeoutException</code> 异常。</li></ul><p><code>Future</code> 可以使用 <code>Runnable</code> 或 <code>Callable</code> 实例来完成提交的任务，通过其源码可以看出，它存在如下几个问题：</p><ul><li><strong>阻塞</strong> 调用 <code>get()</code> 方法会一直阻塞，直到等待直到计算完成，它没有提供任何方法可以在完成时通知，同时也不具有附加回调函数的功能。</li><li><strong>链式调用和结果聚合处理</strong> 在很多时候我们想链接多个 <code>Future</code> 来完成耗时较长的计算，此时需要合并结果并将结果发送到另一个任务中，该接口很难完成这种处理。</li><li><strong>异常处理</strong> <code>Future</code> 没有提供任何异常处理的方式。</li></ul><p>以上这些问题在 <code>CompletableFuture</code> 中都已经解决了，接下来让我们看看如何去使用 <code>CompletableFuture</code>。</p><h4 id="如何创建-CompletableFuture"><a href="#如何创建-CompletableFuture" class="headerlink" title="如何创建 CompletableFuture"></a>如何创建 CompletableFuture</h4><p>最简单的创建方式就是调用 <code>CompletableFuture.completedFuture(U value)</code> 方法来获取一个已经完成的 <code>CompletableFuture</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleCompletableFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.completedFuture(<span class="string">"Hello mghio"</span>);</span><br><span class="line">    assertTrue(completableFuture.isDone());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        assertEquals(<span class="string">"Hello mghio"</span>, completableFuture.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是当我们对不完整的 <code>CompleteableFuture</code>调用 <code>get</code> 方法的话，会由于 <code>Future</code> 未完成，因此 <code>get</code> 调用将永远阻塞，此时可以使用 <code>CompletableFuture.complete</code> 方法手动完成 <code>Future</code>。</p><h4 id="任务异步处理"><a href="#任务异步处理" class="headerlink" title="任务异步处理"></a>任务异步处理</h4><p>当我们想让程序在后台异步执行任务而不关心任务的处理结果时，可以使用 <code>runAsync</code> 方法，该方法接收一个 <code>Runnable</code> 类型的参数返回 <code>CompletableFuture&lt;Void&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureRunAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AtomicInteger variable = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    CompletableFuture&lt;Void&gt; runAsync = CompletableFuture.runAsync(() -&gt; process(variable));</span><br><span class="line">    runAsync.join();</span><br><span class="line">    assertEquals(<span class="number">100</span>, variable.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AtomicInteger variable)</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread() + <span class="string">" Process..."</span>);</span><br><span class="line">    variable.set(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想让任务在后台异步执行而且需要获取任务的处理结果时，可以使用 <code>supplyAsync</code> 方法，该方法接收一个 <code>Supplier&lt;T&gt;</code> 类型的参数返回一个 <code>CompletableFuture&lt;T&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureSupplyAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(<span class="keyword">this</span>::process);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        assertEquals(<span class="string">"Hello mghio"</span>, supplyAsync.get()); <span class="comment">// Blocking</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello mghio"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里你可能会有个问题，上面执行 <code>runAsync</code> 和 <code>supplyAsync</code> 任务的线程是从哪里来的、谁创建的呢？实际上它和 Java 8 中的 <code>parallelStream</code> 类似，   <code>CompletableFuture</code> 也是从全局 <code>ForkJoinPool.commonPool()</code> 获得的线程中执行这些任务的。同时，上面的两个方法也提供了自定义线程池去执行任务，其实你如果去了解过 <code>CompletableFuture</code> 的源码的话，你会发现其 <code>API</code> 中的所有方法都有个重载的版本，有或没有自定义 <code>Executor</code> 执行器。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureSupplyAsyncWithExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(<span class="keyword">this</span>::process, newFixedThreadPool);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        assertEquals(<span class="string">"Hello mghio"</span>, supplyAsync.get()); <span class="comment">// Blocking</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello mghio"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式调用和结果聚合处理"><a href="#链式调用和结果聚合处理" class="headerlink" title="链式调用和结果聚合处理"></a>链式调用和结果聚合处理</h4><p>我们知道 <code>CompletableFuture</code> 的 <code>get()</code> 方法会一直<code>阻塞</code>直到获取到结果，<code>CompletableFuture</code> 提供了 <code>thenApply</code>、<code>thenAccept</code> 和 <code>thenRun</code> 等方法来避免这种情况，而且我们还可以添加任务完成后的回调通知。这几个方法的使用场景如下：</p><ul><li><strong>thenApply</strong> 当我们如果要在从 <code>Future</code> 接收值后任务之前运行自定义的业务代码，然后要为此任务返回一些值时，则可以使用该方法</li><li><strong>thenAccept</strong> 如果我们希望在从 <code>Future</code> 接收到一些值后执行任务之前运行自定义的业务代码而不关心返回结果值时，则可以使用该方法</li><li><strong>thenRun</strong> 如果我们想在Future完成后运行自定义的业务代码，并且不想为此返回任何值时，则可以使用该方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenApply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer notificationId = CompletableFuture.supplyAsync(<span class="keyword">this</span>::thenApplyProcess)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::thenApplyNotify) <span class="comment">// Non Blocking</span></span><br><span class="line">        .join();</span><br><span class="line">    assertEquals(<span class="keyword">new</span> Integer(<span class="number">1</span>), notificationId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>::processVariable)</span><br><span class="line">        .thenAccept(<span class="keyword">this</span>::thenAcceptNotify) <span class="comment">// Non Blocking</span></span><br><span class="line">        .join();</span><br><span class="line">    assertEquals(<span class="number">100</span>, variable.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>::processVariable)</span><br><span class="line">        .thenRun(<span class="keyword">this</span>::thenRunNotify)</span><br><span class="line">        .join();</span><br><span class="line">    assertEquals(<span class="number">100</span>, variable.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">processVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    variable.set(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thenRunNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"thenRun completed notify ...."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">thenApplyNotify</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> integer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thenAcceptNotify</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">    String.format(<span class="string">"Thread %s completed notify ...."</span>, Thread.currentThread().getName()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">thenApplyProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有大量的异步计算，那么我们可以继续将值从一个回调传递到另一个回调中去，也就是使用链式调用方式，使用方式很简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenApplyAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>::findAccountNumber)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::calculateBalance)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::notifyBalance)</span><br><span class="line">        .thenAccept((i) -&gt; notifyByEmail()).join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyByEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    System.out.println(<span class="string">"send notify by email ..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Double <span class="title">notifyBalance</span><span class="params">(Double d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    System.out.println(String.format(<span class="string">"your balance is $%s"</span>, d));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9527</span>D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Double <span class="title">calculateBalance</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">9527</span>D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Double <span class="title">findAccountNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">9527</span>D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较细心的朋友可能注意到在所有前面的几个方法示例中，所有方法都是在同一线程上执行的。如果我们希望这些任务在单独的线程上运行时，那么我们可以使用这些方法对应的异步版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureApplyAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    ScheduledExecutorService newSingleThreadScheduledExecutor = Executors</span><br><span class="line">        .newSingleThreadScheduledExecutor();</span><br><span class="line">    CompletableFuture&lt;Double&gt; completableFuture =</span><br><span class="line">        CompletableFuture</span><br><span class="line">            .supplyAsync(<span class="keyword">this</span>::findAccountNumber,</span><br><span class="line">                newFixedThreadPool) <span class="comment">// 从线程池 newFixedThreadPool 获取线程执行任务</span></span><br><span class="line">            .thenApplyAsync(<span class="keyword">this</span>::calculateBalance,</span><br><span class="line">                newSingleThreadScheduledExecutor)</span><br><span class="line">            .thenApplyAsync(<span class="keyword">this</span>::notifyBalance);</span><br><span class="line">    Double balance = completableFuture.join();</span><br><span class="line">    assertEquals(<span class="number">9527</span>D, balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果处理"><a href="#执行结果处理" class="headerlink" title="执行结果处理"></a>执行结果处理</h4><p><code>thenCompose</code> 方法适合有依赖性的任务处理，比如一个计算账户余额的业务：首先我们要先找到帐号，然后为该帐户计算余额，然后计算完成后再发送通知。所有这些任务都是依赖前一个任务的返回 <code>CompletableFuture</code> 结果，此时我们需要使用 <code>thenCompose</code> 方法，其实有点类似于 Java 8 流的 <code>flatMap</code> 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenCompose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Double balance = <span class="keyword">this</span>.doFindAccountNumber()</span><br><span class="line">        .thenCompose(<span class="keyword">this</span>::doCalculateBalance)</span><br><span class="line">        .thenCompose(<span class="keyword">this</span>::doSendNotifyBalance).join();</span><br><span class="line">    assertEquals(<span class="number">9527</span>D, balance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Double&gt; <span class="title">doSendNotifyBalance</span><span class="params">(Double aDouble)</span> </span>&#123;</span><br><span class="line">    sleepSeconds(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    System.out.println(String.format(<span class="string">"%s doSendNotifyBalance ...."</span>, Thread.currentThread().getName()));</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="number">9527</span>D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Double&gt; <span class="title">doCalculateBalance</span><span class="params">(Double d)</span> </span>&#123;</span><br><span class="line">    sleepSeconds(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    System.out.println(String.format(<span class="string">"%s doCalculateBalance ...."</span>, Thread.currentThread().getName()));</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="number">9527</span>D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Double&gt; <span class="title">doFindAccountNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sleepSeconds(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    System.out.println(String.format(<span class="string">"%s doFindAccountNumber ...."</span>, Thread.currentThread().getName()));</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="number">9527</span>D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleepSeconds</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(timeout);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thenCombine</code> 方法主要是用于合并多个独立任务的处理结果。假设我们需要查找一个人的姓名和住址，则可以使用不同的任务来分别获取，然后要获得这个人的完整信息（姓名 + 住址），则需要合并这两种方法的结果，那么我们可以使用 <code>thenCombine</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenCombine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; thenCombine = <span class="keyword">this</span>.findName().thenCombine(<span class="keyword">this</span>.findAddress(), (name, address) -&gt; name + address);</span><br><span class="line">    String personInfo = thenCombine.join();</span><br><span class="line">    assertEquals(<span class="string">"mghio Shanghai, China"</span>, personInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;String&gt; <span class="title">findAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleepSeconds(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// business code</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Shanghai, China"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;String&gt; <span class="title">findName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleepSeconds(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// business code</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"mghio "</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待多个任务执行完成"><a href="#等待多个任务执行完成" class="headerlink" title="等待多个任务执行完成"></a>等待多个任务执行完成</h4><p>在许多情况下，我们希望并行运行多个任务，并在所有任务完成后再进行一些处理。假设我们要查找 3 个不同用户的姓名并将结果合并。此时就可以使用 <code>CompletableFuture</code> 的静态方法 <code>allOf</code>，该方法会等待所有任务完成，需要注意的是该方法它不会返回所有任务的合并结果，因此我们必须手动组合任务的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureAllof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; list = Lists.newArrayListWithCapacity(<span class="number">4</span>);</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">3</span>).forEach(num -&gt; list.add(findName(num)));</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; allFuture = CompletableFuture</span><br><span class="line">        .allOf(list.toArray(<span class="keyword">new</span> CompletableFuture[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;List&lt;String&gt;&gt; allFutureList = allFuture</span><br><span class="line">        .thenApply(val -&gt; list.stream().map(CompletableFuture::join).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; futureHavingAllValues = allFutureList</span><br><span class="line">        .thenApply(fn -&gt; String.join(<span class="string">""</span>, fn));</span><br><span class="line"></span><br><span class="line">    String result = futureHavingAllValues.join();</span><br><span class="line">    assertEquals(<span class="string">"mghio0mghio1mghio2"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;String&gt; <span class="title">findName</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleepSeconds(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// business code</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"mghio"</span> + num;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>在多线程中程序异常其实不太好处理，但是幸运的是在 <code>CompletableFuture</code> 中给我们提供了很方便的异常处理方式，在我们上面的例子代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenCompose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Double balance = <span class="keyword">this</span>.doFindAccountNumber()</span><br><span class="line">        .thenCompose(<span class="keyword">this</span>::doCalculateBalance)</span><br><span class="line">        .thenCompose(<span class="keyword">this</span>::doSendNotifyBalance).join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，三个方法 <code>doFindAccountNumber</code>、<code>doCalculateBalance</code> 和 <code>doSendNotifyBalance</code> 只要任意一个发生异常了，则之后调用的方法将不会运行。<br><code>CompletableFuture</code> 提供了三种处理异常的方式，分别是 <code>exceptionally</code>、<code>handle</code> 和 <code>whenComplete</code> 方法。第一种方式是使用 <code>exceptionally</code> 方法处理异常，如果前面的方法失败并发生异常，则会调用异常回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureExceptionally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; thenApply = CompletableFuture.supplyAsync(<span class="keyword">this</span>::findAccountNumber)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::calculateBalance)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::notifyBalance)</span><br><span class="line">        .exceptionally(ex -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception "</span> + ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>D;</span><br><span class="line">        &#125;);</span><br><span class="line">    Double join = thenApply.join();</span><br><span class="line">    assertEquals(<span class="number">9527</span>D, join);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式是使用 <code>handle</code> 方法处理异常，使用该方式处理异常比上面的 <code>exceptionally</code> 方式更为灵活，我们可以同时获取到异常对象和当前的处理结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>::findAccountNumber)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::calculateBalance)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::notifyBalance)</span><br><span class="line">        .handle((ok, ex) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"最终要运行的代码..."</span>);</span><br><span class="line">            <span class="keyword">if</span> (ok != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"No Exception !!"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception "</span> + ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>D;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ok;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种是使用 <code>whenComplete</code> 方法处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureWhenComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>::findAccountNumber)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::calculateBalance)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::notifyBalance)</span><br><span class="line">        .whenComplete((result, ex) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"result = "</span> + result + <span class="string">", ex = "</span> + ex);</span><br><span class="line">            System.out.println(<span class="string">"最终要运行的代码..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在本文中，介绍了 <code>CompletableFuture</code> 类的部分方法和使用方式，这个类的方法很多同时提供的功能也非常强大，在异步编程中使用的比较多，熟悉了基本的使用方法之后要深入了解还是要深入源码分析其实现原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在我们的意识里，同步执行的程序都比较符合人们的思维方式，而异步的东西通常都不好处理。在异步计算的情况下，以回调表示的动作往往会分散在代码中，也可能相互嵌套在内部，如果需要处理其中一个步骤中可能发生的错误时，情况变得更加糟糕。Java 8 引入了很多的新特性，其中就包含了 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CompletableFuture&lt;/a&gt; 类的引入，这让我们编写清晰可读的异步代码变得更加容易，该类功能非常强大，包含了超过 50 多个方法。。。&lt;/p&gt;
&lt;h4 id=&quot;什么是-CompletableFuture&quot;&gt;&lt;a href=&quot;#什么是-CompletableFuture&quot; class=&quot;headerlink&quot; title=&quot;什么是 CompletableFuture&quot;&gt;&lt;/a&gt;什么是 CompletableFuture&lt;/h4&gt;&lt;p&gt;&lt;code&gt;CompletableFuture&lt;/code&gt; 类的设计灵感来自于 &lt;code&gt;Google Guava&lt;/code&gt; 的 &lt;a href=&quot;https://guava.dev/releases/21.0/api/docs/com/google/common/util/concurrent/ListenableFuture.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ListenableFuture&lt;/a&gt; 类，它实现了 &lt;code&gt;Future&lt;/code&gt; 和 &lt;code&gt;CompletionStage&lt;/code&gt; 接口并且新增了许多方法，它支持 lambda，通过回调利用非阻塞方法，提升了异步编程模型。它允许我们通过在与主应用程序线程不同的线程上（也就是异步）运行任务，并向主线程通知任务的进度、完成或失败，来编写非阻塞代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="异步" scheme="https://www.mghio.cn/categories/Java/%E5%BC%82%E6%AD%A5/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="异步" scheme="https://www.mghio.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>代码中的坏味道</title>
    <link href="https://www.mghio.cn/post/a38c0645.html"/>
    <id>https://www.mghio.cn/post/a38c0645.html</id>
    <published>2020-03-29T06:04:12.000Z</published>
    <updated>2020-03-29T11:26:55.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在日常生活中，当我们买的水果放久了之后会发出一种难闻的气味（“坏味道”），这个时候我们就应该把它扔掉。同样，代码也有“坏味道”，当然确定什么是和不是代码“坏味道”是主观的，它会随语言、开发人员和开发方法的不同而不同。在工作当中，很多时候都是在维护之前的项目和在此基础上增加一些新功能，为了能让项目代码易于理解和维护，要时刻注意代码中的“坏味道”，当发现代码如果有坏味道了，要及时去重构它使其变成优秀的整洁的代码。本文列举代码中一些常见的“坏味道”和相应的重构方案。</p><h4 id="过长方法-Long-Method"><a href="#过长方法-Long-Method" class="headerlink" title="过长方法 (Long Method)"></a>过长方法 (Long Method)</h4><p>这种“坏味道”表现为<code>方法代码行数过长</code>，方法行数越长，就越难以理解和维护它。一个比较有用的方案就是当你觉得需要对方法中的内容加注释的时候，你应该将这个代码段作为一个新方法提取出来，哪怕有时候仅仅是一行代码也可以这么做，而且方法的命名要尽量做到见名知意，如果局部变量和参数干扰到方法的提取，则可以使用引入参数对象来进行提取。一般情况下，方法中条件运算符和循环是可以将代码移至单独方法的一个很好的代码段，对于条件运算符，可以尝试分解条件，如果方法出现循环，可以尝试提取方法。</p><a id="more"></a><h4 id="过大的类-Large-Class"><a href="#过大的类-Large-Class" class="headerlink" title="过大的类 (Large Class)"></a>过大的类 (Large Class)</h4><p>这种“坏味道”表现为<code>一个定义了很多的变量、方法代码行数很长的大类</code>，刚开始的时候类通常都不“大”，一段时间之后，随着业务的发展新功能的增加，类通常都会就会变得越来越“大”，通常程序员都喜欢在原有的类上添加属性或者添加新的方法的方式来完成功能的开发，当一个类的代码行数过多或者功能职责过多的时候，就意味着我们应该将其拆分了，常用有以下三种不同的拆分方式：</p><ol><li>提取新类，当大类的部分行为可以分解为一​​个单独的组件，则可以使用提取类的方式拆分。</li><li>提取子类，当大类的部分行为可以以不同的方式实现或在极少数情况下使用，则可以使用提取子类方式拆分。</li><li>提取接口，当有必要列出客户端可以使用的操作和行为的列表的时候，则可以提取接口的方式拆分。</li></ol><p>通过重构大类，可以使开发人员无需记住一个类的大量属性，在许多情况下，将大类分成多个部分可以避免代码和功能的重复。</p><h4 id="过长参数列表-Long-Parameter-List"><a href="#过长参数列表-Long-Parameter-List" class="headerlink" title="过长参数列表 (Long Parameter List)"></a>过长参数列表 (Long Parameter List)</h4><p>这种“坏味道”表现为<code>一个方法超过三个以上的参数</code>，当一个方法合并了几个算法之后就会可能出现过多参数的情况，这些参数用来控制方法将要运行哪种算法以及如何运行的。长参数列表也可能是由于我们将类的对象创建过程拆分产生的，想象这么一个场景，当我们把用于创建方法所需对象的代码片段从方法内部移至用于调用方法的代码，然后创建的对象作为参数传入方法，这样，原始类就不再了解对象之间的关系，依赖性降低了。当有多个这种对象需要创建之后，每个对象将需要自己的参数，这意味着参数列表会更长。随着时间的流逝，我们就会越来越难于理解这种方法的长参数列表的具体含义了，清除这种“坏味道”的方式就是将方法的参数列表封装成一个对象的属性。通过重构之后，可以使代码的可读性更高，代码更简短，同时可能还会让你看到以前未被注意的重复代码。</p><h4 id="过多注释-Too-Many-Comments"><a href="#过多注释-Too-Many-Comments" class="headerlink" title="过多注释 (Too Many Comments)"></a>过多注释 (Too Many Comments)</h4><p>这种“坏味道”表现为<code>一种方法充满解释性的注释</code>，当开发者意识到自己的代码不直观或不明显时一般都会给代码加上相应的注释。写代码注释的意图通常都是好的，是为了可以有更好的可读性让后面易于维护，在这种情况下，代码注释就会掩盖了可以改进的可疑代码的“坏味道”，好的方法名或者类名就是最好的注释。</p><blockquote><p>The best comment is a good name for a method or class.</p></blockquote><p>当我们遇到没有注释就无法理解代码片段时，首先应该尝试以无需注释的方式更改代码结构，解决过多注释通常有以下几种方式：</p><ol><li>提取变量，当如果要使用注释来解释复杂的表达式的时候，则可以使用“提取变量”的方式将表达式拆分为可理解的子表达式。</li><li>提取方法，当如果注释解释了一段代码片段，则可以通过提取方法的方式来将这一部分变成一个单独的方法，这个时候往往方法的名称就是注释的内容。</li></ol><p>通过提取变量或者提取方法的方式可以使代码变得更加直观和明显。</p><h4 id="Switch-滥用（Switch-Abuse）"><a href="#Switch-滥用（Switch-Abuse）" class="headerlink" title="Switch 滥用（Switch Abuse）"></a>Switch 滥用（Switch Abuse）</h4><p>这种“坏味道”表现为<code>代码中存在一个复杂的 switch 运算符</code>，通常，<code>if</code> 条件语句的代码可以分散在程序中的不同位置，当需要添加新条件后，就必须找到所有开关代码并进行修改。根据经验，当看到 <code>switch</code> 时，你第一时间应该想到要用多态性去重构代码。如果 <code>switch</code> 是基于类型判断的，可以使用“用子类替换”或“用状态/策略替换”。但是当运算符中没有太多条件，并且它们都使用不同的参数调用相同的方法，那么多态其实是多余的。在这种情况下，则可以使用“将参数替换为方法”，然后将该方法分解为多个较小的方法，并相应地更改 <code>switch</code> ，代码经过重构之后改进其的组织方式。当然如果 <code>switch</code> 操作只是执行简单的判断时，则没有必要进行代码重构。还有就是，在工厂设计模式（工厂方法和抽象工厂）使用开关运算符来选择创建的类时，也没有必要对其进行重构。</p><h4 id="异曲同工类（Alternative-Classes-with-Different-Interfaces）"><a href="#异曲同工类（Alternative-Classes-with-Different-Interfaces）" class="headerlink" title="异曲同工类（Alternative Classes with Different Interfaces）"></a>异曲同工类（Alternative Classes with Different Interfaces）</h4><p>这种“坏味道”表现为<code>两个类有着相同的功能，但方法名称不同</code>，产生这种代码的原因通常是创建其中一个类的程序员可能并不知道功能上等效的类已经存在。清除这种“坏味道”有以下几种方式：</p><ol><li>方法重命名，重命名相同功能的方法，使它们在所有替代类中相同。</li><li>移动方法、添加参数和泛型方法使得方法的签名和实现相同。</li><li>如果仅仅是重复了方法的部分功能，可以使用提取相同父类的方式重构，在这种情况下，现有的类将成为该父类的子类。</li></ol><p>通过重构异曲同工类后，可以去除掉不必要的重复代码，从而减少代码的行数，同时代码也会有更好的可读更易于理解。</p><h4 id="临时变量滥用（Temporary-Field）"><a href="#临时变量滥用（Temporary-Field）" class="headerlink" title="临时变量滥用（Temporary Field）"></a>临时变量滥用（Temporary Field）</h4><p>这种“坏味道”表现为<code>一些临时变量仅在某些情况下才获得其值，在这些情况之外，它们都为空</code>，通常，当我们在创建一个算法后需要定义一些临时变量以供该算法输入使用。此时，程序员往往会决定在类中为此算法去创建变量，而不是在方法中创建大量参数，导致这些变量仅在算法当中才会使用，其它地方都不会使用这些变量。一个应对的方式就是将这些临时变量和对其进行操作的所有代码都提取出来放到单独的类中。</p><h4 id="重复代码（Duplicate-Code）"><a href="#重复代码（Duplicate-Code）" class="headerlink" title="重复代码（Duplicate Code）"></a>重复代码（Duplicate Code）</h4><p>这种“坏味道”表现为<code>两个或者多个代码片段看起来几乎相同</code>，当我们多个人同时在同一项目中的不同部分上工作时，通常就会发生复制，产生重复的代码。因为正在实现不同的功能，因此可能并不知道其他人已经编写了类似的代码，这些代码其实是可以根据自己的需要进行复用的。当代码中的一些特定部分看起来不同但实际上实现相同的功能时，这样的代码有着更多细微的重复，这种情况下的代码重复可能很难找到和修复。如果重复代码在<code>两个处于相同层次结构的子类</code>出现时，我们可以通过以下方式进行重构：</p><ol><li>提取方法，将重复的代码片段提取为方法然后放到共同的父类当中。</li><li>如果重复的代码在构造方法内部，则将其提取到父类的构造方法当中去，然后再在当前类的构造方法中使用 <code>super</code> 的方式调用父类构造方法。</li><li>如果重复的代码结构上相似但又不完全相同，那么则使用模板方法方式重构。</li></ol><p>如果重复代码在<code>两个或者多个不同的类</code>出现时，我们可以通过以下方式进行重构：</p><ol><li>如果这些类不是层次结构的一部分，可以使用提取共同父类的方式来为这些类创建一个保留所有之前的功能的单个父类。</li><li>当很难或者不可能创建父类，那么可以在其中的任意一个类中使用提取类的方式来重构，然后在其它类中使用刚刚创建出来的类。</li></ol><p>通过重构合并重复的代码可以简化代码的结构并使其更加简短和易于后期维护。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文总结了一些代码中常见的“坏味道”并给出了一些解决方法，重构是需要我们开发人员时刻都要去做的，要将重构始终贯穿在整个开发过程中，不断去发现代码中的“坏味道”，不断的持续的渐进重构。最后不管我们是如何去重构代码的，其背后的指导思想都是 <a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">Solid 原则</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在日常生活中，当我们买的水果放久了之后会发出一种难闻的气味（“坏味道”），这个时候我们就应该把它扔掉。同样，代码也有“坏味道”，当然确定什么是和不是代码“坏味道”是主观的，它会随语言、开发人员和开发方法的不同而不同。在工作当中，很多时候都是在维护之前的项目和在此基础上增加一些新功能，为了能让项目代码易于理解和维护，要时刻注意代码中的“坏味道”，当发现代码如果有坏味道了，要及时去重构它使其变成优秀的整洁的代码。本文列举代码中一些常见的“坏味道”和相应的重构方案。&lt;/p&gt;
&lt;h4 id=&quot;过长方法-Long-Method&quot;&gt;&lt;a href=&quot;#过长方法-Long-Method&quot; class=&quot;headerlink&quot; title=&quot;过长方法 (Long Method)&quot;&gt;&lt;/a&gt;过长方法 (Long Method)&lt;/h4&gt;&lt;p&gt;这种“坏味道”表现为&lt;code&gt;方法代码行数过长&lt;/code&gt;，方法行数越长，就越难以理解和维护它。一个比较有用的方案就是当你觉得需要对方法中的内容加注释的时候，你应该将这个代码段作为一个新方法提取出来，哪怕有时候仅仅是一行代码也可以这么做，而且方法的命名要尽量做到见名知意，如果局部变量和参数干扰到方法的提取，则可以使用引入参数对象来进行提取。一般情况下，方法中条件运算符和循环是可以将代码移至单独方法的一个很好的代码段，对于条件运算符，可以尝试分解条件，如果方法出现循环，可以尝试提取方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="重构" scheme="https://www.mghio.cn/categories/Java/%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="重构" scheme="https://www.mghio.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 垃圾收集技术</title>
    <link href="https://www.mghio.cn/post/4615256d.html"/>
    <id>https://www.mghio.cn/post/4615256d.html</id>
    <published>2020-03-21T01:55:11.000Z</published>
    <updated>2020-03-22T06:55:21.680Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在计算机科学中，垃圾回收（<code>GC: garbage collection</code>）是内存自动管理的一种方式，它并不是同 <code>Java</code> 语言一起诞生的，实际上，早在 1959 年为了简化 <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" target="_blank" rel="noopener">Lisp</a> 语言的手动内存管理，该语言的作者就开始使用了内存自动管理技术。 <code>垃圾收集</code>和<code>手动内存管理</code>刚好相反，后者需要编程人员自己去指定需要释放的对象然后将内存归还给操作系统，而前者不需要关心给对象分配的内存回收问题。<code>Java</code> 语言使用自动垃圾收集器来管理对象生命周期中的内存，要进行垃圾收集首先需要明确三个问题：<code>1. 哪些内存需要回收</code>、<code>2. 什么时候进行回收</code>、<code>3. 怎么进行内存回收</code>。接下来让我们一起看看 <code>Java</code> 语言对这些问题是如何处理的。</p><h4 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h4><p>为了方便管理和跨平台，<code>Java</code> 虚拟机规范规定在执行 <code>Java</code> 程序的时候把它所管理的内存划分为若干个不同的数据区域。这些区域都有着各自不同的用途以及创建和销毁的时间，有的数据区域随着用户线程的启动和结束而建立和销毁，有的区域会随着虚拟机进程的启动和停止而存在和销毁。更多有关运行时数据区域的内容请看 <a href="https://www.mghio.cn/post/8a061473.html">Java 运行时数据区域</a>。<br>由于 <code>Java</code> 运行时数据区域中的 <code>程序计数器</code>、<code>虚拟机栈</code>和<code>本地方法栈</code>和线程的生命周期一致，随线程的启动和结束而建立和销毁。而且当我们的类结构确定了之后，在编译期间，一个栈帧需要分配内存的大小基本上也就确定下来了，这三个区域的内存分配和收回都是具备确定性的，不需要我们过多的去考虑内存回收问题。主要考虑<code>Java 堆</code>和<code>方法区</code>的内存回收的问题。</p><a id="more"></a><h4 id="什么时候进行回收"><a href="#什么时候进行回收" class="headerlink" title="什么时候进行回收"></a>什么时候进行回收</h4><p>在 <code>Java</code> 语言中，一个对象的生命周期分为以下三个阶段：</p><ul><li><strong>对象创建阶段</strong> 通常我们使用 <code>new</code> 关键字进行对象创建 <code>e.g. Object obj = new Object();</code>，当我们创建对象时，<code>Java</code> 虚拟机将分配一定大小的内存来存储该对象，分配的内存量可能会根据虚拟机厂商的不同而有所不同。</li><li><strong>对象使用阶段</strong> 在这个阶段，对象被应用程序的其它对象使用（其它活动对象拥有指向它的引用）。在使用期间，该对象会一直驻留在内存当中，并且可能包含对其它对象的引用。</li><li><strong>对象销毁阶段</strong> 垃圾收集系统监视对象，如果发现对象不被任何对象引用了，则进行该对象内存回收操作。</li></ul><p>那么问题来了，该如何去判断一个对象有没有被引用呢？目前，主要有两种判断对象是否存活的算法，分别是 <code>引用计数算法（Reference counting algorithm）</code>和<code>可达性分析算法（Accessibility analysis algorithm）</code>。</p><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>首先我们看看<code>引用计数算法</code>是如何判断的，该算法的主要思想就是给每个对象都添加一个引用计数器，当该对象被变量或者另一个对象引用时该计数器值就会加 1，同时当对象的一个引用无效时，对象计数器的值会相应的减 1。当对象引用计数器的值为 0 时，说明该对象已经不再被引用了，那么就可以销毁对象进行内存回收操作了。这个算法的实现比较简单，对象是否“存活”的判断效率也比较高，这个算法看起来确实不错，但是它有个致命的缺点就是：<code>无法解决对象间相互引用的问题</code>。相互引用简单来说就是，有两个对象 <code>object1</code> 和 <code>object2</code> 都有一个引用类型字段 <code>ref</code>，并且做了如下赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object1.ref = object2;</span><br><span class="line">object2.ref = object1;</span><br></pre></td></tr></table></figure><p>这两个对象除了上面这个赋值之外，不被其它任何对象引用，实际上这两个对象都不可能再被访问了，但是因为它们俩都互相引用了对方，导致引用计数器不为 0，导致使用引用计数器算法的 <code>垃圾收集器</code> 无法收集它们，它们就会一直存在于内存之中直到虚拟机进程结束。正是因为这个原因，市场上主流的 <code>Java</code> 虚拟机大部分都没有选用这个算法来管理内存，下面介绍的 <code>可达性分析算法</code> 就可以很好的避免了对象间相互引用的问题。</p><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p><code>Java</code> 虚拟机是通过<code>可达性分析算法</code>来判断对象是否存活的，该算法的主要思想是将一系列称为 <code>GC Root</code> 的对象作为起点，向下进行搜索，搜索经过的路径称为<code>引用链（Reference chain）</code>，当一个对象到 <code>GC Root</code> 对象没有任何引用链的时候，则表示该对象是不可达的，可以对其进行内存回收。</p><p><img src="https://i.loli.net/2020/03/21/aSIOt2ei6xHg1Zz.png" alt="accessibility-analysis-algorithm.png"></p><p>在 <code>Java</code> 虚拟机中，规定以下几种情况可以作为 <code>GC Root</code> 对象：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 <code>Native</code> 方法引用的对象</li></ul><h4 id="怎么进行内存回收"><a href="#怎么进行内存回收" class="headerlink" title="怎么进行内存回收"></a>怎么进行内存回收</h4><p>当我们创建的对象不可达之后，<code>Java</code> 虚拟机会在后台自动去收集回收不可达对象的内存，自 <code>Java</code> 语言诞生以来，在垃圾收集算法上进行了许多更新，主要有<code>标记-清除算法（Mark and sweep algorithm）</code>、<code>复制算法（Copying algorithm）</code>、<code>标记—整理算法（Mark and compact algorithm）</code>和<code>分代收集算法（Generational collection algorithm）</code>，根据这些算法实现的垃圾收集器在后台默默运行以释放内存，下面让我们看看它们是如何工作的。</p><h5 id="标记-清除算法（mark-and-sweep-algorithm）"><a href="#标记-清除算法（mark-and-sweep-algorithm）" class="headerlink" title="标记-清除算法（mark and sweep algorithm）"></a>标记-清除算法（mark and sweep algorithm）</h5><p><code>标记—清除算法</code>是初始且非常基本的算法，主要分为以下两个阶段：</p><ol><li>标记需要回收对象，找出程序中所有需要回收的对象并标记。</li><li>清除所有标记对象，在标记完成后统一回收被标记对象。</li></ol><p>首先标记出需要回收的对象，标记完成后再统一回收被标记对象。这个算法是最基础的垃圾收集算法，后面将要介绍的几个算法都是在它的基础上优化改进的，算法主要有两个不足的地方：① <code>效率不高</code>，标记和清除过程的效率都不高。② <code>空间利用率不高</code>，标记清除之后会产生大量不连续的内存碎片，后面如果要分配大对象的时候由于连续内存不足可能会再次触发垃圾收集操作。</p><h5 id="复制算法（copying-algorithm）"><a href="#复制算法（copying-algorithm）" class="headerlink" title="复制算法（copying algorithm）"></a>复制算法（copying algorithm）</h5><p><code>复制算法</code>就是为了解决<code>标记—清除算法</code>的效率问题的，主要思想就是将可用的内存分为大小相等的两个部分，每一次都只使用其中的一块，当这块内存使用完了之后，就将依然存活的对象复制到另一块内存上去，然后再把这块含有可回收对象的内存清理掉，这样每次都是清理一半的连续内存了，就不会存在内存碎片的情况。但是这个算法的缺点也很明显，它把可用内存的大小缩小到了一半。</p><h5 id="标记-整理算法（mark-and-compact-algorithm）"><a href="#标记-整理算法（mark-and-compact-algorithm）" class="headerlink" title="标记-整理算法（mark and compact algorithm）"></a>标记-整理算法（mark and compact algorithm）</h5><p>如果对象的存活率比较低的情况下，上面介绍的<code>复制算法</code>效率还是很高的，毕竟只要复制少部分存活对象到另一块内存中即可，但是当对象的存活率比较高时就会进行多次复制操作。比如老年代，老年代的对象是经过多次垃圾回收依然存活的对象，对象的存活率相对来说比较高，根据老年代的这个特点，于是针对这种情况就有了另一个算法称之为<code>标记-整理算法</code>，主要思想和其名字一样也是分为<code>标记</code>和<code>整理</code>两个阶段，第一个标记阶段依然和<code>标记—清除算法</code>一样，后面的第二个整理阶段就不是直接对可回收对象进行清理了，而是让所有存活的对象都向内存的同一侧移动，然后就直接清除掉另一侧的内存。</p><h5 id="分代收集算法（generational-collection-algorithm）"><a href="#分代收集算法（generational-collection-algorithm）" class="headerlink" title="分代收集算法（generational collection algorithm）"></a>分代收集算法（generational collection algorithm）</h5><p>根据不同分代的特点，现在商业上的虚拟机针对不同的分代采取适合的垃圾收集，一般是把 <code>Java</code> 堆分为新生代和老年代。在新生代中，对象大部分存活时间都很短每次垃圾收集都会有很多的对象被清除，只有少部分对象可以存活下来，那么此时就可以使用<code>复制算法</code>，只需要复制出少部分存活的对象即可效率高。然而在老年代中大部分对象的存活时间比较长，则需采用<code>标记-清除算法</code>或者<code>标记-整理算法</code>来进行垃圾收集。<br>垃圾收集算法对于垃圾回收来说类似于我们程序中的接口，是一套垃圾回收的指导算法，算法的具体实现我们称之为<code>垃圾收集器</code>。但是 <code>Java</code> 虚拟机规范中并没有对垃圾收集器的实现有任何规定。所以不同的厂商和不同版本的虚拟机实现的垃圾收集器也不一样，不过一般都会提供一些配置参数来让用户根据自身情况来设置所需的垃圾收集器。</p><h4 id="JVM-相关-GC-配置"><a href="#JVM-相关-GC-配置" class="headerlink" title="JVM 相关 GC 配置"></a>JVM 相关 GC 配置</h4><p><code>Java</code> 虚拟机部分垃圾收集（<code>Garbage Collection，GC</code>）相关配置如下</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-Xms2048m</td><td align="center">设置初始堆大小（新生代 + 老年代）</td></tr><tr><td align="center">-XX:InitialHeapSize=3g</td><td align="center">设置初始堆大小（新生代 + 老年代）</td></tr><tr><td align="center">-Xmx3g</td><td align="center">设置最大堆大小（新生代 + 老年代）</td></tr><tr><td align="center">-XX:MaxHeapSize=3g</td><td align="center">设置最大堆大小（新生代 + 老年代）</td></tr><tr><td align="center">-XX:NewSize=128m</td><td align="center">设置堆初始新生代大小</td></tr><tr><td align="center">-XX:MaxNewSize=128m</td><td align="center">设置堆最大新生代大小</td></tr><tr><td align="center">-XX:PermSize=512m（JDK 1.7）</td><td align="center">设置初始永久代（元空间）大小</td></tr><tr><td align="center">-XX:MetaspaceSize=512m（JDK 1.8+）</td><td align="center">设置初始永久代（元空间）大小</td></tr><tr><td align="center">-XX:MaxPermSize=1g（JDK 1.7）</td><td align="center">设置最大永久代（元空间）大小</td></tr><tr><td align="center">-XX:MaxMetaspaceSize=1g（JDK 1.8+）</td><td align="center">设置最大永久代（元空间）大小</td></tr><tr><td align="center">-XX:+DisableExplicitGC</td><td align="center">忽略应用程序对 <code>System.gc()</code> 方法的任何调用</td></tr><tr><td align="center">-XX:+PrintGCDetails</td><td align="center">打印输出 <code>GC</code> 收集相关信息</td></tr></tbody></table><hr><p>参考文章</p><ul><li><p><a href="https://book.douban.com/subject/24722612" target="_blank" rel="noopener">深入理解Java虚拟机（第2版）</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener">Garbage collection (computer science)</a></p></li><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html" target="_blank" rel="noopener">The Java® Virtual Machine Specification（Java SE 8 Edition）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在计算机科学中，垃圾回收（&lt;code&gt;GC: garbage collection&lt;/code&gt;）是内存自动管理的一种方式，它并不是同 &lt;code&gt;Java&lt;/code&gt; 语言一起诞生的，实际上，早在 1959 年为了简化 &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lisp&lt;/a&gt; 语言的手动内存管理，该语言的作者就开始使用了内存自动管理技术。 &lt;code&gt;垃圾收集&lt;/code&gt;和&lt;code&gt;手动内存管理&lt;/code&gt;刚好相反，后者需要编程人员自己去指定需要释放的对象然后将内存归还给操作系统，而前者不需要关心给对象分配的内存回收问题。&lt;code&gt;Java&lt;/code&gt; 语言使用自动垃圾收集器来管理对象生命周期中的内存，要进行垃圾收集首先需要明确三个问题：&lt;code&gt;1. 哪些内存需要回收&lt;/code&gt;、&lt;code&gt;2. 什么时候进行回收&lt;/code&gt;、&lt;code&gt;3. 怎么进行内存回收&lt;/code&gt;。接下来让我们一起看看 &lt;code&gt;Java&lt;/code&gt; 语言对这些问题是如何处理的。&lt;/p&gt;
&lt;h4 id=&quot;哪些内存需要回收&quot;&gt;&lt;a href=&quot;#哪些内存需要回收&quot; class=&quot;headerlink&quot; title=&quot;哪些内存需要回收&quot;&gt;&lt;/a&gt;哪些内存需要回收&lt;/h4&gt;&lt;p&gt;为了方便管理和跨平台，&lt;code&gt;Java&lt;/code&gt; 虚拟机规范规定在执行 &lt;code&gt;Java&lt;/code&gt; 程序的时候把它所管理的内存划分为若干个不同的数据区域。这些区域都有着各自不同的用途以及创建和销毁的时间，有的数据区域随着用户线程的启动和结束而建立和销毁，有的区域会随着虚拟机进程的启动和停止而存在和销毁。更多有关运行时数据区域的内容请看 &lt;a href=&quot;https://www.mghio.cn/post/8a061473.html&quot;&gt;Java 运行时数据区域&lt;/a&gt;。&lt;br&gt;由于 &lt;code&gt;Java&lt;/code&gt; 运行时数据区域中的 &lt;code&gt;程序计数器&lt;/code&gt;、&lt;code&gt;虚拟机栈&lt;/code&gt;和&lt;code&gt;本地方法栈&lt;/code&gt;和线程的生命周期一致，随线程的启动和结束而建立和销毁。而且当我们的类结构确定了之后，在编译期间，一个栈帧需要分配内存的大小基本上也就确定下来了，这三个区域的内存分配和收回都是具备确定性的，不需要我们过多的去考虑内存回收问题。主要考虑&lt;code&gt;Java 堆&lt;/code&gt;和&lt;code&gt;方法区&lt;/code&gt;的内存回收的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="GC" scheme="https://www.mghio.cn/categories/Java/GC/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="GC" scheme="https://www.mghio.cn/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>服务发现组件之 — Eureka</title>
    <link href="https://www.mghio.cn/post/710bd10b.html"/>
    <id>https://www.mghio.cn/post/710bd10b.html</id>
    <published>2020-03-14T06:29:52.000Z</published>
    <updated>2020-03-17T11:47:13.241Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>现在流行的微服务体系结构正在改变我们构建应用程序的方式，从单一的单体服务转变为越来越小的可单独部署的服务（称为<code>微服务</code>），共同构成了我们的应用程序。当进行一个业务时不可避免就会存在多个服务之间调用，假如一个服务 A 要访问在另一台服务器部署的服务 B，那么前提是服务 A 要知道服务 B 所在机器的 IP 地址和服务对应的端口，最简单的方式就是让服务 A 自己去维护一份服务 B 的配置（包含 IP 地址和端口等信息），但是这种方式有几个明显的缺点：随着我们调用服务数量的增加，配置文件该如何维护；缺乏灵活性，如果服务 B 改变 IP 地址或者端口，服务 A 也要修改相应的文件配置；还有一个就是进行服务的动态扩容或缩小不方便。<br>一个比较好的解决方案就是 <code>服务发现（Service Discovery）</code>。它抽象出来了一个注册中心，当一个新的服务上线时，它会将自己的 IP 和端口注册到注册中心去，会对注册的服务进行定期的心跳检测，当发现服务状态异常时将其从注册中心剔除下线。服务 A 只要从注册中心中获取服务 B 的信息即可，即使当服务 B 的 IP 或者端口变更了，服务 A 也无需修改，从一定程度上解耦了服务。服务发现目前业界有很多开源的实现，比如 <code>apache</code> 的 <a href="https://github.com/apache/zookeeper" target="_blank" rel="noopener">zookeeper</a>、 <code>Netflix</code> 的 <a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">eureka</a>、<code>hashicorp</code> 的 <a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener">consul</a>、 <code>CoreOS</code> 的 <a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener">etcd</a>。</p><a id="more"></a><h4 id="Eureka-是什么"><a href="#Eureka-是什么" class="headerlink" title="Eureka 是什么"></a>Eureka 是什么</h4><p><code>Eureka</code> 在 <a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">github</a> 上对其的定义为</p><blockquote><p>Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers.<br>At Netflix, Eureka is used for the following purposes apart from playing a critical part in mid-tier load balancing.</p></blockquote><p><code>Eureka</code> 是由 <a href="https://www.netflix.com" target="_blank" rel="noopener">Netflix</a> 公司开源，采用的是 Client / Server 模式进行设计，基于 http 协议和使用 Restful Api 开发的服务注册与发现组件，提供了完整的服务注册和服务发现，可以和 <code>Spring Cloud</code> 无缝集成。其中 Server 端扮演着服务注册中心的角色，主要是为 Client 端提供服务注册和发现等功能，维护着 Client 端的服务注册信息，同时定期心跳检测已注册的服务当不可用时将服务剔除下线，Client 端可以通过 Server 端获取自身所依赖服务的注册信息，从而完成服务间的调用。遗憾的是从其官方的 <a href="https://github.com/Netflix/eureka/wik" target="_blank" rel="noopener">github wiki</a> 可以发现，2.0 版本已经不再开源。但是不影响我们对其进行深入了解，毕竟服务注册、服务发现相对来说还是比较基础和通用的，其它开源实现框架的思想也是想通的。</p><h4 id="服务注册中心（Eureka-Server）"><a href="#服务注册中心（Eureka-Server）" class="headerlink" title="服务注册中心（Eureka Server）"></a>服务注册中心（Eureka Server）</h4><p>我们在项目中引入 <code>Eureka Server</code> 的相关依赖，然后在启动类加上注解 <code>@EnableEurekaServer</code>，就可以将其作为注册中心，启动服务后访问页面如下：</p><p><img src="https://i.loli.net/2020/03/15/7TAmjGKnQ2PXuMd.png" alt="eureka-server-homepage.png"></p><p>我们继续添加两个模块 <code>service-provider</code>，<code>service-consumer</code>，然后在启动类加上注解 <code>@EnableEurekaClient</code> 并指定注册中心地址为我们刚刚启动的 <code>Eureka Server</code>，再次访问可以看到两个服务都已经注册进来了。</p><p><img src="https://i.loli.net/2020/03/15/O7QpAjDRsqEBcz1.png" alt="instance-registered-currently.png"></p><p><code>Demo</code> 仓库地址：<a href="https://github.com/mghio/depth-in-springcloud" target="_blank" rel="noopener">https://github.com/mghio/depth-in-springcloud</a></p><p>可以看到 <code>Eureka</code> 的使用非常简单，只需要添加几个注解和配置就实现了服务注册和服务发现，接下来我们看看它是如何实现这些功能的。</p><h5 id="服务注册（Register）"><a href="#服务注册（Register）" class="headerlink" title="服务注册（Register）"></a>服务注册（Register）</h5><p>注册中心提供了服务注册接口，用于当有新的服务启动后进行调用来实现服务注册，或者心跳检测到服务状态异常时，变更对应服务的状态。服务注册就是发送一个 <code>POST</code> 请求带上当前实例信息到类 <code>ApplicationResource</code> 的 <code>addInstance</code> 方法进行服务注册。</p><p><img src="https://i.loli.net/2020/03/15/fsuYMRQgdZJ2BjK.png" alt="eureka-server-applicationresource-addinstance.png"></p><p>可以看到方法调用了类 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>register</code> 方法，该方法主要分为两步：</p><ol><li>调用父类 <code>AbstractInstanceRegistry</code> 的 <code>register</code> 方法把当前服务注册到注册中心</li><li>调用 <code>replicateToPeers</code> 方法使用异步的方式向其它的 <code>Eureka Server</code> 节点同步服务注册信息</li></ol><p>服务注册信息保存在一个嵌套的 <code>map</code> 中，它的结构如下：</p><p><img src="https://i.loli.net/2020/03/15/j1JAOcCbUIn5hu3.png" alt="eureka-server-registry-structure.png"></p><p>第一层 <code>map</code> 的 <code>key</code> 是应用名称（对应 <code>Demo</code> 里的 <code>SERVICE-PROVIDER</code>），第二层 <code>map</code> 的 <code>key</code> 是应用对应的实例名称（对应 <code>Demo</code> 里的 <code>mghio-mbp:service-provider:9999</code>），一个应用可以有多个实例，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/fWbIeUM3FGsT7nE.png" alt="eureka-server-register-sequence-chart.png"></p><h5 id="服务续约（Renew）"><a href="#服务续约（Renew）" class="headerlink" title="服务续约（Renew）"></a>服务续约（Renew）</h5><p>服务续约会由服务提供者（比如 <code>Demo</code> 中的 <code>service-provider</code>）定期调用，类似于心跳，用来告知注册中心 <code>Eureka Server</code> 自己的状态，避免被 <code>Eureka Server</code> 认为服务时效将其剔除下线。服务续约就是发送一个 <code>PUT</code> 请求带上当前实例信息到类 <code>InstanceResource</code> 的 <code>renewLease</code> 方法进行服务续约操作。</p><p><img src="https://i.loli.net/2020/03/15/UXSiGIjPydWxuFD.png" alt="eureka-server-instanceresource-renew.png"></p><p>进入到 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>renew</code> 方法可以看到，服务续约步骤大体上和服务注册一致，先更新当前 <code>Eureka Server</code> 节点的状态，服务续约成功后再用异步的方式同步状态到其它 <code>Eureka Server</code> 节上，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/tDTNqfn8wsuU2XM.png" alt="eureka-server-renew-sequence-chart.png"></p><h5 id="服务下线（Cancel）"><a href="#服务下线（Cancel）" class="headerlink" title="服务下线（Cancel）"></a>服务下线（Cancel）</h5><p>当服务提供者（比如 <code>Demo</code> 中的 <code>service-provider</code>）停止服务时，会发送请求告知注册中心 <code>Eureka Server</code> 进行服务剔除下线操作，防止服务消费者从注册中心调用到不存在的服务。服务下线就是发送一个 <code>DELETE</code> 请求带上当前实例信息到类 <code>InstanceResource</code> 的 <code>cancelLease</code> 方法进行服务剔除下线操作。</p><p><img src="https://i.loli.net/2020/03/15/PqTHv1VyC98YnSh.png" alt="eureka-server-instanceresource-cancellease.png"></p><p>进入到 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>cancel</code> 方法可以看到，服务续约步骤大体上和服务注册一致，先在当前 <code>Eureka Server</code> 节点剔除下线该服务，服务下线成功后再用异步的方式同步状态到其它 <code>Eureka Server</code> 节上，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/bViYUoXfKgcyMZB.png" alt="eureka-server-cancellease-sequence-chart.png"></p><h5 id="服务剔除（Eviction）"><a href="#服务剔除（Eviction）" class="headerlink" title="服务剔除（Eviction）"></a>服务剔除（Eviction）</h5><p>服务剔除是注册中心 <code>Eureka Server</code> 在启动时就启动一个守护线程 <code>evictionTimer</code> 来定期（默认为 <code>60</code> 秒）执行检测服务的，判断标准就是超过一定时间没有进行 <code>Renew</code> 的服务，默认的失效时间是 <code>90</code> 秒，也就是说当一个已注册的服务在 <code>90</code> 秒内没有向注册中心 <code>Eureka Server</code> 进行服务续约（Renew），就会被从注册中心剔除下线。失效时间可以通过配置 <code>eureka.instance.leaseExpirationDurationInSeconds</code> 进行修改，定期执行检测服务可以通过配置 <code>eureka.server.evictionIntervalTimerInMs</code> 进行修改，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/khRzlKOL2ZigUwa.png" alt="eureka-server-evict-sequence-chart.png"></p><h4 id="服务提供者（Service-Provider）"><a href="#服务提供者（Service-Provider）" class="headerlink" title="服务提供者（Service Provider）"></a>服务提供者（Service Provider）</h4><p>对于服务提供方（比如 <code>Demo</code> 中的 <code>service-provider</code> 服务）来说，主要有三大类操作，分别为 <code>服务注册（Register）</code>、<code>服务续约（Renew）</code>、<code>服务下线（Cancel）</code>，接下来看看这三个操作是如何实现的。</p><h5 id="服务注册（Register）-1"><a href="#服务注册（Register）-1" class="headerlink" title="服务注册（Register）"></a>服务注册（Register）</h5><p>一个服务要对外提供服务，首先要在注册中心 <code>Eureka Server</code> 进行服务相关信息注册，能进行这一步的前提是你要配置 <code>eureka.client.register-with-eureka=true</code>，这个默认值为 <code>true</code>，注册中心不需要把自己注册到注册中心去，把这个配置设为 <code>false</code>，这个调用比较简单，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/uv9GsO2JPeCMd3N.png" alt="service-provider-register-sequence-chart.png"></p><h5 id="服务续约（Renew）-1"><a href="#服务续约（Renew）-1" class="headerlink" title="服务续约（Renew）"></a>服务续约（Renew）</h5><p>服务续约是由服务提供者方定期（默认为 <code>30</code> 秒）发起心跳的，主要是用来告知注册中心 <code>Eureka Server</code> 自己状态是正常的还活着，可以通过配置 <code>eureka.instance.lease-renewal-interval-in-seconds</code> 来修改，当然服务续约的前提是要配置 <code>eureka.client.register-with-eureka=true</code>，将该服务注册到注册中心中去，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/1YVRCjrm45sPOag.png" alt="service-provider-renew-sequence-chart.png"></p><h5 id="服务下线（Cancel）-1"><a href="#服务下线（Cancel）-1" class="headerlink" title="服务下线（Cancel）"></a>服务下线（Cancel）</h5><p>当服务提供者方服务停止时，要发送 <code>DELETE</code> 请求告知注册中心 <code>Eureka Server</code> 自己已经下线，好让注册中心将自己剔除下线，防止服务消费方从注册中心获取到不可用的服务。这个过程实现比较简单，在类 <code>DiscoveryClient</code> 的 <code>shutdown</code> 方法加上注解 <code>@PreDestroy</code>，当服务停止时会自动触发服务剔除下线，执行服务下线逻辑，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/UGIsoMjSh9xu23t.png" alt="service-provider-cancel-sequence-chart.png"></p><h4 id="服务消费者（Service-Consumer）"><a href="#服务消费者（Service-Consumer）" class="headerlink" title="服务消费者（Service Consumer）"></a>服务消费者（Service Consumer）</h4><p>这里的服务消费者如果不需要被其它服务调用的话，其实只会涉及到两个操作，分别是从注册中心 <code>获取服务列表（Fetch）</code> 和 <code>更新服务列表（Update）</code>。如果同时也需要注册到注册中心对外提供服务的话，那么剩下的过程和上文提到的服务提供者是一致的，这里不再阐述，接下来看看这两个操作是如何实现的。</p><h5 id="获取服务列表（Fetch）"><a href="#获取服务列表（Fetch）" class="headerlink" title="获取服务列表（Fetch）"></a>获取服务列表（Fetch）</h5><p>服务消费者方启动之后首先肯定是要先从注册中心 <code>Eureka Server</code> 获取到可用的服务列表同时本地也会缓存一份。这个获取服务列表的操作是在服务启动后 <code>DiscoverClient</code> 类实例化的时候执行的。</p><p><img src="https://i.loli.net/2020/03/15/ImUKf8lScgj37ZN.png" alt="service-consumer-fetchregistry.png"></p><p>可以看出，能发生这个获取服务列表的操作前提是要保证配置了 <code>eureka.client.fetch-registry=true</code>，该配置的默认值为 <code>true</code>，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/Dy5LA439fcpjYav.png" alt="service-consumer-fetch-sequence-chart.png"></p><h5 id="更新服务列表（Update）"><a href="#更新服务列表（Update）" class="headerlink" title="更新服务列表（Update）"></a>更新服务列表（Update）</h5><p>由上面的 <code>获取服务列表（Fetch）</code> 操作过程可知，本地也会缓存一份，所以这里需要定期的去到注册中心 <code>Eureka Server</code> 获取服务的最新配置，然后比较更新本地缓存，这个更新的间隔时间可以通过配置 <code>eureka.client.registry-fetch-interval-seconds</code> 修改，默认为 <code>30</code> 秒，能进行这一步更新服务列表的前提是你要配置 <code>eureka.client.register-with-eureka=true</code>，这个默认值为 <code>true</code>。主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/5Zi6MstvO87UoSJ.png" alt="service-consumer-update-sequence-chart.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>工作中项目使用的是 <code>Spring Cloud</code> 技术栈，它有一套非常完善的开源代码来整合 <code>Eureka</code>，使用起来非常方便。之前都是直接加注解和修改几个配置属性一气呵成的，没有深入了解过源码实现，本文主要是阐述了服务注册、服务发现等相关过程和实现方式，对 <code>Eureka</code> 服务发现组件有了更近一步的了解。</p><hr><p>参考文章<br><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">Netflix Eureka</a><br><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture" target="_blank" rel="noopener">Service Discovery in a Microservices Architecture</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;现在流行的微服务体系结构正在改变我们构建应用程序的方式，从单一的单体服务转变为越来越小的可单独部署的服务（称为&lt;code&gt;微服务&lt;/code&gt;），共同构成了我们的应用程序。当进行一个业务时不可避免就会存在多个服务之间调用，假如一个服务 A 要访问在另一台服务器部署的服务 B，那么前提是服务 A 要知道服务 B 所在机器的 IP 地址和服务对应的端口，最简单的方式就是让服务 A 自己去维护一份服务 B 的配置（包含 IP 地址和端口等信息），但是这种方式有几个明显的缺点：随着我们调用服务数量的增加，配置文件该如何维护；缺乏灵活性，如果服务 B 改变 IP 地址或者端口，服务 A 也要修改相应的文件配置；还有一个就是进行服务的动态扩容或缩小不方便。&lt;br&gt;一个比较好的解决方案就是 &lt;code&gt;服务发现（Service Discovery）&lt;/code&gt;。它抽象出来了一个注册中心，当一个新的服务上线时，它会将自己的 IP 和端口注册到注册中心去，会对注册的服务进行定期的心跳检测，当发现服务状态异常时将其从注册中心剔除下线。服务 A 只要从注册中心中获取服务 B 的信息即可，即使当服务 B 的 IP 或者端口变更了，服务 A 也无需修改，从一定程度上解耦了服务。服务发现目前业界有很多开源的实现，比如 &lt;code&gt;apache&lt;/code&gt; 的 &lt;a href=&quot;https://github.com/apache/zookeeper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zookeeper&lt;/a&gt;、 &lt;code&gt;Netflix&lt;/code&gt; 的 &lt;a href=&quot;https://github.com/Netflix/eureka&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;eureka&lt;/a&gt;、&lt;code&gt;hashicorp&lt;/code&gt; 的 &lt;a href=&quot;https://github.com/hashicorp/consul&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;consul&lt;/a&gt;、 &lt;code&gt;CoreOS&lt;/code&gt; 的 &lt;a href=&quot;https://github.com/etcd-io/etcd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;etcd&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="服务发现" scheme="https://www.mghio.cn/categories/Java/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
      <category term="Eureka" scheme="https://www.mghio.cn/categories/Java/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/Eureka/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="服务发现" scheme="https://www.mghio.cn/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
      <category term="Eureka" scheme="https://www.mghio.cn/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>2020 年 JVM 生态报告解读</title>
    <link href="https://www.mghio.cn/post/e09f0428.html"/>
    <id>https://www.mghio.cn/post/e09f0428.html</id>
    <published>2020-03-04T01:47:56.000Z</published>
    <updated>2020-03-06T05:56:29.111Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>做过 <code>Java</code> 开发的同学都知道，<code>JVM（Java 虚拟机）</code> 是 <code>Java</code> 实现的基础，虽然在平时工作中真正运用到的时候可能并不多，但是一个程序员想要上升到高级层次，那就必须知道 <code>Java</code> 到底是怎么运行的，这就有必要去学习了解 <code>JVM</code> 的相关知识了。学习 <code>JVM</code> 可以能更深入的理解 <code>Java</code> 这门语言，可以清楚知道Java程序是如何执行的以及为未来排查线上问题打下坚实的基础。接下来我们看看 2020 年的 <code>JVM</code> 生态报告和最新趋势，值得我们每个 <code>Java</code> 开发者去关注了解。</p><h4 id="JDK-厂商占比"><a href="#JDK-厂商占比" class="headerlink" title="JDK 厂商占比"></a>JDK 厂商占比</h4><p><code>Oracle JDK</code> 和 <code>Open JDK</code> 加起来占比将近 <code>60%</code>，其中 <code>Oracle JDK</code> 占比略多一些，<code>Oracle JDK</code> 和 <code>Open JDK</code> 都是市场上的热门选择，我们看看二者之间的一些差异。<code>Oracle JDK</code> 更多的关注稳定性，更适合企业级用户，而 <code>Open JDK</code> 相对而言没有那么稳定，它会经常发布一些新特性。<code>Oracle JDK</code> 支持长期发布的更改，而 <code>Open JDK</code> 仅支持计划和完成下一个发行版，还有一个就是 <code>Oracle JDK</code> 是根据 <a href="https://zh.wikipedia.org/wiki/Zlib%E6%8E%88%E6%9D%83%E6%9D%A1%E6%AC%BE" target="_blank" rel="noopener">二进制代码许可协议</a> 获得许可，而 <code>Open JDK</code> 是根据 <a href="https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81" target="_blank" rel="noopener">GPL v2</a> 许可获得许可。使用 <code>Oracle</code> 平台时会产生一些许可影响。如 <code>Oracle</code> 宣布的那样，在没有商业许可的情况下，在 2019 年 1 月之后发布的 <code>Oracle Java SE 8</code> 的公开更新将无法用于商业，商业或生产用途。但是，<code>Open JDK</code> 是完全开源的，可以自由使用。</p><a id="more"></a><p><img src="https://i.loli.net/2020/03/04/YZDLa9Be6H1kOpW.png" alt="which-java-vendor-use.png"></p><h4 id="愿意付费用户占比很少"><a href="#愿意付费用户占比很少" class="headerlink" title="愿意付费用户占比很少"></a>愿意付费用户占比很少</h4><p>只有 <code>9%</code> 的用户表示愿意为 <code>JDK</code> 支付费用，还有 <code>86%</code> 的用户表示并不想为 <code>JDK</code> 支付费用，可以看出大部分用户其实对 <code>JDK</code> 的付费使用还是不赞同的，目前来看，如果要真正实行付费模式还是有点难。不过人们选择为 <code>JDK</code> 支付费用时，<code>Oracle</code> 还是当之无愧的大赢家的。自从 <code>JDK9</code> 发布之后，以后每年的 3 月和 9 月都会发布一个新的版本，这个发布节奏的改变，这个对许多用户的版本更新策略还是有一定的影响。调查结果显示这个发布节奏的变更影响了三分之一的开发者们是否决定为其支付费用。</p><p><img src="https://i.loli.net/2020/03/04/z5iKXwyclG48ZPF.png" alt="paying-for-jdk-support.png"></p><h4 id="Java-8-仍然是主流版本"><a href="#Java-8-仍然是主流版本" class="headerlink" title="Java 8 仍然是主流版本"></a>Java 8 仍然是主流版本</h4><p>从 <code>Java 9</code> 之后对 <code>JDK</code> 的结构做了很大的调整，这也是影响人们升级的原因之一，根据报告结果来看 <code>Java 8</code> 仍然是大家使用最多的版本，但是在 2018 年 9 月发布了第一个 <code>LTS(长期支持)</code> 版的 <code>Java 11</code> 之后，有四分之一的开发者在生产环境中使用了 <code>Java 11</code>。因为发布节奏的原因，大部分开发者还是不愿意每 6 个月就对版本进行一次更新，版本迁移成本其实也不低，还有新版本在生产环境的稳定性也是其中的一个考虑因素。</p><p><img src="https://i.loli.net/2020/03/04/ma1sHtEYzVOPU4v.png" alt="java-version-use-production.png"></p><h4 id="Kotlin-在-JVM-类语言中占比第二"><a href="#Kotlin-在-JVM-类语言中占比第二" class="headerlink" title="Kotlin 在 JVM 类语言中占比第二"></a>Kotlin 在 JVM 类语言中占比第二</h4><p>在 <code>JVM</code> 类语言语言中 <code>Java</code> 占比 <code>86.9%</code> 稳居第一，除了 <code>Java</code> 语言之外，<code>Kotlin</code> 语言在 <code>JVM</code> 类语言占比第二占比 <code>5.5%</code>，<code>Kotlin</code> 从去年的 <code>2.4%</code> 增加到今年的 <code>5.5%</code>，<code>JVM</code> 类语言的用户中 <code>Kotlin</code> 使用率的增长，因为它可以与 <code>Java</code> 无缝集成也不足为奇，像在 <code>Spring Boot</code> 框架中使用 <code>Kotlin</code> 进行开发也很容易。<code>Kotlin</code> 也一直在创新，积极拥抱 <code>Java</code> 的大腿，在 <code>Java</code> 的新版本中也在试图整合一些 <code>Kotlin</code> 的概念。</p><p><img src="https://i.loli.net/2020/03/04/KiqruXYm9AG6Nw2.png" alt="jvm-language-use.png"></p><h4 id="Spring-依然是-Java-框架中的王者"><a href="#Spring-依然是-Java-框架中的王者" class="headerlink" title="Spring 依然是 Java 框架中的王者"></a>Spring 依然是 Java 框架中的王者</h4><p>有十分之六的开发者依赖 <code>Spring</code> 框架来构建他们的程序，这对于众多的第三方开源框架来说，这是一个很高的占比，<code>Spring Framework</code> 依然是 <code>Java</code> 开发框架中的王者，<code>Spring</code> 框架已经发布了很长一段时间了，通过长时间的改进和创新，无疑 <code>Spring</code> 现在已经成为 <code>Java</code> 生态系统中的最重要的框架。在众多的使用者中有将近三分之二的用户使用 <code>Spring 5</code>，可见大家对 <code>Spring</code> 框架的新版使用率还是很高的。</p><p><img src="https://i.loli.net/2020/03/04/Xwg1GLW9jNl6YTv.png" alt="spring-version-use.png"></p><h4 id="Spring-Boot-是主流的服务器端-Web-框架"><a href="#Spring-Boot-是主流的服务器端-Web-框架" class="headerlink" title="Spring Boot 是主流的服务器端 Web 框架"></a>Spring Boot 是主流的服务器端 Web 框架</h4><p>服务器端依然是 <code>Spring</code> 的天下，其中有一半的人使用的是 <code>Spring Boot</code> 框架，还有将近的三分之一的人使用的是 <code>Spring MVC</code> 框架，前几年比较火的 <code>Struts</code> 框架已经开始没落了，这个占比和现在市场上比较流行微服务架构是分不开，因为 <code>Spring Boot</code> 框架天生就是为微服务而生的，它可以快速实现微服务。使用基于 <code>Spring Boot</code> 的 <code>Spring Cloud</code> 框架可以快速搭建一个分布式的服务或应用。</p><p><img src="https://i.loli.net/2020/03/04/UEJbGHIgz6YLsFa.png" alt="server-side-web-framework.png"></p><h4 id="IntelliJ-IDEA-是主流的开发工具"><a href="#IntelliJ-IDEA-是主流的开发工具" class="headerlink" title="IntelliJ IDEA 是主流的开发工具"></a>IntelliJ IDEA 是主流的开发工具</h4><p><code>IntelliJ IDEA</code> 是 <code>Java</code> 开发者们使用最广泛的开发工具，调查结果显示有 <code>62%</code> 的开发人员使用社区免费版和付费终极版。<code>Apache NetBeans</code> 以 <code>10%</code> 的市场份额保持在第三位，和去年的调查结果一致。可以发现被业界广泛称赞的 <code>VS Code</code> 神级编辑器在 <code>Java</code> 开发人员中并没有想象的那么受欢迎。</p><p><img src="https://i.loli.net/2020/03/04/nUVkcPDbW3zKoI1.png" alt="which-ide-use.png"></p><h4 id="Maven-是主流的项目构建管理工具"><a href="#Maven-是主流的项目构建管理工具" class="headerlink" title="Maven 是主流的项目构建管理工具"></a>Maven 是主流的项目构建管理工具</h4><p><code>Maven</code> 是一个软件项目管理和自动构建的工具，由 <code>Apache 基金会</code> 维护。它基于项目对象模型(POM)概念，<code>Maven</code> 利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。调查结果显示它在排名仍是第一，一直都是主流的项目构建工具，排名第二的 <code>Gradle</code> 一直保持着增长的趋势，在 2019 年占比达到四分之一，而在 2012 年占比高达 <code>40%</code> 的老牌的构建工具 <code>Ant</code> 将逐渐退出舞台，到 2019 年占比不到 <code>10%</code>。可以明确的是，构建工具之间的竞争从不会停止，能否及时更新发布一些可以解决使用者痛点的工具是大家选择的因素之一。</p><p><img src="https://i.loli.net/2020/03/04/Cst4LldU9Zz1G8B.png" alt="which-build-tool-use.png"></p><h4 id="Jenkins-仍然是持续集成工具中的王者"><a href="#Jenkins-仍然是持续集成工具中的王者" class="headerlink" title="Jenkins 仍然是持续集成工具中的王者"></a>Jenkins 仍然是持续集成工具中的王者</h4><p>和我们大多数 <code>Java</code> 开发人员的期望一致，<code>Jenkins</code> 以高达 <code>58%</code> 的占比排名稳居第一，排名第二的 <code>GitLab</code> 占比仅为 <code>6%</code>，有趣的是没有使用工具的也高达 <code>12%</code>，虽然不适用工具的人数占比比去年低了很多，但是这个占比还是让人有点儿惊讶。</p><p><img src="https://i.loli.net/2020/03/05/SRBTX6NVA4WJsyd.png" alt="which-CI-server-use.png"></p><hr><p>生态报告来源：<a href="https://snyk.io/blog/jvm-ecosystem-report-2020" target="_blank" rel="noopener">https://snyk.io/blog/jvm-ecosystem-report-2020</a></p><p>PS：关注公众号「mghio」，回复关键字 <code>JVM</code> 获取 2020 年 <code>JVM</code> 生态报告 <code>PDF</code> 版原文。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;做过 &lt;code&gt;Java&lt;/code&gt; 开发的同学都知道，&lt;code&gt;JVM（Java 虚拟机）&lt;/code&gt; 是 &lt;code&gt;Java&lt;/code&gt; 实现的基础，虽然在平时工作中真正运用到的时候可能并不多，但是一个程序员想要上升到高级层次，那就必须知道 &lt;code&gt;Java&lt;/code&gt; 到底是怎么运行的，这就有必要去学习了解 &lt;code&gt;JVM&lt;/code&gt; 的相关知识了。学习 &lt;code&gt;JVM&lt;/code&gt; 可以能更深入的理解 &lt;code&gt;Java&lt;/code&gt; 这门语言，可以清楚知道Java程序是如何执行的以及为未来排查线上问题打下坚实的基础。接下来我们看看 2020 年的 &lt;code&gt;JVM&lt;/code&gt; 生态报告和最新趋势，值得我们每个 &lt;code&gt;Java&lt;/code&gt; 开发者去关注了解。&lt;/p&gt;
&lt;h4 id=&quot;JDK-厂商占比&quot;&gt;&lt;a href=&quot;#JDK-厂商占比&quot; class=&quot;headerlink&quot; title=&quot;JDK 厂商占比&quot;&gt;&lt;/a&gt;JDK 厂商占比&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Oracle JDK&lt;/code&gt; 和 &lt;code&gt;Open JDK&lt;/code&gt; 加起来占比将近 &lt;code&gt;60%&lt;/code&gt;，其中 &lt;code&gt;Oracle JDK&lt;/code&gt; 占比略多一些，&lt;code&gt;Oracle JDK&lt;/code&gt; 和 &lt;code&gt;Open JDK&lt;/code&gt; 都是市场上的热门选择，我们看看二者之间的一些差异。&lt;code&gt;Oracle JDK&lt;/code&gt; 更多的关注稳定性，更适合企业级用户，而 &lt;code&gt;Open JDK&lt;/code&gt; 相对而言没有那么稳定，它会经常发布一些新特性。&lt;code&gt;Oracle JDK&lt;/code&gt; 支持长期发布的更改，而 &lt;code&gt;Open JDK&lt;/code&gt; 仅支持计划和完成下一个发行版，还有一个就是 &lt;code&gt;Oracle JDK&lt;/code&gt; 是根据 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Zlib%E6%8E%88%E6%9D%83%E6%9D%A1%E6%AC%BE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二进制代码许可协议&lt;/a&gt; 获得许可，而 &lt;code&gt;Open JDK&lt;/code&gt; 是根据 &lt;a href=&quot;https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GPL v2&lt;/a&gt; 许可获得许可。使用 &lt;code&gt;Oracle&lt;/code&gt; 平台时会产生一些许可影响。如 &lt;code&gt;Oracle&lt;/code&gt; 宣布的那样，在没有商业许可的情况下，在 2019 年 1 月之后发布的 &lt;code&gt;Oracle Java SE 8&lt;/code&gt; 的公开更新将无法用于商业，商业或生产用途。但是，&lt;code&gt;Open JDK&lt;/code&gt; 是完全开源的，可以自由使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="JVM" scheme="https://www.mghio.cn/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.mghio.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统之 — CAP 定理</title>
    <link href="https://www.mghio.cn/post/11cb7677.html"/>
    <id>https://www.mghio.cn/post/11cb7677.html</id>
    <published>2020-02-29T01:12:06.000Z</published>
    <updated>2020-04-10T13:23:19.242Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在互联网时代，我们的应用都是分布式系统，部署在 N 台机器上。说到分布式系统我们就不得不说分布式系统的祖先——集中式系统。它和分布式系统是两个完全相反的概念，集中式系统就是把所有的程序和功能都放到一台主机上，从而对外提供服务。集中式系统的优点就是容易理解、维护方便，它的的弊端也很明显，如果这个主机出故障了那么整个系统就崩溃了。著名投资家巴菲特有个关于投资的名言：</p><blockquote><p>不要把鸡蛋放在一个篮子里</p></blockquote><p>对于我们的系统而言也是如此，我们不可能保证主机永远不坏、也无法保证自己的程序永远不会出 <code>bug</code>，所以问题是无法避免的，我们只能把“鸡蛋”分散到不同的“篮子”里，降低系统出故障的风险，这就是我们为什么需要分布式系统的原因之一。使用分布式系统的另一个理由就是扩展性，毕竟单台主机都会有性能的极限，分布式系统可以通过增加主机数量来实现横向水平性能的扩展。接下来我们看看分布式系统中的一个基本定理——<code>CAP定理</code>。</p><a id="more"></a><h4 id="什么是-CAP-定理"><a href="#什么是-CAP-定理" class="headerlink" title="什么是 CAP 定理"></a>什么是 CAP 定理</h4><p><code>CAP 定理</code>指出对于一个分布式系统来说，不可能同时满足以下三点：</p><ul><li>一致性（Consistency）</li><li>可用性（Availability）</li><li>分区容错性（Partition tolerance）</li></ul><p>定理看起来很简单，但是<code>一致性</code>、<code>可用性</code>、<code>分区容错性</code>究竟是代表什么意思呢？理解定理的最简单的方式就是想象一个有两个节点分别处在不同的分区（PS：可以简单的把分区理解为不同的子网络）的分布式系统。</p><h4 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h4><p>我们假定一个很简单的分布式系统，系统由两个系统 <code>S1</code> 和 <code>S2</code> 组成。两个系统上面有两个相同的变量 <code>K</code>，该变量在两个系统对应的初始值为 <code>V0</code>。系统 <code>S1</code> 和 <code>S2</code> 可以进行通信同时也对外提供服务。我们假定的分布式系统如下所示：</p><p><img src="https://i.loli.net/2020/02/29/S7GyDcNF5zaxkhW.png" alt="cap-distributed-system.png"></p><p>客户端 <code>client</code> 可以向 <code>S1</code> 和 <code>S2</code> 任何一个系统发起读和写请求。当一个服务接收到发过来的请求后进行一些相关业务操作，然后返回给客户端 <code>client</code>，发起写请求的过程如下图所示：</p><p><img src="https://i.loli.net/2020/04/10/O8aCKB6FS9ncYoQ.png" alt="cap-client-send-write-request.png"></p><p>客户端发起读请求的过程如下所示：</p><p><img src="https://i.loli.net/2020/02/29/6Qa7LRwxWbsfpjA.png" alt="cap-client-send-read-request.png"></p><p>我们的分布式系统模型建立好了，接下来我们通过这个模型来分析<code>CAP 定理</code>中的一致性、可用性和分区容错性的具体含义。</p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p><code>一致性</code>要求在一个写操作完成之后的任何读操作都必须返回该值或者以后进行写操作的结果。在满足一致性的分布式系统中，客户端发起一个写请求到分布式系统的任何一个子系统中，然后再向该系统中任何一个子系统发起读请求查询该变量对应的值，都会返回上次更新的最新结果。客户端向一个<code>不满足一致性</code>的分布式系统发起写-读请求的过程如下所示：</p><p><img src="https://i.loli.net/2020/02/29/UWgRHxphk81sAuB.png" alt="cap-inconsistent-system.png"></p><p>当客户端向系统 <code>S1</code> 发送写请求(write V1)，得到成功返回响应后，再向系统 <code>S2</code> 发送读请求读取该变量的值，系统 <code>S2</code> 还是返回旧值 <code>V0</code>。另一方面，我们看看客户端向一个满足<code>一致性</code>的分布式系统发起写-读请求的过程：</p><p><img src="https://i.loli.net/2020/02/29/sdY5hNPoUHrpQMc.png" alt="cap-consistent-system.png"></p><p>在这个满足一致性的系统中，在上述过程中系统 <code>S1</code> 在返回客户端请求结果之前会先把最新值 <code>V1</code> 发送到系统 <code>S2</code>，然后才返回客户端的写请求结果。因此，当客户端再去请求系统 <code>S2</code> 的时候就会返回最新值 <code>V1</code>。</p><h4 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h4><p><code>可用性</code>要求在分布式系统中非故障节点收到的每一个请求都必须返回响应。在一个满足<code>可用性</code>的分布式系统中，如果客户端向系统中任意一个节点发送请求并且服务器没有崩溃的情况下，则该节点必须响应客户端，不管是哪个节点，只要收到请求，就必须告诉用户，到底是 <code>V0</code> 还是 <code>V1</code>，否则就不满足可用性，不允许服务器忽略客户端的请求。</p><h4 id="分区容错性（Partition-tolerance）"><a href="#分区容错性（Partition-tolerance）" class="headerlink" title="分区容错性（Partition tolerance）"></a>分区容错性（Partition tolerance）</h4><p>分区容错表明当消息从一个节点向另一个节点发送消息的过程中，消息可能会丢失。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在<code>一致性</code>和<code>可用性</code>之间做出选择。如果所有消息都无法发送的话，分布式系统的各个节点将无法同步消息。如下所示：</p><p><img src="https://i.loli.net/2020/02/29/QMkRvOA2aLWNPmr.png" alt="cap-partition-tolerance.png"></p><p>一般来说，分区容错无法避免，因此可以认为<code>CAP定理</code>的<code>分区容错性</code>总是成立。<code>CAP 定理</code>告诉我们，剩下的<code>一致性</code>和<code>可用性</code>无法同时做到。通常我们为了分区容错，我们的系统必须保证能够在任意网络分区下正常运行。</p><h4 id="为何不能同时满足一致性和可用性"><a href="#为何不能同时满足一致性和可用性" class="headerlink" title="为何不能同时满足一致性和可用性"></a>为何不能同时满足一致性和可用性</h4><p>我们现在知道了<code>一致性</code>、<code>可用性</code>、<code>分区容错性</code>所表示的具体含义，接下来看看为什么在一个分布式系统中不能同时满足<code>一致性</code>和<code>可用性</code>。我们假定存在一个同时满足这三个特性的系统。首先要做的就是对该系统进行分区，分区后系统如下所示：</p><p><img src="https://i.loli.net/2020/02/29/SU9NmiW7PqKwe25.png" alt="cap-partition.png"></p><p>下一步，客户端向分布式系统的节点 <code>S1</code> 发送一个写请求(write V1)，系统只要是可用的，该节点总是会返回响应。但是系统存在网络分区，因此节点 <code>S1</code> 无法将最新值 <code>V1</code> 通知节点 <code>S2</code> 去更新。如下所示：</p><p><img src="https://i.loli.net/2020/02/29/vDEw5VOk6fiHpzb.png" alt="cap-eight.png"></p><p>接下来，客户端向分布式系统的节点 <code>S2</code> 发送一个读请求（read K）查询变量 <code>K</code> 的值，同样的，系统只要是可用的，该节点总是会返回响应，但是系统存在网络分区，因此节点 <code>S2</code> 无法从节点 <code>S1</code> 获取到最新值 <code>V1</code> 进行更新。如下所示：</p><p><img src="https://i.loli.net/2020/02/29/RdfvYtVC16bMnZQ.png" alt="cap-nine.png"></p><p>客户端已经向节点 <code>S1</code> 发送写请求（write V1）成功后，再向节点 <code>S2</code> 发起读请求，得到的返回值是旧值 <code>V0</code>。这和我们假设的一致性冲突。如果要保证节点 <code>S1</code> 的一致性，那么节点 <code>S1</code> 必须在写操作时，锁定节点 <code>S2</code> 的读操作和写操作。只有当数据同步后，才能重新开放节点 <code>S2</code> 的读写操作。那么在锁定期间，<code>S2</code>不能读写，它就没有可用性了。再来看看，我们如果保证节点 <code>S2</code> 的可用性，那么就不能锁定节点 <code>S2</code> 的读写操作，所以一致性不成立。所以，节点 <code>S2</code> 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性，如果追求所有节点的可用性，那就没法做到一致性了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>CAP定理</code>指明了分布式系统的三大指标<code>一致性（Consistency）</code>、<code>可用性（Availability）</code>和<code>分区容错性（Partition tolerance）</code>不能同时满足，该定理是分布式系统的基本定理，也是理解分布式系统的起点。(PS: 像我们常用的注册中心 <code>Eureka</code>，因为节点之间的状态同步采用的异步方式，所以不能保证任意时刻各个节点间的状态一定是一致的，只能保证节点间最终状态是一致的。所以按照<code>CAP理论</code>，<code>Eureka</code> 的选择就是放弃了<code>一致性</code>，选择<code>可用性</code>和<code>分区容错性</code>。)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在互联网时代，我们的应用都是分布式系统，部署在 N 台机器上。说到分布式系统我们就不得不说分布式系统的祖先——集中式系统。它和分布式系统是两个完全相反的概念，集中式系统就是把所有的程序和功能都放到一台主机上，从而对外提供服务。集中式系统的优点就是容易理解、维护方便，它的的弊端也很明显，如果这个主机出故障了那么整个系统就崩溃了。著名投资家巴菲特有个关于投资的名言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要把鸡蛋放在一个篮子里&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于我们的系统而言也是如此，我们不可能保证主机永远不坏、也无法保证自己的程序永远不会出 &lt;code&gt;bug&lt;/code&gt;，所以问题是无法避免的，我们只能把“鸡蛋”分散到不同的“篮子”里，降低系统出故障的风险，这就是我们为什么需要分布式系统的原因之一。使用分布式系统的另一个理由就是扩展性，毕竟单台主机都会有性能的极限，分布式系统可以通过增加主机数量来实现横向水平性能的扩展。接下来我们看看分布式系统中的一个基本定理——&lt;code&gt;CAP定理&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式系统" scheme="https://www.mghio.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="CAP定理" scheme="https://www.mghio.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/CAP%E5%AE%9A%E7%90%86/"/>
    
    
      <category term="分布式系统" scheme="https://www.mghio.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="CAP定理" scheme="https://www.mghio.cn/tags/CAP%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 最新版（2019.3）激活教程</title>
    <link href="https://www.mghio.cn/post/f440d00b.html"/>
    <id>https://www.mghio.cn/post/f440d00b.html</id>
    <published>2020-01-12T00:28:07.000Z</published>
    <updated>2020-01-12T10:45:50.230Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>相信做 <code>Java</code> 开发的朋友们绝大部分人应该都是用 <a href="https://www.jetbrains.com/idea" target="_blank" rel="noopener">IntelliJ IDEA</a> 作为开发工具，没用过的朋友们建议将你的开发工具换成这个，关于它的优点可以去 <code>Google</code> 一下，我之前都是用 <a href="https://www.eclipse.org" target="_blank" rel="noopener">Eclipse</a> 作为开发工具，自从用过一次 <code>IDEA</code> 之后就再也回不去了。。。今天早上<del>更新</del>（作死）了一下 <code>IDEA</code> 到最新版（<code>2019.3.1</code>），安装完毕之后进入就提示说之前的激活码失效了，经过一顿搜索之后终于成功激活了，在此记录一下激活过程。</p><p><img src="https://i.loli.net/2020/01/12/mFe5thxWnykXUY6.png" alt="start_welcome.png"></p><a id="more"></a><h4 id="Step-1-升级-IDEA-到-2019-3-版本"><a href="#Step-1-升级-IDEA-到-2019-3-版本" class="headerlink" title="Step 1 升级 IDEA 到 2019.3 版本"></a>Step 1 升级 IDEA 到 2019.3 版本</h4><p>如果之前电脑安装过 <code>IDEA</code>，依次选择菜单项 <code>IntelliJ IDEA -&gt; About IntelliJ IDEA</code> 查看 <code>IDEA</code> 的版本（<code>PS: windows 系统菜单项可能不同</code>），如果不是 <code>2019.3</code> 版本，则要到 <a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">官网</a> 下载 <code>2019.3.1</code> 版本，具体安装过程比较简单，安装过程有问题的朋友们请自行 <code>Google</code>。</p><p><img src="https://i.loli.net/2020/01/12/15uoLas2jgX9DYl.png" alt="about_idea.png"></p><h4 id="Step-2-下载补丁包"><a href="#Step-2-下载补丁包" class="headerlink" title="Step 2 下载补丁包"></a>Step 2 下载补丁包</h4><p>扫码关注微信公众号 <code>mghio</code> 后回复「<code>idea</code>」获取激活补丁包。</p><p><img src="https://i.loli.net/2020/01/12/tXKpok8JAqQZ7ER.jpg" alt="wechat_subscriber.jpg"></p><h4 id="Step-3-编辑-IDEA-的-idea-vmoptions-文件"><a href="#Step-3-编辑-IDEA-的-idea-vmoptions-文件" class="headerlink" title="Step 3 编辑 IDEA 的 idea.vmoptions 文件"></a>Step 3 编辑 <code>IDEA</code> 的 <code>idea.vmoptions</code> 文件</h4><p>经过 <code>Step 1</code> 安装完成之后，打开 <code>IDEA</code> 开发工具，然后它会提示要激活，这里我们先选择 <code>试用 30 天</code>。</p><p><img src="https://i.loli.net/2020/01/12/VmzJvbaqtU8PdlM.png" alt="use_evaluate_free.png"></p><p>然后将 <code>Step 2</code> 我们下载好的激活补丁包 <code>jetbrains-agent.jar</code> 拷贝到 <code>IDEA</code> 安装目录的 <code>bin</code> 目录下。</p><p><img src="https://i.loli.net/2020/01/12/GIcljvdAbg38SpT.png" alt="copy_to_bin.png"></p><p>编辑 <code>IDEA</code> 的 <code>idea.vmoptions</code>（<code>PS:推荐直接从</code>IDEA<code>中编辑</code>），依次选择菜单项 <code>Help -&gt; Edit Custom VM Optons...</code>。</p><p><img src="https://i.loli.net/2020/01/12/jWlQZ9xrho7Uebq.png" alt="config_vm_options.png"></p><p>点击打开编辑，在其内容最后追加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:你的 IDEA 的安装目录/bin/jetbrains-agent.jar</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/12/Xj42VQ7MuTRKFNc.png" alt="edit_idea_vmoptions.png"></p><h4 id="Step-4-重启后输入激活码激活"><a href="#Step-4-重启后输入激活码激活" class="headerlink" title="Step 4 重启后输入激活码激活"></a>Step 4 重启后输入激活码激活</h4><p>退出 <code>IDEA</code> 重新启动进入，依次选择菜单项 <code>Help -&gt; Register...</code>。</p><p><img src="https://i.loli.net/2020/01/12/4itcGQqxwFSgTWJ.png" alt="idea_register_enter.png"></p><p>进入后选择 <code>Activation code</code> 以输入激活码方式激活，在第二步 <code>Step 2 下载补丁包</code> 中下载的 <code>txt</code> 文件（<code>文件名：激活码.txt</code>）为激活码，这里也贴一下，激活码如下（<code>PS: 鼠标移至激活码区域，点击右侧 「复制」 按钮即可复制</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/12/btQoAjC5xzFvgWU.png" alt="activate_success.png"></p><p>部分朋友输入以上激活码后点击激活可能会出现如下报错提示：<code>Your activation code could not be validated（error 1653219）</code>，未出现此错误提示的朋友可以跳过以下步骤。</p><p><img src="https://i.loli.net/2020/01/12/5sxrd3kGpRTCLw6.png" alt="activate_error.png"></p><p>出现此错误是因为没有屏蔽 <code>account.jetbrains.com</code> 的 <code>443</code> 端口，因此修改本地 <code>hosts</code> 文件在其内容追加以下内容即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0 https://account.jetbrains.com:443</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/12/zrfTvG6gC9HWAZS.png" alt="modify_mac_hosts_file.png"></p><p>修改保存 <code>hosts</code> 文件后，再次激活即可激活。</p><p><img src="https://i.loli.net/2020/01/12/Os3JUgZVYlAXLMG.png" alt="enter_licenses_success.png"></p><h4 id="Step-5-验证是否激活"><a href="#Step-5-验证是否激活" class="headerlink" title="Step 5 验证是否激活"></a>Step 5 验证是否激活</h4><p>重启 <code>IDEA</code> 后，依次选择菜单项 <code>IntelliJ IDEA -&gt; About IntelliJ IDEA</code>，可以看到激活到期日期为：<code>2089-07-08</code>。</p><p><img src="https://i.loli.net/2020/01/12/FW17nLZvjorsUIm.png" alt="activated_display.png"></p><p>至此， <code>IntelliJ IDEA</code> 激活完成。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上激活步骤只针对 <code>IntelliJ IDEA</code> 的 <code>2019.3.1</code> 版本，不同的版本可能无法激活，在激活前请确认好你所使用的 <code>IDEA</code> 版本。激活码和激活补丁包要一起使用，单独使用无效，在激活过程中有问题请在文末留言区留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;相信做 &lt;code&gt;Java&lt;/code&gt; 开发的朋友们绝大部分人应该都是用 &lt;a href=&quot;https://www.jetbrains.com/idea&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IntelliJ IDEA&lt;/a&gt; 作为开发工具，没用过的朋友们建议将你的开发工具换成这个，关于它的优点可以去 &lt;code&gt;Google&lt;/code&gt; 一下，我之前都是用 &lt;a href=&quot;https://www.eclipse.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Eclipse&lt;/a&gt; 作为开发工具，自从用过一次 &lt;code&gt;IDEA&lt;/code&gt; 之后就再也回不去了。。。今天早上&lt;del&gt;更新&lt;/del&gt;（作死）了一下 &lt;code&gt;IDEA&lt;/code&gt; 到最新版（&lt;code&gt;2019.3.1&lt;/code&gt;），安装完毕之后进入就提示说之前的激活码失效了，经过一顿搜索之后终于成功激活了，在此记录一下激活过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/mFe5thxWnykXUY6.png&quot; alt=&quot;start_welcome.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="IDEA" scheme="https://www.mghio.cn/categories/Java/IDEA/"/>
    
      <category term="工具" scheme="https://www.mghio.cn/categories/Java/IDEA/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="IDEA" scheme="https://www.mghio.cn/tags/IDEA/"/>
    
      <category term="工具" scheme="https://www.mghio.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射机制（二）</title>
    <link href="https://www.mghio.cn/post/7528c810.html"/>
    <id>https://www.mghio.cn/post/7528c810.html</id>
    <published>2020-01-04T08:51:05.000Z</published>
    <updated>2020-01-05T14:51:30.490Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上篇 <a href="http://www.mghio.cn/post/102cd3d9.html">Java 反射机制（一）</a> 介绍了一些 <code>Java</code> 反射相关的常用 API ，在知道了如何去使用反射之后，作为一个合格的工程师，下一步肯定是要去了解它的如何实现的，我们今天就来看看在 <code>JDK</code> 源码中是如何去实现反射的(<code>PS:以下源码分析基于 JDK1.8</code>)。</p><h4 id="Field-类-set-方法的实现"><a href="#Field-类-set-方法的实现" class="headerlink" title="Field 类 set 方法的实现"></a>Field 类 set 方法的实现</h4><p><code>Field</code> 类的 <code>set</code> 方法是在运行时用来动态修改一个类的属性的值，进入到 <code>Field</code> 类的 <code>set</code> 方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getFieldAccessor(obj).set(obj, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据 <code>override</code> 判断是否需要检查字段的访问权限，然后通过 <code>getFieldAccessor</code> 方法获得一个 <code>FieldAccessor</code> 字段访问者对象，最后调用的是 <code>FieldAccessor</code> 类的 <code>set</code> 方法进行下一步操作的，<code>FieldAccessor</code> 是一个接口，定义了对字段的一些操作，该接口有如下一些实现类：</p><a id="more"></a><p><img src="https://i.loli.net/2020/01/04/Dj24fGFKh8Qdzgb.png" alt="fieldaccessor_implements.png"></p><p>要看 <code>set</code> 到底调用的是哪个实现类的方法，那么我们需要看看 <code>getFieldAccessor()</code> 返回的是哪个类的对象，下面是 <code>getFieldAccessor</code> 方法的源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// security check is done before calling this method</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldAccessor <span class="title">getFieldAccessor</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ov = override;</span><br><span class="line">    FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;</span><br><span class="line">    <span class="keyword">return</span> (a != <span class="keyword">null</span>) ? a : acquireFieldAccessor(ov);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先通过 <code>override</code> 来获取不同的缓存的 <code>FieldAccessor</code>，其中 <code>overrideFieldAccessor</code> 代表本类覆盖父类的字段访问者对象缓存，<code>fieldAccessor</code> 是本类的字段访问器对象缓存。如果缓存存在的话就直接复用之前的对象，否则就调用 <code>Field</code> 类的 <code>acquireFieldAccessor</code> 方法获取。我们进入到 <code>acquireFieldAccessor</code> 方法中看看，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FieldAccessor <span class="title">acquireFieldAccessor</span><span class="params">(<span class="keyword">boolean</span> overrideFinalCheck)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    FieldAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getFieldAccessor(overrideFinalCheck);</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (overrideFinalCheck)</span><br><span class="line">            overrideFieldAccessor = tmp;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fieldAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newFieldAccessor(<span class="keyword">this</span>, overrideFinalCheck);</span><br><span class="line">        setFieldAccessor(tmp, overrideFinalCheck);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>acquireFieldAccessor</code> 的源码中我们可以看到，先判断是否已存在 <code>FieldAccessor</code> 对象，如果存在的话那么就会复用之前的 <code>FieldAccessor</code> 对象，否则就使用 <code>reflectionFactory</code> 工厂的 <code>newFieldAccessor</code> 方法生成一个新的 <code>FieldAccessor</code> 对象出来。所以我们就要进到 <code>newFieldAccessor</code> 方法里面看看是如何生成的，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field var1, <span class="keyword">boolean</span> var2)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    <span class="keyword">return</span> UnsafeFieldAccessorFactory.newFieldAccessor(var1, var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>newFieldAccessor</code> 方法代码可以得知，在方法里面是通过 <code>UnsafeFieldAccessorFactory</code> 类的 <code>static</code> 方法 <code>newFieldAccessor</code> 来生产 <code>FieldAccessor</code> 的，那么我们继续进入到 <code>UnsafeFieldAccessorFactory</code> 类的 <code>newFieldAccessor</code> 方法里面看看，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field var0, <span class="keyword">boolean</span> var1)</span> </span>&#123;</span><br><span class="line">    Class var2 = var0.getType();</span><br><span class="line">    <span class="keyword">boolean</span> var3 = Modifier.isStatic(var0.getModifiers());</span><br><span class="line">    <span class="keyword">boolean</span> var4 = Modifier.isFinal(var0.getModifiers());</span><br><span class="line">    <span class="keyword">boolean</span> var5 = Modifier.isVolatile(var0.getModifiers());</span><br><span class="line">    <span class="keyword">boolean</span> var6 = var4 || var5;</span><br><span class="line">    <span class="keyword">boolean</span> var7 = var4 &amp;&amp; (var3 || !var1);</span><br><span class="line">    <span class="keyword">if</span> (var3) &#123;</span><br><span class="line">      UnsafeFieldAccessorImpl.unsafe.ensureClassInitialized(var0.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (!var6) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var2 == Boolean.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticBooleanFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Byte.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticByteFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Short.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticShortFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Character.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticCharacterFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Integer.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticIntegerFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Long.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticLongFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Float.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticFloatFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (FieldAccessor)(var2 == Double.TYPE ? <span class="keyword">new</span> UnsafeStaticDoubleFieldAccessorImpl(var0) : <span class="keyword">new</span> UnsafeStaticObjectFieldAccessorImpl(var0));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 剩下的部分省略...</span></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上 <code>UnsafeFieldAccessorFactory</code> 类的 <code>newFieldAccessor</code> 方法代码可以看出，方法里面通过类的字段修饰符类型和字段的类类型共同决定返回的 <code>FieldAccessor</code> 实现类，这里要注意一下方法里面这几个变量的含义：</p><ul><li>var3（isStatic）：静态属性，也就是 <code>static</code> 关键字修饰的属性。</li><li>var4（isFinal）：<code>final</code> 关键字修饰的属性。</li><li>var5（isVolatile）：<code>valatile</code> 关键字修饰的属性。</li><li>var6（isQualified）：<code>valatile</code> 关键字或者 <code>final</code> 关键字修饰的属性。</li><li>var7 (isReadOnly)：是否只读属性，<code>final</code> 关键字修饰的属性或者 <code>static</code> 关键字修饰并且不能覆盖（<code>override = false</code>）的属性</li></ul><p>举一个例子，假设在一个类中的字段声明为 <code>public static String name</code>，那么返回的字段访问器为 <code>UnsafeStaticCharacterFieldAccessorImpl</code>，我们看看这个类的 <code>set</code> 方法是如何实现的，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object var1, Object var2)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFinal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.throwFinalFieldIllegalAccessException(var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.throwSetIllegalArgumentException(var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var2 <span class="keyword">instanceof</span> Character) &#123;</span><br><span class="line">      unsafe.putChar(<span class="keyword">this</span>.base, <span class="keyword">this</span>.fieldOffset, (Character)var2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.throwSetIllegalArgumentException(var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面方法的代码得知，方法最终还是通过 <code>Unsafe</code> 类的 <code>native</code> 方法 <code>putChar(Object var1, long var2, char var4)</code> 来实现的，有关 <code>Unsafe</code> 类的介绍请看这篇文章（<a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html" target="_blank" rel="noopener">Java魔法类：Unsafe应用解析</a>）。</p><h4 id="Method-类-invoke-方法的实现"><a href="#Method-类-invoke-方法的实现" class="headerlink" title="Method 类 invoke 方法的实现"></a>Method 类 invoke 方法的实现</h4><p><code>Method</code> 类的 <code>invoke</code> 方法用来在运行时动态调用对象的方法，我们进入到 <code>Method</code> 类的 <code>invoke</code> 方法中看看在 <code>JDK</code> 中到底是怎么做的，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上方法代码我们可以看到，和上文说的的 <code>Field</code> 类一样，首先也是先根据 <code>override</code> 进行了一些权限检查，最后调用的是 <code>MethodAccessor</code> 的 <code>invoke</code> 方法进行处理，这个方法访问器 <code>MethodAccessor</code> 是一个接口，它只有一个操作方法调用的 <code>invoke</code> 方法，它有如下三个实现类：</p><p><img src="https://i.loli.net/2020/01/05/qNho7AfvJU4nGQW.png" alt="methodaccessor_implements.png"></p><p>要想知道 <code>ma.invoke</code> 具体调用的是哪个类的方法，我们需要看看方法 <code>acquireMethodAccessor</code> 返回的对象是哪个，该方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    MethodAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getMethodAccessor();</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        methodAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</span><br><span class="line">        setMethodAccessor(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上方法 <code>acquireMethodAccessor</code> 的源码可以看出，首先会先先判断是否已经存在了对应的 <code>MethodAccessor</code> 对象，如果有就会复用这个对象，否则就调用工厂 <code>reflectionFactory</code> 的 <code>newMethodAccessor</code> 方法生成一个 <code>MethodAccessor</code> 对象出来。那么我们就需要进入到方法 <code>newMethodAccessor</code> 中，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method var1)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      NativeMethodAccessorImpl var2 = <span class="keyword">new</span> NativeMethodAccessorImpl(var1);</span><br><span class="line">      DelegatingMethodAccessorImpl var3 = <span class="keyword">new</span> DelegatingMethodAccessorImpl(var2);</span><br><span class="line">      var2.setParent(var3);</span><br><span class="line">      <span class="keyword">return</span> var3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法 <code>newMethodAccessor</code> 的代码可以看到，方法首先是使用 <code>Method</code> 对象作为入参生成了 <code>NativeMethodAccessorImpl</code> 对象，然后再使用 <code>NativeMethodAccessorImpl</code> 对象作为入参生成了 <code>DelegatingMethodAccessorImpl</code> 对象。这个使用了<code>代理模式</code>，将 <code>NativeMethodAccessorImpl</code> 交给了 <code>DelegatingMethodAccessorImpl</code> 类进行了代理，进入到代理类 <code>DelegatingMethodAccessorImpl</code> 中可以看到：</p><p><img src="https://i.loli.net/2020/01/05/iOXY41amPClUj7F.png" alt="delegatingmethodaccessorimpl.png"></p><p>从上面的红色方框可以看到，在类 <code>DelegatingMethodAccessorImpl</code> 的构造方法中将参数赋值给类中的 <code>delegate</code> 属性，所有上所说的 <code>ma.invoke</code> 最终会进入到 <code>DelegatingMethodAccessorImpl</code> 代理类的 <code>invoke</code>，方法里调用的是 <code>delegate</code> 属性的 <code>invoke</code> 方法，该属性声明的类型为抽象类 <code>MethodAccessorImpl</code>，它有如下两个实现类： </p><p><img src="https://i.loli.net/2020/01/05/HVpQ48Pmv9MIKG3.png" alt="methodaccessorimpl_implements.png"></p><p>按照上文所说的，这里的 <code>delegate</code> 属性是 <code>NativeMethodAccessorImpl</code> 对象，那么就进入到 <code>NativeMethodAccessorImpl</code> 的 <code>invoke</code> 方法中，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">      MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">      <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 <code>NativeMethodAccessorImpl</code> 的 <code>invoke</code> 方法会先判断此次调用是否超过 <code>ReflectionFactory.inflationThreshold()</code> 方法返回的阈值（<code>PS：默认的阈值大小为 15</code>），如果超过了该阈值，则使用方法访问生成器重新生成一个 <code>MethodAccessorImpl</code>，并将 <code>DelegatingMethodAccessorImpl</code> 的 <code>delegate</code> 属性指向这个新生成的 <code>MethodAccessorImpl</code> 对象。从 <code>Reflectionfactory</code> 工厂类的一下注释：</p><p><img src="https://i.loli.net/2020/01/05/gxE8bmp9s5Ydt1P.png" alt="reflectionfactory_doc.png"></p><p>可以得知 <code>JVM</code> 初次加载字节码实现反射的时候，使用 <code>Method.invoke</code> 和 <code>Constructor.newInstance</code> 方式加载所花费的时间是使用原生代码加载所花费的时间的 3 - 4 倍。这也就是我们平常说为什么频繁使用反射的应用需要花费更多的时间。<code>JVM</code> 作者们为了避免这种花费较长的加载时间，我们在第一次加载的时候重用了 <code>JVM</code> 的入口，之后切换到字节码实现的实现。<br>正如注释所述，在 <code>MethodAccessor</code> 接口的实现中，有两个不同的版本，一个 <code>Java</code> 实现的，一个是 <code>Native</code> 实现的。<code>Java</code> 版本实现的版本在初始化的时需要比较多的时间，但长久来说性能会更好一些；而 <code>Native</code> 版本则正好相反，在初始化时相对较快，但是在运行一段时间之后性能就不如 <code>Java</code> 版本的了。为了权衡两种版本的特性，<code>sun</code> 公司的 <code>JDK</code> 使用了 <code>inflation</code> 机制，让 <code>Java</code> 方法在被反射调用时，开头的几次调用使用 <code>native</code> 版，等反射调用次数超过阈值时则生成一个专用的 <code>MethodAccessor</code> 实现类，生成其中的 <code>invoke</code> 方法的字节码，以后对该 <code>Java</code> 方法的反射调用就会使用 <code>Java</code> 版。 </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍反射调用 <code>set(Object obj, Object value)</code> 方法和 <code>invoke(Object obj, Object... args)</code> 方法的底层实现，由于水平有限本人暂时还没有能力分析 <code>JVM</code> 的实现，这里只分析到最终 <code>native</code> 方法的调用。底层会依赖到 <code>Unsafe</code> 类来执行一些低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 <code>Java</code> 运行效率、增强 <code>Java</code> 语言底层资源操作能力方面起到了很大的作用。对于属性反射的方法 <code>setXXX</code> 和 <code>getXXX</code> 的实现分别对应 <code>Unsafe</code> 类的 <code>putXXX</code> 和 <code>getXXX</code> 方法，也就是说完全依赖 <code>Unsafe</code> 类中的 <code>native</code> 方法来实现的；对于方法反射的方法 <code>invoke</code> 底层调用的是 <code>NativeMethodAccessorImpl</code> 类的 <code>invoke0</code> 的 <code>native</code> 方法来实现的。对于反射构造器调用的实现，读者可以自己进入其源码进行分析，大体上和反射方法调用的实现类似。</p><hr><p>参考文章</p><ul><li><a href="https://www.cnblogs.com/onlywujun/p/3519037.html" target="_blank" rel="noopener">JAVA深入研究——Method的Invoke方法。</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在上篇 &lt;a href=&quot;http://www.mghio.cn/post/102cd3d9.html&quot;&gt;Java 反射机制（一）&lt;/a&gt; 介绍了一些 &lt;code&gt;Java&lt;/code&gt; 反射相关的常用 API ，在知道了如何去使用反射之后，作为一个合格的工程师，下一步肯定是要去了解它的如何实现的，我们今天就来看看在 &lt;code&gt;JDK&lt;/code&gt; 源码中是如何去实现反射的(&lt;code&gt;PS:以下源码分析基于 JDK1.8&lt;/code&gt;)。&lt;/p&gt;
&lt;h4 id=&quot;Field-类-set-方法的实现&quot;&gt;&lt;a href=&quot;#Field-类-set-方法的实现&quot; class=&quot;headerlink&quot; title=&quot;Field 类 set 方法的实现&quot;&gt;&lt;/a&gt;Field 类 set 方法的实现&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Field&lt;/code&gt; 类的 &lt;code&gt;set&lt;/code&gt; 方法是在运行时用来动态修改一个类的属性的值，进入到 &lt;code&gt;Field&lt;/code&gt; 类的 &lt;code&gt;set&lt;/code&gt; 方法的源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj, Object value)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IllegalArgumentException, IllegalAccessException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!override) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            checkAccess(caller, clazz, obj, modifiers);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getFieldAccessor(obj).set(obj, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;首先根据 &lt;code&gt;override&lt;/code&gt; 判断是否需要检查字段的访问权限，然后通过 &lt;code&gt;getFieldAccessor&lt;/code&gt; 方法获得一个 &lt;code&gt;FieldAccessor&lt;/code&gt; 字段访问者对象，最后调用的是 &lt;code&gt;FieldAccessor&lt;/code&gt; 类的 &lt;code&gt;set&lt;/code&gt; 方法进行下一步操作的，&lt;code&gt;FieldAccessor&lt;/code&gt; 是一个接口，定义了对字段的一些操作，该接口有如下一些实现类：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="反射" scheme="https://www.mghio.cn/categories/Java/%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="反射" scheme="https://www.mghio.cn/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
</feed>
