<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mghio&#39;s blog</title>
  
  <subtitle>JAVA 搬运工 &amp; 终身学习者。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mghio.cn/"/>
  <updated>2019-11-03T23:40:43.101Z</updated>
  <id>https://www.mghio.cn/</id>
  
  <author>
    <name>mghio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步工具类</title>
    <link href="https://www.mghio.cn/post/ee27c07f.html"/>
    <id>https://www.mghio.cn/post/ee27c07f.html</id>
    <published>2019-11-03T12:35:02.000Z</published>
    <updated>2019-11-03T23:40:43.101Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h4><p>同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。在容器中，有些也可以作为同步工具类，其它类型的同步工具类还包括闭锁（Latch）、信号量（Semaphore）以及栅栏（Barrier）。阻塞队列（eg: BlockQueue）是一种独特的类：它们不仅能作为保存对象的容器，还能协调生产者和消费者之间的控制流，因为它提供的 <code>take</code> 和 <code>put</code> 等方法将会阻塞，直到队列达到期望的状态。所有的同步工具类都包含一些特定的属性：它们封装了一些状态，这些状态将决定同步工具类的线程是继续执行还是等待，此外还提供了一些方法对其状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。</p><h4 id="1-2-闭锁"><a href="#1-2-闭锁" class="headerlink" title="1.2 闭锁"></a>1.2 闭锁</h4><p>闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有线程通过。当闭锁到达结束状态后，将不会再次改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其它活动都完成后才继续执行。比如：</p><ul><li>确保某个计算机在其需要的所有资源初始化后才能继续执行。</li><li>确保某个服务在其依赖的所有服务都已经启动后才启动。</li><li>等待直到某个操作的所有参与者都就绪后再继续执行。<a id="more"></a></li></ul><h5 id="1-2-1-CountDownLatch"><a href="#1-2-1-CountDownLatch" class="headerlink" title="1.2.1 CountDownLatch"></a>1.2.1 CountDownLatch</h5><p><code>CountDownLatch</code> 是一种灵活的闭锁实现，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待事件的数量。<code>countDown()</code> 方法递减计数器，表示有一个事件已经发生了，而 <code>await()</code> 方法等待计数器达到 0 ，这表示所有需要等待的事件都已经发生。如果计数器的值非 0 ，那么 <code>await()</code> 方法会一直阻塞到计数器的值为 0 ，或者等待线程中断，或者等待超时。<br><code>CountDownLatch</code> 被用来同步一个或多个任务，强制它们等待由其它任务执行的一组操作完成。你可以向 <code>CountDownLatch</code> 对象设置一个初始计数值，任何在这个对象上调用 <code>await()</code> 的方法都将阻塞，直到这个计数值到达 0。其它任务在结束工作时，可以在该对象上调用 <code>countDown()</code> 方法来减小这个计数值。<code>CountDownLatch</code> 被设计为只触发一次，计数值不能重置。如果你需要重置计数值的版本，请看下文的 <code>CyclicBarrier</code>。把大象放入冰箱的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-11-03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步工具类 —— CountDownLatch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"step 1：打开冰箱门..."</span>);</span><br><span class="line">      <span class="comment">// 对 countDownLatch1 倒计时 -1</span></span><br><span class="line">      countDownLatch1.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待 countDownLatch1 倒计时，计时为 0 则往下运行</span></span><br><span class="line">        countDownLatch1.await();</span><br><span class="line">        System.out.println(<span class="string">"step 2：把大象放入冰箱..."</span>);</span><br><span class="line">        <span class="comment">// 对 countDownLatch2 倒计时 -1</span></span><br><span class="line">        countDownLatch2.countDown();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对 countDownLatch2 倒计时，计时为 0 则往下进行</span></span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        System.out.println(<span class="string">"step 3：关上冰箱门..."</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"------- 把大象放入冰箱 --------"</span>);</span><br><span class="line">    thread3.start();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------- 把大象放入冰箱 --------</span><br><span class="line">step <span class="number">1</span>：打开冰箱门...</span><br><span class="line">step <span class="number">2</span>：把大象放入冰箱...</span><br><span class="line">step <span class="number">3</span>：关上冰箱门...</span><br></pre></td></tr></table></figure><h5 id="1-2-2-FutureTask"><a href="#1-2-2-FutureTask" class="headerlink" title="1.2.2 FutureTask"></a>1.2.2 FutureTask</h5><p><code>FutureTask</code> 也可以用作闭锁。它实现了 <code>Future</code> 的语义，表示一种抽象可生成结果的计算。 <code>FutureTask</code> 表示的计算是通过 <code>Callable</code> 来实现的，相当于一种可生成结果的 <code>Runnable</code> ，并且可以处于这三种状态：<code>等待运行（Waiting to run）</code>、<code>正在运行（Running）</code>和<code>运行完成（Completed）</code>。其中<code>执行完成</code>表示计算的所有可能结束方式，包括正常结束、由于取消结束和由于异常结束等。当 <code>FutureTask</code> 进入完成状态后，它就会永远停在这个状态上。<code>get()</code> 方法的行为取决于任务的状态。如果此时任务已经完成，那么 <code>get()</code> 方法会立即返回结果，否则将会阻塞直到任务进入到完成状态，然后返回结果或者抛出异常。<code>FutureTask</code> 将计算结果从执行计算的线程传递到获取这个结果的线程，而 <code>FutureTask</code> 的规范确保了这种传递过程能实现结果的安全发布。<br><code>FutureTask</code> 在 <code>Executor</code> 框架中表示异步任务，除此之外还可以用来表示一些耗时比较长的计算，这些计算可以在使用计算结果之前启动。以下示例使用其执行一个异步任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-11-03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步工具类 —— FutureTask</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"--------- 进入主线程执行任务"</span>);</span><br><span class="line">    ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">    System.out.println(<span class="string">"--------- 提交异步任务"</span>);</span><br><span class="line">    FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; <span class="string">"成功获取 future 异步任务结果"</span>);</span><br><span class="line">    threadPool.execute(future);</span><br><span class="line">    System.out.println(<span class="string">"--------- 提交异步任务之后，立马返回到主线程继续往下执行"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">"--------- 此时需要获取上面异步任务的执行结果"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">      <span class="keyword">if</span> (future.isDone() &amp;&amp; !future.isCancelled()) &#123;</span><br><span class="line">        String futureResult = future.get();</span><br><span class="line">        System.out.println(<span class="string">"--------- 异步任务返回的结果是："</span> + futureResult);</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!threadPool.isShutdown()) &#123;</span><br><span class="line">      threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------- 进入主线程执行任务</span><br><span class="line">--------- 提交异步任务</span><br><span class="line">--------- 提交异步任务之后，立马返回到主线程继续往下执行</span><br><span class="line">--------- 此时需要获取上面异步任务的执行结果</span><br><span class="line">--------- 异步任务返回的结果是：成功获取 future 异步任务结果</span><br></pre></td></tr></table></figure><h4 id="1-4-信号量"><a href="#1-4-信号量" class="headerlink" title="1.4 信号量"></a>1.4 信号量</h4><p>计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行指定操作的数量。计数信号量还可以用来实现某种资源池或者对容器施加边界。<code>Semaphore</code> 中管理着一组虚拟的许可（<code>permit</code>），许可的初始数量可以通过构造函数来指定，在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，那么 <code>acquire()</code> 将阻塞直到有许可或者直到终端或者直到超时。<code>release()</code> 方法将返回一个许可给信号量。<code>Semaphore</code> 可以用于实现资源池，例如数据库连接池。我们可以构造一个固定长度的资源池，当池为空时，请求资源将会失败，但你真正希望看到的行为是阻塞而不是失败，并且当池非空时解除阻塞。如果将 <code>Semaphore</code> 的计数值初始化为池的大小，并在从池中获取一个资源之前首先调用 <code>acquire()</code> 方法获取一个许可，在将资源返回给池之后调用 <code>release()</code> 方法释放许可，那么 <code>acquire()</code> 方法将一直阻塞直到资源池不为空。以下示例将使用 <code>Semaphore</code> 将 <code>HashSet</code> 容器变成有界的阻塞容器，信号量的计数值会初始化为容器容量的最大值。<code>add</code> 操作在向底层容器添加一个元素之前，首先要获取一个许可。如果 <code>add</code> 操作没有添加任何元素，那么会立刻释放许可。同样 <code>remove</code> 操作会释放一个许可，使更多的元素能够添加到容器中。底层的 <code>Set</code> 实现并不知道关于边界的任何信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> maguihai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-11-03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步工具类 —— Semaphore</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    <span class="keyword">this</span>.sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sem.acquire();</span><br><span class="line">    <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      wasAdded = set.add(o);</span><br><span class="line">      <span class="keyword">return</span> wasAdded;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!wasAdded) &#123;</span><br><span class="line">        sem.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> wasRemoved = set.remove(o);</span><br><span class="line">    <span class="keyword">if</span> (wasRemoved) &#123;</span><br><span class="line">      sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wasRemoved;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-栅栏"><a href="#1-5-栅栏" class="headerlink" title="1.5 栅栏"></a>1.5 栅栏</h4><p>我们已经看到通过<code>闭锁</code>来启动一组相关的操作，或者等待一组相关的操作结束。闭锁是一次性对象，一旦进入终止状态，就不能被重置。栅栏（Barrier）类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于：所有线程都必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其它线程。栅栏用于实现一些协议，例如几个家庭决定在某个地方集合：“所有人 6:00 在 KFC 碰头，到了以后要等其它人，之后再讨论下一步要做的事情”。<code>CyclicBarrier</code> 适用于这样的情况：你希望创建一组任务，他们并行执行工作，然后再运行下一个步骤之前等待，知道所有任务都完成（有点儿像线程的 <code>join</code> 方法）。它使得所有的并行任务都将处于栅栏处列队，因此可以一致的向前移动。这和上文的 <code>CountDownLatch</code> 非常像，只是 <code>CountDownLatch</code> 只是触发一次的事件，而 <code>CyclicBarrier</code> 可以重复使用。<br><code>CyclicBarrier</code> 可以使一定数量的参与方反复地在栅栏位置汇聚，它在并行迭代算法中非常有用：这种算法通常将一个问题拆分成一系列相互独立的子问题。当线程达到栅栏位置时将调用 <code>await()</code> 方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有栅栏都到达栅栏了位置，那么栅栏将打开，此时所有的线程都被释放，而栅栏将被重置以便下次使用。如果对 <code>await()</code> 方法调用超时，或者线程被中断，那么栅栏就认为是被打破了，所有阻塞 <code>await()</code> 的调用都将终止并抛出 <code>BrokenBarrierException</code>。如果成功通过栅栏，那么 <code>await()</code> 将为每一个线程返回一个唯一的到达索引号，我们可以利用这些索引来“选举”产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。<code>CyclicBarrier</code> 还可以使你将一个栅栏操作传递给构造函数，这个一个 <code>Runnable</code> ，当成功通过栅栏时会（在一个子任务线程中）执行它，但是它在阻塞线程被释放前是不能执行的。使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-11-03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步工具类 —— CyclicBarrier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrieDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// 创建 CyclicBarrier 对象并设置 3 个公共屏障点</span></span><br><span class="line">    <span class="keyword">final</span> CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">          System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() + <span class="string">" 即将到达集合地点1，当前已有 "</span> + cb.getNumberWaiting() + <span class="string">" 个已经到达，正在等候"</span>);</span><br><span class="line">          <span class="comment">// 到此如果没有达到公共屏障点，则该线程处于等待状态，如果达到公共屏障点则所有处于等待的线程都继续往下运行</span></span><br><span class="line">          cb.await();</span><br><span class="line">          Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">          System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() + <span class="string">" 即将到达集合地点2，当前已有 "</span> + cb.getNumberWaiting() + <span class="string">" 个已经到达，正在等候"</span>);</span><br><span class="line">          cb.await();</span><br><span class="line">          Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">          System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() + <span class="string">" 即将到达集合地点3，当前已有 "</span> + cb.getNumberWaiting() + <span class="string">" 个已经到达，正在等候"</span>);</span><br><span class="line">          cb.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      service.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">    service.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">3</span> 即将到达集合地点<span class="number">1</span>，当前已有 <span class="number">0</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 即将到达集合地点<span class="number">1</span>，当前已有 <span class="number">1</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 即将到达集合地点<span class="number">1</span>，当前已有 <span class="number">2</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">3</span> 即将到达集合地点<span class="number">2</span>，当前已有 <span class="number">0</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 即将到达集合地点<span class="number">2</span>，当前已有 <span class="number">1</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 即将到达集合地点<span class="number">2</span>，当前已有 <span class="number">2</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">3</span> 即将到达集合地点<span class="number">3</span>，当前已有 <span class="number">0</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 即将到达集合地点<span class="number">3</span>，当前已有 <span class="number">1</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 即将到达集合地点<span class="number">3</span>，当前已有 <span class="number">2</span> 个已经到达，正在等候</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h4&gt;&lt;p&gt;同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。在容器中，有些也可以作为同步工具类，其它类型的同步工具类还包括闭锁（Latch）、信号量（Semaphore）以及栅栏（Barrier）。阻塞队列（eg: BlockQueue）是一种独特的类：它们不仅能作为保存对象的容器，还能协调生产者和消费者之间的控制流，因为它提供的 &lt;code&gt;take&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt; 等方法将会阻塞，直到队列达到期望的状态。所有的同步工具类都包含一些特定的属性：它们封装了一些状态，这些状态将决定同步工具类的线程是继续执行还是等待，此外还提供了一些方法对其状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。&lt;/p&gt;
&lt;h4 id=&quot;1-2-闭锁&quot;&gt;&lt;a href=&quot;#1-2-闭锁&quot; class=&quot;headerlink&quot; title=&quot;1.2 闭锁&quot;&gt;&lt;/a&gt;1.2 闭锁&lt;/h4&gt;&lt;p&gt;闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有线程通过。当闭锁到达结束状态后，将不会再次改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其它活动都完成后才继续执行。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保某个计算机在其需要的所有资源初始化后才能继续执行。&lt;/li&gt;
&lt;li&gt;确保某个服务在其依赖的所有服务都已经启动后才启动。&lt;/li&gt;
&lt;li&gt;等待直到某个操作的所有参与者都就绪后再继续执行。
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java, 并发" scheme="https://www.mghio.cn/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 运行时数据区域</title>
    <link href="https://www.mghio.cn/post/8a061473.html"/>
    <id>https://www.mghio.cn/post/8a061473.html</id>
    <published>2019-10-26T14:10:10.000Z</published>
    <updated>2019-10-27T14:06:36.833Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-为什么要进行内存区域划分"><a href="#1-1-为什么要进行内存区域划分" class="headerlink" title="1.1 为什么要进行内存区域划分"></a>1.1 为什么要进行内存区域划分</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="noopener">JVM规范</a> 规定，JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间，有的区域随着虚拟机进程的启动就存在了，而有些区域则依赖用户线程的启动和结束而建立和销毁。JVM 规范对 JVM 定义了运行时统一的内存划分规范，统一了标准，类似于 JDBC 规范一样。JVM 也有许多厂商的不同产品。比如下面的这些：</p><table><thead><tr><th align="center">厂商</th><th align="left">JVM</th></tr></thead><tbody><tr><td align="center">Oracle-SUN</td><td align="left">Hotspot</td></tr><tr><td align="center">Oracle</td><td align="left">JRocket</td></tr><tr><td align="center">IBM</td><td align="left">J9 JVM</td></tr><tr><td align="center">阿里</td><td align="left">Taobao JVM</td></tr></tbody></table><p>其内存区域划分规范对于 JVM 的含义类似于我们 Java 中的接口，都是起到了规范的作用，JVM 是一台可以运行 Java 应用程序的抽象的计算机。在 JVM 中存在三个重要的概念：</p><ul><li>JVM 规范：它定义了虚拟机运行的规范，但是由 Oracle（SUN）或者其它厂商实现</li><li>Java 运行时环境(JRE：Java Runtime Environment)：它是 JVM 规范的具体实现</li><li>JVM 实例：编写好 Java 代码之后，运行 Java 程序，此时就会创建 JMV 实例</li></ul><p>对于 Java 程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个对象去编写内存释放的代码，不要像 C 或者 C++ 要时刻注意着内存泄漏和内存溢出的问题，这种由虚拟机去管理一切看起来都很美好。不过，也正是因为 Java 设计者把内存控制全部交给了 JVM，一旦出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎么分配运行时内存的，那么排查错误将是一项非常艰难的工作。</p><a id="more"></a><h4 id="1-2-运行时数据区域的组成"><a href="#1-2-运行时数据区域的组成" class="headerlink" title="1.2 运行时数据区域的组成"></a>1.2 运行时数据区域的组成</h4><p>为什么我们经常把运行时数据区叫做 Java 内存模型（JMM：Java Memory Model），是因为运行时数据区太过于分散，没有联系，所以才会有 JVM 内存模型这个词，让我们把这些东西联系起来，方便记忆。JVM 运行时数据区中有些数据是一直存在的，被所有线程所共享。而有些区域则是线程私有的，伴随着线程的开始而创建，线程的结束而销毁。所以我们可以把JMM 分为两类：<code>线程共享的</code>、<code>线程私有的</code>。根据 JVM 虚拟机规范的规定，JVM 虚拟机运行时数据区划分如下图所示：</p><p><img src="https://i.loli.net/2019/10/27/2TGhQutDpMkinlo.png" alt="jmm-structure.png"> 运行时数据区主要分为以下几个部分：</p><ul><li>方法区</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>程序计数器</li></ul><p>其中，按照线程在各个区域的数据是否共享划分为：</p><ul><li>线程共享部分：方法区、Java 堆以及运行时常量池（归属于方法区）</li><li>线程私有部分：虚拟机栈、本地方法栈、程序计数器</li></ul><p>接下来看看 Java 运行时数据区中各个部分的用途和特点：</p><blockquote><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4></blockquote><h5 id="1-1-什么是方法区"><a href="#1-1-什么是方法区" class="headerlink" title="1.1 什么是方法区"></a>1.1 什么是方法区</h5><p>在 JVM 中，方法区是可供各个线程共享运行时的内存区域。方法区域传统语言中的编译代码存储区或者操作系统进程的正文段的作用非常类似，它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、类的构造函数和普通方法的字节码内容、还包括一些类、实例、接口初始化的时候用到的特殊方法。在 Hotspot 虚拟机中，JDK 1.7 版本称作<code>永久代（Permanent Generation）</code>，而在 JDK 1.8 则称为 <code>元空间（Metapace）</code>。<br>方法区有个别名叫做非堆（Non-Heap），用于区别于 Java 堆区。默认最小值为 16 MB，最大值为 64 MB，可通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 参数设置方法的大小。<br>JDK 1.7 及之前的版本设置为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=<span class="number">10</span>m</span><br><span class="line">-XX:MaxPermSize=<span class="number">55</span>m</span><br></pre></td></tr></table></figure><p>JDK 1.8 及之后的版本设置为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=<span class="number">10</span>m</span><br><span class="line">-XX:MaxMetaspaceSize=<span class="number">55</span>m</span><br></pre></td></tr></table></figure><h5 id="1-2-方法区的特点"><a href="#1-2-方法区的特点" class="headerlink" title="1.2 方法区的特点"></a>1.2 方法区的特点</h5><ul><li>线程共享：方法区是堆的一个逻辑部分，因此和对一样是线程共享的。整个虚拟机中只有一个方法区。</li><li>永久代：方法区中的信息一般要长期存在，而且它又是堆的逻辑部分，因此用堆的划分方法，我们把方法区称作永久代（方法区是规范，永久代是实现）。</li><li>内存回收低：方法区中的信息一般需要长期存在，回收一遍内存之后可能之后少量信息无效。对方法区的内存回收主要是 <code>对常量池的回收和对类型的卸载</code>。</li><li>JVM 规范对方法区的定义比较宽松：和堆一样，允许固定大小，也允许可扩展大小，还允许不实现垃圾回收。</li></ul><p>方法区是所有都线程共享的，在一定的条件下它也会被 GC，当方法区域需要使用的内存超过其允许的大小时，会抛出 OOM（OutOfMemory）错误信息。</p><h5 id="1-3-运行时常量池"><a href="#1-3-运行时常量池" class="headerlink" title="1.3 运行时常量池"></a>1.3 运行时常量池</h5><p>类加载后，Class 文件结构中常量池中的数据将被存储在运行时常量池中。我们一般在一个类中通过 <code>public static final</code> 来声明一个常量或者声明一个字符串 <code>String str = &quot;abc&quot;</code>。这个类编译后产生的 Class 文件，这个类的所有信息都存储在这个 class 文件中，当这个类被 JVM 加载之后，class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池添加新的常量。比如，String 类的 intern() 方法就能在运行期间向常量池中添加新的常量。当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用时，那么就需要垃圾收集器回收。JVM 为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。其包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用。即字面量和符号引用，其中字面量指的是整个类中的字面量。包含成员变量、静态方法、非静态方法等中的字面量。池中的数据和数组一样通过索引访问。</p><blockquote><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4></blockquote><h5 id="1-1-什么是虚拟机栈"><a href="#1-1-什么是虚拟机栈" class="headerlink" title="1.1 什么是虚拟机栈"></a>1.1 什么是虚拟机栈</h5><p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。Java 虚拟机栈会为每一个即将运行的方法创建一块叫做 <code>栈帧</code> 的区域，这块区域用于存储用于方法在运行时所需要的一些信息，这些信息具体包括：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口信息</li><li>其它信息</li></ul><p>当一个方法即将被运行时，Java 虚拟机栈首先会在 Java 虚拟机栈中为该方法创建一块”栈帧”，栈帧中包含局部变量表，操作数栈，动态链接，方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。<code>Java 虚拟机栈上数据都是私有的</code>，其他线程都不能访问该线程的栈数据。在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。当在一段代码块中定义一个变量时，Java 就会在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java 会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p><h5 id="1-2-Java-虚拟机栈的特点"><a href="#1-2-Java-虚拟机栈的特点" class="headerlink" title="1.2 Java 虚拟机栈的特点"></a>1.2 Java 虚拟机栈的特点</h5><ul><li>局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。局部变量表的大小在程序的编译期间就确定下来了，在创建的时候需要事先指定好大小，在方法运行的过程中局部变量表的大小是不会发生改变的。</li><li>Java虚拟机栈会出现两种错误（StackOverFlowError 和 OutOfMemoryError），<code>StackOverFlowError</code>：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候就会抛出 StackOverFlowError。<code>OutOfMemoryError</code>：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展了，此时就会抛出 StackOverFlowError。</li><li>虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</li><li>栈中的数据在线程内部是共享的，要注意这种数据的共享与两个对象引用同 时指向一个对象的这种共享是不同的。它是由编译器完成的，它有利于节省空间。</li></ul><blockquote><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4></blockquote><p>本地方法指的是使用 Java 以外的其他语言编写的代码，因为有些时候 Java 无法直接操作一些底层资源，只能通过 C 或汇编操作。因此需要通过本地方法来实现。而本地方法栈就是设计用来调用这些非 Java 语言方法的。会存放对应的局部变量信息、返回结果等。本地方法栈和 Java 虚拟机栈实现的功能类似，只不过本地方法栈是本地方法运行的内存模型。区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则是为虚拟机用到的 Native 方法服务，本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接以及出口信息等。方法执行完毕后相应的栈帧也会出栈并释放内存空间。也会抛出两种错误，StackOverFlowError 和 OutOfMemoryError。</p><blockquote><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4></blockquote><h5 id="1-1-什么是堆"><a href="#1-1-什么是堆" class="headerlink" title="1.1 什么是堆"></a>1.1 什么是堆</h5><p>堆是用来存放对象（类、接口、数组）的内存空间。几乎所有的对象都存储在堆中（实例创建后，成员变量也随对象存在堆中，随着垃圾回收进行释放）。堆是一个运行时数据区，在程序运行时动态分配内存。<br>在堆中产生了一个数组对对象后，还可以在栈中定义一个特殊的变量，让栈用这个变量的取值等于数组或对象在堆地址内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组和对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中数组或对象。<br>引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域外后释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码之外，数组和对象本身占据的内存空间不会被释放，数组和对象在没有引用指向它的时候才会变为垃圾，不能再被使用。仍然占据内存空间不放，在随后的一个不确定的时期被 GC 垃圾回收收走。这也是 Java 比较占用内存的原因之一，实际上，栈中的变量指向堆内存的变量，这就是 Java 中的指针。</p><h5 id="1-2-堆的特点"><a href="#1-2-堆的特点" class="headerlink" title="1.2 堆的特点"></a>1.2 堆的特点</h5><ul><li>线程共享：整个 JVM 只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li><li>在虚拟机启动的时候创建。</li><li>垃圾回收的主要场所。</li><li>堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的。</li><li>堆可以分为：新生代和老年代<br>新生代：新生代程序新创建的对象都在新生代分配的，新生代由 <code>Eden Space</code> 和两块大小相同的 <code>Survivor Space</code>（通常又称 S0 和 S1或 FROM 和 To ）构成，可通过 -Xmn 参数来指定新生代的大小，也可以通过 -XX:SurvivorRation 来调整 Eden Space 及 Survivor Space 的大小，因此新生代又可被分为：Eden，From Survivor，To Survivor。<br>老年代：老年代用户存放经过多次新生代垃圾回收仍然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代。主要有两种情况：一种是 <code>大对象</code>，可通过启动参数设置 -XX:PretenureSizeThreshold=1024（单位为字节，默认为 0）来代表超过多大时就不再在新生代分配，而是直接在老年代分配。另一种是 <code>大的数组对象</code>，且数组中无引用外部对象。老年代所占的内存大小为 -Xmx 对应的值减去 -Xmn（新生代）对应的值。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更加高效。</li><li>JDK 1.8 及之后版本堆的内存空间分配<br>老年代：三分之二的堆空间<br>年轻代：三分之一的堆空间<ul><li>eden 区： 十分之八的年轻代空间</li><li>survivor 0：十分之一的年轻代空间</li><li>survivor 1：十分之一的年轻代空间</li></ul></li></ul><blockquote><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4></blockquote><h5 id="1-1-什么是程序计数器"><a href="#1-1-什么是程序计数器" class="headerlink" title="1.1 什么是程序计数器"></a>1.1 什么是程序计数器</h5><p>程序计数器是一块比较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。当然，<code>程序计数器是线程私有的</code>。但是，如果当前线程执行的是一个线程本地的方法，那么此时这个线程的程序计数器为空。</p><blockquote><p>本地方法为 Native Method，即由 native 修饰的方法。在定义一个 native 方法时，并不提供实现（类似 Java 中的接口或者抽象方法），因为其实现往往是由外面的 C 或者 C++ 等非 Java 语言实现的。</p></blockquote><h5 id="1-2-程序计数器的作用"><a href="#1-2-程序计数器的作用" class="headerlink" title="1.2 程序计数器的作用"></a>1.2 程序计数器的作用</h5><p>程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如顺序执行、选择、循环、异常处理等。</li><li>在多线程的条件下，程序计数器用来记录当前线程执行的位置，从而当线程被切换回来的时候能够知道这个线程上次运行到哪个地方了。</li></ul><h5 id="1-3-程序计数器的特点"><a href="#1-3-程序计数器的特点" class="headerlink" title="1.3 程序计数器的特点"></a>1.3 程序计数器的特点</h5><ul><li>是一块比较小的存储空间</li><li>是线程私有的，即每一个线程都有一个独立程序计数器</li><li>是唯一一个不会出现 OOM（OutOfMemoryError）的内存区域</li><li>声明周期随着线程的开始而创建，随着线程的终止而结束</li></ul><blockquote><h4 id="方法区、永久代和元空间"><a href="#方法区、永久代和元空间" class="headerlink" title="方法区、永久代和元空间"></a>方法区、永久代和元空间</h4></blockquote><h5 id="1-1-方法区和永久代的关系"><a href="#1-1-方法区和永久代的关系" class="headerlink" title="1.1 方法区和永久代的关系"></a>1.1 方法区和永久代的关系</h5><p>涉及到内存模型，往往都会提到永久代，那么它和方法区又是什么关系呢？<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">JVM 虚拟机规范</a> 只是规定了有方法区这个概念和它的作用，并没有规定如何实现它。那么，在不同 JVM 上方法区的实现肯定是不同的。同时大多数公司用的 JVM 都是 Oracle 公司的 HotSpot。在 HotSpot 上把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区。因此，我们可以得到结论，永久代是 HotSpot 的概念，方式区是 JVM 规范的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。其它的虚拟机实现并没有永久代这么一说。在 JDK 1.7 及之前的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC 分代来实现方法区内存回收，可以使用以下参数来调准方法区的大小：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize     # 方法区初始大小</span><br><span class="line">-XX:MaxPermSize  # 方法区最大大小（超过这个值会抛出 OutOfMemoryError 异常：java.lang.OutOfMemoryError：PermGen）</span><br></pre></td></tr></table></figure><h5 id="1-2-元空间"><a href="#1-2-元空间" class="headerlink" title="1.2 元空间"></a>1.2 元空间</h5><p>对于 Java 8，HotSpot 取消了永久代，那么是不是也就没有方法了吗？<br>当然不是，方法区是一个规范，规范没变，它就会一直在。那么取代永久代的就是元空间。它和永久代有什么不同呢？</p><ul><li>存储位置不同，永久代物理上是堆的一部分，和新生代、老年代地址是连续的，而元空间属于本地内存</li><li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。</li></ul><h4 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h4><h6 id="1-1-JVM-内存模型一共有两个“栈”，分别是-Java-虚拟机栈和本地方法栈"><a href="#1-1-JVM-内存模型一共有两个“栈”，分别是-Java-虚拟机栈和本地方法栈" class="headerlink" title="1.1 JVM 内存模型一共有两个“栈”，分别是 Java 虚拟机栈和本地方法栈"></a>1.1 JVM 内存模型一共有两个“栈”，分别是 Java 虚拟机栈和本地方法栈</h6><p>两个“栈”功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是方法私有的。只不过 Java 虚拟机栈描述的是 Java 方法运行过程的内存模型，而本地方法栈是描述 Java 本地方法运行过程的内存模型。</p><h6 id="1-2-JVM-内存模型中一共有两个“堆”，分别是原本的堆和方法区"><a href="#1-2-JVM-内存模型中一共有两个“堆”，分别是原本的堆和方法区" class="headerlink" title="1.2 JVM 内存模型中一共有两个“堆”，分别是原本的堆和方法区"></a>1.2 JVM 内存模型中一共有两个“堆”，分别是原本的堆和方法区</h6><p>方法区本质上还是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量，即时编译器编译后的代码等。</p><h6 id="1-3-堆是-JVM-中最大的一块内存区域，也是垃圾收集器主要工作的地方"><a href="#1-3-堆是-JVM-中最大的一块内存区域，也是垃圾收集器主要工作的地方" class="headerlink" title="1.3 堆是 JVM 中最大的一块内存区域，也是垃圾收集器主要工作的地方"></a>1.3 堆是 JVM 中最大的一块内存区域，也是垃圾收集器主要工作的地方</h6><p>在创建对象的时候，非静态成员会被加载到堆内存中，并完成成员变量的初始化。也就是说所有的非静态成员（成员变量、成员方法、构造方法、构造代码块和普通代码块）都是保存在堆内存中的。但是方法调用的时候，调用的方法会在栈内存中执行，构造代码块也会在栈内存中执行。</p><h6 id="1-4-线程私有与共享"><a href="#1-4-线程私有与共享" class="headerlink" title="1.4 线程私有与共享"></a>1.4 线程私有与共享</h6><p>Java 虚拟机栈、程序计数器和本地方法栈都是线程私有的，也就是说每个线程都是各自的程序计数器、Java 虚拟机栈和本地方法栈。他们的生命周期和线程的生命周期一样。而堆、方法区则是线程共享的，在 JVM 中只有一个堆，一个方法区。并在 JVM 启动的时候就创建，直到 JVM 停止的时候才销毁。</p><hr><p>参考文章：<br><a href="https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/" target="_blank" rel="noopener">Java Memory Management for Java Virtual Machine (JVM)</a><br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html" target="_blank" rel="noopener">The Java® Virtual Machine Specification（Java SE 8 Edition）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-为什么要进行内存区域划分&quot;&gt;&lt;a href=&quot;#1-1-为什么要进行内存区域划分&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么要进行内存区域划分&quot;&gt;&lt;/a&gt;1.1 为什么要进行内存区域划分&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVM规范&lt;/a&gt; 规定，JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间，有的区域随着虚拟机进程的启动就存在了，而有些区域则依赖用户线程的启动和结束而建立和销毁。JVM 规范对 JVM 定义了运行时统一的内存划分规范，统一了标准，类似于 JDBC 规范一样。JVM 也有许多厂商的不同产品。比如下面的这些：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;厂商&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;JVM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Oracle-SUN&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Hotspot&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Oracle&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;JRocket&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;IBM&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;J9 JVM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;阿里&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Taobao JVM&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;其内存区域划分规范对于 JVM 的含义类似于我们 Java 中的接口，都是起到了规范的作用，JVM 是一台可以运行 Java 应用程序的抽象的计算机。在 JVM 中存在三个重要的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM 规范：它定义了虚拟机运行的规范，但是由 Oracle（SUN）或者其它厂商实现&lt;/li&gt;
&lt;li&gt;Java 运行时环境(JRE：Java Runtime Environment)：它是 JVM 规范的具体实现&lt;/li&gt;
&lt;li&gt;JVM 实例：编写好 Java 代码之后，运行 Java 程序，此时就会创建 JMV 实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 Java 程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个对象去编写内存释放的代码，不要像 C 或者 C++ 要时刻注意着内存泄漏和内存溢出的问题，这种由虚拟机去管理一切看起来都很美好。不过，也正是因为 Java 设计者把内存控制全部交给了 JVM，一旦出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎么分配运行时内存的，那么排查错误将是一项非常艰难的工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="JVM" scheme="https://www.mghio.cn/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.mghio.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 ThreadLocal</title>
    <link href="https://www.mghio.cn/post/bfcdfeaf.html"/>
    <id>https://www.mghio.cn/post/bfcdfeaf.html</id>
    <published>2019-10-19T14:14:50.000Z</published>
    <updated>2019-10-21T10:42:08.910Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-什么是-ThreadLocal"><a href="#1-1-什么是-ThreadLocal" class="headerlink" title="1.1 什么是 ThreadLocal"></a>1.1 什么是 ThreadLocal</h4><p>ThreadLocal 简单理解 <code>Thread</code> 即线程，<code>Local</code> 即本地，结合起来理解就是 <code>每个线程都是本地独有的</code>。在早期的计算机中不包含操作系统，从头到尾只执行一个程序，并且这个程序能访问计算中的所有资源，这对于计算机资源来说是一种浪费。要想充分发挥多处理器的强大计算能力，最简单的方式就是使用多线程。与串行程序相比，在并发程序中存在更多容易出错的地方。当访问共享数据时，通常需要使用同步来控制并发程序的访问。一种避免使用同步的方式就是让这部分共享数据变成不共享的，试想一下，如果只是在单个线程内对数据进行访问，那么就可以不用同步了，这种技术称为<code>线程封闭（Thread Confinement）</code>，它是实现线程安全最简单的方式之一。<br>当某个对象封闭在一个单个线程中时，这种用法会自动实现了线程安全，因为只有一个线程访问数据，从根本上避免了共享数据的线程安全问题，即使被封闭的对象本身不是线程安全的。要保证线程安全，并不是一定就需要同步，两者没有因果关系，同步只是保证共享数据征用时正确性的手段，如果一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证正确性。而维持线程封闭的一种规范用法就是使用 <strong>ThreadLoal</strong>，这个类能使当前线程中的某个值与保存的值关联起来。ThreadLocal 提供了 <code>get()</code> 与 <code>set(T value)</code> 等方法，<code>set</code> 方法为每个使用了该变量的线程都存有一份独立的副本，因此当我们调用 <code>get</code> 方法时总是返回由当前线程在调用 <code>set</code> 方法的时候设置的最新值。</p><h4 id="1-2-ThreadLocal-的用法"><a href="#1-2-ThreadLocal-的用法" class="headerlink" title="1.2 ThreadLocal 的用法"></a>1.2 ThreadLocal 的用法</h4><p>接下来通过一个示例代码说明 ThreadLocal 的使用方式，该示例使用了三个不同的线程 <code>Main Thread</code>、<code>Thread-1</code> 和 <code>Thread-2</code> 分别对同一个 ThreadLocal 对象中存储副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 并发之 ThreadLocal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemoTests</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ThreadLocal&lt;String&gt; boolThreadLocal = ThreadLocal.withInitial(() -&gt; <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUseCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boolThreadLocal.set(<span class="string">"main-thread-set"</span>);</span><br><span class="line">    System.out.printf(<span class="string">"Main Thread: %s\n"</span>, boolThreadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-1"</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boolThreadLocal.set(<span class="string">"thread-1-set"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"Thread-1: %s\n"</span>, boolThreadLocal.get());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-2"</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Thread-2: %s\n"</span>, boolThreadLocal.get());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>打印的输出结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main Thread: main-thread-set</span><br><span class="line">Thread-<span class="number">1</span>: thread-<span class="number">1</span>-set</span><br><span class="line">Thread-<span class="number">2</span>:</span><br></pre></td></tr></table></figure><p>我们从输出结果可以看出，ThreadLocal 把不同的线程的数据进行隔离，互不影响，Thread-2 的线程因为我们没有重新设置值会使用 <code>withInitial</code> 方法设置的默认初始值 <code>&quot;&quot;</code>，在不同的线程对同一个 ThreadLocal 对象设置值，对不同的线程取出来的值不一样。接下来我们来分析一下源码，看看它是如何实现的。</p><h4 id="1-3-ThreadLocal-的实现原理"><a href="#1-3-ThreadLocal-的实现原理" class="headerlink" title="1.3 ThreadLocal 的实现原理"></a>1.3 ThreadLocal 的实现原理</h4><p>既然要对每个访问 ThreadLocal 变量的线程都要有自己的一份<code>本地独立副本</code>。我们很容易想到可以用一个 Map 结构去存储，它的键就是我们当前的线程，值是它在该线程内的实例。然后当我们使用该 ThreadLocal 的 get 方法获取实例值时，只需要使用 <code>Thread.currentThread()</code> 获取当前线程，以当前线程为键，从我们的 Map 中获取对应的实例值即可。结构示意图如下所示：<br><img src="https://i.loli.net/2019/10/20/8A1nO9vTaxcgpz7.png" alt="threadlocal-one.png"><br>上面这个方案可以满足前文所说的每个线程本地独立副本的要求。每个新的线程访问该 ThreadLocal 的时候，就会向 Map 中添加一条映射记录，而当线程运行结束时，应该从 Map 中清除该条记录，那么就会存在如下问题：</p><ol><li>因为新增线程或者线程执行完都要操作这个 Map，所以需要保证 Map 是线程安全的。虽然可以使用 JDK 提供的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="noopener">ConcurrentHashMap</a> 来保证线程安全，但是它还是要通过使用锁来保证线程安全的。</li><li>当一个线程运行结束时要及时移除 Map 中对应的记录，不然可能会发生 <a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" target="_blank" rel="noopener">内存泄漏</a> 问题。</li></ol><p>由于存在锁的问题，所有最终 JDK 并没有采用这个方案，而是使用无锁的 <code>ThreadLocal</code>。上述方案出现锁的原因是因为有两一个以上的线程同时访问同一个 Map 导致的。我们可以换一种思路来看这个问题，如果将这个 Map 由每个 Thread 维护，从而使得每个 Thread 只访问自己的 Map，那样就不会存在线程安全的问题，也不会需要锁了，因为是每个线程自己独有的，其它线程根本看不到其它线程的 Map 。这个方案如下图所示：<br><img src="https://i.loli.net/2019/10/20/z1ybDCfWicRF9G2.png" alt="threalocal-two.png"> 这个方案虽然不存在锁的问题，但是由于每个线程访问 ThreadLocal 变量后，都会在自己的 Map 内维护该 ThreadLoal 变量与具体存储实例的映射，如果我们不手动删除这些实例，可能会造成内存泄漏。<br>我们进入到 Thread 的源码内可以看到其内部定义了一个 <code>ThreadLocalMap</code> 成员变量，如下图所示：<br><img src="https://i.loli.net/2019/10/20/OLmpZnfePybKkBr.png" alt="thread-codesource.png"> ThreadLoalMap 类是一个类似 Map 的类，是 ThreadLocal 的内部类。它的 key 是 ThreadLocal ，一个 ThreadLocalMap 可以存储多个 key（ThreadLocal），它的 value 就对应着在 ThreadLocal 存储的 value。因此我们可以看出：每一个 Thread 都对应自己的一个 ThreadLocalMap ，而 ThreadLocalMap 可以存储多个以 ThreadLocal 为 key 的键值对。这里也解释了为什么我们使用多个线程访问同一个 ThreadLocal ，然后 get 到的确是不同数值。</p><p>上面对 ThreadLocal 进行了一些解释，接下来我们看看 ThreadLocal 具体是如何实现的。先看一下 ThreadLocal 类提供的几个常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><ol><li><code>initialValue</code> 方法是一个 protected 方法，一般是用来使用时进行重写，设置默认初始值的方法，它是一个延迟加载的方法，在。</li><li><code>set</code> 方法是用来设置当前线程的变量副本的方法</li><li><code>get</code> 方法是用获取 ThreadLocal 在当前线程中保存的变量副本</li><li><code>remove</code> 方法是 JDK1.5+ 才提供的方法，是用来移除当前线程中的变量副本</li></ol><p><code>initialValue</code> 方法是在 <code>setInitialValue</code> 方法被调用的，由于 setInitialValue 方法是 private 方法，所以我们只能重写 initialValue 方法，我们看看 setInitialValue 的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment"> * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   T value = initialValue();</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map = getMap(t);</span><br><span class="line">   <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">       map.set(<span class="keyword">this</span>, value);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       createMap(t, value);</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过以上代码我们知道，会先调用 initialValue 获取初始值，然后使用当前线程从 Map 中获取线程对应 ThreadLocalMap，如果 map 不为 <code>null</code>，就设置键值对，如果为 <code>null</code>，就再创建一个 Map。<br>首先我们看下在 getMap 方法中干了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可能大家没有想到的是，在 getMap 方法中，是调用当期线程 t，返回当前线程 t 中的一个成员变量 threadLocals 。那么我们继续到 Thread 类中源代码中看一下成员变量 threadLocals 到底是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>它实际上就是一个 ThreadLocalMap ，这个类型是 ThreadLocal 类内定义的一个内部类，我们看一下 ThreadLocalMap 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocalMap is a customized hash map suitable only for</span></span><br><span class="line"><span class="comment"> * maintaining thread local values. No operations are exported</span></span><br><span class="line"><span class="comment"> * outside of the ThreadLocal class. The class is package private to</span></span><br><span class="line"><span class="comment"> * allow declaration of fields in class Thread.  To help deal with</span></span><br><span class="line"><span class="comment"> * very large and long-lived usages, the hash table entries use</span></span><br><span class="line"><span class="comment"> * WeakReferences for keys. However, since reference queues are not</span></span><br><span class="line"><span class="comment"> * used, stale entries are guaranteed to be removed only when</span></span><br><span class="line"><span class="comment"> * the table starts running out of space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">       <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">       Object value;</span><br><span class="line"></span><br><span class="line">       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">           <span class="keyword">super</span>(k);</span><br><span class="line">           value = v;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 ThreadLocalMap 的 Entry 继承了 WeakReference (<a href="https://zh.wikipedia.org/wiki/%E5%BC%B1%E5%BC%95%E7%94%A8" target="_blank" rel="noopener">弱引用</a>)，并且使用 ThreadLocal 作为键值。</p><p>下面我们看下 createMap 方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">   t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>直接 new 一个 ThreadLoalMap 对象，然后赋值给当前线程的 threadLocals 属性。</p><p>然后我们看一下 <code>set</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map = getMap(t);</span><br><span class="line">   <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">       map.set(<span class="keyword">this</span>, value);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       createMap(t, value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先获取当前线程，然后从线程的属性 <code>threadLocals</code> 获取当前线程对应的 ThreadLocalMap 对象，如果不为空，就以 <strong>this (ThreadLocal)</strong> 而不是当前线程 t 为 key，添加到 ThreadLocalMap 中。如果为空，那么就先创建后再加入。ThreadLocal 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏。</p><p>接下来我们看一下 <code>get</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map = getMap(t);</span><br><span class="line">   <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">       ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">           T result = (T)e.value;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> setInitialValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>先获取当前线程，然后通过 getMap 方法传入当前线程获取到 ThreadLocalMap 。然后接着获取 Entry (key，value) 键值对，<strong>这里传入的是 this，而不是当前线程 t</strong> ，如果获取成功，则返回对应的 value，如果没有获取到，返回空，则调用 setInitialValue 方法返回 value。</p><p>至此，我们总结一下 <code>ThreadLocal</code> 是如何为每个线程创建变量副本的：首先，在每个线程 Thread 内部有个 ThreadLocal.ThreadLocalMap 类型的成员变量 threadLocals，这个 threadLocals 变量就是用来存储实际变量的副本的，它的键为当前 ThreadLocal ，value 为变量副本（即 T 类型的变量）。<br>初始时，在 Thread 类里面， threadLocals 为 <code>null</code>，当通过 ThreadLocal 调用 set 或者 get 方法时，如果此前没有对当前线程的 threadLocals 进行过初始化操作，那么就会以当前 ThreadLocal 变量为键值，以 ThreadLocal 要保存的副本变量为 value，存到当前线程的 threadLocals 变量中。以后在当前线程中，如果要用到当前线程的副本变量，就可以通过 get 方法在当前线程的 threadLocals 变量中查找了。</p><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><p><code>ThreadLocal</code> 设计的目的就是为了能够在当前线程中有属于自己的变量，并不是为了解决并发或者共享变量的问题。</p><ol><li>通过 ThreadLocal 创建的副本是存储在每个线程自己的 threadLocals 变量中的</li><li>为何 threadLocals 的类型 ThreadLocalMap 的键值为 ThreadLocal 对象，因为每个线程中可有多个 threadLocal 变量，就像前文图片中的 ThreadLocal<string> 和 ThreadLocal<integer> ，就是一个线程存在两个 threadLocal 变量</integer></string></li><li>在进行 get 之前，必须先 set ，否则会报空指针异常，如果想在 get 之前不需要调用 set 就能正常访问的话，必须重写 initialValue 方法</li><li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li></ol><hr><p>另外，内存泄漏的问题请参考博文：<a href="https://www.javazhiyin.com/18072.html" target="_blank" rel="noopener">ThreadLocal 内存泄漏问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-什么是-ThreadLocal&quot;&gt;&lt;a href=&quot;#1-1-什么是-ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是 ThreadLocal&quot;&gt;&lt;/a&gt;1.1 什么是 ThreadLocal&lt;/h4&gt;&lt;p&gt;ThreadLocal 简单理解 &lt;code&gt;Thread&lt;/code&gt; 即线程，&lt;code&gt;Local&lt;/code&gt; 即本地，结合起来理解就是 &lt;code&gt;每个线程都是本地独有的&lt;/code&gt;。在早期的计算机中不包含操作系统，从头到尾只执行一个程序，并且这个程序能访问计算中的所有资源，这对于计算机资源来说是一种浪费。要想充分发挥多处理器的强大计算能力，最简单的方式就是使用多线程。与串行程序相比，在并发程序中存在更多容易出错的地方。当访问共享数据时，通常需要使用同步来控制并发程序的访问。一种避免使用同步的方式就是让这部分共享数据变成不共享的，试想一下，如果只是在单个线程内对数据进行访问，那么就可以不用同步了，这种技术称为&lt;code&gt;线程封闭（Thread Confinement）&lt;/code&gt;，它是实现线程安全最简单的方式之一。&lt;br&gt;当某个对象封闭在一个单个线程中时，这种用法会自动实现了线程安全，因为只有一个线程访问数据，从根本上避免了共享数据的线程安全问题，即使被封闭的对象本身不是线程安全的。要保证线程安全，并不是一定就需要同步，两者没有因果关系，同步只是保证共享数据征用时正确性的手段，如果一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证正确性。而维持线程封闭的一种规范用法就是使用 &lt;strong&gt;ThreadLoal&lt;/strong&gt;，这个类能使当前线程中的某个值与保存的值关联起来。ThreadLocal 提供了 &lt;code&gt;get()&lt;/code&gt; 与 &lt;code&gt;set(T value)&lt;/code&gt; 等方法，&lt;code&gt;set&lt;/code&gt; 方法为每个使用了该变量的线程都存有一份独立的副本，因此当我们调用 &lt;code&gt;get&lt;/code&gt; 方法时总是返回由当前线程在调用 &lt;code&gt;set&lt;/code&gt; 方法的时候设置的最新值。&lt;/p&gt;
&lt;h4 id=&quot;1-2-ThreadLocal-的用法&quot;&gt;&lt;a href=&quot;#1-2-ThreadLocal-的用法&quot; class=&quot;headerlink&quot; title=&quot;1.2 ThreadLocal 的用法&quot;&gt;&lt;/a&gt;1.2 ThreadLocal 的用法&lt;/h4&gt;&lt;p&gt;接下来通过一个示例代码说明 ThreadLocal 的使用方式，该示例使用了三个不同的线程 &lt;code&gt;Main Thread&lt;/code&gt;、&lt;code&gt;Thread-1&lt;/code&gt; 和 &lt;code&gt;Thread-2&lt;/code&gt; 分别对同一个 ThreadLocal 对象中存储副本。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; mghio&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@date&lt;/span&gt;: 2019-10-20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@version&lt;/span&gt;: 1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@description&lt;/span&gt;: Java 并发之 ThreadLocal&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@since&lt;/span&gt; JDK 1.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadLocalDemoTests&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; boolThreadLocal = ThreadLocal.withInitial(() -&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testUseCase&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boolThreadLocal.set(&lt;span class=&quot;string&quot;&gt;&quot;main-thread-set&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.printf(&lt;span class=&quot;string&quot;&gt;&quot;Main Thread: %s\n&quot;&lt;/span&gt;, boolThreadLocal.get());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;string&quot;&gt;&quot;Thread-1&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        boolThreadLocal.set(&lt;span class=&quot;string&quot;&gt;&quot;thread-1-set&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.printf(&lt;span class=&quot;string&quot;&gt;&quot;Thread-1: %s\n&quot;&lt;/span&gt;, boolThreadLocal.get());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;string&quot;&gt;&quot;Thread-2&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.printf(&lt;span class=&quot;string&quot;&gt;&quot;Thread-2: %s\n&quot;&lt;/span&gt;, boolThreadLocal.get());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 字符串 split 踩坑记</title>
    <link href="https://www.mghio.cn/post/8bd965a0.html"/>
    <id>https://www.mghio.cn/post/8bd965a0.html</id>
    <published>2019-10-13T02:33:40.000Z</published>
    <updated>2019-10-16T12:59:36.969Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-split-的坑"><a href="#1-1-split-的坑" class="headerlink" title="1.1 split 的坑"></a>1.1 split 的坑</h4><p>前几天在公司对通过 <a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">FTP</a> 方式上传的数据文件按照事先规定的格式进行解析后入库，代码的大概实现思路是这样的：先使用流进行文件读取，对文件的每一行数据解析封装成一个个对象，然后进行入库操作。本以为很简单的一个操作，然后写完代码后自己测试发现对文件的每一行进行字符串分割的时候存在问题，在这里做个简单的记录总结。在 Java 中使用 split 方法对字符串进行分割是经常使用的方法，经常在一些文本处理、字符串分割的逻辑中，需要按照一定的分隔符进行分割拆解。这样的功能，大多数情况下我们都会使用 String 中的 split 方法。关于这个方法，稍不注意很容易踩坑。</p><p><strong>（1）split 的参数是正则表达式</strong><br>首先一个常见的问题，就是忘记了 String 的 split 方法的参数不是普通的字符串，而是正则表达式，例如下面的这两种使用方式都达不到我们的预期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringSplitRegexArg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m.g.h.i.o"</span>.split(<span class="string">"."</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m|g|h|i|o"</span>.split(<span class="string">"|"</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>以上代码的结果输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[m, |, g, |, h, |, i, |, o]</span><br></pre></td></tr></table></figure><p>上面出错的原因是因为 <strong>.</strong> 和 <strong>|</strong> 都是正则表达式，应该用转义字符进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"m.g.h.i.o"</span>.split(<span class="string">"\\."</span>)</span><br><span class="line"><span class="string">"m|g|h|i|o"</span>.split(<span class="string">"\\|"</span>)</span><br></pre></td></tr></table></figure><p>在 String 类中还有其它的和这个相似的方法，例如：replaceAll。</p><p><strong>（2）split 会忽略分割后的空字符串</strong><br>大多数情况下我们都只会使用带一个参数的 split 方法，但是只带一个参数的 split 方法有个坑：就是此方法只会匹配到最后一个有值的地方，后面的会忽略掉，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringSplitSingleArg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m_g_h_i_o"</span>.split(<span class="string">"_"</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m_g_h_i_o__"</span>.split(<span class="string">"_"</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m__g_h_i_o_"</span>.split(<span class="string">"_"</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[m, g, h, i, o]</span><br><span class="line">[m, g, h, i, o]</span><br><span class="line">[m, , g, h, i, o]</span><br></pre></td></tr></table></figure><p>像第二、三个输出结果其实和我们的预期是不符的，因为像一些文件上传其实有的字段通常是可以为空的，如果使用单个参数的 split 方法进行处理就会有问题。通过查看 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">API 文档</a> 后，发现其实 String 中的 split 方法还有一个带两个参数的方法。第二个参数是一个整型类型变量，代表最多匹配上多少个，0 表示只匹配到最后一个有值的地方，单个参数的 split 方法的第二个参数其实就是 0，要想强制匹配可以选择使用负数（通常传入 -1 ），换成以下的写法，输出结果就和我们的预期一致了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"m_g_h_i_o"</span>.split(<span class="string">"_"</span>, -<span class="number">1</span>)      <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line"><span class="string">"m_g_h_i_o__"</span>.split(<span class="string">"_"</span>, -<span class="number">1</span>)    <span class="comment">// [m, g, h, i, o, , ]</span></span><br><span class="line"><span class="string">"m__g_h_i_o_"</span>.split(<span class="string">"_"</span>, -<span class="number">1</span>)    <span class="comment">// [m, , g, h, i, o, ]</span></span><br></pre></td></tr></table></figure><p><strong>（3）JDK 中字符串切割的其它 API</strong><br>在 JDK 中还有一个叫做 <strong>StringTokenizer</strong> 的类也可以对字符串进行切割，用法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringTokenizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         StringTokenizer st = <span class="keyword">new</span> StringTokenizer(<span class="string">"This|is|a|mghio's|blog"</span>, <span class="string">"|"</span>);</span><br><span class="line">         <span class="keyword">while</span> (st.hasMoreElements()) &#123;</span><br><span class="line">         System.out.println(st.nextElement());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不过，我们从源码的 javadoc 上得知，这是从 JDK 1.0 开始就已经存在了，属于历史遗留的类，并且推荐使用 String 的 split 方法。</p><h4 id="1-2-JDK-源码探究"><a href="#1-2-JDK-源码探究" class="headerlink" title="1.2 JDK 源码探究"></a>1.2 JDK 源码探究</h4><p>通过查看 JDK 中 String 类的源码，我们得知在 String 类中单个参数的 split 方法（<strong>split(String regex)</strong>）里面调用了两个参数的 split 方法（<strong>split(String regex, int limit)</strong>），两个参数的 split 方法，先根据传入第一个参数 <strong>regex</strong> 正则表达式分割字符串，第二个参数 <strong>limit</strong> 限定了分割后的字符串个数，超过数量限制的情况下前limit-1个子字符串正常分割，最后一个子字符串包含剩下所有字符。单个参数的重载方法将 <strong>limit</strong> 设置为 0。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">         <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">         (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">          (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">        (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">         ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> limited = limit &gt; <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!limited || list.size() &lt; limit - <span class="number">1</span>) &#123;</span><br><span class="line">                list.add(substring(off, next));</span><br><span class="line">                off = next + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></span><br><span class="line">                <span class="comment">//assert (list.size() == limit - 1);</span></span><br><span class="line">                list.add(substring(off, value.length));</span><br><span class="line">                off = value.length;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If no match was found, return this</span></span><br><span class="line">        <span class="keyword">if</span> (off == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add remaining segment</span></span><br><span class="line">        <span class="keyword">if</span> (!limited || list.size() &lt; limit)</span><br><span class="line">            list.add(substring(off, value.length));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Construct result</span></span><br><span class="line">        <span class="keyword">int</span> resultSize = list.size();</span><br><span class="line">        <span class="keyword">if</span> (limit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] result = <span class="keyword">new</span> String[resultSize];</span><br><span class="line">        <span class="keyword">return</span> list.subList(<span class="number">0</span>, resultSize).toArray(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来让我们一起看看 String 的 split 方法是如何实现的。</p><p><strong>（1）特殊情况判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">         <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">         (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">          (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">        (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">         ch &gt; Character.MAX_LOW_SURROGATE))</span><br></pre></td></tr></table></figure><ul><li>第一个参数 <strong>regex</strong> 为单个字符时，将其赋值给 ch，并判断是否在元字符：「.$|()[{^?*+\」中</li><li>第一个参数 <strong>regex</strong> 为两个字符时，第一个字符为 \\（要表示一个\需要用两个\转义得到），第二个字符不在数字、大小写字母和 <a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode 编码</a> Character.MIN_HIGH_SURROGATE（’\uD800’）和 Character.MAX_LOW_SURROGATE（’\uDBFF’）之间。</li></ul><p><strong>（2）字符串分割</strong><br>第一次分割时，使用 off 和 next，off 指向每次分割的起始位置，next 指向分隔符的下标，完成一次分割后更新 off 的值，当 list  的大小等于 limit - 1 时，直接添加剩下的子字符串。</p><ul><li>如果字符串不含有分隔符，则直接返回原字符串</li><li>如果字符串进行完第一次分割后，数量没有达到 limit - 1 的话，则剩余的字符串在第二次添加</li><li>如果传入的第二个参数 <strong>limit</strong> 等于 0 ，则从最后的字符串往前移动，将所有的空字符串（”“）全部清除</li></ul><p><strong>（3）正则匹配</strong><br>String 的 split 方法在不是上面的特殊情况下，会使用两个类 <strong>Pattern</strong> 与 <strong>Matcher</strong> 进行分割匹配处理，而且 Strig 中涉及正则的操作都是调用这两个类进行处理的。</p><ul><li>Pattern 类我们可以将其理解为模式类，它主要是用来创建一个匹配模式，它的构造方法是私有的，不能直接创建该对象，可以通过 <strong>Pattern.complie(String regex)</strong> 简单的工厂方法创建一个正则表达式。</li><li>Matcher 类我们可以将其理解为匹配器类，它是用来解释 Pattern 类对字符串执行匹配操作的引擎，它的构造方法也是私有的，不能直接创建该对象，可以通过 <strong>Pattern.matcher(CharSequence input)</strong> 方法得到该类的实例。String 类的双参数 split 方法最后使用 Pattern 类的 compile 和 split 方法，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br></pre></td></tr></table></figure></li></ul><p>首先调用 Pattern 类的静态方法 compile 获取 Pattern 模式类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pattern(regex, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用 Pattern 的 split(CharSequence input, int limit) 方法，在这个方法中调 matcher(CharSequence input) 方法返回一个 Matcher 匹配器类的实例 m，与 String 类中 split 方法的特殊情况有些类似。</p><ul><li>使用 m.find()、m.start()、m.end() 方法</li><li>每找到一个分割符，则更新 start 和 end 的位置</li><li>然后处理没找到分隔符、子字符串数量小于 limit 以及 limit = 0 的情况</li></ul><h4 id="1-3-其它的字符串分割方式"><a href="#1-3-其它的字符串分割方式" class="headerlink" title="1.3 其它的字符串分割方式"></a>1.3 其它的字符串分割方式</h4><ul><li>方式一：使用 org.apache.commons.lang3.StringUtils#split，此方法使用完整的字符串作为参数，而不是正则表达式。底层调用 splitWorker 方法（<strong><font color="#dd0000">注意：</font></strong>此方法会忽略分割后的空字符串）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testApacheCommonsLangStringUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Arrays.toString(StringUtils.split(<span class="string">"m.g.h.i.o"</span>, <span class="string">"."</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(StringUtils.split(<span class="string">"m__g_h_i_o_"</span>, <span class="string">"_"</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[m, g, h, i, o]</span><br><span class="line">[m, g, h, i, o]</span><br></pre></td></tr></table></figure><ul><li>方式二：使用 com.google.common.base.Splitter，使用 Google Guava 包中提供的分割器 splitter，它提供了更加丰富的分割结果处理的方法，比如对结果前后去除空格，去除空字符串等<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testApacheCommonsLangStringUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Iterable&lt;String&gt; result = Splitter.on(<span class="string">"_"</span>).split(<span class="string">"m__g_h_i_o_"</span>);</span><br><span class="line">         List&lt;String&gt; resultList = Lists.newArrayList();</span><br><span class="line">         result.forEach(resultList::add);</span><br><span class="line">         System.out.println(<span class="string">"stringList's size: "</span> + resultList.size());</span><br><span class="line">         result.forEach(System.out::println);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringList<span class="string">'s size: 7</span></span><br><span class="line"><span class="string">m</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string">h</span></span><br><span class="line"><span class="string">i</span></span><br><span class="line"><span class="string">o</span></span><br></pre></td></tr></table></figure><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><p>String 类中除了 split 方法外，有正则表达式接口的方法都是调用 Pattern（模式类）和 Matcher（匹配器类）进行实现的。JDK 源码的每一个如 <strong>final</strong>、<strong>private</strong> 的关键字都设计的十分严谨，多读类和方法中的javadoc，多注意这些细节对于阅读代码和自己写代码都有很大的帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-split-的坑&quot;&gt;&lt;a href=&quot;#1-1-split-的坑&quot; class=&quot;headerlink&quot; title=&quot;1.1 split 的坑&quot;&gt;&lt;/a&gt;1.1 split 的坑&lt;/h4&gt;&lt;p&gt;前几天在公司对通过 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FTP&lt;/a&gt; 方式上传的数据文件按照事先规定的格式进行解析后入库，代码的大概实现思路是这样的：先使用流进行文件读取，对文件的每一行数据解析封装成一个个对象，然后进行入库操作。本以为很简单的一个操作，然后写完代码后自己测试发现对文件的每一行进行字符串分割的时候存在问题，在这里做个简单的记录总结。在 Java 中使用 split 方法对字符串进行分割是经常使用的方法，经常在一些文本处理、字符串分割的逻辑中，需要按照一定的分隔符进行分割拆解。这样的功能，大多数情况下我们都会使用 String 中的 split 方法。关于这个方法，稍不注意很容易踩坑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）split 的参数是正则表达式&lt;/strong&gt;&lt;br&gt;首先一个常见的问题，就是忘记了 String 的 split 方法的参数不是普通的字符串，而是正则表达式，例如下面的这两种使用方式都达不到我们的预期：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; mghio&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@date&lt;/span&gt;: 2019-10-13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@version&lt;/span&gt;: 1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@description&lt;/span&gt;: Java 字符串 split 踩坑记&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@since&lt;/span&gt; JDK 1.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;JavaStringSplitTests&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testStringSplitRegexArg&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         System.out.println(Arrays.toString(&lt;span class=&quot;string&quot;&gt;&quot;m.g.h.i.o&quot;&lt;/span&gt;.split(&lt;span class=&quot;string&quot;&gt;&quot;.&quot;&lt;/span&gt;)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         System.out.println(Arrays.toString(&lt;span class=&quot;string&quot;&gt;&quot;m|g|h|i|o&quot;&lt;/span&gt;.split(&lt;span class=&quot;string&quot;&gt;&quot;|&quot;&lt;/span&gt;)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 字节码</title>
    <link href="https://www.mghio.cn/post/192cb539.html"/>
    <id>https://www.mghio.cn/post/192cb539.html</id>
    <published>2019-10-02T07:45:32.000Z</published>
    <updated>2019-10-03T07:10:43.847Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-什么是字节码？"><a href="#1-1-什么是字节码？" class="headerlink" title="1.1 什么是字节码？"></a>1.1 什么是字节码？</h4><p>Java 在刚刚诞生之时曾经提出过一个非常著名的口号: “<strong>一次编写，到处运行（write once，run anywhere）</strong>”，这句话充分表达了软件开发人员对冲破平台界限的渴求。“与平台无关”的理想最终实现在操作系统的运用层上: 虚拟机提供商开发了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写到处运行”。<br><br>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—<strong>字节码（ByteCode）</strong>，因此，可以看出字节码对 Java 生态的重要性。之所以被称为字节码，是因为字节码是由十六进制组成的，而 JVM（Java Virtual Machine）以两个十六进制为一组，即以字节为单位进行读取。在 Java 中使用 <strong><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html" target="_blank" rel="noopener">javac</a></strong> 命令把源代码编译成字节码文件，一个 .java 源文件从编译成 .class 字节码文件的示例如图 1 所示:<br><img src="https://i.loli.net/2019/10/03/jcIPJSvYnd2ayOi.png" alt="图1"><center>图 1</center></p><a id="more"></a><p>对于从事基于 JVM 的语言的开发人员来说，比如: Java，了解字节码可以更准确、更直观的理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观的看到 <strong>volatile</strong> 关键字如何在字节码上生效。另外，字节码增强技术在各种 ORM 框架、Spring AOP、热部署等一些应用中经常使用，深入理解其原理对于我们来说大有裨益。由于 JVM 规范的存在，只要最终生成了符合 JVM 字节码规范的文件都可以在 JVM 上运行，因此，这个也给其它各种运行在 JVM 上的语言（如: <a href="https://www.scala-lang.org/" target="_blank" rel="noopener">Scala</a>、<a href="https://groovy-lang.org/" target="_blank" rel="noopener">Groovy</a>、<a href="https://kotlinlang.org/" target="_blank" rel="noopener">Kotlin</a>）提供了一个机会，可以扩展 Java 没有实现的特性或者实现一些语法糖。<br><br>接下来就让我们就一起看看这个字节码文件结构到底是什么样的。</p><h4 id="1-2-Java-字节码结构"><a href="#1-2-Java-字节码结构" class="headerlink" title="1.2 Java 字节码结构"></a>1.2 Java 字节码结构</h4><p>Java 源文件通过用 <strong><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html" target="_blank" rel="noopener">javac</a></strong> 命令编译后就会得到 .class 结尾的字节码文件，比如一个简单的 <strong>JavaCodeCompilerDemo</strong> 类如图 2 所示:<br><img src="https://i.loli.net/2019/10/03/raIK3DpwS67lTsZ.png" alt="图2"><center>图 2</center><br>编译后生成的 .class 字节码文件，打开后是一堆 <a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6" target="_blank" rel="noopener">十六进制</a> 数，如图 3 所示:<br><img src="https://i.loli.net/2019/10/03/gZfiXKmzI7o628x.png" alt="图3"><center>图 3</center><br>在上节提过，JVM 对于字节码规范是有要求的，打开编译后的字节码文件看似混乱无章，其实它是符合一定的结构规范的，JVM 规范要求每一个字节码文件都要由十部分固定的顺序组成的，接下来我们将一一介绍这部分，整体的组成结构如图 4 所示:<br><img src="https://i.loli.net/2019/10/03/f8NnQeZ6BuqGRHC.png" alt="图4"><center>图 4</center></p><p><strong>（1）魔数（Magic Number）</strong><br>每个字节码文件的头 4 个字节称为 <strong>魔数（Magic Number）</strong>，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如 gif 或者 jpg 等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意改动。魔数的固定值为: <strong>0xCAFEBABE</strong>，魔数放在文件头，JVM 可以根据文件的开头来判断这个文件是否可能是一个字节码文件，如果是，才会进行之后的操作。</p><blockquote><p>有趣的是，魔数的固定值是 Java 之父 <a href="https://zh.wikipedia.org/wiki/%E8%A9%B9%E5%A7%86%E6%96%AF%C2%B7%E9%AB%98%E6%96%AF%E6%9E%97" target="_blank" rel="noopener">James Gosling</a> 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡。</p></blockquote><p><strong>（2）版本号（Version）</strong><br>版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version），上图 3 中版本号为: “00 00 00 34”，次版本号转化为十进制为 0，主版本号转化为十进制 52（3 * 16^1 + 4 * 16^0 = 52），在 Oracle 官网中查询序号 52 对应的 JDK 版本为 1.8，所以编译该源代码文件的 Java 版本为 1.8.0。</p><p><strong>（3）常量池（Constant Pool）</strong><br>紧接着主版本号之后的字节是常量池入口。常量池中存储两种类型常量: 字面量和符号运用。字面量为代码中声明为 <strong>final</strong> 的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。常量池整体上分为两部分: 常量池计数器和常量池数据区，如图 5 所示：<br><img src="https://i.loli.net/2019/10/03/drScelTF6xN3Uoa.png" alt="图5"><center>图 5</center><br><strong>常量池计数器（constant_pool_count）</strong>: 由于常量池的数量不固定，所以需要先放置两个字节来表示常量池容量计数值，图 2 示例代码的字节码的前十个字节如下图 6 所示，将十六进制的 17 转为十进制的值为 33 (1 * 16^1 + 7 * 16^0 = 33)，排除下标 0，也就是说这个类文件有 32 个常量。<br><img src="https://i.loli.net/2019/10/03/IGVoJLYUSP9a3uH.png" alt="图6"><center>图 6</center><br><strong>常量池数据区</strong>: 数据区是由（constant_pool_count - 1）个 cp_info 结构组成，一个 cp_info 的结构对应一个常量。在字节码中共有 14 种类型的 cp_info ，每种类型的结构都是固定的，如图 7 所示:<br><img src="https://i.loli.net/2019/10/03/VB8KPSiEh6Zzav7.png" alt="图7"><center>图 7</center><br>以 CONSTANT_Utf8_info 为例，它的结构如表 1 所示:</p><table><thead><tr><th>名称</th><th align="left">长度</th><th align="center">值</th></tr></thead><tbody><tr><td>tag</td><td align="left">1 字节</td><td align="center">01 对应图 7 中 CONSTANT_Utf8_info 的<strong>标志栏</strong>中的值</td></tr><tr><td>length</td><td align="left">2 字节</td><td align="center">该 utf8 字符串的长度</td></tr><tr><td>bytes</td><td align="left">length 字节</td><td align="center">length 个字节的具体数据</td></tr></tbody></table><center>表 1</center>首先第一个字节 tag，它的取值对应图 7 中的 Tag，由于它的类型是 CONSTANT_Utf8_info，所以值为 01（十六进制）。接下来两个字节标识该字符串的长度 length，然后 length 个字节为这个字符串具体的值。从图 3 的字节码中摘取一个 cp_info 结构，将它翻译过来后，其含义为: 该常量为 utf8 字符串，长度为 7 字节，数据为: numberA，如图 8 所示:<p><img src="https://i.loli.net/2019/10/03/cgUGTEs5rqm4wQ6.png" alt="图8"><center>图 8</center><br>其它类型的 cp_info 结构在本文不在细说，和 CONSTANT_Utf8_info 的结构大同小异，都是先通过 tag 来标识类型，然后后续的 n 个字节来描述长度和数据。等我们对这些结构比较了解了之后，我们可以通过: <strong>javap -verbose JavaCodeCompilerDemo</strong> 命令查看 JVM 反编译后的完整常量池，可以看到反编译结果可以将每一个 cp_info 结构的类型和值都很明确的呈现出来，如图 9 所示:<br><img src="https://i.loli.net/2019/10/03/XLOV4PnltSoEQ8A.png" alt="图9"><center>图 9</center></p><p><strong>（4）访问标志（access_flag）</strong><br>常量池结束之后的两个字节，描述该 Class 是类还是接口，以及是否被 <strong>Public</strong>、<strong>Abstract</strong>、<strong>Final</strong> 等修饰符修饰。JVM 规范规定了如下表 2 所示的 9 种访问标志。需要注意的是，JVM 并没有穷举所有的访问标志，而是使用 <a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%93%8D%E4%BD%9C#%E6%8C%89%E4%BD%8D%E6%88%96%EF%BC%88OR%EF%BC%89" target="_blank" rel="noopener">按位或</a> 操作来进行描述的，比如某个类的修饰符为 public final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 <strong>0x0001 | 0x0010 = 0x0011</strong>。</p><table><thead><tr><th>标志名称</th><th align="left">标志值</th><th align="center">含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td align="left">0x0001</td><td align="center">字段是否为 public</td></tr><tr><td>ACC_PRIVATE</td><td align="left">0x0002</td><td align="center">字段是否为 private</td></tr><tr><td>ACC_PROTECTED</td><td align="left">0x0004</td><td align="center">字段是否为 protected</td></tr><tr><td>ACC_STATIC</td><td align="left">0x0008</td><td align="center">字段是否为 static</td></tr><tr><td>ACC_FINAL</td><td align="left">0x0010</td><td align="center">字段是否为 final</td></tr><tr><td>ACC_VOLATILE</td><td align="left">0x0040</td><td align="center">字段是否为 volatile</td></tr><tr><td>ACC_TRANSIENT</td><td align="left">0x0080</td><td align="center">字段是否为 transient</td></tr><tr><td>ACC_SYNCHETIC</td><td align="left">0x1000</td><td align="center">字段是否为编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td align="left">0x4000</td><td align="center">字段是否为 enum</td></tr></tbody></table><center>表 2</center><p><strong>（5）当前类名（this_class）</strong><br>访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。</p><p><strong>（6）父类名称（super_class）</strong><br>当前类名的后两个字节，描述父类的全限定名。这两个字节保存的值也是在常量池中的索引值，根据索引值就能在常量池中找到这个类的父类的全限定名。</p><p><strong>（7）接口信息（interfaces）</strong><br>父类名称后的两个字节，描述这个类的接口计数器，即: 当前类或父类实现的接口数量。紧接着的 n 个字节是所有的接口名称的字符串常量在常量池的索引值。</p><p><strong>（8）字段表（field_table）</strong><br>字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的 <a href="https://zh.wikipedia.org/wiki/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">局部变量</a>。字段表也分为两部分，第一部分是两个字节，描述字段个数，第二部分是每个字段的详细信息 <strong>field_info</strong>。字段表结构如图 10 所示:<br><img src="https://i.loli.net/2019/10/03/7qSyCJugf6iWLNc.png" alt="图10"><center>图 10</center><br>以图 3 中的字节码字段表为例，如下图 11 所示。其中字段的访问标志查表 2，002 对应为 Private，通过索引下标在图 9 中常量池分别得到字段名为: numberA，描述符为: I（在JVM 中的I代表 Java 中的 int）。综上，就可以唯一确定出类 <strong>JavaCodeCompilerDemo</strong> 中声明的变量为: <strong>private int numberA</strong> 。<br><img src="https://i.loli.net/2019/10/03/JcOBekuzqwMovAb.png" alt="图11"><center>图 11</center></p><p><strong>（9）方法表（method_table）</strong><br>字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数，第二个部分为每个方法的详细信息。方法的详细信息包括：方法的访问标志、方法名、方法的描述符以及方法的属性，如图 12 所示:<br><img src="https://i.loli.net/2019/10/03/2zmkgxBdhCrweL9.png" alt="图12"><center>图 12</center><br>方法的权限修饰符依然可以通过图 9 的值查询到，方法名和方法的描述符都是常量池的索引值，可以通过索引值在常量池中查询得到。而方法属性这个部分比较复杂，我们可以借助 <strong>javap -verbose</strong> 将其反编译为人们可读的信息进行解读。如图 13 所示。我们可以看到属性中包含三个部分:</p><ol><li><strong>Code 区</strong>: 源代码对应的 JVM 指令操作码，我们在字节码增强的时候重点操作的就是这个部分。</li><li><strong>LineNumberTable</strong>: 行号表，将 Code 区的操作码和源代码的行号对应，Debug 时会起到作用（即: 当源代码向下走一行，相应的需要走几个 JVM 指令操作码）。 </li><li><strong>LocalVariableTable</strong>: 本地变量表，包含 this 和局部变量，之所以可以在每一个非 static 的方法内部都可以调用到 this，是因为 JVM 将 this 作为每个方法的第一个参数隐式进行传入。<br><img src="https://i.loli.net/2019/10/03/Vza6e1xhFGsg9HJ.png" alt="图13"><center>图 13</center></li></ol><p><strong>（10）附加属性表（additional_attribute_table）</strong><br>字节码的最后一部分，存放了在文件中类或接口所定义的属性的基本信息。</p><h4 id="1-3-Java-字节码操作集合"><a href="#1-3-Java-字节码操作集合" class="headerlink" title="1.3 Java 字节码操作集合"></a>1.3 Java 字节码操作集合</h4><p>在图 13 中，Code 区的编号是 0 ~ 10，就是 .java 源文件的方法源代码编译后让 JVM 真正执行的操作码。为了帮助人们理解，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码和助记符的对应关系，以及每个操作码的具体作用可以查看 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Oracle 官网</a>，在需要的时候查阅即可。比如上图 13 的助记符为 iconst_2，对应图 3 中的字节码 0x05，作用是将 int 值 2 压入操作数栈中。以此类推，对 0 ~ 10 的助记符理解后就是整个 <strong>sum()</strong> 方法的操作数码实现。</p><h4 id="1-4-查看字节码工具"><a href="#1-4-查看字节码工具" class="headerlink" title="1.4 查看字节码工具"></a>1.4 查看字节码工具</h4><p>如果我们每次反编译都要使用 <strong>javap</strong> 命令的话，确实比较繁琐，这里我推荐大家一个 IDEA 插件: <a href="https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer" target="_blank" rel="noopener">jclasslib</a>。使用效果如图 14 所示: 代码编译后在菜单栏: <strong>View</strong> -&gt; <strong>Show Bytecode With jclasslib</strong>，可以很直观地看到当前字节码文件的类信息、常量池、方法区等信息，非常方便。<br><img src="https://i.loli.net/2019/10/03/Xj5kUt6eO2ysYCb.png" alt="图14"><center>图 14</center></p><h4 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h4><p>Java 中字节码文件是 JVM 执行引擎的数据入口，也是 Java 技术体系的基础构成之一。了解字节码文件的组成结构对后面进一步了解虚拟机和深入学习 Java 有很重要的意义。本文较为详细的讲解了字节码文件结构的各个组成部分，以及每个部分的定义、数据结构和使用方法。强烈建议自己动手分析一下，会理解得更加深入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-什么是字节码？&quot;&gt;&lt;a href=&quot;#1-1-什么是字节码？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是字节码？&quot;&gt;&lt;/a&gt;1.1 什么是字节码？&lt;/h4&gt;&lt;p&gt;Java 在刚刚诞生之时曾经提出过一个非常著名的口号: “&lt;strong&gt;一次编写，到处运行（write once，run anywhere）&lt;/strong&gt;”，这句话充分表达了软件开发人员对冲破平台界限的渴求。“与平台无关”的理想最终实现在操作系统的运用层上: 虚拟机提供商开发了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写到处运行”。&lt;br&gt;&lt;br&gt;各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—&lt;strong&gt;字节码（ByteCode）&lt;/strong&gt;，因此，可以看出字节码对 Java 生态的重要性。之所以被称为字节码，是因为字节码是由十六进制组成的，而 JVM（Java Virtual Machine）以两个十六进制为一组，即以字节为单位进行读取。在 Java 中使用 &lt;strong&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;javac&lt;/a&gt;&lt;/strong&gt; 命令把源代码编译成字节码文件，一个 .java 源文件从编译成 .class 字节码文件的示例如图 1 所示:&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/10/03/jcIPJSvYnd2ayOi.png&quot; alt=&quot;图1&quot;&gt;&lt;center&gt;图 1&lt;/center&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="https://www.mghio.cn/post/b1d4025b.html"/>
    <id>https://www.mghio.cn/post/b1d4025b.html</id>
    <published>2019-10-01T15:24:11.000Z</published>
    <updated>2019-10-03T05:23:44.943Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Hello World ~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloWorld&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello World ~~~&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
</feed>
