<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mghio&#39;s blog</title>
  
  <subtitle>JAVA 搬运工 &amp; 终身学习者。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mghio.cn/"/>
  <updated>2020-01-12T06:12:33.131Z</updated>
  <id>https://www.mghio.cn/</id>
  
  <author>
    <name>mghio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDEA 最新版（2019.3）激活教程</title>
    <link href="https://www.mghio.cn/post/f440d00b.html"/>
    <id>https://www.mghio.cn/post/f440d00b.html</id>
    <published>2020-01-12T00:28:07.000Z</published>
    <updated>2020-01-12T06:12:33.131Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>相信做 <code>Java</code> 开发的朋友们绝大部分人应该都是用 <a href="https://www.jetbrains.com/idea" target="_blank" rel="noopener">IntelliJ IDEA</a> 作为开发工具，没用过的朋友们建议将你的开发工具换成这个，关于它的优点可以去 <code>Google</code> 一下，我之前都是用 <a href="https://www.eclipse.org" target="_blank" rel="noopener">Eclipse</a> 作为开发工具，自从用过一次 <code>IDEA</code> 之后就再也回不去了。。。今天早上<del>更新</del>（作死）了一下 <code>IDEA</code> 到最新版（<code>2019.3.1</code>），安装完毕之后进入就提示说之前的激活码失效了，经过一顿搜索之后终于成功激活了，在此记录一下激活过程。</p><p><img src="https://i.loli.net/2020/01/12/mFe5thxWnykXUY6.png" alt="start_welcome.png"></p><a id="more"></a><h4 id="Step-1-升级-IDEA-到-2019-3-版本"><a href="#Step-1-升级-IDEA-到-2019-3-版本" class="headerlink" title="Step 1 升级 IDEA 到 2019.3 版本"></a>Step 1 升级 IDEA 到 2019.3 版本</h4><p>如果之前电脑安装过 <code>IDEA</code>，依次选择菜单项 <code>IntelliJ IDEA -&gt; About IntelliJ IDEA</code> 查看 <code>IDEA</code> 的版本（<code>PS: windows 系统菜单项可能不同</code>），如果不是 <code>2019.3</code> 版本，则要到 <a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">官网</a> 下载 <code>2019.3.1</code> 版本，具体安装过程比较简单，安装过程有问题的朋友们请自行 <code>Google</code>。</p><p><img src="https://i.loli.net/2020/01/12/15uoLas2jgX9DYl.png" alt="about_idea.png"></p><h4 id="Step-2-下载补丁包"><a href="#Step-2-下载补丁包" class="headerlink" title="Step 2 下载补丁包"></a>Step 2 下载补丁包</h4><p>扫码关注微信公众号 <code>mghio</code> 后回复「<code>idea</code>」获取激活补丁包。</p><p><img src="http://q2epkjatk.bkt.clouddn.com/wechat_subscriber.jpg" alt="mghio_wechat_subscriber"></p><h4 id="Step-3-编辑-IDEA-的-idea-vmoptions-文件"><a href="#Step-3-编辑-IDEA-的-idea-vmoptions-文件" class="headerlink" title="Step 3 编辑 IDEA 的 idea.vmoptions 文件"></a>Step 3 编辑 <code>IDEA</code> 的 <code>idea.vmoptions</code> 文件</h4><p>经过 <code>Step 1</code> 安装完成之后，打开 <code>IDEA</code> 开发工具，然后它会提示要激活，这里我们先选择 <code>试用 30 天</code>。</p><p><img src="https://i.loli.net/2020/01/12/VmzJvbaqtU8PdlM.png" alt="use_evaluate_free.png"></p><p>然后将 <code>Step 2</code> 我们下载好的激活补丁包 <code>jetbrains-agent.jar</code> 拷贝到 <code>IDEA</code> 安装目录的 <code>bin</code> 目录下。</p><p><img src="https://i.loli.net/2020/01/12/GIcljvdAbg38SpT.png" alt="copy_to_bin.png"></p><p>编辑 <code>IDEA</code> 的 <code>idea.vmoptions</code>（<code>PS:推荐直接从</code>IDEA<code>中编辑</code>），依次选择菜单项 <code>Help -&gt; Edit Custom VM Optons...</code>。</p><p><img src="https://i.loli.net/2020/01/12/jWlQZ9xrho7Uebq.png" alt="config_vm_options.png"></p><p>点击打开编辑，在其内容最后追加如下代码：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="string">javaagent:</span>你的 IDEA 的安装目录<span class="regexp">/bin/</span>jetbrains-agent.jar</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/12/Xj42VQ7MuTRKFNc.png" alt="edit_idea_vmoptions.png"></p><h4 id="Step-4-重启后输入激活码激活"><a href="#Step-4-重启后输入激活码激活" class="headerlink" title="Step 4 重启后输入激活码激活"></a>Step 4 重启后输入激活码激活</h4><p>退出 <code>IDEA</code> 重新启动进入，依次选择菜单项 <code>Help -&gt; Register...</code>。</p><p><img src="https://i.loli.net/2020/01/12/4itcGQqxwFSgTWJ.png" alt="idea_register_enter.png"></p><p>进入后选择 <code>Activation code</code> 以输入激活码方式激活，在第二步 <code>Step 2 下载补丁包</code> 中下载的 <code>txt</code> 文件（<code>文件名：激活码.txt</code>）为激活码，这里也贴一下，激活码如下（<code>PS: 鼠标移至激活码区域，点击右侧 「复制」 按钮即可复制</code>）：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/12/btQoAjC5xzFvgWU.png" alt="activate_success.png"></p><p>部分朋友输入以上激活码后点击激活可能会出现如下报错提示：<code>Your activation code could not be validated（error 1653219）</code>，未出现此错误提示的朋友可以跳过以下步骤。</p><p><img src="https://i.loli.net/2020/01/12/5sxrd3kGpRTCLw6.png" alt="activate_error.png"></p><p>出现此错误是因为没有屏蔽 <code>account.jetbrains.com</code> 的 <code>443</code> 端口，因此修改本地 <code>hosts</code> 文件在其内容追加以下内容即可。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="string">https:</span><span class="comment">//account.jetbrains.com:443</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/12/zrfTvG6gC9HWAZS.png" alt="modify_mac_hosts_file.png"></p><p>修改保存 <code>hosts</code> 文件后，再次激活即可激活。</p><p><img src="https://i.loli.net/2020/01/12/Os3JUgZVYlAXLMG.png" alt="enter_licenses_success.png"></p><h4 id="Step-5-验证是否激活"><a href="#Step-5-验证是否激活" class="headerlink" title="Step 5 验证是否激活"></a>Step 5 验证是否激活</h4><p>重启 <code>IDEA</code> 后，依次选择菜单项 <code>IntelliJ IDEA -&gt; About IntelliJ IDEA</code>，可以看到激活到期日期为：<code>2089-07-08</code>。</p><p><img src="https://i.loli.net/2020/01/12/FW17nLZvjorsUIm.png" alt="activated_display.png"></p><p>至此， <code>IntelliJ IDEA</code> 激活完成。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上激活步骤只针对 <code>IntelliJ IDEA</code> 的 <code>2019.3.1</code> 版本，不同的版本可能无法激活，在激活前请确认好你所使用的 <code>IDEA</code> 版本。激活码和激活补丁包要一起使用，单独使用无效，在激活过程中有问题请在文末留言区留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;相信做 &lt;code&gt;Java&lt;/code&gt; 开发的朋友们绝大部分人应该都是用 &lt;a href=&quot;https://www.jetbrains.com/idea&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IntelliJ IDEA&lt;/a&gt; 作为开发工具，没用过的朋友们建议将你的开发工具换成这个，关于它的优点可以去 &lt;code&gt;Google&lt;/code&gt; 一下，我之前都是用 &lt;a href=&quot;https://www.eclipse.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Eclipse&lt;/a&gt; 作为开发工具，自从用过一次 &lt;code&gt;IDEA&lt;/code&gt; 之后就再也回不去了。。。今天早上&lt;del&gt;更新&lt;/del&gt;（作死）了一下 &lt;code&gt;IDEA&lt;/code&gt; 到最新版（&lt;code&gt;2019.3.1&lt;/code&gt;），安装完毕之后进入就提示说之前的激活码失效了，经过一顿搜索之后终于成功激活了，在此记录一下激活过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/mFe5thxWnykXUY6.png&quot; alt=&quot;start_welcome.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="IDEA" scheme="https://www.mghio.cn/categories/Java/IDEA/"/>
    
      <category term="工具" scheme="https://www.mghio.cn/categories/Java/IDEA/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="IDEA" scheme="https://www.mghio.cn/tags/IDEA/"/>
    
      <category term="工具" scheme="https://www.mghio.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射机制（二）</title>
    <link href="https://www.mghio.cn/post/7528c810.html"/>
    <id>https://www.mghio.cn/post/7528c810.html</id>
    <published>2020-01-04T08:51:05.000Z</published>
    <updated>2020-01-05T14:51:30.490Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上篇 <a href="http://www.mghio.cn/post/102cd3d9.html">Java 反射机制（一）</a> 介绍了一些 <code>Java</code> 反射相关的常用 API ，在知道了如何去使用反射之后，作为一个合格的工程师，下一步肯定是要去了解它的如何实现的，我们今天就来看看在 <code>JDK</code> 源码中是如何去实现反射的(<code>PS:以下源码分析基于 JDK1.8</code>)。</p><h4 id="Field-类-set-方法的实现"><a href="#Field-类-set-方法的实现" class="headerlink" title="Field 类 set 方法的实现"></a>Field 类 set 方法的实现</h4><p><code>Field</code> 类的 <code>set</code> 方法是在运行时用来动态修改一个类的属性的值，进入到 <code>Field</code> 类的 <code>set</code> 方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getFieldAccessor(obj).set(obj, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据 <code>override</code> 判断是否需要检查字段的访问权限，然后通过 <code>getFieldAccessor</code> 方法获得一个 <code>FieldAccessor</code> 字段访问者对象，最后调用的是 <code>FieldAccessor</code> 类的 <code>set</code> 方法进行下一步操作的，<code>FieldAccessor</code> 是一个接口，定义了对字段的一些操作，该接口有如下一些实现类：</p><a id="more"></a><p><img src="https://i.loli.net/2020/01/04/Dj24fGFKh8Qdzgb.png" alt="fieldaccessor_implements.png"></p><p>要看 <code>set</code> 到底调用的是哪个实现类的方法，那么我们需要看看 <code>getFieldAccessor()</code> 返回的是哪个类的对象，下面是 <code>getFieldAccessor</code> 方法的源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// security check is done before calling this method</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldAccessor <span class="title">getFieldAccessor</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ov = override;</span><br><span class="line">    FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;</span><br><span class="line">    <span class="keyword">return</span> (a != <span class="keyword">null</span>) ? a : acquireFieldAccessor(ov);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先通过 <code>override</code> 来获取不同的缓存的 <code>FieldAccessor</code>，其中 <code>overrideFieldAccessor</code> 代表本类覆盖父类的字段访问者对象缓存，<code>fieldAccessor</code> 是本类的字段访问器对象缓存。如果缓存存在的话就直接复用之前的对象，否则就调用 <code>Field</code> 类的 <code>acquireFieldAccessor</code> 方法获取。我们进入到 <code>acquireFieldAccessor</code> 方法中看看，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FieldAccessor <span class="title">acquireFieldAccessor</span><span class="params">(<span class="keyword">boolean</span> overrideFinalCheck)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    FieldAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getFieldAccessor(overrideFinalCheck);</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (overrideFinalCheck)</span><br><span class="line">            overrideFieldAccessor = tmp;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fieldAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newFieldAccessor(<span class="keyword">this</span>, overrideFinalCheck);</span><br><span class="line">        setFieldAccessor(tmp, overrideFinalCheck);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>acquireFieldAccessor</code> 的源码中我们可以看到，先判断是否已存在 <code>FieldAccessor</code> 对象，如果存在的话那么就会复用之前的 <code>FieldAccessor</code> 对象，否则就使用 <code>reflectionFactory</code> 工厂的 <code>newFieldAccessor</code> 方法生成一个新的 <code>FieldAccessor</code> 对象出来。所以我们就要进到 <code>newFieldAccessor</code> 方法里面看看是如何生成的，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field var1, <span class="keyword">boolean</span> var2)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    <span class="keyword">return</span> UnsafeFieldAccessorFactory.newFieldAccessor(var1, var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>newFieldAccessor</code> 方法代码可以得知，在方法里面是通过 <code>UnsafeFieldAccessorFactory</code> 类的 <code>static</code> 方法 <code>newFieldAccessor</code> 来生产 <code>FieldAccessor</code> 的，那么我们继续进入到 <code>UnsafeFieldAccessorFactory</code> 类的 <code>newFieldAccessor</code> 方法里面看看，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field var0, <span class="keyword">boolean</span> var1)</span> </span>&#123;</span><br><span class="line">    Class var2 = var0.getType();</span><br><span class="line">    <span class="keyword">boolean</span> var3 = Modifier.isStatic(var0.getModifiers());</span><br><span class="line">    <span class="keyword">boolean</span> var4 = Modifier.isFinal(var0.getModifiers());</span><br><span class="line">    <span class="keyword">boolean</span> var5 = Modifier.isVolatile(var0.getModifiers());</span><br><span class="line">    <span class="keyword">boolean</span> var6 = var4 || var5;</span><br><span class="line">    <span class="keyword">boolean</span> var7 = var4 &amp;&amp; (var3 || !var1);</span><br><span class="line">    <span class="keyword">if</span> (var3) &#123;</span><br><span class="line">      UnsafeFieldAccessorImpl.unsafe.ensureClassInitialized(var0.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (!var6) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var2 == Boolean.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticBooleanFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Byte.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticByteFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Short.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticShortFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Character.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticCharacterFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Integer.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticIntegerFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Long.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticLongFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Float.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticFloatFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (FieldAccessor)(var2 == Double.TYPE ? <span class="keyword">new</span> UnsafeStaticDoubleFieldAccessorImpl(var0) : <span class="keyword">new</span> UnsafeStaticObjectFieldAccessorImpl(var0));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 剩下的部分省略...</span></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上 <code>UnsafeFieldAccessorFactory</code> 类的 <code>newFieldAccessor</code> 方法代码可以看出，方法里面通过类的字段修饰符类型和字段的类类型共同决定返回的 <code>FieldAccessor</code> 实现类，这里要注意一下方法里面这几个变量的含义：</p><ul><li>var3（isStatic）：静态属性，也就是 <code>static</code> 关键字修饰的属性。</li><li>var4（isFinal）：<code>final</code> 关键字修饰的属性。</li><li>var5（isVolatile）：<code>valatile</code> 关键字修饰的属性。</li><li>var6（isQualified）：<code>valatile</code> 关键字或者 <code>final</code> 关键字修饰的属性。</li><li>var7 (isReadOnly)：是否只读属性，<code>final</code> 关键字修饰的属性或者 <code>static</code> 关键字修饰并且不能覆盖（<code>override = false</code>）的属性</li></ul><p>举一个例子，假设在一个类中的字段声明为 <code>public static String name</code>，那么返回的字段访问器为 <code>UnsafeStaticCharacterFieldAccessorImpl</code>，我们看看这个类的 <code>set</code> 方法是如何实现的，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object var1, Object var2)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFinal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.throwFinalFieldIllegalAccessException(var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.throwSetIllegalArgumentException(var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var2 <span class="keyword">instanceof</span> Character) &#123;</span><br><span class="line">      unsafe.putChar(<span class="keyword">this</span>.base, <span class="keyword">this</span>.fieldOffset, (Character)var2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.throwSetIllegalArgumentException(var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面方法的代码得知，方法最终还是通过 <code>Unsafe</code> 类的 <code>native</code> 方法 <code>putChar(Object var1, long var2, char var4)</code> 来实现的，有关 <code>Unsafe</code> 类的介绍请看这篇文章（<a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html" target="_blank" rel="noopener">Java魔法类：Unsafe应用解析</a>）。</p><h4 id="Method-类-invoke-方法的实现"><a href="#Method-类-invoke-方法的实现" class="headerlink" title="Method 类 invoke 方法的实现"></a>Method 类 invoke 方法的实现</h4><p><code>Method</code> 类的 <code>invoke</code> 方法用来在运行时动态调用对象的方法，我们进入到 <code>Method</code> 类的 <code>invoke</code> 方法中看看在 <code>JDK</code> 中到底是怎么做的，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上方法代码我们可以看到，和上文说的的 <code>Field</code> 类一样，首先也是先根据 <code>override</code> 进行了一些权限检查，最后调用的是 <code>MethodAccessor</code> 的 <code>invoke</code> 方法进行处理，这个方法访问器 <code>MethodAccessor</code> 是一个接口，它只有一个操作方法调用的 <code>invoke</code> 方法，它有如下三个实现类：</p><p><img src="https://i.loli.net/2020/01/05/qNho7AfvJU4nGQW.png" alt="methodaccessor_implements.png"></p><p>要想知道 <code>ma.invoke</code> 具体调用的是哪个类的方法，我们需要看看方法 <code>acquireMethodAccessor</code> 返回的对象是哪个，该方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    MethodAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getMethodAccessor();</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        methodAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</span><br><span class="line">        setMethodAccessor(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上方法 <code>acquireMethodAccessor</code> 的源码可以看出，首先会先先判断是否已经存在了对应的 <code>MethodAccessor</code> 对象，如果有就会复用这个对象，否则就调用工厂 <code>reflectionFactory</code> 的 <code>newMethodAccessor</code> 方法生成一个 <code>MethodAccessor</code> 对象出来。那么我们就需要进入到方法 <code>newMethodAccessor</code> 中，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method var1)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      NativeMethodAccessorImpl var2 = <span class="keyword">new</span> NativeMethodAccessorImpl(var1);</span><br><span class="line">      DelegatingMethodAccessorImpl var3 = <span class="keyword">new</span> DelegatingMethodAccessorImpl(var2);</span><br><span class="line">      var2.setParent(var3);</span><br><span class="line">      <span class="keyword">return</span> var3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法 <code>newMethodAccessor</code> 的代码可以看到，方法首先是使用 <code>Method</code> 对象作为入参生成了 <code>NativeMethodAccessorImpl</code> 对象，然后再使用 <code>NativeMethodAccessorImpl</code> 对象作为入参生成了 <code>DelegatingMethodAccessorImpl</code> 对象。这个使用了<code>代理模式</code>，将 <code>NativeMethodAccessorImpl</code> 交给了 <code>DelegatingMethodAccessorImpl</code> 类进行了代理，进入到代理类 <code>DelegatingMethodAccessorImpl</code> 中可以看到：</p><p><img src="https://i.loli.net/2020/01/05/iOXY41amPClUj7F.png" alt="delegatingmethodaccessorimpl.png"></p><p>从上面的红色方框可以看到，在类 <code>DelegatingMethodAccessorImpl</code> 的构造方法中将参数赋值给类中的 <code>delegate</code> 属性，所有上所说的 <code>ma.invoke</code> 最终会进入到 <code>DelegatingMethodAccessorImpl</code> 代理类的 <code>invoke</code>，方法里调用的是 <code>delegate</code> 属性的 <code>invoke</code> 方法，该属性声明的类型为抽象类 <code>MethodAccessorImpl</code>，它有如下两个实现类： </p><p><img src="https://i.loli.net/2020/01/05/HVpQ48Pmv9MIKG3.png" alt="methodaccessorimpl_implements.png"></p><p>按照上文所说的，这里的 <code>delegate</code> 属性是 <code>NativeMethodAccessorImpl</code> 对象，那么就进入到 <code>NativeMethodAccessorImpl</code> 的 <code>invoke</code> 方法中，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">      MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">      <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 <code>NativeMethodAccessorImpl</code> 的 <code>invoke</code> 方法会先判断此次调用是否超过 <code>ReflectionFactory.inflationThreshold()</code> 方法返回的阈值（<code>PS：默认的阈值大小为 15</code>），如果超过了该阈值，则使用方法访问生成器重新生成一个 <code>MethodAccessorImpl</code>，并将 <code>DelegatingMethodAccessorImpl</code> 的 <code>delegate</code> 属性指向这个新生成的 <code>MethodAccessorImpl</code> 对象。从 <code>Reflectionfactory</code> 工厂类的一下注释：</p><p><img src="https://i.loli.net/2020/01/05/gxE8bmp9s5Ydt1P.png" alt="reflectionfactory_doc.png"></p><p>可以得知 <code>JVM</code> 初次加载字节码实现反射的时候，使用 <code>Method.invoke</code> 和 <code>Constructor.newInstance</code> 方式加载所花费的时间是使用原生代码加载所花费的时间的 3 - 4 倍。这也就是我们平常说为什么频繁使用反射的应用需要花费更多的时间。<code>JVM</code> 作者们为了避免这种花费较长的加载时间，我们在第一次加载的时候重用了 <code>JVM</code> 的入口，之后切换到字节码实现的实现。<br>正如注释所述，在 <code>MethodAccessor</code> 接口的实现中，有两个不同的版本，一个 <code>Java</code> 实现的，一个是 <code>Native</code> 实现的。<code>Java</code> 版本实现的版本在初始化的时需要比较多的时间，但长久来说性能会更好一些；而 <code>Native</code> 版本则正好相反，在初始化时相对较快，但是在运行一段时间之后性能就不如 <code>Java</code> 版本的了。为了权衡两种版本的特性，<code>sun</code> 公司的 <code>JDK</code> 使用了 <code>inflation</code> 机制，让 <code>Java</code> 方法在被反射调用时，开头的几次调用使用 <code>native</code> 版，等反射调用次数超过阈值时则生成一个专用的 <code>MethodAccessor</code> 实现类，生成其中的 <code>invoke</code> 方法的字节码，以后对该 <code>Java</code> 方法的反射调用就会使用 <code>Java</code> 版。 </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍反射调用 <code>set(Object obj, Object value)</code> 方法和 <code>invoke(Object obj, Object... args)</code> 方法的底层实现，由于水平有限本人暂时还没有能力分析 <code>JVM</code> 的实现，这里只分析到最终 <code>native</code> 方法的调用。底层会依赖到 <code>Unsafe</code> 类来执行一些低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 <code>Java</code> 运行效率、增强 <code>Java</code> 语言底层资源操作能力方面起到了很大的作用。对于属性反射的方法 <code>setXXX</code> 和 <code>getXXX</code> 的实现分别对应 <code>Unsafe</code> 类的 <code>putXXX</code> 和 <code>getXXX</code> 方法，也就是说完全依赖 <code>Unsafe</code> 类中的 <code>native</code> 方法来实现的；对于方法反射的方法 <code>invoke</code> 底层调用的是 <code>NativeMethodAccessorImpl</code> 类的 <code>invoke0</code> 的 <code>native</code> 方法来实现的。对于反射构造器调用的实现，读者可以自己进入其源码进行分析，大体上和反射方法调用的实现类似。</p><hr><p>参考文章</p><ul><li><a href="https://www.cnblogs.com/onlywujun/p/3519037.html" target="_blank" rel="noopener">JAVA深入研究——Method的Invoke方法。</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在上篇 &lt;a href=&quot;http://www.mghio.cn/post/102cd3d9.html&quot;&gt;Java 反射机制（一）&lt;/a&gt; 介绍了一些 &lt;code&gt;Java&lt;/code&gt; 反射相关的常用 API ，在知道了如何去使用反射之后，作为一个合格的工程师，下一步肯定是要去了解它的如何实现的，我们今天就来看看在 &lt;code&gt;JDK&lt;/code&gt; 源码中是如何去实现反射的(&lt;code&gt;PS:以下源码分析基于 JDK1.8&lt;/code&gt;)。&lt;/p&gt;
&lt;h4 id=&quot;Field-类-set-方法的实现&quot;&gt;&lt;a href=&quot;#Field-类-set-方法的实现&quot; class=&quot;headerlink&quot; title=&quot;Field 类 set 方法的实现&quot;&gt;&lt;/a&gt;Field 类 set 方法的实现&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Field&lt;/code&gt; 类的 &lt;code&gt;set&lt;/code&gt; 方法是在运行时用来动态修改一个类的属性的值，进入到 &lt;code&gt;Field&lt;/code&gt; 类的 &lt;code&gt;set&lt;/code&gt; 方法的源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj, Object value)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IllegalArgumentException, IllegalAccessException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!override) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            checkAccess(caller, clazz, obj, modifiers);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getFieldAccessor(obj).set(obj, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;首先根据 &lt;code&gt;override&lt;/code&gt; 判断是否需要检查字段的访问权限，然后通过 &lt;code&gt;getFieldAccessor&lt;/code&gt; 方法获得一个 &lt;code&gt;FieldAccessor&lt;/code&gt; 字段访问者对象，最后调用的是 &lt;code&gt;FieldAccessor&lt;/code&gt; 类的 &lt;code&gt;set&lt;/code&gt; 方法进行下一步操作的，&lt;code&gt;FieldAccessor&lt;/code&gt; 是一个接口，定义了对字段的一些操作，该接口有如下一些实现类：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="反射" scheme="https://www.mghio.cn/categories/Java/%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="反射" scheme="https://www.mghio.cn/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射机制（一）</title>
    <link href="https://www.mghio.cn/post/102cd3d9.html"/>
    <id>https://www.mghio.cn/post/102cd3d9.html</id>
    <published>2019-12-29T06:00:29.000Z</published>
    <updated>2019-12-31T04:30:05.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在 <code>Java</code> 中有两种方式可以让我们在运行时识别对象和类的信息。一种是 <code>RTTI</code>（运行时类型识别：Run-Time Type Identification），它假定了我们在编译时已经知道了所有的类型；另一种是我们本文要说的<code>反射机制</code>，它允许我们在运行时获取和使用类的信息。无论是 <code>RTTI</code> 还是<code>反射</code>，其本质都是一样的，都是去动态的获取类的信息。它们唯一不同的是，<code>RTTI</code> 在编译时期知道要解析的类型，而<code>反射</code>是在运行时才知道要解析的类型。</p><h4 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h4><p>反射就是把 <code>Java</code> 类中的各个部分（属性、方法、构造方法等）映射成一个个对象。<code>Class</code> 类与 <code>java.lang.reflect</code> 类库一起对反射的概念提供了支持，类库中包含了 <code>Field</code>、<code>Method</code> 及 <code>Constructor</code> 类，每个类都实现了 <code>Member</code> 接口。这些类型的对象都是由 <code>JVM</code> 运行时创建的，用来表示未知类里对应的成员。这样我们就可以使用 <code>Constructor</code> 创建新的对象，用 <code>get</code> 和 <code>set</code> 方法读取和修改类中与 <code>Field</code> 对象关联的字段，用 <code>invoke</code> 方法调用类中与 <code>Method</code> 对象关联的方法等。<br><code>Java</code> 反射机制是在运行状态中的，对于任意一个类我们可以通过反射获取这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。重要的是，要认识到反射机制并没有什么特别之处，当我们通过反射和一个未知类型的对象打交道时，<code>JVM</code> 只是简单的对这个对象做检查，看它属于哪个类，在用它做其它事情之前必须先加载那个类 <code>Class</code> 对象。所以那个类的字节码文件对象对于 <code>JVM</code> 来说必须是可获取的，要么在本地机器上，要么通过网络获取。</p><a id="more"></a><h4 id="反射-API-的使用"><a href="#反射-API-的使用" class="headerlink" title="反射 API 的使用"></a>反射 API 的使用</h4><p>想要通过反射获取一个类的信息之前，首先要先获取这个类的 <code>Class</code> 对象，在 <code>Java</code> 中所有类型都有与之关联的 <code>Class</code> 对象。</p><h5 id="获取类的-Class-对象"><a href="#获取类的-Class-对象" class="headerlink" title="获取类的 Class 对象"></a>获取类的 Class 对象</h5><p>在 <code>Java</code> 中获取一个类的 <code>Class</code> 对象有三种方式：<br><strong>第 ① 种</strong> 使用 <code>Class</code> 类的 <code>forName</code> 静态方法，当我们知道一个类的全路径时，可以通过 <code>Class.forName</code> 方法获取类的 <code>Class</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class stringClass = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">System.out.println(stringClass);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 使用 <code>.class</code> 获取，这种方式只适合在编译前就已经知道了要操作的 <code>Class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class stringClass = String.class;</span><br><span class="line">System.out.println(stringClass);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br></pre></td></tr></table></figure><p><strong>第 ③ 种</strong> 使用 <code>getClass()</code> 方法获取 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class stringClass = <span class="string">"mghio"</span>.getClass();</span><br><span class="line">System.out.println(stringClass);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br></pre></td></tr></table></figure><h5 id="通过反射创建类对象"><a href="#通过反射创建类对象" class="headerlink" title="通过反射创建类对象"></a>通过反射创建类对象</h5><p>通过反射创建类对象有两种方式：</p><p><strong>第 ① 种</strong> 通过调用 <code>Class</code> 对象的 <code>newInstance()</code> 方法创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Person person = personClass.newInstance();</span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 通过调用 <code>Constructor</code> 对象的 <code>newInstance()</code> 方法创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Constructor personConstructor = personClass.getConstructor();</span><br><span class="line">Person person = (Person) personConstructor.newInstance();</span><br></pre></td></tr></table></figure><p>两者的区别是，通过 <code>Class</code> 的 <code>newInstance</code> 方法只能通过无参构造方法创建，这就要求这个类必须有一个无参的构造方法，而通过 <code>Constructor</code> 的 <code>newInstance</code> 可以指定参数来选择特定的构造方法来创建对象。以下代码就是指定参数然后通过特定的构造方法创建对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Constructor personConstructor = personClass.getConstructor();</span><br><span class="line">Person person = (Person) personConstructor.newInstance(<span class="string">"mghio"</span>, <span class="string">"中国上海"</span>);</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的属性"><a href="#通过反射获取类的属性" class="headerlink" title="通过反射获取类的属性"></a>通过反射获取类的属性</h5><p><code>Class</code> 类提供了两种方式获取一个类的属性。<br><strong>第 ① 种</strong> 是通过 <code>Class</code> 对象的 <code>getFields</code> 方法获取类的属性，该方法只能获取类的 <code>public</code> 属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Field[] fields = personClass.getFields();</span><br><span class="line">System.out.println(Arrays.toString(fields));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.id, </span><br><span class="line"><span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.name]</span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 是通过 <code>Class</code> 对象的 <code>getDeclaredFields</code> 方法获取类的属性，该方法可以获取类的所有属性（包括 <code>private</code> 修饰的属性）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Field[] fields = personClass.getDeclaredFields();</span><br><span class="line">System.out.println(Arrays.toString(fields));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.id, </span><br><span class="line"><span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.name, </span><br><span class="line"><span class="keyword">protected</span> java.lang.Integer cn.mghio.blogmghiocode.reflect.Person.age, </span><br><span class="line"><span class="keyword">private</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.address]</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的方法"><a href="#通过反射获取类的方法" class="headerlink" title="通过反射获取类的方法"></a>通过反射获取类的方法</h5><p><code>Class</code> 也提供了两种方式获取类的方法。<br><strong>第 ① 种</strong> 是通过 <code>Class</code> 对象的 <code>getMethods</code> 方法获取类的方法（包括继承而得的方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Method[] methods = personClass.getMethods();</span><br><span class="line">System.out.println(Arrays.toString(methods));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.toString(), </span><br><span class="line"><span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.getAddress(), </span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass(), </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()]</span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 是通过 <code>Class</code> 对象的 <code>getDeclaredMethods</code> 方法获取类的方法（只包含类中定义的方法，不包含继承而来的方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Method[] methods = personClass.getDeclaredMethods();</span><br><span class="line">System.out.println(Arrays.toString(methods));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.toString(), </span><br><span class="line"><span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.getAddress(), </span><br><span class="line">... </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> cn.mghio.blogmghiocode.reflect.Person.protectedMethod(), </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> cn.mghio.blogmghiocode.reflect.Person.privateMethod()]</span><br></pre></td></tr></table></figure><p>从以上结果可以看出这个方法只获取当前类中定义的方法，包含 <code>private</code> 方法，不会获取从父类中继承而来的方法。</p><h5 id="通过反射获取类的构造方法"><a href="#通过反射获取类的构造方法" class="headerlink" title="通过反射获取类的构造方法"></a>通过反射获取类的构造方法</h5><p><code>Class</code> 也提供了两种方式获取类的构造方法。<br><strong>第 ① 种</strong> 是通过 <code>Class</code> 对象的 <code>getConstructors</code> 方法获取类的构造方法（只能获取当前类的 <code>public</code> 构造方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Constructor[] constructors = personClass.getConstructors();</span><br><span class="line">System.out.println(Arrays.toString(constructors));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> cn.mghio.blogmghiocode.reflect.Person(java.lang.String,java.lang.String,java.lang.Integer,java.lang.String)]</span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 是通过 <code>Class</code> 对象的 <code>getDeclaredConstructors</code> 方法获取类的构造方法（只包含类中定义的所有构造方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Constructor[] constructors = personClass.getDeclaredConstructors();</span><br><span class="line">System.out.println(Arrays.toString(constructors));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> cn.mghio.blogmghiocode.reflect.Person(java.lang.String,java.lang.String,java.lang.Integer,java.lang.String), </span><br><span class="line"><span class="keyword">protected</span> cn.mghio.blogmghiocode.reflect.Person(java.lang.String,java.lang.String), </span><br><span class="line"><span class="keyword">private</span> cn.mghio.blogmghiocode.reflect.Person()]</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的类名"><a href="#通过反射获取类的类名" class="headerlink" title="通过反射获取类的类名"></a>通过反射获取类的类名</h5><p><code>Class</code> 类提供了两种方式获取类的类名。<br><strong>第 ① 种</strong> 是通过 <code>getName</code> 方法获取类的全限定名（包含包名）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">String fullPersonClassName = personClass.getName();</span><br><span class="line">System.out.println(fullPersonClassName);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cn.mghio.blogmghiocode.reflect.Person</span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 是通过 <code>Class</code> 对象的 <code>getSimpleName</code> 方法获取类的类名（不包含包名）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">String fullPersonClassName = personClass.getSimpleName();</span><br><span class="line">System.out.println(fullPersonClassName);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的修饰符"><a href="#通过反射获取类的修饰符" class="headerlink" title="通过反射获取类的修饰符"></a>通过反射获取类的修饰符</h5><p>可以通过 <code>Class</code> 类来获取一个类的修饰符，也就是我们熟知的 <code>public</code>、<code>protected</code>、<code>private</code> 等关键字，通过调用 <code>getModifiers</code> 方法来获取一个类的修饰符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"><span class="keyword">int</span> modifyInt = personClass.getModifiers();</span><br><span class="line">System.out.println(modifyInt);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>返回 <code>1</code> 表示类 <code>Person</code> 的修饰符为 <code>public</code>，修饰符在 <code>Modifier</code> 类中都被包装成一个 <code>int</code> 类型的数字，部分修饰符定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The &#123;<span class="doctag">@code</span> int&#125; value representing the &#123;<span class="doctag">@code</span> public&#125;</span></span><br><span class="line"><span class="comment">  * modifier.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC           = <span class="number">0x00000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The &#123;<span class="doctag">@code</span> int&#125; value representing the &#123;<span class="doctag">@code</span> private&#125;</span></span><br><span class="line"><span class="comment">  * modifier.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIVATE          = <span class="number">0x00000002</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The &#123;<span class="doctag">@code</span> int&#125; value representing the &#123;<span class="doctag">@code</span> protected&#125;</span></span><br><span class="line"><span class="comment">  * modifier.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROTECTED        = <span class="number">0x00000004</span>;</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的包信息"><a href="#通过反射获取类的包信息" class="headerlink" title="通过反射获取类的包信息"></a>通过反射获取类的包信息</h5><p><code>Class</code> 对象通过 <code>getPackage</code> 方法获取类的包相关信息，可以使用 <code>Class</code> 对象通过如下的方式获取包信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Package packageClazz = personClass.getPackage();</span><br><span class="line">System.out.println(packageClazz.getName());</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cn.mghio.blogmghiocode.reflect</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的父类"><a href="#通过反射获取类的父类" class="headerlink" title="通过反射获取类的父类"></a>通过反射获取类的父类</h5><p>可以通过 <code>Class</code> 类来获取一个类的父类，通过调用 <code>getModifiers</code> 方法来获取一个类的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Class superclass = personClass.getSuperclass();</span><br><span class="line">System.out.println(superclass.getName());</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br></pre></td></tr></table></figure><p>以上运行结果表示 <code>Person</code> 类的父类是 <code>Object</code> 类，可以看到 <code>superclass</code> 对象其实就是一个 <code>Class</code> 类的实例，所以也可以继续在这个对象上进行反射操作。</p><h5 id="通过反射获取类的实现接口"><a href="#通过反射获取类的实现接口" class="headerlink" title="通过反射获取类的实现接口"></a>通过反射获取类的实现接口</h5><p>可以通过 <code>Class</code> 类来获取一个类的父类，通过调用 <code>getInterfaces</code> 方法来获取一个类实现的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Class&lt;?&gt;[] interfaces = personClass.getInterfaces();</span><br><span class="line">System.out.println(Arrays.toString(interfaces));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[interface cn.mghio.blogmghiocode.reflect.IPerson]</span><br></pre></td></tr></table></figure><p>在 <code>Java</code> 中一个类可以实现多个接口，因此 <code>getInterfaces</code> 方法返回一个 <code>Class</code> 数组，在 <code>Java</code> 中接口也同样有对应的 <code>Class</code> 对象。这个方法需要注意的是，<code>getInterfaces</code> 方法仅仅只返回当前类所实现的接口。当前类的父类如果实现了接口，这些接口是不会在返回的 <code>Class</code> 集合中的，尽管实际上当前类其实已经实现了父类接口。</p><h5 id="通过反射获取泛型信息"><a href="#通过反射获取泛型信息" class="headerlink" title="通过反射获取泛型信息"></a>通过反射获取泛型信息</h5><p>当我们在声明一个类或者接口的时候可以指定它可以参数化，常用的 <code>List</code> 接口就是一个参数化接口的例子。比如想要检查 <code>List</code> 接口的参数化类型，我们是没有办法能知道它具体的参数化类型是什么。这个类型就可以是一个应用中所有的类型。但是，当你检查一个使用了被参数化的类型的变量或者方法，你可以获得这个被参数化类型的具体参数。<br><strong>第 ① 种 泛型方法返回类型</strong> 当你获得了 <code>Method</code> 对象，那么就可以获取到这个方法的泛型返回类型信息。如果方法是在一个被参数化类型之中（例如: T foo()），那么将无法获得它的具体类型，但是如果方法返回的是一个泛型类（例如：List<string> foo()），那么就可以获得这个泛型类的具体参数化类型。下面这个例子中的类定义了一个返回类型是泛型的方法。</string></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> List&lt;Integer&gt; stringList = Arrays.asList(<span class="number">2</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">90</span>, <span class="number">81</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getStringList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stringList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以获取上面这个类 <code>ReflectGenericDemo</code> 的方法 <code>getStringList</code> 的泛型返回类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemoTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodReturnGenericType</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    Class&lt;ReflectGenericDemo&gt; reflectClass = ReflectGenericDemo.class;</span><br><span class="line">    Method method = reflectClass.getMethod(<span class="string">"getStringList"</span>, (Class&lt;?&gt;) <span class="keyword">null</span>);</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      ParameterizedType type = (ParameterizedType) returnType;</span><br><span class="line">      Type[] typeArguments = type.getActualTypeArguments();</span><br><span class="line">      <span class="keyword">for</span> (Type typeArgument : typeArguments) &#123;</span><br><span class="line">        Class typeArgumentClass = (Class) typeArgument;</span><br><span class="line">        System.out.println(<span class="string">"typeArgumentClass = "</span> + typeArgumentClass);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeArgumentClass = <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span></span></span><br></pre></td></tr></table></figure><p><code>typeArguments</code> 数组只有一个值，这个数组中唯一的值是 <code>Integer</code> 的 <code>Class</code> 类的实例，同时 <code>Class</code> 类也实现了 <code>Type</code> 接口。</p><p><strong>第 ② 种 泛型方法返回类型</strong> 泛型方法参数类型，我们也可以通过反射来获取方法参数的泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> List&lt;Integer&gt; stringList = Arrays.asList(<span class="number">2</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">90</span>, <span class="number">81</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStringList</span><span class="params">(List&lt;Integer&gt; stringList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stringList = stringList;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过以下方式获取方法参数的泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemoTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodParameterGenericType</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    Class&lt;ReflectGenericDemo&gt; reflectClass = ReflectGenericDemo.class;</span><br><span class="line">    Method method = reflectClass.getMethod(<span class="string">"setStringList"</span>, List.class);</span><br><span class="line">    Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">      <span class="keyword">if</span> (genericParameterType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        ParameterizedType parameterizedType = (ParameterizedType) genericParameterType;</span><br><span class="line">        Type[] parameterArgTypes = parameterizedType.getActualTypeArguments();</span><br><span class="line">        <span class="keyword">for</span> (Type parameterArgType : parameterArgTypes) &#123;</span><br><span class="line">          Class parameterArgClass = (Class) parameterArgType;</span><br><span class="line">          System.out.println(<span class="string">"parameterArgClass = "</span> + parameterArgClass);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameterArgClass = <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span></span></span><br></pre></td></tr></table></figure><p><strong>第 ③ 种 泛型变量类型</strong> 可以通过反射来访问类中定义变量的泛型类型，不管这个变量是一个类的静态成员变量或是实例成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt; stringList = Arrays.asList(<span class="number">2</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">90</span>, <span class="number">81</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过以下代码来获取类 <code>ReflectGenericDemo</code> 的私有变量 <code>stringList</code> 的泛型变量类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemoTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFieldGenericType</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    Class&lt;ReflectGenericDemo&gt; reflectClass = ReflectGenericDemo.class;</span><br><span class="line">    Field field = reflectClass.getDeclaredField(<span class="string">"stringList"</span>);</span><br><span class="line">    Type type = field.getGenericType();</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      ParameterizedType fieldGenericType = (ParameterizedType) type;</span><br><span class="line">      Type[] fieldGenericTypes = fieldGenericType.getActualTypeArguments();</span><br><span class="line">      <span class="keyword">for</span> (Type genericType : fieldGenericTypes) &#123;</span><br><span class="line">        Class fieldGenericTypeClass = (Class) genericType;</span><br><span class="line">        System.out.println(fieldGenericTypeClass);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span></span></span><br></pre></td></tr></table></figure><p>数组 <code>fieldGenericTypes</code> 只有一个元素，它代表类 <code>Integer</code> 的 <code>Class</code> 类的实例。我们可以得出通过反射获取泛型信息的套路都是先获取 <code>Class</code> 类对象，然后通过该对象获取相应的类，如果是要获取变量的泛型信息就先获取到 <code>Field</code> 类，如果是要获取方法的泛型信息就先获取到 <code>Method</code> 类，最后再通过是否是 <code>ParameterizedType</code> 的实例来判断是否是泛型类型。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们介绍了 <code>Java</code> 泛型的基本使用，反射可能在我们日常的工作中不怎么接触到，但是，在很多框架中都有运用，比如，<code>Spring</code> 的 <code>IOC/DI</code> 也是反射；还有 <code>JDBC</code> 的 <code>classForName</code> 也是反射。所有深入了解 <code>Java</code> 反射机制很有必要。</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Constructor getConstructor(Class[] params)</td><td align="center">根据构造方法的参数，返回一个 <code>public</code> 类型的构造方法</td></tr><tr><td align="center">Constructor getConstructors()</td><td align="center">返回所有 <code>public</code> 类型的构造方法数组</td></tr><tr><td align="center">Constructor getDeclaredConstructor(Class[] params)</td><td align="center">根据构造方法的参数，返回一个具体的构造方法（所有的类型）</td></tr><tr><td align="center">Constructor getDeclaredConstructors()</td><td align="center">返回该类中所有的构造方法数组（所有的类型）</td></tr><tr><td align="center">Method getMethod(String name, Class[] params)</td><td align="center">根据方法名和参数，返回一个 <code>public</code> 类型的方法</td></tr><tr><td align="center">Method[] getMethods()</td><td align="center">返回所有 <code>public</code> 类型的方法数组</td></tr><tr><td align="center">Method getDeclaredMethod(String name, Class[] params)</td><td align="center">根据方法名和参数，返回一个具体的方法（所有的类型）</td></tr><tr><td align="center">Method[] getDeclaredMethods()</td><td align="center">返回该类中的所有的方法数组（所有的类型）</td></tr><tr><td align="center">Field getField(String name)</td><td align="center">根据变量名，返回一个 <code>public</code> 类型的成员变量</td></tr><tr><td align="center">Field[] getFields()</td><td align="center">返回 <code>public</code> 类型的成员变量的数组</td></tr><tr><td align="center">Field getDeclaredField(String name)</td><td align="center">根据变量名，返回一个成员变量（所有的类型）</td></tr><tr><td align="center">Field[] getDelcaredField()</td><td align="center">返回所有成员变量组成的数组（所有的类型）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;Java&lt;/code&gt; 中有两种方式可以让我们在运行时识别对象和类的信息。一种是 &lt;code&gt;RTTI&lt;/code&gt;（运行时类型识别：Run-Time Type Identification），它假定了我们在编译时已经知道了所有的类型；另一种是我们本文要说的&lt;code&gt;反射机制&lt;/code&gt;，它允许我们在运行时获取和使用类的信息。无论是 &lt;code&gt;RTTI&lt;/code&gt; 还是&lt;code&gt;反射&lt;/code&gt;，其本质都是一样的，都是去动态的获取类的信息。它们唯一不同的是，&lt;code&gt;RTTI&lt;/code&gt; 在编译时期知道要解析的类型，而&lt;code&gt;反射&lt;/code&gt;是在运行时才知道要解析的类型。&lt;/p&gt;
&lt;h4 id=&quot;反射概述&quot;&gt;&lt;a href=&quot;#反射概述&quot; class=&quot;headerlink&quot; title=&quot;反射概述&quot;&gt;&lt;/a&gt;反射概述&lt;/h4&gt;&lt;p&gt;反射就是把 &lt;code&gt;Java&lt;/code&gt; 类中的各个部分（属性、方法、构造方法等）映射成一个个对象。&lt;code&gt;Class&lt;/code&gt; 类与 &lt;code&gt;java.lang.reflect&lt;/code&gt; 类库一起对反射的概念提供了支持，类库中包含了 &lt;code&gt;Field&lt;/code&gt;、&lt;code&gt;Method&lt;/code&gt; 及 &lt;code&gt;Constructor&lt;/code&gt; 类，每个类都实现了 &lt;code&gt;Member&lt;/code&gt; 接口。这些类型的对象都是由 &lt;code&gt;JVM&lt;/code&gt; 运行时创建的，用来表示未知类里对应的成员。这样我们就可以使用 &lt;code&gt;Constructor&lt;/code&gt; 创建新的对象，用 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 方法读取和修改类中与 &lt;code&gt;Field&lt;/code&gt; 对象关联的字段，用 &lt;code&gt;invoke&lt;/code&gt; 方法调用类中与 &lt;code&gt;Method&lt;/code&gt; 对象关联的方法等。&lt;br&gt;&lt;code&gt;Java&lt;/code&gt; 反射机制是在运行状态中的，对于任意一个类我们可以通过反射获取这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。重要的是，要认识到反射机制并没有什么特别之处，当我们通过反射和一个未知类型的对象打交道时，&lt;code&gt;JVM&lt;/code&gt; 只是简单的对这个对象做检查，看它属于哪个类，在用它做其它事情之前必须先加载那个类 &lt;code&gt;Class&lt;/code&gt; 对象。所以那个类的字节码文件对象对于 &lt;code&gt;JVM&lt;/code&gt; 来说必须是可获取的，要么在本地机器上，要么通过网络获取。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="反射" scheme="https://www.mghio.cn/categories/Java/%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="反射" scheme="https://www.mghio.cn/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="https://www.mghio.cn/post/817c7d82.html"/>
    <id>https://www.mghio.cn/post/817c7d82.html</id>
    <published>2019-12-21T04:00:49.000Z</published>
    <updated>2019-12-21T15:52:44.260Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h4><p>作为 <code>Java</code> 后端开发的我们，开发的项目绝大部分都是部署在 <code>Linux</code> 系统上的，因此熟练使用一些常用的 <code>Linux</code> 命令不管是对于日常开发、服务部署或者查找问题都非常有用。以下整理了一些常用的 <code>Linux</code> 常用命令。</p><h4 id="1-2-文件管理"><a href="#1-2-文件管理" class="headerlink" title="1.2 文件管理"></a>1.2 文件管理</h4><h5 id="1-2-1-ls-命令"><a href="#1-2-1-ls-命令" class="headerlink" title="1.2.1 ls 命令"></a>1.2.1 ls 命令</h5><p><code>ls</code> 命令是 <code>Linux</code> 最常用的命令之一，其功能是列出指定目录下的内容及其相关属性信息。默认状态下，<code>ls</code> 命令会列出当前目录的内容，它也可以带上一些参数来实现更多的功能。<br><strong>语法格式</strong>：ls [选项] [文件]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">显示所有文件及目录（包括以 <code>.</code> 开头的隐藏文件）</td></tr><tr><td align="center">-l</td><td align="center">使用长格式列出文件及目录</td></tr><tr><td align="center">-r</td><td align="center">将文件以相反次序显示（默认按照英文字母次序）</td></tr><tr><td align="center">-t</td><td align="center">根据最后的修改时间排序</td></tr><tr><td align="center">-A</td><td align="center">同 <code>-a</code>，但是不列出 <code>.</code>（当前目录）以及 <code>..</code>（父级目录）</td></tr><tr><td align="center">-S</td><td align="center">根据文件大小排序</td></tr><tr><td align="center">-R</td><td align="center">递归列出所有子目录</td></tr></tbody></table><a id="more"></a><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -<span class="keyword">a</span>       # 列出所有文件（包括隐藏文件）</span><br><span class="line"><span class="keyword">ls</span> -<span class="keyword">l</span>       # 列出文件的详细信息</span><br><span class="line"><span class="keyword">ls</span> /        # 列出根目录（/）下的所有目录</span><br><span class="line"><span class="keyword">ls</span> -ltr s*  # 列出当前目录下所有名称是 s 开头的文件</span><br><span class="line"><span class="keyword">ls</span> -AS      # 列出当前目录下所有文件及目录并以文件大小进行排序</span><br></pre></td></tr></table></figure><h5 id="1-2-2-chown-命令"><a href="#1-2-2-chown-命令" class="headerlink" title="1.2.2 chown 命令"></a>1.2.2 chown 命令</h5><p><code>Linux</code> 是一种多用户多任务的操作系统，所有的文件都有一个拥有者。<code>chown</code> 命令就是用来将指定文件的拥有者改为指定的用户或者组（<code>PS：用户和组都可以是名称或者其 ID</code>），文件是以空格分开的要改变权限的文件列表，支持通配符。<br><strong>语法格式</strong>：chown [参数]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-R</td><td align="center">对当前目录下的所有文件与子目录进行相同的拥有者变更</td></tr><tr><td align="center">-c</td><td align="center">若该文件拥有者确实已经更改，才显示其更改动作</td></tr><tr><td align="center">-f</td><td align="center">若该文件拥有者无法更改也不显示错误信息</td></tr><tr><td align="center">-v</td><td align="center">显示拥有者变更的详细信息</td></tr><tr><td align="center">–version</td><td align="center">显示版本</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 将 change_usergroup_and_user_demo.txt 文件用户组与用户都改为 mghio</span><br><span class="line"></span><br><span class="line">[root@mghio ~]# <span class="keyword">ll</span> change_usergroup_and_user_demo.txt</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">56</span> Dec <span class="number">21</span> <span class="number">10</span>:<span class="number">17</span> change_usergroup_and_user_demo.txt</span><br><span class="line">[root@mghio ~]# chown mghio:mghio change_usergroup_and_user_demo.txt</span><br><span class="line">[root@mghio ~]# <span class="keyword">ll</span> change_usergroup_and_user_demo.txt</span><br><span class="line">-rw-r--r-- <span class="number">1</span> mghio mghio <span class="number">56</span> Dec <span class="number">21</span> <span class="number">10</span>:<span class="number">17</span> change_usergroup_and_user_demo.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示其更改动作</span><br><span class="line"></span><br><span class="line">[root@mghio ~]# <span class="keyword">ll</span> change_usergroup_and_user_demo.txt</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">45</span> Dec <span class="number">21</span> <span class="number">10</span>:<span class="number">30</span> change_usergroup_and_user_demo.txt</span><br><span class="line">[root@mghio ~]# chown -<span class="keyword">c</span> mghio:mghio change_usergroup_and_user_demo.txt</span><br><span class="line">changed ownership of <span class="string">'change_usergroup_and_user_demo.txt'</span> <span class="keyword">to</span> mghio:mghio</span><br></pre></td></tr></table></figure><h5 id="1-2-3-cp-命令"><a href="#1-2-3-cp-命令" class="headerlink" title="1.2.3 cp 命令"></a>1.2.3 cp 命令</h5><p><code>cp</code> 命令为英文单词 <code>copy</code> 的缩写，功能为复制文件或目录。<code>cp</code> 命令可以将多个文件复制到一个具体的文件名或者一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。<br><strong>语法格式</strong>：cp [参数] [文件]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-f</td><td align="center">若目标文件已经存在，则直接覆盖原文件</td></tr><tr><td align="center">-i</td><td align="center">若目标文件已经存在，则会询问是否覆盖</td></tr><tr><td align="center">-p</td><td align="center">保留原文件或者目录的属性</td></tr><tr><td align="center">-r</td><td align="center">递归复制文件和目录</td></tr><tr><td align="center">-d</td><td align="center">当复制符号链接时，把目标文件或者目录也建立符号链接，并指向和原文件或目录连接的原始文件或目录</td></tr><tr><td align="center">-l</td><td align="center">对原文件建立连接，而非复制文件</td></tr><tr><td align="center">-s</td><td align="center">对原文件建立符合连接，而非复制文件</td></tr><tr><td align="center">-b</td><td align="center">覆盖已经存在的文件目标前将目标文件备份</td></tr><tr><td align="center">-v</td><td align="center">详细显示 <code>cp</code> 命令的执行过程</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 复制目录</span><br><span class="line"><span class="keyword">cp</span> -R source_dir1 dest_dir2/</span><br><span class="line"></span><br><span class="line"># 将文件 demo1.txt 改名为 demo2.txt</span><br><span class="line"><span class="keyword">cp</span> -<span class="keyword">f</span> demo1.txt demo2.txt</span><br><span class="line"></span><br><span class="line"># 复制多个文件</span><br><span class="line"><span class="keyword">cp</span> -r file1 file2 file3 dest_dir</span><br></pre></td></tr></table></figure><h5 id="1-2-4-mkdir-命令"><a href="#1-2-4-mkdir-命令" class="headerlink" title="1.2.4 mkdir 命令"></a>1.2.4 mkdir 命令</h5><p><code>mkdir</code> 命令是 <code>make directories</code> 的缩写，其功能是用来创建目录。默认状态下，如果要创建的目录如果已经存在，则提示已存在，而不会继续创建目录。所有我们在创建目录时，应该要保证新建的目录与它所在的目录下的文件没有重名，同时该命令还可以一次性创建多个目录。<br><strong>语法格式</strong>：mkdir [参数] [目录]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-p</td><td align="center">递归创建多级目录</td></tr><tr><td align="center">-m</td><td align="center">建立目录的同时设置目录的权限</td></tr><tr><td align="center">-v</td><td align="center">显示目录的常见过程</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录下，创建一个名为 dir 的子目录</span><br><span class="line"><span class="built_in">mkdir</span> dir</span><br><span class="line"></span><br><span class="line"># 在目录 /usr/mghio 下建立子目录 dir，并且设置文件属主有读（<span class="number">4</span>）、写（<span class="number">2</span>）和执行（<span class="number">1</span>）权限，其它用户无法访问</span><br><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">m</span> <span class="number">700</span> /usr/mghio/dir</span><br><span class="line"></span><br><span class="line"># 一次性创建目录 dir1、dir2、dir3</span><br><span class="line"><span class="built_in">mkdir</span> dir1 dir2 dir3</span><br><span class="line"></span><br><span class="line"># 递归创建目录</span><br><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> /mghio/dir</span><br></pre></td></tr></table></figure><h5 id="1-2-5-mv-命令"><a href="#1-2-5-mv-命令" class="headerlink" title="1.2.5 mv 命令"></a>1.2.5 mv 命令</h5><p><code>mv</code> 命令为英文单词 <code>move</code> 的缩写，功能为移动文件或者对文件重新命名。<code>mv</code> 与 <code>cp</code> 命令的结果不同。<code>mv</code> 命令是将文件整个移走，文件名发生改变，但是个数没有增加。而 <code>cp</code> 命令是对文件进行复制操作，文件个数增加。<br><strong>语法格式</strong>：mv [参数]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">若存在同名文件，则会询问是否覆盖</td></tr><tr><td align="center">-f</td><td align="center">覆盖已经存在的文件时，不进行任何提示</td></tr><tr><td align="center">-b</td><td align="center">当文件存在时，覆盖前为其创建一个备份</td></tr><tr><td align="center">-u</td><td align="center">当原文件比目标文件新或者目标文件不存在时，才会执行</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 将文件 file1 重命名为 file2</span><br><span class="line">mv file1 file2</span><br><span class="line"></span><br><span class="line"># 将文件 <span class="keyword">file</span> 移动到目录 dest_dir</span><br><span class="line">mv <span class="keyword">file</span> /dest_dir</span><br><span class="line"></span><br><span class="line"># 将目录 dir 下的所有文件移到当前目录</span><br><span class="line">mv /dir/* .</span><br></pre></td></tr></table></figure><h4 id="1-3-文档编辑"><a href="#1-3-文档编辑" class="headerlink" title="1.3 文档编辑"></a>1.3 文档编辑</h4><h5 id="1-3-1-cat-命令"><a href="#1-3-1-cat-命令" class="headerlink" title="1.3.1 cat 命令"></a>1.3.1 cat 命令</h5><p>在 <code>Linux</code> 系统中有很多用于查看文件内容的命令，<code>cat</code> 命令就是用来查看<code>内容较少</code>的纯文本内容文件的。当文件内容较大时，文本内容会在屏幕上快速滚屏，我们通常都看不到所显示的内容。对于较长文件内容可以按 <code>Ctrl+S</code> 键来停止滚屏，以及 <code>Ctrl+Q</code> 键来恢复滚屏，按 <code>Ctrl+C（中断）</code>键则可以终止该命令的执行。对于大文件，推荐使用下文说的 <code>more</code> 命令。<br><strong>语法格式</strong>：cat [参数] [文件]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">显示行数（一个空行显示一个编号）</td></tr><tr><td align="center">-s</td><td align="center">显示行数（多个空行只算一个编号）</td></tr><tr><td align="center">-b</td><td align="center">显示行数（空行不编号）</td></tr><tr><td align="center">-E</td><td align="center">每行结束显示 <code>$</code> 符号</td></tr><tr><td align="center">-T</td><td align="center">将 <code>TAB</code> 字符显示为 <code>^|</code> 符号</td></tr><tr><td align="center">–version</td><td align="center">显示版本信息</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查看文件内容 </span><br><span class="line"><span class="keyword">cat</span> demo.txt</span><br><span class="line"></span><br><span class="line"># 查看文件内容，并显示行号</span><br><span class="line"><span class="keyword">cat</span> -n demo.txt</span><br><span class="line"></span><br><span class="line"># 产查看文件的内容，并添加行数编号后输出到另外一个文件中</span><br><span class="line"><span class="keyword">cat</span> -n mghio.<span class="built_in">log</span> &gt; mghio_with_line_number.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"># 清空文件内容</span><br><span class="line"><span class="keyword">cat</span> /dev/null &gt; /mghio/demo.txt</span><br><span class="line"></span><br><span class="line"># 持续写入文件内容，直到碰到 `EOF` 符号后结束并保存</span><br><span class="line"><span class="keyword">cat</span> &gt; demo.txt &lt;&lt; EOF</span><br><span class="line">&gt; Hello, World</span><br><span class="line">&gt; mghio</span><br><span class="line">&gt; EOF</span><br></pre></td></tr></table></figure><h5 id="1-3-2-more-命令"><a href="#1-3-2-more-命令" class="headerlink" title="1.3.2 more 命令"></a>1.3.2 more 命令</h5><p><code>more</code> 命令用于将内容较长的文本文件内容（无法在一屏显示完）进行分屏显示，并且支持显示时定位关键字。对于内容比较少的文本内容推荐使用 <code>cat</code> 命令查看。<br><strong>语法格式</strong>：more [参数] [文件]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-num</td><td align="center">指定每屏显示的内容行数</td></tr><tr><td align="center">-l</td><td align="center"><code>more</code> 在通常情况下把 <code>^L</code> 当遇到这个字符就会暂停，这个参数可以屏蔽这个特性</td></tr><tr><td align="center">-f</td><td align="center">计算实际的行数，而非自动换行的行数</td></tr><tr><td align="center">-p</td><td align="center">先清除屏幕在显示文本文件的剩余内容</td></tr><tr><td align="center">-c</td><td align="center">与 <code>-p</code> 相似，不滚屏，先显示内容在清除内容</td></tr><tr><td align="center">-s</td><td align="center">多个空行压缩成一行显示</td></tr><tr><td align="center">-u</td><td align="center">禁止下划线</td></tr><tr><td align="center">+/pattern</td><td align="center">在每个文档显示前搜寻该字（<code>pattern</code>），然后该字串之后开始显示</td></tr><tr><td align="center">+num</td><td align="center">从第 <code>num</code> 行开始显示</td></tr></tbody></table><p><strong>查看时的命令操作</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Space 键</td><td align="center">显示文本的下一屏内容</td></tr><tr><td align="center">Enter 键</td><td align="center">向下 <code>n</code> 行，需要定义，默认为 1 行</td></tr><tr><td align="center"><code>\</code> 键</td><td align="center">接着输入一个模式，可以在文本中寻找下一个相匹配的模式</td></tr><tr><td align="center">H 键</td><td align="center">显示帮助屏</td></tr><tr><td align="center">B 键</td><td align="center">显示上一屏内容</td></tr><tr><td align="center">Q 键</td><td align="center">退出 <code>more</code> 命令</td></tr><tr><td align="center">Ctrl + F、空格键</td><td align="center">向下滚动一屏</td></tr><tr><td align="center">Ctrl + B</td><td align="center">返回上一屏</td></tr><tr><td align="center">=</td><td align="center">输出当前的行号</td></tr><tr><td align="center">:f</td><td align="center">输出文件名和当前的行号</td></tr><tr><td align="center">V</td><td align="center">调用 <code>vi</code> 编辑器</td></tr><tr><td align="center">!</td><td align="center">调用 <code>Shell</code>， 并执行命令</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 显示文件 demo.txt 的内容和已显示的百分比，显示之前先清屏</span><br><span class="line">more -dc demo.txt</span><br><span class="line"></span><br><span class="line"># 显示文件 demo.txt 的内容，每 <span class="number">10</span> 行显示一次，而且在显示之前先清屏</span><br><span class="line">more -<span class="keyword">c</span> -<span class="number">10</span> demo.txt</span><br><span class="line"></span><br><span class="line"># 显示文件 demo.txt 的内容，每 <span class="number">5</span> 行显示一次，而且在显示之后再清屏</span><br><span class="line">more -<span class="keyword">p</span> -<span class="number">5</span> demo.txt</span><br><span class="line"></span><br><span class="line"># 从第 <span class="number">20</span> 行开始显示文件 demo.txt 的内容</span><br><span class="line">more +<span class="number">20</span> demo.txt</span><br></pre></td></tr></table></figure><h5 id="1-3-3-tail-命令"><a href="#1-3-3-tail-命令" class="headerlink" title="1.3.3 tail 命令"></a>1.3.3 tail 命令</h5><p><code>tial</code> 命令用于显示文件尾部的内容，默认在屏幕上显示指定文件的末尾 10 行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题，如果没有指定文件或者文件名为 <code>-</code>，则读取标准输入。<br><strong>语法格式</strong>：tail [参数]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">–retry</td><td align="center">即是在 <code>tail</code> 命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与 <code>—f</code> 一起使用</td></tr><tr><td align="center">-c <n></n></td><td align="center">输出文件尾部的 <code>N</code>（<code>N</code> 为整数） 个字节内容</td></tr><tr><td align="center">-f</td><td align="center">显示文件最新追加的内容</td></tr><tr><td align="center">-n <n></n></td><td align="center">输出文件的尾部 <code>N</code>（<code>N</code> 为整数） 行内容</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 显示文件 demo.txt 的最后 <span class="number">10</span> 行</span><br><span class="line">tail demo.txt</span><br><span class="line"></span><br><span class="line"># 显示文件 demo.txt 的内容，从第 <span class="number">20</span> 行至文件末尾</span><br><span class="line">tail +<span class="number">20</span> demo.txt</span><br><span class="line"></span><br><span class="line"># 显示文件 demo.txt 的最后 <span class="number">10</span> 个字符</span><br><span class="line">tail -<span class="keyword">c</span> <span class="number">10</span> demo.txt</span><br></pre></td></tr></table></figure><h5 id="1-3-4-grep-命令"><a href="#1-3-4-grep-命令" class="headerlink" title="1.3.4 grep 命令"></a>1.3.4 grep 命令</h5><p><code>grep</code> 是英文 <code>global search regular expression and print out the line</code> 的简称。是全面搜索正则表达式，并将其打印出来。这个命令可以结合正则表达式使用，使用非常广泛。<code>grep</code> 命令的选项用于对搜索过程的补充，而其命令的模式十分灵活，可以是变量、字符串、正则表达式，需要注意的是，当我们的模式中包含了空格的话，要使用双引号将其引起来。<br><strong>语法格式</strong>：grep [参数]<br><strong>参数列表</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">搜索时，忽略大小写</td></tr><tr><td align="center">-c</td><td align="center">只输出匹配行的数量</td></tr><tr><td align="center">-l</td><td align="center">只列出符合匹配的文件名，不列出具体匹配行</td></tr><tr><td align="center">-n</td><td align="center">列出所有匹配行，显示行号</td></tr><tr><td align="center">-h</td><td align="center">查询多文件时不显示文件名</td></tr><tr><td align="center">-s</td><td align="center">不显示不存在、没有匹配文本的错误信息</td></tr><tr><td align="center">-v</td><td align="center">显示不包含匹配文本的所有行</td></tr><tr><td align="center">-w</td><td align="center">匹配整词</td></tr><tr><td align="center">-x</td><td align="center">匹配整行</td></tr><tr><td align="center">-r</td><td align="center">递归搜索</td></tr><tr><td align="center">-q</td><td align="center">禁止输出任何结果，已退出状态表示搜索是否成功</td></tr><tr><td align="center">-b</td><td align="center">打印匹配行距文件头部的偏移量（以字节为单位）</td></tr><tr><td align="center">-o</td><td align="center">与 <code>-b</code> 结合使用，打印匹配的词距文件头部的偏移量（以字节为单位）</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 支持多文件查询并支持使用通配符</span><br><span class="line"></span><br><span class="line">[root@mghio ~]# <span class="keyword">grep</span> mghio file_* /usr/demo</span><br><span class="line">file_1:mghio</span><br><span class="line">file_1:mghioddkjflkdjfdlkfjlsdkj</span><br><span class="line">file_2:mghio</span><br><span class="line">file_4:dkfjlmghioejfkds</span><br><span class="line">file_4:mghio djftgf</span><br><span class="line">file_4:twetmghioedkfgj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 列出所有的匹配行，并显示行号</span><br><span class="line">[root@mghio ~]# <span class="keyword">grep</span> mghio file_* /usr/demo</span><br><span class="line">file_1:<span class="number">1</span>:mghio</span><br><span class="line">file_1:<span class="number">3</span>:mghioddkjflkdjfdlkfjlsdkj</span><br><span class="line">file_2:<span class="number">4</span>:mghio</span><br><span class="line">file_4:<span class="number">8</span>:dkfjlmghioejfkds</span><br><span class="line">file_4:<span class="number">11</span>:mghio djftgf</span><br><span class="line">file_4:<span class="number">20</span>:twetmghioedkfgj</span><br></pre></td></tr></table></figure><h5 id="1-3-5-echo-命令"><a href="#1-3-5-echo-命令" class="headerlink" title="1.3.5 echo 命令"></a>1.3.5 echo 命令</h5><p><code>echo</code> 命令用于在终端设备上输出字符串或者变量提取后的值，这是在 <code>Linux</code> 系统中最常用的几个命令之一，在 <code>Linux</code> 系统中，人们一般使用在变量前加上 <code>$</code> 符号的方式提取出变量的值，例如：<code>$PATH</code>，然后再用 <code>echo</code> 命令予以输出。或者直接使用 <code>echo</code> 命令输出一段字符串到屏幕上，起到给用户提示的作用。<br><strong>语法格式</strong>：echo [参数] [字符串]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">不输出结尾的换行符</td></tr><tr><td align="center">-e”\a”</td><td align="center">发出警告音</td></tr><tr><td align="center">-e”\b”</td><td align="center">删除前面的一个字符</td></tr><tr><td align="center">-e”\c”</td><td align="center">结尾不加换行符</td></tr><tr><td align="center">-e”\f”</td><td align="center">换行，光标仍然停留在原来的坐标位置</td></tr><tr><td align="center">-e”\n”</td><td align="center">换行，光标移至行首</td></tr><tr><td align="center">-e”\r”</td><td align="center">光标移至首行，但是不换行</td></tr><tr><td align="center">-E</td><td align="center">禁止反斜杠转义，与 <code>-e</code> 参数功能相反</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 输出一段字符串</span><br><span class="line">[root@mghio ~]#  <span class="keyword">echo</span> <span class="string">"mghio.cn"</span> </span><br><span class="line">mghio.<span class="keyword">cn</span></span><br><span class="line"></span><br><span class="line"># 输出变量提取后的值</span><br><span class="line">[root@mghio ~]# <span class="keyword">echo</span> $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</span><br><span class="line"></span><br><span class="line"># 对内容进行转义，不让$符号的提取变量值功能生效</span><br><span class="line">[root@mghio ~]# <span class="keyword">echo</span> \$PATH</span><br><span class="line">$PATH</span><br><span class="line"></span><br><span class="line"># 使用反引号符执行命令，并输出其结果到终端</span><br><span class="line">[root@mghio ~]# <span class="keyword">echo</span> `date`</span><br><span class="line">Sat Dec <span class="number">21</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">24</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure><h4 id="1-4-网络通讯"><a href="#1-4-网络通讯" class="headerlink" title="1.4 网络通讯"></a>1.4 网络通讯</h4><h5 id="1-4-1-ssh-命令"><a href="#1-4-1-ssh-命令" class="headerlink" title="1.4.1 ssh 命令"></a>1.4.1 ssh 命令</h5><p><code>ssh</code> 命令是 <code>openssh</code> 套件中的客户端连接工具，可以给予 <code>ssh</code> 加密协议实现安全的远程登录服务器，实现对服务器的管理。<br><strong>语法格式</strong>：ssh [参数] [主机]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">强制使用 <code>ssh</code> 协议版本 1</td></tr><tr><td align="center">-2</td><td align="center">强制使用 <code>ssh</code> 协议版本 2</td></tr><tr><td align="center">-4</td><td align="center">强制使用 <code>IPv4</code> 地址</td></tr><tr><td align="center">-6</td><td align="center">强制使用 <code>IPv6</code> 地址</td></tr><tr><td align="center">-A</td><td align="center">开启认证代理连接转发功能</td></tr><tr><td align="center">-a</td><td align="center">关闭认证代理连接转发功能</td></tr><tr><td align="center">-b&lt;IP地址&gt;</td><td align="center">使用本机指定的地址作为对位连接的源 <code>IP</code> 地址</td></tr><tr><td align="center">-C</td><td align="center">请求压缩所有数据</td></tr><tr><td align="center">-F&lt;配置文件&gt;</td><td align="center">指定 <code>ssh</code> 指令的配置文件，默认的配置文件为 <code>/etc/ssh/ssh_config</code></td></tr><tr><td align="center">-f</td><td align="center">后台执行 <code>ssh</code>指令</td></tr><tr><td align="center">-g</td><td align="center">允许远程主机连接本机的转发端口</td></tr><tr><td align="center">-i&lt;身份文件&gt;</td><td align="center">指定身份文件（即私钥文件）</td></tr><tr><td align="center">-l&lt;登录名&gt;</td><td align="center">指定连接远程服务器的登录用户名</td></tr><tr><td align="center">-N</td><td align="center">不执行远程指令</td></tr><tr><td align="center">-o&lt;选项&gt;</td><td align="center">指定配置选项</td></tr><tr><td align="center">-p&lt;端口&gt;</td><td align="center">指定远程服务器上的端口</td></tr><tr><td align="center">-q</td><td align="center">静默模式，所有的警告和诊断信息被禁止输出</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 登录远程服务器</span><br><span class="line">[root@mghio ~]# ssh <span class="number">112.67</span>.<span class="number">239.127</span></span><br><span class="line"></span><br><span class="line"># 用 mghio 用户连接远程服务器</span><br><span class="line">[root@linuxcool ~]# ssh -<span class="keyword">l</span> mghio <span class="number">112.67</span>.<span class="number">239.127</span></span><br></pre></td></tr></table></figure><h5 id="1-4-2-sftp-命令"><a href="#1-4-2-sftp-命令" class="headerlink" title="1.4.2 sftp 命令"></a>1.4.2 sftp 命令</h5><p><code>sftp</code> 命令全称是 <code>Secure File Transfer Protocol</code>。是一个交互式的文件传输程序，<code>sftp</code> 命令的运行和使用与 <code>ftp</code> 相似，但是 <code>sftp</code> 命令对传输的所有信息使用 <code>ssh</code> 加密 ，它还支持公钥认证和压缩等功能。<br><strong>语法格式</strong>：sftp [参数] [IP或主机名]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-B</td><td align="center">指定传输文件缓冲区的大小</td></tr><tr><td align="center">-l</td><td align="center">使用 <code>ssh</code> 协议版本 1</td></tr><tr><td align="center">-b</td><td align="center">指定批处理文件</td></tr><tr><td align="center">-C</td><td align="center">使用压缩</td></tr><tr><td align="center">-o</td><td align="center">指定 <code>ssh</code> 选项</td></tr><tr><td align="center">-F</td><td align="center">指定 <code>ssh</code> 配置文件</td></tr><tr><td align="center">-R</td><td align="center">指定一次可以容忍多少请求数</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用 sftp 命令连接到服务器</span><br><span class="line">[root@mghio ~]# sftp <span class="number">112.67</span>.<span class="number">239.127</span></span><br><span class="line"></span><br><span class="line"># 指定传输文件是缓冲区大小</span><br><span class="line">[root@mghio ~]# sftp -B <span class="number">256</span> <span class="number">112.67</span>.<span class="number">239.127</span></span><br><span class="line"></span><br><span class="line"># 在传输过程中使用压缩</span><br><span class="line">[root@linuxcool ~]# sftp -C <span class="number">112.67</span>.<span class="number">239.127</span></span><br></pre></td></tr></table></figure><h5 id="1-4-3-telnet-命令"><a href="#1-4-3-telnet-命令" class="headerlink" title="1.4.3 telnet 命令"></a>1.4.3 telnet 命令</h5><p><code>telnet</code> 命令的功能是远端登入，执行 <code>telnet</code> 指令开启终端机阶段作业，并登入远端主机。<code>telnet</code> 命令可以帮助你从这台路由器远程登陆到远端开启了 <code>telnet</code> 服务的设备，包括路由器、交换机、<code>Linux</code> 服务器等，并且配置当前路由器的 <code>telnet</code> 服务。<br><strong>语法格式</strong>：telnet [参数]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-8</td><td align="center">允许使用 8 位字符资料，包括输入与输出</td></tr><tr><td align="center">-a</td><td align="center">尝试自动登入远端系统</td></tr><tr><td align="center">-b</td><td align="center">使用别名指定远端主机名称</td></tr><tr><td align="center">-c</td><td align="center">不读取用户专属目录里的 <code>.telnetrc</code> 文件</td></tr><tr><td align="center">-d</td><td align="center">启动排错模式</td></tr><tr><td align="center">-e</td><td align="center">设置脱离字符</td></tr><tr><td align="center">-E</td><td align="center">滤除脱离字符</td></tr><tr><td align="center">-f</td><td align="center">此参数的效果和指定 <code>-F</code> 参数相同</td></tr><tr><td align="center">-F</td><td align="center">使用 <code>Kerberos V5</code> 认证时，加上此参数可把本地主机的认证数据上传到远端主机</td></tr><tr><td align="center">-k</td><td align="center">使用 <code>Kerberos</code> 认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名</td></tr><tr><td align="center">-K</td><td align="center">不自动登入远端主机</td></tr><tr><td align="center">-l</td><td align="center">指定要登入远端主机的用户名称</td></tr><tr><td align="center">-L</td><td align="center">允许输出8位字符资料</td></tr><tr><td align="center">-n</td><td align="center">指定文件记录相关信息</td></tr><tr><td align="center">-r</td><td align="center">使用类似 <code>rlogin</code> 指令的用户界面</td></tr><tr><td align="center">-S</td><td align="center">设置 <code>telnet</code> 连线所需的 <code>IP TOS</code> 信息</td></tr><tr><td align="center">-x</td><td align="center">假设主机有支持数据加密的功能，就使用它</td></tr><tr><td align="center">-X</td><td align="center">关闭指定的认证形态</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 登录远程主机</span><br><span class="line">[root@mghio ~]# telnet <span class="number">112.67</span>.<span class="number">239.127</span></span><br><span class="line"></span><br><span class="line"># 连接本地主机，端口号为 <span class="number">23</span></span><br><span class="line">[root@mghio ~]# telnet localhost <span class="number">23</span></span><br></pre></td></tr></table></figure><h5 id="1-4-4-netstat-命令"><a href="#1-4-4-netstat-命令" class="headerlink" title="1.4.4 netstat 命令"></a>1.4.4 netstat 命令</h5><p><code>netstat</code> 命令用于显示各种网络相关信息，如网络连接、路由表、接口状态、多播成员等。从整体上看，<code>netstat</code> 的输出结果为两部分：一个是 <code>Active Internet connections</code> 称为 <code>有源 TCP 连接</code>，其中 <code>Recv-Q</code> 和 <code>Send-Q</code> 指 <code>%OA</code> 的是接收队列和发送队列。另一个是 <code>Active UNIX domain sockets</code>，称为<code>有源Unix域套接口</code>(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。<br><strong>语法格式</strong>：netstat [参数]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">显示所有连线中的 <code>Socket</code></td></tr><tr><td align="center">-p</td><td align="center">显示正在使用 <code>Socket</code> 的程序识别码和程序名称</td></tr><tr><td align="center">-u</td><td align="center">显示 <code>UDP</code> 传输协议的连线状况</td></tr><tr><td align="center">-i</td><td align="center">显示网络界面信息表单</td></tr><tr><td align="center">-n</td><td align="center">直接使用 <code>IP</code> 地址，不通过域名服务器</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 显示详细的网络状况</span><br><span class="line">[root@mghio ~]# netstat -<span class="keyword">a</span></span><br><span class="line"></span><br><span class="line"># 显示当前 UDP 连接状况</span><br><span class="line">[root@mghio ~]# netstat -<span class="keyword">nu</span></span><br><span class="line"></span><br><span class="line"># 显示网卡列表</span><br><span class="line">[root@mghio ~]# netstat -i</span><br><span class="line">Kernel Interface table </span><br><span class="line">Iface MTU Met  RX-OK  RX-ERR  RX-DRP RX-OVR  TX-OK TX-ERR TX-DRP TX-OVR Flg </span><br><span class="line">eth0 <span class="number">1500</span>   <span class="number">0</span>  <span class="number">181864</span>   <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>     <span class="number">141278</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    BMRU </span><br><span class="line"><span class="keyword">lo</span>   <span class="number">16436</span>  <span class="number">0</span>   <span class="number">3362</span>    <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>     <span class="number">3362</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    LRU</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h4&gt;&lt;p&gt;作为 &lt;code&gt;Java&lt;/code&gt; 后端开发的我们，开发的项目绝大部分都是部署在 &lt;code&gt;Linux&lt;/code&gt; 系统上的，因此熟练使用一些常用的 &lt;code&gt;Linux&lt;/code&gt; 命令不管是对于日常开发、服务部署或者查找问题都非常有用。以下整理了一些常用的 &lt;code&gt;Linux&lt;/code&gt; 常用命令。&lt;/p&gt;
&lt;h4 id=&quot;1-2-文件管理&quot;&gt;&lt;a href=&quot;#1-2-文件管理&quot; class=&quot;headerlink&quot; title=&quot;1.2 文件管理&quot;&gt;&lt;/a&gt;1.2 文件管理&lt;/h4&gt;&lt;h5 id=&quot;1-2-1-ls-命令&quot;&gt;&lt;a href=&quot;#1-2-1-ls-命令&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 ls 命令&quot;&gt;&lt;/a&gt;1.2.1 ls 命令&lt;/h5&gt;&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 命令是 &lt;code&gt;Linux&lt;/code&gt; 最常用的命令之一，其功能是列出指定目录下的内容及其相关属性信息。默认状态下，&lt;code&gt;ls&lt;/code&gt; 命令会列出当前目录的内容，它也可以带上一些参数来实现更多的功能。&lt;br&gt;&lt;strong&gt;语法格式&lt;/strong&gt;：ls [选项] [文件]&lt;br&gt;&lt;strong&gt;常用参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;参数&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-a&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;显示所有文件及目录（包括以 &lt;code&gt;.&lt;/code&gt; 开头的隐藏文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-l&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;使用长格式列出文件及目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-r&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;将文件以相反次序显示（默认按照英文字母次序）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-t&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;根据最后的修改时间排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-A&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;同 &lt;code&gt;-a&lt;/code&gt;，但是不列出 &lt;code&gt;.&lt;/code&gt;（当前目录）以及 &lt;code&gt;..&lt;/code&gt;（父级目录）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-S&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;根据文件大小排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-R&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;递归列出所有子目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="Linux笔记" scheme="https://www.mghio.cn/categories/Linux%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux笔记" scheme="https://www.mghio.cn/tags/Linux%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程基础（二）</title>
    <link href="https://www.mghio.cn/post/4ea48fa7.html"/>
    <id>https://www.mghio.cn/post/4ea48fa7.html</id>
    <published>2019-12-14T08:32:14.000Z</published>
    <updated>2019-12-16T12:22:59.495Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在上篇 <a href="https://www.mghio.cn/post/7eb2637f.html">Java 多线程基础（一）</a> 我们提到了一些线程的常用方法，这篇我们具体看看其中一些方法的使用以及方法的区别，让我们在工作中更好的使用。</p><h4 id="wait-方法与-notify-方法"><a href="#wait-方法与-notify-方法" class="headerlink" title="wait 方法与 notify 方法"></a>wait 方法与 notify 方法</h4><p>在 <code>Object</code> 类中定义了 <code>wait</code> 方法和 <code>notify</code> 方法，<code>wait</code> 方法的作用是让当前线程进入等待状态，将当前线程置入 <code>预执行队列</code>，会在 <code>wait</code> 方法所在代码处停止执行，直到被通知或者被中断，在调用 <code>wait</code> 方法之前，线程必须获取该对象的锁，因此只能在<code>同步方法</code>或者<code>同步代码块</code>中调用 <code>wait</code> 方法，并且该方法会释放当前线程锁持有的锁。<code>notify</code> 方法是唤醒在当前对象上等待的<code>单个线程</code>，如果有多个线程等待，那么线程调度器会挑出一个 <code>wait</code> 的线程，对其发出 <code>notify</code> ，并使它等待获取该对象的对象锁，这意味着，即使收到了通知，线程也不会立即获取到对象锁，必须等待 <code>notify</code> 方法的线程释放锁才可以。和 <code>wait</code> 方法一样，<code>notify</code> 方法也只能在<code>同步方法</code>或者<code>同步代码块</code>中调用。它还有个相似的方法 <code>notifyAll</code>，它的作用是唤醒在当前对象上等待的<code>所有线程</code>。</p><a id="more"></a><p>下面通过一个生产者消费者来说明 <code>wait</code> 方法和 <code>notify</code> 方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程 wait() 和 notify() 方法使用示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitAndNotifyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">new</span> Consumer(<span class="string">"Consumer One"</span>, producer).start();</span><br><span class="line">    <span class="keyword">new</span> Consumer(<span class="string">"Consumer Two"</span>, producer).start();</span><br><span class="line">    <span class="keyword">new</span> Consumer(<span class="string">"Consumer Three"</span>, producer).start();</span><br><span class="line">    <span class="keyword">new</span> Consumer(<span class="string">"Consumer Four"</span>, producer).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; messageList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (messageList) &#123;</span><br><span class="line">            String message = String.format(<span class="string">"producer message [create time:%s]"</span>, LocalDateTime.now());</span><br><span class="line">            messageList.add(message);</span><br><span class="line">            System.out.println(<span class="string">"Producer "</span> + getName() + <span class="string">" producer a msg: "</span> + message);</span><br><span class="line">            messageList.notify();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (messageList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (messageList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            messageList.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> messageList.remove(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name, Producer producer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">      <span class="keyword">this</span>.producer = producer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String message = producer.getMessage();</span><br><span class="line">        System.out.println(<span class="string">"Consumer "</span> + getName() + <span class="string">" get a msg: "</span> + message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Producer Thread-<span class="number">0</span> producer a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">42.319</span>]</span><br><span class="line">Consumer Consumer One get a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">42.319</span>]</span><br><span class="line">Producer Thread-<span class="number">0</span> producer a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">44.324</span>]</span><br><span class="line">Consumer Consumer Two get a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">44.324</span>]</span><br><span class="line">Producer Thread-<span class="number">0</span> producer a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">46.325</span>]</span><br><span class="line">Consumer Consumer Three get a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">46.325</span>]</span><br><span class="line">Producer Thread-<span class="number">0</span> producer a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">48.328</span>]</span><br><span class="line">Consumer Consumer Four get a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">48.328</span>]</span><br></pre></td></tr></table></figure><p>消费者线程循环调用生产者的 <code>getMessage</code> 方法获取消息，如果消息列表 <code>messageList</code> 为空，则调用消息列表的 <code>wait</code> 方法让线程进入等待状态，生产者每隔 2 秒生成消息并放入消息列表 <code>messageList</code> 中，放入成功后调用 <code>notify</code> 方法唤醒一个处于 <code>wait</code> 状态的线程去消费消息，需要注意的是，在调用 <code>wait</code> 和 <code>notify</code> 方法时必须要先获得该对象的锁，上面的示例中是在 <code>synchronized</code> 代码块中调用的。</p><h4 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep 方法"></a>sleep 方法</h4><p>与 <code>wait</code>、<code>notify</code> 方法不同，<code>sleep</code> 方法定义在 <code>Thread</code> 类中，从方法名也可以知道，这个方法的作用就是让<code>当前线程休眠</code>，即调用该方法后当前线程会从<code>运行状态(Running）状态</code>进入到<code>阻塞（休眠）状态（Blocked）</code>，同时该方法必须指定休眠的时间，当前线程的休眠时间会大于或者等于这个指定的休眠时间。当线程重新被唤醒时，线程会由<code>阻塞状态（Blocked）</code>变成<code>就绪状态（Runnable）</code>，然后等待 CPU 的调度执行。<code>sleep</code> 方法的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程 sleep() 方法使用示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread myThreadOne = <span class="keyword">new</span> MyThread(<span class="string">"t1"</span>);</span><br><span class="line">    MyThread myThreadTwo = <span class="keyword">new</span> MyThread(<span class="string">"t2"</span>);</span><br><span class="line">    myThreadOne.start();</span><br><span class="line">    myThreadTwo.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s: %d"</span>, <span class="keyword">this</span>.getName(), i));</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">              Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1: <span class="number">0</span></span><br><span class="line">t1: <span class="number">1</span></span><br><span class="line">t1: <span class="number">2</span></span><br><span class="line">t1: <span class="number">3</span></span><br><span class="line">t1: <span class="number">4</span></span><br><span class="line">t2: <span class="number">0</span></span><br><span class="line">t2: <span class="number">1</span></span><br><span class="line">t2: <span class="number">2</span></span><br><span class="line">t2: <span class="number">3</span></span><br><span class="line">t2: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>我们启动了两个线程 <code>t1</code> 和 <code>t2</code>，两个线程的 <code>run</code> 方法引用了同一个对象 <code>object</code> 的同步锁（<code>synchronized (object)</code>），虽然在第一个线程 <code>t1</code> 中当 <code>i</code> 被 2 整除时会调用 <code>Thread.sleep(2000)</code> 让当前线程休眠 2 s，但是此时线程 <code>t2</code> 也不会得到 cpu 的执行权去执行，因为 <code>t1</code> 线程调用 <code>sleep</code> 方法并没有释放<code>object</code>所持有的同步锁。如果我们注释掉 <code>synchronized (object)</code> 后再次执行该程序，线程 <code>t1</code> 和 <code>t2</code> 是可以交替执行的，注释之后的输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t2: <span class="number">0</span></span><br><span class="line">t1: <span class="number">0</span></span><br><span class="line">t1: <span class="number">1</span></span><br><span class="line">t2: <span class="number">1</span></span><br><span class="line">t1: <span class="number">2</span></span><br><span class="line">t2: <span class="number">2</span></span><br><span class="line">t2: <span class="number">3</span></span><br><span class="line">t1: <span class="number">3</span></span><br><span class="line">t2: <span class="number">4</span></span><br><span class="line">t1: <span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield 方法"></a>yield 方法</h4><p><code>yield</code> 方法定义在 <code>Thread</code> 类中，是线程特有的方法。此方法的主要作用是<code>让步</code>，它会使当前线程从<code>运行状态（Running）</code>变为<code>就绪状态（Runnable）</code>，从而让其他具有同样优先级的处于<code>就绪状态</code>的线程获取到 CPU 执行权(<code>PS: CPU 会从众多的处于就绪状态的线程里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到</code>)，但是，也并不能保证在当前线程调用 <code>yield</code> 之后，其它哪些具有相同优先级的线程就一定能获得执行权，也有可能是当前线程又进入到<code>运行状态（Running）</code>继续运行。<code>yield</code> 方法的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程 yield() 方法使用示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread myThreadOne = <span class="keyword">new</span> MyThread(<span class="string">"t1"</span>);</span><br><span class="line">    MyThread myThreadTwo = <span class="keyword">new</span> MyThread(<span class="string">"t2"</span>);</span><br><span class="line">    myThreadOne.start();</span><br><span class="line">    myThreadTwo.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyThread(String name) &#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s [%d] ---&gt; %d"</span>, <span class="keyword">this</span>.getName(), <span class="keyword">this</span>.getPriority(), i));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">          yield();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">0</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">0</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">1</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">2</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">3</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">4</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">5</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">6</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">7</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">8</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">9</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">1</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">2</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">3</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">4</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">5</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">6</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">7</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">8</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure><p>从以上输出结果可以看出，线程 <code>t1</code> 中的变量 <code>i</code> 在被 2 整除的时候，并没有切换到线程 <code>t2</code> 去执行，这也验证了我们上文说的，<code>yield</code> 方法虽然可以让线程由<code>运行状态</code>变成<code>就绪状态</code>，但是，它不一定会让其它线程获取 CPU 执行权从而进入到<code>运行状态</code>，即使这个其它线程和当前具有相同的优先级，<code>yield</code> 方法不会释放锁（证明方法只需将上面这个示例的 <code>run</code> 方法里面加上 <code>synchronized (obj)</code> 即可，此时 <code>t2</code> 线程会等到线程 <code>t1</code> 执行完毕后才会执行）。</p><h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h4><p>在有些场景中我们需要在子线程去执行一些耗时的任务，但是我们的主线程又必须等待子线程执行完毕之后才能结束，那么此时就可以使用 <code>join</code> 方法了，该方法定义在 <code>Thread</code> 类中，方法的作用是：<code>让主线程等待子线程执行结束之后才能继续执行</code>，下面我们通过一个例子来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程 join() 方法使用示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MyThread myThread = <span class="keyword">new</span> MyThread(<span class="string">"t1"</span>);</span><br><span class="line">      myThread.start();</span><br><span class="line">      myThread.join();</span><br><span class="line">      System.out.println(String.format(<span class="string">"%s ---&gt; %s finish"</span>, LocalDateTime.now(), Thread.currentThread().getName()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyThread(String name) &#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(String.format(<span class="string">"%s ---&gt; %s start"</span>, LocalDateTime.now(), <span class="keyword">this</span>.getName()));</span><br><span class="line">      <span class="comment">// 模拟耗时操作</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(String.format(<span class="string">"%s ---&gt; %s finish"</span>, LocalDateTime.now(), <span class="keyword">this</span>.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">15</span>T00:<span class="number">22</span>:<span class="number">55.971</span> ---&gt; t1 start</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">15</span>T00:<span class="number">22</span>:<span class="number">57.984</span> ---&gt; t1 finish</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">15</span>T00:<span class="number">22</span>:<span class="number">57.985</span> ---&gt; main finish</span><br></pre></td></tr></table></figure><p>在主线程 <code>main</code> 中通过 <code>new MyThread(&quot;t1&quot;)</code> 新建线程 <code>t1</code>。 接着，通过 <code>t1.start()</code> 启动线程 <code>t1</code>，在执行 <code>t1.join()</code>之后， 主线程会进入<code>阻塞状态</code>等待 <code>t1</code> 运行结束。子线程 <code>t1</code> 结束之后，会唤醒主线程，主线程重新获取 CPU 执行权，主线程继续往下运行。在使用了 <code>join</code> 方法之后主线程会等待子线程结束之后才会结束。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上是线程一些常用的方法介绍和具体使用知识总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在上篇 &lt;a href=&quot;https://www.mghio.cn/post/7eb2637f.html&quot;&gt;Java 多线程基础（一）&lt;/a&gt; 我们提到了一些线程的常用方法，这篇我们具体看看其中一些方法的使用以及方法的区别，让我们在工作中更好的使用。&lt;/p&gt;
&lt;h4 id=&quot;wait-方法与-notify-方法&quot;&gt;&lt;a href=&quot;#wait-方法与-notify-方法&quot; class=&quot;headerlink&quot; title=&quot;wait 方法与 notify 方法&quot;&gt;&lt;/a&gt;wait 方法与 notify 方法&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;Object&lt;/code&gt; 类中定义了 &lt;code&gt;wait&lt;/code&gt; 方法和 &lt;code&gt;notify&lt;/code&gt; 方法，&lt;code&gt;wait&lt;/code&gt; 方法的作用是让当前线程进入等待状态，将当前线程置入 &lt;code&gt;预执行队列&lt;/code&gt;，会在 &lt;code&gt;wait&lt;/code&gt; 方法所在代码处停止执行，直到被通知或者被中断，在调用 &lt;code&gt;wait&lt;/code&gt; 方法之前，线程必须获取该对象的锁，因此只能在&lt;code&gt;同步方法&lt;/code&gt;或者&lt;code&gt;同步代码块&lt;/code&gt;中调用 &lt;code&gt;wait&lt;/code&gt; 方法，并且该方法会释放当前线程锁持有的锁。&lt;code&gt;notify&lt;/code&gt; 方法是唤醒在当前对象上等待的&lt;code&gt;单个线程&lt;/code&gt;，如果有多个线程等待，那么线程调度器会挑出一个 &lt;code&gt;wait&lt;/code&gt; 的线程，对其发出 &lt;code&gt;notify&lt;/code&gt; ，并使它等待获取该对象的对象锁，这意味着，即使收到了通知，线程也不会立即获取到对象锁，必须等待 &lt;code&gt;notify&lt;/code&gt; 方法的线程释放锁才可以。和 &lt;code&gt;wait&lt;/code&gt; 方法一样，&lt;code&gt;notify&lt;/code&gt; 方法也只能在&lt;code&gt;同步方法&lt;/code&gt;或者&lt;code&gt;同步代码块&lt;/code&gt;中调用。它还有个相似的方法 &lt;code&gt;notifyAll&lt;/code&gt;，它的作用是唤醒在当前对象上等待的&lt;code&gt;所有线程&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="多线程" scheme="https://www.mghio.cn/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="多线程" scheme="https://www.mghio.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程基础（一）</title>
    <link href="https://www.mghio.cn/post/7eb2637f.html"/>
    <id>https://www.mghio.cn/post/7eb2637f.html</id>
    <published>2019-12-07T13:56:55.000Z</published>
    <updated>2019-12-08T15:20:18.832Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在接触<code>多线程</code>之前，在我们程序中在任意时刻都只能执行一个步骤，称之为<code>单线程</code>。在单线程开发的程序中所有的程序路径都是顺序执行的，前面的必须先执行，后面的才会执行。单线程的优点也很明显，相对于多线程来说更加稳定、扩展性更强、程序开发相对比较容易。但是由于每次都要等上一个任务执行完成后才能开始新的任务，导致其效率比多线程低，甚至有时候应用程序会出现假死的现象。使用多线程有利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。多线程是 Java 学习的非常重要的方面，是每个 Java 程序员必须掌握的基本技能。本文是有关 Java 多线程的一些基础知识总结。</p><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程是<code>操作系统资源分配</code>的基本单位，它是操作系统的基础，是一个程序及其数据在处理机上顺序执行时所发生的活动。一个程序进入内存运行，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立功能。进程的实质就是程序在操作系统中的一次执行过程，它是动态产生的、动态销毁的，拥有自己的生命周期和各种不同的运行状态。同时，进程还具有并发性，它可以同其他进程一起并发执行，按各自独立的、不可预知的速度向前推进（<code>PS：并发性和并行性是不同的概念，并行指的是同一时刻，两个及两个以上的指令在多个处理器上同时执行。而并发指的是同一时刻只有一条指令执行，但是多个进程可以被 CPU 快速交换执行，给我们感觉好像是多个执行在同时执行一样</code>）。　</p><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程是<code>任务调度和执行</code>的基本单位，也被称为<code>轻量级进程</code>，线程由线程 ID，当前指令指针(PC），寄存器集合和堆栈组成。线程不拥有系统资源，它只会拥有一点儿在运行时必不可少的资源，但是它可以与同属于同一进程的线程共享该进程所拥有的所有资源。一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</p><a id="more"></a><h5 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h5><ol><li><strong>调度</strong> 线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li><li><strong>并发性</strong> 不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</li><li><strong>拥有资源</strong> 进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源</li><li><strong>系统开销</strong> 在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销</li></ol><h4 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h4><p>在 Java 中使用 Thread 类代表线程，所有的线程对象都必须是 Thread 类或者其子类的实例，Java 中创建线程主要有以下三种方式：</p><h5 id="方式一-继承-Thread-类"><a href="#方式一-继承-Thread-类" class="headerlink" title="方式一 继承 Thread 类"></a>方式一 继承 Thread 类</h5><p><strong>step 1</strong> 定义一个类继承自 <code>Thread</code> 类，然后重写该类的 <code>run</code> 方法，这个方法的内容表示线程要完成的任务<br><strong>step 2</strong> 创建线程对象，即创建 <code>Thread</code> 类子类的实例<br><strong>step 3</strong> 调用步骤二中创建出来的对象的 <code>start</code> 方法来启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过继承 Thread 类的方式创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByExtendsThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CreateThreadByExtendsThread threadOne = <span class="keyword">new</span> CreateThreadByExtendsThread();</span><br><span class="line">    CreateThreadByExtendsThread threadTwo = <span class="keyword">new</span> CreateThreadByExtendsThread();</span><br><span class="line">    CreateThreadByExtendsThread threadThree = <span class="keyword">new</span> CreateThreadByExtendsThread();</span><br><span class="line"></span><br><span class="line">    threadOne.start();</span><br><span class="line">    threadTwo.start();</span><br><span class="line">    threadThree.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二-实现-Runnable-接口"><a href="#方式二-实现-Runnable-接口" class="headerlink" title="方式二 实现 Runnable 接口"></a>方式二 实现 Runnable 接口</h5><p><strong>step 1</strong> 定义一个类实现 <code>Runnable</code> 接口，然后实现该接口的 <code>run</code> 方法，这个方法的内容同样也表示线程要完成的任务<br><strong>step 2</strong> 创建 <code>Runnable</code> 接口实现类的实例，并使用该实例作为 <code>Thraed</code> 构造方法的参数创建 <code>Thread</code> 类的对象，该对象才是真正的线程对象<br><strong>step 3</strong> 调用线程对象的 <code>start</code> 方法来启动该线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过实现 Runnable 接口的方式创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByImplementsRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CreateThreadByImplementsRunnable target = <span class="keyword">new</span> CreateThreadByImplementsRunnable();</span><br><span class="line">    <span class="keyword">new</span> Thread(target, <span class="string">"thread-one"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(target, <span class="string">"thread-two"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(target, <span class="string">"thread-three"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式三-实现-Callable-接口"><a href="#方式三-实现-Callable-接口" class="headerlink" title="方式三 实现 Callable 接口"></a>方式三 实现 Callable 接口</h5><p><strong>step 1</strong> 定义一个类实现 <code>Callable</code> 接口，然后实现该接口的 <code>call</code> 方法，这个方法的内容同样也表示线程要完成的任务，并且有返回值<br><strong>step 2</strong> 创建 <code>Callable</code> 接口实现类的实例，使用 <code>FutureTask</code> 类来包装 <code>Callable</code> 对象，该 <code>FutureTask</code> 对象封装了 <code>Callable</code> 对象的 <code>call</code> 方法的返回值<br><strong>step 3</strong> 并使用 <code>FutureTask</code> 对象作为 <code>Thraed</code> 构造方法的参数创建 <code>Thread</code> 对象，并调用该对象的 <code>start</code> 方法启动线程<br><strong>step 4</strong> 调用 <code>FutureTask</code> 对象的 <code>get</code> 方法获取线程执行结束后的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过实现 Callable 接口的方式创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByImplementsCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    IntStream.rangeClosed(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">      count.getAndIncrement();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CreateThreadByImplementsCallable target = <span class="keyword">new</span> CreateThreadByImplementsCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(target);</span><br><span class="line"></span><br><span class="line">    IntStream.rangeClosed(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" 的循环变量 i 的值"</span> + i);</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"有返回值的线程"</span>).start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"有返回值线程的返回值："</span> + futureTask.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上可以看出，其实通过实现 <code>Runnable</code> 接口和实现 <code>Callable</code> 接口这两种方式创建线程基本相同，采用实现 <code>Runnable</code> 和 <code>Callable</code> 接口的方式创建线程时，线程类只是实现接口，还可以继承其它类（<code>PS：Java 单继承决定</code>）。在这种方式下，多个线程可以共享同一个 <code>target</code>对象，所以非常适合多个相同线程来处理同一份资源的情况。还有一点就是，使用继承 <code>Thread</code> 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 <code>Thread.currentThread()</code> 方法，直接使用 <code>this</code> 即可获得当前线程。，在实际项目中如果使用这三种方式创建线程，如果创建关闭频繁会消耗系统资源影响性能，而使用线程池可以不用线程的时候放回线程池，用的时候再从线程池取，所以在我们项目开发中主要还是使用线程池，有关线程池的可以看看这两篇 <a href="https://www.mghio.cn/post/bc557e1a.html">Java 线程池（一）</a>、<a href="https://www.mghio.cn/post/ab706eb5.html">Java 线程池（二）</a>。</p><h4 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h4><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程，在 Java 中一个线程完整的生命周期一共包含以下五种状态：<br><strong>新建状态（New）</strong><br>当使用 <code>new</code> 关键字和 <code>Thread</code> 类或其子类创建一个线程对象后，那么线程就进入了<code>新建状态</code>，此时它和其它的 Java 对象一样，仅仅由 JVM 分配了内存，并初始化其成员变量值，它会一直保持这个状态直到调用该对象的 <code>start</code> 方法。</p><p><strong>就绪状态（Runnable）</strong><br>当线程对象调用了 <code>start</code> 方法之后，该线程就进入了就绪状态。就绪状态的线程会放在一个就绪队列中，等待 JVM 里的调度器进行调度。处于就绪状态的线程，随时可能被 CPU 调度执行。</p><p><strong>运行状态（Running）</strong><br>如果就绪状态的执行被 CPU 调度执行，就可以执行 <code>run</code> 方法，此时线程就处于线程状态。处于运行状态的线程最复杂，它可以变为<code>阻塞状态</code>、<code>就绪状态</code>和<code>死亡状态</code>。需要注意一点，线程变为<code>运行状态</code>之前的状态只能是<code>就绪状态</code>。</p><p><strong>阻塞状态（Blocked）</strong><br>线程变为阻塞状态是因为某种原因放弃 CPU 的使用权，暂时停止运行，如果执行了 <code>sleep</code>、<code>suspend</code> 等方法，释放了所占用的资源之后，线程就从<code>运行状态</code>进入<code>阻塞状态</code>。等待睡眠时间结束或者获得设备资源之可以重新进入<code>就绪状态</code>。阻塞可以分为以下三种：</p><ol><li><strong>等待阻塞</strong> 处于<code>运行状态</code>的线程调用<code>wait</code>方法，会使线程进入<code>等待阻塞状态</code></li><li><strong>同步阻塞</strong> 当线程获取 <code>synchronized</code> 同步锁因为同步锁被其他线程占用而失败后，会使线程进入<code>同步阻塞</code></li><li><strong>其它阻塞</strong> 通过调用线程的<code>sleep</code>或<code>join</code>发出了 I/O 请求时，线程就会进入到阻塞状态。当<code>sleep</code>状态超时，<code>join</code>等待线程终止或超时，或者 I/O 处理完毕，线程重新回到<code>就绪状态</code>。</li></ol><p><strong>死亡状态（Dead）</strong><br>一个处于<code>运行状态</code>的线程执行完了 <code>run</code> 方法或者因为其它终止条件发生时，线程就会进入到<code>死亡状态</code>，该线程结束生命周期。<br>以上线程各种状态的流转用一张图表示如下：</p><p><img src="https://i.loli.net/2019/12/07/ZtTHNLP8eoAYqcM.png" alt="thread-state-transfer.png"></p><h4 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h4><p>线程中常用的方法按照来源可以分为两类，一类是继承自 <code>Object</code> 类的方法，如下所示：</p><table><thead><tr><th align="left">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">public final native void notify()</td><td align="center">唤醒在此对象监视器上等待的单个线程，使其进入<code>就绪状态</code></td></tr><tr><td align="left">public final native void notifyAll()</td><td align="center">唤醒在此对象监视器上等待的所有线程，使其进入<code>就绪状态</code></td></tr><tr><td align="left">public final void wait()</td><td align="center">让当前线程处于·<code>等待阻塞状态</code>，直到其他线程调用此对象的<code>notify</code>方法或<code>notifyAll</code>方法，当前线程被唤醒，会释放它所持有的锁</td></tr><tr><td align="left">public final native void wait(long timeout)</td><td align="center">让当前线程处于·<code>等待阻塞状态</code>，直到其他线程调用此对象的<code>notify</code>方法或<code>notifyAll</code>方法，当前线程被唤醒</td></tr><tr><td align="left">public final void wait(long timeout, int nanos)</td><td align="center">让当前线程处于·<code>等待阻塞状态</code>，直到其他线程调用此对象的<code>notify</code>方法或<code>notifyAll</code>方法或者其他某个线程中断当前线程，或者已超过某个实际时间量，当前线程被唤醒</td></tr></tbody></table><p>另一类是 <code>Thread</code> 类定义的方法，如下所示：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public static native void yield()</td><td align="center">暂停当前正在执行的线程对象，并执行其他线程，<code>yield</code> 方法不会释放锁</td></tr><tr><td align="center">public static native void sleep(long millis)</td><td align="center">在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），<code>sleep</code> 方法不会释放锁</td></tr><tr><td align="center">public final void join()</td><td align="center">当某个程序执行流中调用其他线程的 <code>join</code> 方法时，调用线程将被阻塞，直到被 <code>join</code> 的线程执行完毕</td></tr><tr><td align="center">public void interrupt()</td><td align="center">用于中断本线程，这个方法被调用时，会立即将线程的中断标志设置为 <code>true</code></td></tr><tr><td align="center">public static boolean interrupted()</td><td align="center"><code>Thread</code> 类的一个静态方法，它返回一个布尔类型指明当前线程是否已经被中断，<code>interrupted</code> 方法除了返回中断标记之外，它还会清除中断标记(即将中断标记设为 <code>false</code>)</td></tr><tr><td align="center">public boolean isInterrupted()</td><td align="center"><code>Thread</code> 类的一个实例方法，它返回一个布尔类型指明当前线程是否已经被中断，<code>isInterrupted</code> 方法仅仅返回中断标记，不会清楚终端标记</td></tr></tbody></table><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 线程的优先级是一个整数，其取值范围是<code>1（Thread.MIN_PRIORITY ）~ 10（Thread.MAX_PRIORITY ）</code>。默认情况下，每一个线程都会分配一个优先级<code>NORM_PRIORITY（5）</code>。具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源，<code>Thread</code> 类提供了 <code>setPriority</code> 和 <code>getPriority</code> 方法来更改和获取线程优先级（<strong><font color="#ff0000">需要注意的是: 线程优先级不能保证线程执行的顺序，而且非常依赖于平台</font></strong>）。</p><hr><p>参考文章</p><ul><li><a href="https://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html" target="_blank" rel="noopener">进程和线程的区别</a></li><li><a href="https://www.cnblogs.com/skywang12345/p/3479224.html" target="_blank" rel="noopener">Java多线程系列–“基础篇”05之 线程等待与唤醒</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在接触&lt;code&gt;多线程&lt;/code&gt;之前，在我们程序中在任意时刻都只能执行一个步骤，称之为&lt;code&gt;单线程&lt;/code&gt;。在单线程开发的程序中所有的程序路径都是顺序执行的，前面的必须先执行，后面的才会执行。单线程的优点也很明显，相对于多线程来说更加稳定、扩展性更强、程序开发相对比较容易。但是由于每次都要等上一个任务执行完成后才能开始新的任务，导致其效率比多线程低，甚至有时候应用程序会出现假死的现象。使用多线程有利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。多线程是 Java 学习的非常重要的方面，是每个 Java 程序员必须掌握的基本技能。本文是有关 Java 多线程的一些基础知识总结。&lt;/p&gt;
&lt;h4 id=&quot;进程与线程的区别&quot;&gt;&lt;a href=&quot;#进程与线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程与线程的区别&quot;&gt;&lt;/a&gt;进程与线程的区别&lt;/h4&gt;&lt;h5 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h5&gt;&lt;p&gt;进程是&lt;code&gt;操作系统资源分配&lt;/code&gt;的基本单位，它是操作系统的基础，是一个程序及其数据在处理机上顺序执行时所发生的活动。一个程序进入内存运行，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立功能。进程的实质就是程序在操作系统中的一次执行过程，它是动态产生的、动态销毁的，拥有自己的生命周期和各种不同的运行状态。同时，进程还具有并发性，它可以同其他进程一起并发执行，按各自独立的、不可预知的速度向前推进（&lt;code&gt;PS：并发性和并行性是不同的概念，并行指的是同一时刻，两个及两个以上的指令在多个处理器上同时执行。而并发指的是同一时刻只有一条指令执行，但是多个进程可以被 CPU 快速交换执行，给我们感觉好像是多个执行在同时执行一样&lt;/code&gt;）。　&lt;/p&gt;
&lt;h5 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h5&gt;&lt;p&gt;线程是&lt;code&gt;任务调度和执行&lt;/code&gt;的基本单位，也被称为&lt;code&gt;轻量级进程&lt;/code&gt;，线程由线程 ID，当前指令指针(PC），寄存器集合和堆栈组成。线程不拥有系统资源，它只会拥有一点儿在运行时必不可少的资源，但是它可以与同属于同一进程的线程共享该进程所拥有的所有资源。一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="多线程" scheme="https://www.mghio.cn/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="多线程" scheme="https://www.mghio.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程池（二）</title>
    <link href="https://www.mghio.cn/post/ab706eb5.html"/>
    <id>https://www.mghio.cn/post/ab706eb5.html</id>
    <published>2019-11-30T08:07:14.000Z</published>
    <updated>2019-12-01T04:16:31.573Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在上篇 <a href="http://www.mghio.cn/post/bc557e1a.html">Java 线程池（一）</a> 我们介绍了线程池中一些的重要参数和具体含义，这篇我们看一看在 Java 中是如何去实现<code>线程池</code>的，要想用好线程池，只知其然是远远不够的，我们需要深入实现源码去了解线程池的具体实现细节，这样才能更好的使用到我们的工作中，当出现问题时能快速找到问题根源所在。</p><h4 id="线程池如何处理提交的任务"><a href="#线程池如何处理提交的任务" class="headerlink" title="线程池如何处理提交的任务"></a>线程池如何处理提交的任务</h4><p>我们向线程池提交任务有两种方式，分别是通过 <code>submit</code> 方法提交和通过 <code>execute</code> 方法提交，这两种方式的区别为 <code>execute</code> 只能提交 <code>Runnable</code> 类型的任务并且没有返回值，而 <code>submit</code> 既能提交 <code>Runnable</code> 类型的任务也能提交 <code>Callable</code>（JDK 1.5+）类型的任务并且会有一个类型 <code>Future</code> 的返回值，我们知道 <code>Runnable</code> 是没有返回值的，所以只有当提交 <code>Callable</code> 类型的任务时才会有返回值，而提交 <code>Runnable</code> 的返回值是 <code>null</code>。 <code>execute</code> 执行任务时，如果此时遇到异常会直接抛出，而 <code>submit</code> 不会直接抛出，只有在使用 <code>Future</code> 的 <code>get</code> 方法获取任务的返回结果时，才会抛出异常。<br>通过查看 <code>ThreadPoolExecutor</code> 的源码我们发现，其 <code>submit</code> 方法是继承自其抽象父类 <code>AbstractExecutorService</code> 而来的，有三个重载的方法，分别可以提交 <code>Runnable</code> 类型和 <code>Callable</code> 类型的任务。无论是哪个 <code>submit</code> 方法最终还是调用了 <code>execute</code> 方法来实现的。方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>首先对提交的任务进行判非空指针后，三个方法都是调用 <code>newTaskFor</code> 方法把任务统一封装成 <code>RunnableFuture</code> 对象，然后把封装好的对象作为 <code>execute</code> 方法的入参去执行，而此时 <code>execute</code> 方法还未实现，这个方法是在 <code>AbstractExecutorService</code> 的继承类 <code>ThreadPoolExecutor</code> 中实现。下面看看 <code>newTaskFor</code> 方法是如何封装我们提交的任务的，两个重载方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个 <code>FutureTask</code> 是个什么东东呢，进入其源码发现它实现了 <code>RunnableFuture</code> 接口，而 <code>RunnableFuture</code> 接口的作用正如其名，它是 <code>Runnable</code> 和 <code>Future</code> 的结合体，表示一个能<code>异步返回结果的线程</code>。我们知道 <code>Runnable</code> 是不能返回结果的，所以上面第一个 <code>newTaskFor(Runnable runnable, T value)</code> 方法的第二个参数 <code>value</code> 的作用就是指定返回结果。其实最后也是通过 <code>RunnableAdapter</code> 把  <code>Runnable</code> 和 <code>value</code> 封装成 <code>Callable</code> 的。下面我们看看 <code>execute</code> 方法是怎么处理的，方法源码如下：</p><p><img src="https://i.loli.net/2019/12/01/8gXOBWVe4hMmtPG.png" alt="thread-pool-3.png"></p><p><strong>第 ① 步</strong> 获取当前的 <code>ctl</code> 值，在上篇 <a href="http://www.mghio.cn/post/bc557e1a.html">Java 线程池（一）</a> 中说过，变量 <code>ctl</code> 存储了线程池的工作状态 <code>runState</code> 和线程池中正在运行的线程数 <code>workerCount</code>。<br><strong>第 ② 步</strong> 通过 <code>workerCountOf</code> 方法取出线程池中当前正在运行的线程数( <code>ctl</code> 低 29 位的值)，如果线程池当前工作线程数小于核心线程数 <code>corePoolSize</code>，则进行第 ③ 步。<br><strong>第 ③ 步</strong> 通过 <code>addWorker</code> 方法新建一个线程加到线程池中，<code>addWorker</code> 方法的第二个参数如果为 <code>true</code> 则限制添加线程的数量是根据 <code>corePoolSize</code> 来判断，反之则根据 <code>maximumPoolSize</code> 来判断，并把任务添加到该线程中。<br><strong>第 ④ 步</strong> 如果添加失败，则重新获取 <code>ctl</code> 的值。<br><strong>第 ⑤ 步</strong> 如果当前线程池的状态是运行状态（state &lt; SHUTDOWN）并且把任务成功添加到队列中。<br><strong>第 ⑥ 步</strong> 重新获取 <code>ctl</code> 的值，再次判断线程池的运行状态，如果不是运行状态，要从队列中移除任务，因为到这一步了，意味着之前已经把任务成功添加到队列中了，所以需要从队列移除。移除成功后调用拒绝策略对任务进行处理，整个 <code>execute</code> 方法结束（<code>PS：为什么不在入队列之前就先判断线程池的状态呢？因为判断一个线程池工作处于运行状态到执行入队列操作这段时间，线程池可能已经被其它线程关闭了，所以提前判断其实毫无意义</code>）。<br><strong>第 ⑦ 步</strong> 通过 <code>workerCountOf</code> 方法取出线程池中当前正在运行的线程数( <code>ctl</code> 低 29 位的值)，如果是 0 则执行 <code>addWorker(null, false)</code> 方法，第一个参数传 <code>null</code> 表示只是在线程池中创建一个线程出来，但是没有立即启动，因为我们创建线程池时可能要求核心线程数量为 0。第二个参数为 <code>false</code> 表示限制添加线程时根据 <code>maximumPoolSize</code> 来判断，如果当前线程池中正在运行线程数量大于 0 ，则直接返回，因为在上面第 ⑤ 步已经把任务成功添加到队列 <code>workQueue</code> 中，它会在将来的某个时刻执行到。<br><strong>第 ⑧ 步</strong> 如果执行到这个地方，只有两种情况，一种是线程池的状态已经不是运行状态了，另一种是线程池是运行状态，但是此时线程池的工作线程数大于等于核心线程数（workerCount &gt;= corePoolSize）并且队列 <code>workQueue</code> 已满。这时会再次调用 <code>addWorker</code> 方法，第二个参数传的 <code>false</code>，意味着限制添加线程的数量是根据 <code>maximumPoolSize</code> 来判断的，如果失败则调用拒绝策略对任务进行处理，整个 <code>execute</code> 方法结束。<br>上面的 <code>execute</code> 方法中多次调用 <code>addWorker</code>，该方法的主要作用就是创建一个线程来执行任务。<code>addWorker</code> 的方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addWorker(Runnable firstTask, <span class="keyword">boolean</span> core)</span><br></pre></td></tr></table></figure><p>第一个参数 <code>firstTask</code> 如果不为 <code>null</code>，则创建的线程首先执行 <code>firstTask</code> 任务，然后才会从队列中获取任务，否则会直接从队列中获取任务。第二个参数如果为 <code>true</code>，则表示限制添加线程时根据 <code>corePoolSize</code> 来判断，否则根据<code>maximumPoolSize</code> 来判断。我们看看 <code>addWorker</code> 方法的源码，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法首先获取线程池 <code>ctl</code> 属性的值，该属性包含了线程池的<code>运行状态</code>和<code>工作线程数</code>，通过 <code>runStateOf</code> 获取线程池的运行状态，然后执行下面这个比较复杂的条件判断</p><p><img src="https://i.loli.net/2019/11/30/ZlVv9WBwQgmd1xc.png" alt="thread-pool-4.png"></p><p>第 ① 个条件表示此时线程池已经不再接受新任务了，接下来的 ②、③、④ 三个判断条件只要有一个不满足，那么方法就会返回 <code>false</code>，方法结束。第 ② 个条件表示线程池为关闭状态，处于关闭状态的线程池不会处理新提交的任务，但会处理完已处理的任务，第 ③ 个条件为 firstTask 为 <code>null</code>，第 ④ 个条件为队列不为空。我们看看如果线程池此时为关闭状态的情况，这种情况线程池不会接受新提交的任务，所以此时如果传入的 <code>firstTask</code> 不为 <code>null</code>，则会直接返回 <code>false</code>；然后如果 <code>firstTask</code> 为 <code>null</code>，并且队列 <code>workQueue</code> 为空，此时也会返回 <code>false</code>，因为此时队列里已经没有任务了，那么也不需要再添加线程了，然后接下来会进入一个循环。</p><p><img src="https://i.loli.net/2019/11/30/uCHvlNtQpzT1ach.png" alt="thread-pool-5.png"></p><p><strong>第 ① 步</strong> 调用 <code>workerCountOf</code> 方法获取当前线程池的工作线程数<br><strong>第 ② 步</strong> 如果当前线程池的工作数大于 <code>CAPACITY</code> 也就是 <code>ctl</code> 的低 29 位的最大值，则返回 <code>false</code>，如果不大于 <code>CAPACITY</code>，然后根据 <code>core</code> （该方法的第二个参数）来判断是和 <code>corePoolSize</code> 比较还是和 <code>maximumPoolSize</code> 比较，如果比这个值大则返回 <code>false</code>。<br><strong>第 ③ 步</strong> 使用 <code>ctl</code> 的 <code>compareAndSet</code> 原子方法尝试把工作线程数 <code>workerCount + 1</code>，如果增加成功，退出第一层循环。<br><strong>第 ④ 步</strong> 如果增加线程池工作线程数失败，则重新获取 <code>ctl</code> 的值。<br><strong>第 ⑤ 步</strong> 调用 <code>runStateOf</code> 获取线程池的状态，如果不等于方法前面获取的 <code>rs</code>，说明线程池的状态已经改变了，回到第一层循环继续执行。<br>接下来会启动线程执行任务，源码如下：</p><p><img src="https://i.loli.net/2019/11/30/ZnRj4395iqIAk2t.png" alt="thread-pool-6.png"></p><p><strong>第 ① 步</strong> 根据 <code>firstTask</code> 创建 <code>Worker</code> 对象，每一个 <code>Worker</code> 对象都会创建一个线程，然后会使用重入锁 <code>ReentrantLock</code> 进行加锁操作。<br><strong>第 ② 步</strong> 调用 <code>runStateOf</code> 获取线程池的状态，然后进行一个条件判断，第一个 <code>rs &lt; SHUTDOWN</code> 表示线程池是运行状态。如果线程池是运行状态或者线程池是关闭状态并且 <code>firstTask</code> 为 <code>null</code>，那么就往线程池中加入线程（因为当线程池是 <code>SHUTDOWN</code> 状态时不会再向线程池添加新的任务，但会执行队列 <code>workQueue</code> 中的任务）。这里的 <code>workers</code> 是一个 <code>HashSet</code>，所以其 <code>add</code> 方法不是线程安全的，所以需要加锁操作。然后修改线程池中出现过的最大线程数量 <code>largestPoolSize</code> 记录和把是否添加成功标记 <code>workerAdded</code> 为 <code>true</code>。如果 <code>workerAdded</code> 为 <code>true</code> 那么会启动线程并把线程是否启动标记 <code>workerStarted</code> 改为 <code>true</code>。<br><strong>第 ③ 步</strong> 根据线程是否启动 <code>workerStarted</code> 标记来判断是否需要进行失败的操作。包含从 <code>workers</code> 移除当前的 <code>worker</code>、线程池的工作线程数减 1、尝试终端线程池。</p><h4 id="线程池中线程是如何执行的"><a href="#线程池中线程是如何执行的" class="headerlink" title="线程池中线程是如何执行的"></a>线程池中线程是如何执行的</h4><p>线程池的线程执行是调用 <code>Worker</code> 的 <code>thread</code> 属性的 <code>start</code> 方法，而 <code>thread</code> 的 <code>run</code> 方法实际上调用了 <code>Worker</code> 类的 <code>runWorker</code> 方法，所以我们直接来看看 <code>runWorker</code> 方法的源码：</p><p><img src="https://i.loli.net/2019/11/30/YsESi5peaUX31fC.png" alt="thread-pool-7.png"></p><p><strong>第 ① 步</strong> 获取第一个任务，<code>while</code> 循环不断地通过 <code>getTask</code> 方法从队列中获取任务。<br><strong>第 ② 步</strong> 这个判断条件目的是要保证如果线程池正在停止，要保证当前线程是中断状态，如果是的话，要保证当前线程不是终端状态。<br><strong>第 ③ 步</strong> 方法 <code>beforeExecute</code> 方法在类 <code>ThreadPoolExecutor</code> 中没有做任何操作，是留给子类去自定义在线程执行之前添加操作的方法。<br><strong>第 ④ 步</strong> 执行 <code>task.run()</code> 执行任务（<code>PS：这里为什么是调用 run 方法而不是调用 start 方法呢？我们知道当调用了 start 方法后操作系统才会给我们创建一个独立的线程来运行，而调用 run 方法只是一个普通的方法调用，而线程池正好就是需要它是一个普通的方法才能进行任务的调度。我们可以想象一下，假如这里是调用的 Runnable 的 start 方法，那么会是什么结果呢。如果我们往一个核心线程数、最大线程数为 3 的线程池里丢了 500 个任务，那么它会额外的创建 500 个线程，同时每个任务都是异步执行的，结果一下子就执行完毕了，根本无法对任务进行调度。从而没法做到由这 3 个 Worker 线程来调度这 1000 个任务，而只有当做一个普通的 run 方法调用时才能满足线程池的这个要求</code>）。<br><strong>第 ⑤ 步</strong> 方法 <code>afterExecute</code> 方法在类 <code>ThreadPoolExecutor</code> 中没有做任何操作，是留给子类去自定义在线程执行之后添加操作的方法。<code>completedAbruptly</code> 变量是用来表示在执行任务过程中是否出现了异常，<code>processWorkerExit</code> 方法中会对该变量的值进行判断。<br>接下来我们看看 <code>getTask</code> 方法是如何从队列中获取任务的，方法源码如下：</p><p><img src="https://i.loli.net/2019/12/01/PhBqwfsUFx4va3T.png" alt="thread-pool-8.png"></p><p><strong>第 ① 步</strong> 如果线程池不是运行状态，则判断线程池是否正在停止或者当前队列为空，如果条件满足将线程池的工作线程数减一并返回 <code>null</code>。因为如果当前线程池状态的值是 <code>SHUTDOWN</code> 或以上时，就不允许再向队列中添加任务了。<br><strong>第 ② 步</strong> 这里的 <code>timed</code> 变量用来标记是否需要线程进行超时控制，<code>allowCoreThreadTimeOut</code> 默认是 <code>false</code>，也就是核心线程不允许进行超时。<code>wc &gt; corePoolSize</code> 表示当前线程池中的工作线程数量大于核心线程数量，对于超过核心线程数量的这些线程，需要进行超时控制。<br><strong>第 ③ 步</strong> 第一个判断 <code>wc &gt; maximumPoolSize</code> 如果成立是因为可能在此方法执行阶段同时执行了线程池的 <code>setMaximumPoolSize</code> 方法；第二个判断 <code>timed &amp;&amp; timedOut</code> 如果成立表示当前操作需要进行超时控制，并且上次从队列中获取任务发生了超时（<code>timeOut</code> 变量的值表示上次从阻塞队列中取任务时是否超时）；第三个判断 <code>wc &gt; 1 || workQueue.isEmpty()</code> 如果线程池中工作线程数量大于 1，或者队列是空的，那么尝试将 <code>workerCount</code> 减一，如果减一失败，则返回重试。如果 <code>wc == 1</code> 时，也就说明当前线程是线程池中唯一的一个线程了。<br><strong>第 ④ 步</strong> 根据 <code>timed</code> 来判断，如果为 <code>true</code>，则通过阻塞队列的 <code>poll</code> 方法进行超时控制，如果在 <code>keepAliveTime</code> 时间内没有获取到任务，则返回 <code>null</code>，否则通过 <code>take</code> 方法，如果这时队列为空，则 <code>take</code> 方法会阻塞直到队列不为空。如果 <code>r == null</code>，说明已经超时，<code>timedOut</code> 设置为 <code>true</code>。<br><strong>第 ⑤ 步</strong> 如果获取任务时当前线程发生了中断，则设置 <code>timedOut</code> 为 <code>false</code> 并重新循环重试。</p><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><p>线程池的关闭一般都是使用 <code>shutdown</code> 方法和 <code>shutdownNow</code> 方法，两者的区别是前面的 <code>shutdown</code> 方法不会执行新的任务，但是会执行完当前正在执行的任务，而后面的 <code>shutdownNow</code> 方法会立即停止当前线程池，不管当前是否有线程在执行。一般都是使用 <code>shutdown</code> 方法来停止线程池，其方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>advanceRunState(SHUTDOWN)</code> 方法的作用是通过 <code>CAS</code> 原子操作将线程池的状态更改为关闭状态。<code>interruptIdleWorkers</code> 方法是对空闲的线程进行中断，其实是调用重载带参数的函数 <code>interruptIdleWorkers(false)</code>。然后 <code>onShutdown</code> 方法和上文提到的 <code>beforeExecute</code>、<code>afterExecute</code> 方法一样，在类 <code>ThreadPoolExecutor</code> 是空实现，也是个钩子函数。我们看看 <code>interruptIdleWorkers</code> 的实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进行加锁操作，然后遍历 <code>workers</code> 容器，也就是遍历线程池中的线程，对每个线程进行 <code>tryLock</code> 操作，如果成功说明线程空闲，则设置其中断标志位。而线程是否响应中断则交给我们定义任务的人来决定。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文比较详细的分析了线程池任务的提交、线程的执行、线程池的关闭的工作流程。通过学习线程池相关的源码后，看到了在其内部用运用了很多多线程的解决方法，有如下几个方式：</p><ol><li>通过定义重入锁 <code>ReentrantLock</code> 变量 <code>mainLock</code> 来解决并发多线程的安全问题</li><li>利用等待机制来实现线程之间的通讯问题<br>除了内置的功能外，<code>ThreadPoolExecutor</code> 也向外提供了两个接口供我们自己扩展满足我们需求的线程池，这两个接口分别是：<code>beforeExecute</code> 任务执行前执行的方法，<code>afterExecute</code> 任务执行结束后执行的方法。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在上篇 &lt;a href=&quot;http://www.mghio.cn/post/bc557e1a.html&quot;&gt;Java 线程池（一）&lt;/a&gt; 我们介绍了线程池中一些的重要参数和具体含义，这篇我们看一看在 Java 中是如何去实现&lt;code&gt;线程池&lt;/code&gt;的，要想用好线程池，只知其然是远远不够的，我们需要深入实现源码去了解线程池的具体实现细节，这样才能更好的使用到我们的工作中，当出现问题时能快速找到问题根源所在。&lt;/p&gt;
&lt;h4 id=&quot;线程池如何处理提交的任务&quot;&gt;&lt;a href=&quot;#线程池如何处理提交的任务&quot; class=&quot;headerlink&quot; title=&quot;线程池如何处理提交的任务&quot;&gt;&lt;/a&gt;线程池如何处理提交的任务&lt;/h4&gt;&lt;p&gt;我们向线程池提交任务有两种方式，分别是通过 &lt;code&gt;submit&lt;/code&gt; 方法提交和通过 &lt;code&gt;execute&lt;/code&gt; 方法提交，这两种方式的区别为 &lt;code&gt;execute&lt;/code&gt; 只能提交 &lt;code&gt;Runnable&lt;/code&gt; 类型的任务并且没有返回值，而 &lt;code&gt;submit&lt;/code&gt; 既能提交 &lt;code&gt;Runnable&lt;/code&gt; 类型的任务也能提交 &lt;code&gt;Callable&lt;/code&gt;（JDK 1.5+）类型的任务并且会有一个类型 &lt;code&gt;Future&lt;/code&gt; 的返回值，我们知道 &lt;code&gt;Runnable&lt;/code&gt; 是没有返回值的，所以只有当提交 &lt;code&gt;Callable&lt;/code&gt; 类型的任务时才会有返回值，而提交 &lt;code&gt;Runnable&lt;/code&gt; 的返回值是 &lt;code&gt;null&lt;/code&gt;。 &lt;code&gt;execute&lt;/code&gt; 执行任务时，如果此时遇到异常会直接抛出，而 &lt;code&gt;submit&lt;/code&gt; 不会直接抛出，只有在使用 &lt;code&gt;Future&lt;/code&gt; 的 &lt;code&gt;get&lt;/code&gt; 方法获取任务的返回结果时，才会抛出异常。&lt;br&gt;通过查看 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 的源码我们发现，其 &lt;code&gt;submit&lt;/code&gt; 方法是继承自其抽象父类 &lt;code&gt;AbstractExecutorService&lt;/code&gt; 而来的，有三个重载的方法，分别可以提交 &lt;code&gt;Runnable&lt;/code&gt; 类型和 &lt;code&gt;Callable&lt;/code&gt; 类型的任务。无论是哪个 &lt;code&gt;submit&lt;/code&gt; 方法最终还是调用了 &lt;code&gt;execute&lt;/code&gt; 方法来实现的。方法源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Future&amp;lt;?&amp;gt; submit(Runnable task) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (task == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    execute(ftask);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ftask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable task, T result)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (task == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    execute(ftask);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ftask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Callable&amp;lt;T&amp;gt; task)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (task == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    execute(ftask);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ftask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="线程池" scheme="https://www.mghio.cn/categories/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程池（一）</title>
    <link href="https://www.mghio.cn/post/bc557e1a.html"/>
    <id>https://www.mghio.cn/post/bc557e1a.html</id>
    <published>2019-11-23T10:35:30.000Z</published>
    <updated>2019-11-24T03:07:56.046Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h4><p>使用线程池可以很好的提高性能，线程池在运行之初就会创建一定数量的空闲线程，我们将一个任务提交给线程池，线程池就会使用一个空闲的线程来执行这个任务，该任务执行完后，该线程不会死亡，<code>而是再次变成空闲状态返回线程池，等待下一个任务的到来</code>。在使用线程池时，我们把要执行的任务提交给整个线程池，而不是提交给某个线程，线程池拿到提交的任务后，会在内部寻找是否还有空闲的线程，如果有，就将这个任务提交给某个空闲的线程，虽然一个线程同一时刻只能执行一个任务，但是我们可以向线程池提交多个任务。合理使用线程池有以下几个优点：<br>① <strong>降低资源消耗</strong> 多线程运行期间，系统不断的启动和关闭新线程，成本高，会过度消耗系统资源，通过<code>重用</code>存在的线程，减少对象创建、消亡的开销<br>② <strong>提高响应速度</strong> 当有任务到达时，任务可以不需要等待线程的创建，可以直接从线程池中取出空闲的线程来执行任务<br>③ <strong>方便线程管理</strong> 线程对计算机来说是很稀缺的资源，如果让他无限制创建，它不仅消耗系统的资源，还会降低系统的稳定性，我们使用线程池后可以统一进行分配和监控<br>谈到线程池就会想到<code>池化</code>技术，核心思想就是<code>把宝贵的资源放到一个池子中</code>，每次要使用都从池子里面取，用完之后又放回池子让别人用。那么线程池在 Java 中是如何实现的呢？</p><h4 id="Java-四种线程池"><a href="#Java-四种线程池" class="headerlink" title="Java 四种线程池"></a>Java 四种线程池</h4><p>在 Java 中 Executors 工具类给我们提供了四种不同使用场景的线程池的创建方法，分别为：</p><ol><li><code>newSingleThreadExecutor</code> 只有一个线程来执行任务，适用于有顺序的任务的应用场景。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，它可以保证任务按照指定顺序（FIFO，LIFO）执行，它还有可以指定线程工厂（<code>ThreadFactory</code>）的重载方法，可以自定义线程的创建行为</li><li><code>newFixedThreadPool</code> 固定线程数的线程池，只有核心线程，核心线程的即为最大的线程数量，没有非核心线程。每次提交一个任务就创建一个线程，直到达到线程池的最大大小。线程池一旦达到最大值就会保持不变，如果当中的某个线程因为异常而结束，那么线程池会新建一个线程加入到线程池中。它还可以控制线程的最大并发数，超出的线程会在阻塞队列（<code>LinkedBlockingQueue</code>）中等待，同样它也有可以指定线程工厂（<code>ThreadFactory</code>）的重载方法，可以自定义线程的创建行为。</li><li><code>newCachedThreadPool</code> 创建一个可缓存线程池，最大的线程个数为 <code>2^31 - 1（Integer.MAX_VALUE）</code>，可以认为是无限大，若无可回收，则新建线程，如果线程池的大小超出了处理任务所需要的线程，那么就会回收部分空闲（60s 不执行任务）的线程。</li><li><code>newScheduledThreadPool</code> 周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大（<code>Integer.MAX_VALUE：2^31 - 1</code>），适用于执行周期性的任务。</li></ol><a id="more"></a><h4 id="Java-线程池参数详解"><a href="#Java-线程池参数详解" class="headerlink" title="Java 线程池参数详解"></a>Java 线程池参数详解</h4><p>上文说到的 Executors 工具类提供的四种适用于不同场景的线程池，通过查看源码可以发现最终都是调用 <code>ThreadPoolExecutor</code> 类来实现的，我们接下来深入了解这个类一些成员变量的具体含义。首先是<code>ctl</code>，其声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这个成员变量 <code>ctl</code> 主要用于<code>存储线程池的工作状态以及线程池正在运行的线程数</code>。很显然，要在一个整型变量中存储两部分数据，只能将其一分为二。其中的高 3bit 用于存储线程的状态，低 29bit 用于存储线程池中正在执行的线程数。</p><h5 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h5><p>在 <code>ThreadPoolExecutor</code> 定义了线程池的五种状态（<code>注意，这里说的是线程池状态，不是池中的线程的状态</code>），当创建一个线程池时的状态为 <code>RUNNING</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">线程池状态</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">RUNNING</td><td align="center">允许提交并处理任务</td></tr><tr><td align="center">SHUTDOWN</td><td align="center">不会处理新提交的任务，但会处理完已处理的任务</td></tr><tr><td align="center">STOP</td><td align="center">不会处理新提交的任务，也不会处理阻塞队列中未执行的任务，并设置正在执行任务的中断标志位</td></tr><tr><td align="center">TIDYING</td><td align="center">所有任务执行完毕，线程池中工作的线程数为 0，等待执行 terminated() 钩子方法</td></tr><tr><td align="center">TERMINATED</td><td align="center">terminated() 钩子方法执行完毕</td></tr></tbody></table><p>调用线程池的 <code>shutdown</code> 方法，将线程池由 RUNNING 状态转为 SHUTDOWN 状态。调用 <code>shutdownNow</code> 方法，将线程池由 RUNNING 状态转为 STOP 状态。SHUTDOWN 状态和 STOP 状态都会先变为 TIDYING 状态，最终都会变为 TERMINATED 状态。用图表示为：</p><p><img src="https://i.loli.net/2019/11/23/RwvDlzJU23GfjdZ.png" alt="thread-pool-one.png"></p><p><code>ThreadPoolExecutor</code> 同时提供了以下三个方法来查看线程池的状态和池中正在执行的线程数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h5 id="ThreadPoolExecutor-的构造函数"><a href="#ThreadPoolExecutor-的构造函数" class="headerlink" title="ThreadPoolExecutor 的构造函数"></a>ThreadPoolExecutor 的构造函数</h5><p>该类参数最全的构造方法如下，这个方法决定了创建出来的线程池的各种属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>各个参数的含义：<br><code>corePoolSize</code> 线程池中核心线程数的最大值<br><code>maximumPoolSize</code> 线程池中最多能拥有的线程数<br><code>keepAliveTime</code> 空闲线程存活时间<br><code>unit</code> 空闲线程存活时间的单位<br><code>workQueue</code> 用于存放任务的阻塞队列<br><code>threadFactory</code> 创建线程工厂<br><code>handler</code> 当 <code>workQueue</code> 已满，并且池中的线程数达到 <code>maximumPoolSize</code> 时，线程池继续添加新任务时采取的策略</p><p>下面通过一张图来更形象的理解线程池的这几个参数：</p><p><img src="https://i.loli.net/2019/11/23/1rzqtsmXv3g5O24.png" alt="thread-pool-two.png"></p><p>corePoolSize、maximumPoolSize、workQueue 三者的关系，通过向线程池添加新的任务来说明着三者之间的关系：</p><ol><li>如果没有空闲的线程执行该任务，并且池中运行的线程数小于<code>corePoolSize</code>时，则创建新的线程执行该任务</li><li>如果没有空闲的线程执行该任务，并且当池中正在执行的线程数大于<code>corePoolSize</code>时，新添加的任务进入<code>workQueue</code>排队（如果<code>workQueue</code>长度允许），等待空闲线程来执行</li><li>如果没有空闲的线程执行该任务，并且阻塞队列已满同时池中的线程数小于<code>maximumPoolSize</code>，则创建新的线程执行该任务</li><li>如果没有空闲的线程执行该任务，并且阻塞队列已满同时池中的线程数等于<code>maximumPoolSize</code>，则根据构造函数中的<code>handler</code>指定的策略来拒绝新添加的任务</li></ol><p>在线程池中并没有标记出哪些线程是核心线程，哪些非核心线程，线程池它只关心<code>核心线程的数量</code>。下面这个是网上看到的一个形象的比喻：</p><blockquote><p>如果把线程池比作一个单位的话，<code>corePoolSize</code>就表示正式工，线程就可以表示一个员工。当我们向单位委派一项工作时，如果单位发现正式工还没招满，单位就会招个正式工来完成这项工作。随着我们向这个单位委派的工作增多，即使正式工全部满了，工作还是干不完，那么单位只能按照我们新委派的工作按先后顺序将它们找个地方搁置起来，这个地方就是<code>workQueue</code>，等正式工完成了手上的工作，就到这里来取新的任务。如果不巧，年末了，各个部门都向这个单位委派任务，导致<code>workQueue</code>已经没有空位置放新的任务，于是单位决定招点临时工吧（临时工：又是我！）。临时工也不是想招多少就找多少，上级部门通过这个单位的<code>maximumPoolSize</code>确定了你这个单位的人数的最大值，换句话说最多招<code>maximumPoolSize – corePoolSize</code>个临时工。当然，在线程池中，谁是正式工，谁是临时工是没有区别，完全同工同酬。</p></blockquote><h5 id="keepAliveTime-和-unit-单位"><a href="#keepAliveTime-和-unit-单位" class="headerlink" title="keepAliveTime 和 unit 单位"></a>keepAliveTime 和 unit 单位</h5><p>keepAliveTime 表示那些超出<code>corePoolSize</code>数量之外的线程的空闲时间大于<code>keepAliveTime</code>后就被清除了。</p><h5 id="workQueue-任务队列"><a href="#workQueue-任务队列" class="headerlink" title="workQueue 任务队列"></a>workQueue 任务队列</h5><p><code>workQueue</code>决定了缓存任务的排队策略，对于不同的任务场景我们可以采取不同的策略，这个队列需要一个实现了<code>BlockingQueue</code>接口的任务等待队列。从<code>ThreadPoolExecutor</code>的文档中得知，官方一共给我们推荐了三种队列，分别是：<code>SynchronousQueue</code>、<code>LinkedBlockingQueue</code>、<code>ArrayBlockingQueue</code>。其中<code>SynchronousQueue</code>和<code>ArrayBlockingQueue</code>属于<code>有限队列</code>，<code>LinkedBlockingQueue</code>属于<code>无限队列</code>，具体作用如下：</p><ol><li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等待另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>，静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列。</li><li><code>ArrayBlockingQueue</code>：有界阻塞队列。一个由数组支持的有界阻塞队列。此队列按<code>FIFO</code>（先进先出）原则对元素进行排序。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞，试图从空队列中提取元素将导致类似阻塞。</li><li><code>LinkedBlockingQueue</code>：链表结构的阻塞队列，尾部插入元素，头部取出元素。<code>LinkedBlockingQueue</code>是我们在<code>ThreadPoolExecutor</code>线程池中常用的等待队列。它可以指定容量也可以不指定容量。由于它具有“无限容量”的特性，实际上任何无限容量的队列/栈都是有容量的，这个容量就是<code>Integer.MAX_VALUE</code>。<code>LinkedBlockingQueue</code>的实现是基于链表结构，而不是类似<code>ArrayBlockingQueue</code>那样的数组。但实际使用过程中，不需要关心它的内部实现，如果指定了<code>LinkedBlockingQueue</code>的容量大小，那么它反映出来的使用特性就和<code>ArrayBlockingQueue</code>类似了。</li></ol><h5 id="threadFactory-创建线程的工厂"><a href="#threadFactory-创建线程的工厂" class="headerlink" title="threadFactory 创建线程的工厂"></a>threadFactory 创建线程的工厂</h5><p>其实像<code>ThreadPoolExecutor</code>有的没有<code>threadFactory</code>参数的构造方法中使用的创建线程的工厂就是默认的工厂，比如下面这个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个构造方法中，创建线程的工厂的方法使用<code>Executors.defaultThreadFactory()</code>的工厂和<code>ThreadPoolExecutor</code>中的<code>defaultHandler</code>默认抛弃策略。使用 <code>Executors.defaultThreadFactory</code>创建的线程同属于相同的线程组，具有同为<code>Thread.NORM_PRIORITY</code>的优先级，以及名为<code>pool-poolNumber.getAndIncrement()-thread-</code>的线程名（poolNumber.getAndIncrement() 为线程池顺序序号），且创建的线程都是非守护进程。</p><h5 id="handler-拒绝策略"><a href="#handler-拒绝策略" class="headerlink" title="handler 拒绝策略"></a>handler 拒绝策略</h5><p>表示当<code>workQueue</code>已满，池中的线程数达到<code>maximumPoolSize</code>时，线程池拒绝添加新任务时采取的策略。从文档中得知，<code>handler</code>一般可以取以下四种值：</p><table><thead><tr><th align="center">拒绝策略</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">AbortPolicy</td><td align="center">抛出 RejectedExecutionException 异常</td></tr><tr><td align="center">CallerRunsPolicy</td><td align="center">由向线程池提交任务的线程来执行该任务</td></tr><tr><td align="center">DiscardPolicy</td><td align="center">直接丢弃当前的任务</td></tr><tr><td align="center">DiscardOldestPolicy</td><td align="center">抛弃最旧的任务（最先提交而没有得到执行的任务）</td></tr></tbody></table><p>个人觉得最优雅的方式还是<code>AbortPolicy</code>提供的处理方式：抛出异常，由开发人员进行处理。<code>ThreadPoolExecutor</code>默认的拒绝方式<code>defaultHandler</code>就是<code>ThreadPoolExecutor.AbortPolicy</code>。</p><h4 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h4><p>最后，我们要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p><h5 id="任务的性质"><a href="#任务的性质" class="headerlink" title="任务的性质"></a>任务的性质</h5><p>任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能少的线程数量，如配置<code>Ncpu+1</code>个线程的线程池。IO 密集型任务则由于需要等待 IO 操作，线程并不是一直在执行任务，则配置尽可能多的线程，如<code>2*Ncpu</code>。混合型的任务，如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过<code>Runtime.getRuntime().availableProcessors()</code>方法获得当前设备的 CPU 个数。</p><h5 id="任务的优先级"><a href="#任务的优先级" class="headerlink" title="任务的优先级"></a>任务的优先级</h5><p>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p><h5 id="任务的执行时间"><a href="#任务的执行时间" class="headerlink" title="任务的执行时间"></a>任务的执行时间</h5><p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p><h5 id="任务的依赖性"><a href="#任务的依赖性" class="headerlink" title="任务的依赖性"></a>任务的依赖性</h5><p>依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，如果等待的时间越长 CPU 空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用 CPU。建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行 SQL 变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。</p><hr><p>参考文章：<br><a href="https://www.infoq.cn/article/java-threadPool" target="_blank" rel="noopener">JAVA 线程池的分析和使用</a><br><a href="https://blog.csdn.net/xiaojin21cen/article/details/87363143" target="_blank" rel="noopener">ThreadPoolExecutor 的 workQueue 任务队列详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;线程池简介&quot;&gt;&lt;a href=&quot;#线程池简介&quot; class=&quot;headerlink&quot; title=&quot;线程池简介&quot;&gt;&lt;/a&gt;线程池简介&lt;/h4&gt;&lt;p&gt;使用线程池可以很好的提高性能，线程池在运行之初就会创建一定数量的空闲线程，我们将一个任务提交给线程池，线程池就会使用一个空闲的线程来执行这个任务，该任务执行完后，该线程不会死亡，&lt;code&gt;而是再次变成空闲状态返回线程池，等待下一个任务的到来&lt;/code&gt;。在使用线程池时，我们把要执行的任务提交给整个线程池，而不是提交给某个线程，线程池拿到提交的任务后，会在内部寻找是否还有空闲的线程，如果有，就将这个任务提交给某个空闲的线程，虽然一个线程同一时刻只能执行一个任务，但是我们可以向线程池提交多个任务。合理使用线程池有以下几个优点：&lt;br&gt;① &lt;strong&gt;降低资源消耗&lt;/strong&gt; 多线程运行期间，系统不断的启动和关闭新线程，成本高，会过度消耗系统资源，通过&lt;code&gt;重用&lt;/code&gt;存在的线程，减少对象创建、消亡的开销&lt;br&gt;② &lt;strong&gt;提高响应速度&lt;/strong&gt; 当有任务到达时，任务可以不需要等待线程的创建，可以直接从线程池中取出空闲的线程来执行任务&lt;br&gt;③ &lt;strong&gt;方便线程管理&lt;/strong&gt; 线程对计算机来说是很稀缺的资源，如果让他无限制创建，它不仅消耗系统的资源，还会降低系统的稳定性，我们使用线程池后可以统一进行分配和监控&lt;br&gt;谈到线程池就会想到&lt;code&gt;池化&lt;/code&gt;技术，核心思想就是&lt;code&gt;把宝贵的资源放到一个池子中&lt;/code&gt;，每次要使用都从池子里面取，用完之后又放回池子让别人用。那么线程池在 Java 中是如何实现的呢？&lt;/p&gt;
&lt;h4 id=&quot;Java-四种线程池&quot;&gt;&lt;a href=&quot;#Java-四种线程池&quot; class=&quot;headerlink&quot; title=&quot;Java 四种线程池&quot;&gt;&lt;/a&gt;Java 四种线程池&lt;/h4&gt;&lt;p&gt;在 Java 中 Executors 工具类给我们提供了四种不同使用场景的线程池的创建方法，分别为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt; 只有一个线程来执行任务，适用于有顺序的任务的应用场景。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，它可以保证任务按照指定顺序（FIFO，LIFO）执行，它还有可以指定线程工厂（&lt;code&gt;ThreadFactory&lt;/code&gt;）的重载方法，可以自定义线程的创建行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt; 固定线程数的线程池，只有核心线程，核心线程的即为最大的线程数量，没有非核心线程。每次提交一个任务就创建一个线程，直到达到线程池的最大大小。线程池一旦达到最大值就会保持不变，如果当中的某个线程因为异常而结束，那么线程池会新建一个线程加入到线程池中。它还可以控制线程的最大并发数，超出的线程会在阻塞队列（&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;）中等待，同样它也有可以指定线程工厂（&lt;code&gt;ThreadFactory&lt;/code&gt;）的重载方法，可以自定义线程的创建行为。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt; 创建一个可缓存线程池，最大的线程个数为 &lt;code&gt;2^31 - 1（Integer.MAX_VALUE）&lt;/code&gt;，可以认为是无限大，若无可回收，则新建线程，如果线程池的大小超出了处理任务所需要的线程，那么就会回收部分空闲（60s 不执行任务）的线程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt; 周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大（&lt;code&gt;Integer.MAX_VALUE：2^31 - 1&lt;/code&gt;），适用于执行周期性的任务。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="线程池" scheme="https://www.mghio.cn/categories/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深挖 HashMap</title>
    <link href="https://www.mghio.cn/post/99ea2970.html"/>
    <id>https://www.mghio.cn/post/99ea2970.html</id>
    <published>2019-11-14T13:23:23.000Z</published>
    <updated>2019-11-16T09:06:26.019Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h4><p>做过 java 开发的朋友们相信都很熟悉 HashMap 这个类，它是一个基于 hashing 原理用于存储 Key-Value 键值对的集合，其中的每一个键也叫做 <code>Entry</code>，这些键分别存储在一个数组当中，系统会根据 <code>hash</code> 方法来计算出 Key-Value 的存储位置，可以通过 key 快速存取 value。<br>HashMap 基于 hashing 原理，当我们将一个键值对（Key-Value） 传入 <code>put</code> 方法时，它将调用这个 key 的  <code>hashcode</code> 方法计算出 key 的 hashcode 值，然后根据这个 hashcode 值来定位其存放数组的位置来存储对象（HashMap 使用链表来解决碰撞问题，当其发生碰撞了，对象将会存储在链表的下一个节点中，在链表的每个节点中存储 <code>Entry</code> 对象，在 JDK 1.8+ 中，当链表的节点个数超过一定值时会转为红黑树来进行存储），当通过 <code>get</code> 方法传入一个 key 来获取其对应的值时，也是先通过 key 的 <code>hashcode</code> 方法来定位其存储在数组的位置，然后通过键对象的 <code>eqauls</code> 方法找到对应的 value 值。接下来让我们看看其内部的一些实现细节。（<code>PS：以下代码分析都是基于 JDK 1.8</code>）</p><h4 id="1-2-为什么容量始终是-2-的整数次幂"><a href="#1-2-为什么容量始终是-2-的整数次幂" class="headerlink" title="1.2 为什么容量始终是 2 的整数次幂"></a>1.2 为什么容量始终是 2 的整数次幂</h4><p>因为获取 key 在数组中对应的下标是通过 key 的哈希值与数组的长度减一进行与运算来确定的（<code>tab[(n - 1) &amp; hash]</code>）。当数组的长度 n 为 2 的整数次幂，这样进行 n - 1 运算后，之前为 1 的位后面全是 1 ，这样就能保证 <code>(n - 1) &amp; hash</code> 后相应位的值既可能是 1 又可能是 0 ，这完全取决于 key 的哈希值，这样就能保证散列的均匀，同时与运算（位运算）效率高。如果数组的长度 n 不是 2 的整数次幂，会造成更多的 hash 冲突。HashMap 提供了如下四个重载的构造方法来满足不同的使用场景：</p><ol><li>无参构造：<code>HashMap()</code>，使用该方法表示全部使用 HashMap 的默认配置参数</li><li>指定容量初始值构造：<code>HashMap(int initialCapacity)</code>，在初始化 HashMap 时指定其容量大小</li><li>指定容量初始值和扩容因子构造：<code>HashMap(int initialCapacity, float loadFactor)</code>，使用自定义初始化容量和扩容因子</li><li>通过 <code>Map</code> 来构造 HashMap：<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>，使用默认的扩容因子，其容量大小有传入的 <code>Map</code> 大小来决定<a id="more"></a>前三个构造方法最终都是调用第三个即自定义容量初始值和扩容因子构造 <code>HashMap(int initialCapacity, float loadFactor)</code>，其源码实现如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从源码实现可以看出，如果我们传入的初始容量值大于 <code>MAXIMUM_CAPACITY</code> 时，就设置容量为 <code>MAXIMUM_CAPACITY</code>，其值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">  * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">  * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>也就是容量的最大值为 2 的 30 次方（<code>1 &lt;&lt; 30</code>）。我们知道，HashMap 的容量始终是 2 的整数次幂，不管我们传入的初始容量是什么，它都会使用最接近这个值并且是 2 的整数次幂作为 HashMap 的初始容量，这一步处理是通过 <code>tableSizeFor</code> 方法来实现的，我们看看它的源码：</p><p><img src="https://i.loli.net/2019/11/14/MArIFaUlDchbvVG.png" alt="hashmap-tableSizeFor.png"></p><p>通过方法的注释我们也可以知道（<code>英语对于从事技术开发的人太重要了~~~</code>），此方法的返回值始终是 2 的整数次幂，它是如何做到的呢？接下来我们通过一个例子一步一步来看，假设我们传入的初始容量大小 <code>cap</code> 的值 <code>cap</code> 为 15。</p><p><strong>第 ① 步</strong>：将 <code>cap - 1</code> 后，<code>n</code> 的值为 14（15 - 1）。 </p><p><strong>第 ② 步</strong>：将 <code>n</code> 的值先右移 1 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/mCWoVrOeBY4zsuE.png" alt="hashmap-tableSizeFor-2.png"></p><p><strong>第 ③ 步</strong>：将 <code>n</code> 的值先右移 2 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/LHIDGjecq5Ak8oQ.png" alt="hashmap-tableSizeFor-3.png"></p><p><strong>第 ④ 步</strong>：将 <code>n</code> 的值先右移 4 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/oOt6wEuycSBDUjx.png" alt="hashmap-tableSizeFor-4.png"></p><p><strong>第 ⑤ 步</strong>：将 <code>n</code> 的值先右移 8 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/BFRgw85KzCMNsqy.png" alt="hashmap-tableSizeFor-5.png"></p><p><strong>第 ⑥ 步</strong>：将 <code>n</code> 的值先右移 16 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/g7DqVIRf9sz1wK4.png" alt="hashmap-tableSizeFor-6.png"></p><p>最后如果 <code>n</code> 的值小于 <code>0</code>，则返回 1，如果大于最大值 <code>MAXIMUM_CAPACITY</code> 则返回 <code>MAXIMUM_CAPACITY</code>，否则返回 <code>n + 1</code>。 现在 n 为 15，所以返回 n + 1（16），而 16 正好是 2 的 4 次幂。有的朋友可能会问，刚刚上文假设的初始容量大小 <code>cap</code> 是 15，本来就不是 2 的整数次幂，如果我传入初始容量的就是 2 的整数次幂那会怎么样呢？现在假设传的初始容量大小为 32（2 的 5 次方）看看结果是什么。</p><p><strong>第 ① 步</strong>：将 <code>cap - 1</code> 后，<code>n</code> 的值为 31（32 - 1）。 </p><p><strong>第 ② 步</strong>：将 <code>n</code> 的值先右移 1 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/BK2QEp5dxLCfhkA.png" alt="hashmap-tableSizeFor-even-1.png"></p><p><strong>第 ③ 步</strong>：将 <code>n</code> 的值先右移 2 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/WX9BlOhDjfaZypn.png" alt="hashmap-tableSizeFor-even-2.png"></p><p><strong>第 ④ 步</strong>：将 <code>n</code> 的值先右移 4 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/m2MgTlSfuIowHF7.png" alt="hashmap-tableSizeFor-even-4.png"></p><p><strong>第 ⑤ 步</strong>：将 <code>n</code> 的值先右移 8 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/ZYl6Hnf7cSxsJdk.png" alt="hashmap-tableSizeFor-even-5.png"></p><p><strong>第 ⑥ 步</strong>：将 <code>n</code> 的值先右移 16 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/7hgSZaOXxyMbuj8.png" alt="hashmap-tableSizeFor-even-6.png"></p><p>经过以上 6 步计算后得出 n 的值为 31，大于 0 小于 <code>MAXIMUM_CAPACITY</code> 返回 <code>n + 1</code>，所以经过计算后的初始容量大小为 32。稍微总结一下，我们可以得出：如果我们传入的初始容量大小不是 2 的整数次幂，那么经过计算后的初始容量大小为大于我们传入初始容量值的最小值并且是 2 的整数次幂。细心的朋友会发现，为什么第一步要进行 <code>cap - 1</code> 的操作呢？那是因为，如果不进行 - 1 运算的话，当我们传入的初始容量大小为 2 的整数次幂的时候，通过以上步骤计算出来的结果值为传入值的 2 倍。假设我们传入的初始容量大小为 32，此时没有第 ① 步（<code>cap - 1</code>）的操作，那么依次通过以上 ②、③、④、⑤、⑥ 后为 <code>63</code>，最后再进行 <code>n + 1</code> 操作，结果为 <code>64</code> 是 传入值 32 的 2 倍，显然和预期结果（<code>32</code>）不符。这个计算初始容量的算法还是很巧妙的，先进行了 -1 的操作，保证传入初始容量值为 2 的整数次幂的时候，返回传入的原始值。 </p><h4 id="1-3-hash-方法是如何实现的"><a href="#1-3-hash-方法是如何实现的" class="headerlink" title="1.3 hash 方法是如何实现的"></a>1.3 hash 方法是如何实现的</h4><p>不管是通过 <code>get</code> 方法获取 key 对应的 Value 值或者通过 <code>put</code> 方法存储 Key-Value 键值对时，都会先根据 key 的哈希值定位到数组的位置，我们看看 HashMap 里的 <code>hash</code> 方法是如何实现的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 key 为 <code>null</code> 时，返回 0，否则进行 <code>h = key.hashCode()) ^ (h &gt;&gt;&gt; 16</code> 运算，先调用 key 的 <code>hashCode</code> 方法获取 key 的哈希值，然后与 key 的哈希值右移 16 位后的值进行异或运算（相同为 0，不同为 1，简称 <code>同假异真</code>），为什么获取 key 的哈希值还要再进行异或运算，直接返回 key 的哈希值好像也没什么问题，如果没有后面的异或运算，直接返回哈希值，我们假设数组的长度为 16，现在要往 HashMap 存入的三个键值对的 key 的哈希值分别为 32831、33554495、2097215，根据 hash 方法返回值定位到数组的位置（<code>(n - 1) &amp; hash</code>），以上三个值和 15（16 - 1）进行 <code>&amp; 运算（都为 1 才为 1，其它情况都为 0）</code> 如下：</p><p><img src="https://i.loli.net/2019/11/16/EQ2aWPbKxYryDn8.png" alt="hashmap-hashcode-2.png"></p><p>可以发现以上三个哈希值都定位的数组下标为 15 的位置上。所以 <code>hash</code> 如果方法没有后面与哈希值右移 16 位后的值进行异或运算的话，当数组长度比较小时很容易造成 <code>哈希碰撞</code>，即多个 key（不同的哈希值）都会定位到数组上的同一个位置，也就是说会放入到同一个链表或者红黑树中，因为此时 key 的哈希值只有低位的才会参与运算，显然和我们的预期不符合。可见 <code>hash</code> 方法将 key 的哈希值与其右移 16 位后进行异或运算能减少哈希碰撞的次数，把高位和低位都参与了运算，提高了分散性。</p><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><p>HashMap 其实还有很多值得我们深入研究的点，看懂了上面两个方法后，不得不佩服作者的代码设计能力，JDK 中有很多优秀源码都值得我们好好品味，看代码的时候一定要多看几遍多问几个为什么，特别是经典的源代码，然后将这些思想运用到我们的实际工作中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h4&gt;&lt;p&gt;做过 java 开发的朋友们相信都很熟悉 HashMap 这个类，它是一个基于 hashing 原理用于存储 Key-Value 键值对的集合，其中的每一个键也叫做 &lt;code&gt;Entry&lt;/code&gt;，这些键分别存储在一个数组当中，系统会根据 &lt;code&gt;hash&lt;/code&gt; 方法来计算出 Key-Value 的存储位置，可以通过 key 快速存取 value。&lt;br&gt;HashMap 基于 hashing 原理，当我们将一个键值对（Key-Value） 传入 &lt;code&gt;put&lt;/code&gt; 方法时，它将调用这个 key 的  &lt;code&gt;hashcode&lt;/code&gt; 方法计算出 key 的 hashcode 值，然后根据这个 hashcode 值来定位其存放数组的位置来存储对象（HashMap 使用链表来解决碰撞问题，当其发生碰撞了，对象将会存储在链表的下一个节点中，在链表的每个节点中存储 &lt;code&gt;Entry&lt;/code&gt; 对象，在 JDK 1.8+ 中，当链表的节点个数超过一定值时会转为红黑树来进行存储），当通过 &lt;code&gt;get&lt;/code&gt; 方法传入一个 key 来获取其对应的值时，也是先通过 key 的 &lt;code&gt;hashcode&lt;/code&gt; 方法来定位其存储在数组的位置，然后通过键对象的 &lt;code&gt;eqauls&lt;/code&gt; 方法找到对应的 value 值。接下来让我们看看其内部的一些实现细节。（&lt;code&gt;PS：以下代码分析都是基于 JDK 1.8&lt;/code&gt;）&lt;/p&gt;
&lt;h4 id=&quot;1-2-为什么容量始终是-2-的整数次幂&quot;&gt;&lt;a href=&quot;#1-2-为什么容量始终是-2-的整数次幂&quot; class=&quot;headerlink&quot; title=&quot;1.2 为什么容量始终是 2 的整数次幂&quot;&gt;&lt;/a&gt;1.2 为什么容量始终是 2 的整数次幂&lt;/h4&gt;&lt;p&gt;因为获取 key 在数组中对应的下标是通过 key 的哈希值与数组的长度减一进行与运算来确定的（&lt;code&gt;tab[(n - 1) &amp;amp; hash]&lt;/code&gt;）。当数组的长度 n 为 2 的整数次幂，这样进行 n - 1 运算后，之前为 1 的位后面全是 1 ，这样就能保证 &lt;code&gt;(n - 1) &amp;amp; hash&lt;/code&gt; 后相应位的值既可能是 1 又可能是 0 ，这完全取决于 key 的哈希值，这样就能保证散列的均匀，同时与运算（位运算）效率高。如果数组的长度 n 不是 2 的整数次幂，会造成更多的 hash 冲突。HashMap 提供了如下四个重载的构造方法来满足不同的使用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无参构造：&lt;code&gt;HashMap()&lt;/code&gt;，使用该方法表示全部使用 HashMap 的默认配置参数&lt;/li&gt;
&lt;li&gt;指定容量初始值构造：&lt;code&gt;HashMap(int initialCapacity)&lt;/code&gt;，在初始化 HashMap 时指定其容量大小&lt;/li&gt;
&lt;li&gt;指定容量初始值和扩容因子构造：&lt;code&gt;HashMap(int initialCapacity, float loadFactor)&lt;/code&gt;，使用自定义初始化容量和扩容因子&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Map&lt;/code&gt; 来构造 HashMap：&lt;code&gt;HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m)&lt;/code&gt;，使用默认的扩容因子，其容量大小有传入的 &lt;code&gt;Map&lt;/code&gt; 大小来决定
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="原理" scheme="https://www.mghio.cn/categories/Java/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java, 原理" scheme="https://www.mghio.cn/tags/Java-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>同步工具类</title>
    <link href="https://www.mghio.cn/post/ee27c07f.html"/>
    <id>https://www.mghio.cn/post/ee27c07f.html</id>
    <published>2019-11-03T12:35:02.000Z</published>
    <updated>2019-11-03T23:40:43.101Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h4><p>同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。在容器中，有些也可以作为同步工具类，其它类型的同步工具类还包括闭锁（Latch）、信号量（Semaphore）以及栅栏（Barrier）。阻塞队列（eg: BlockQueue）是一种独特的类：它们不仅能作为保存对象的容器，还能协调生产者和消费者之间的控制流，因为它提供的 <code>take</code> 和 <code>put</code> 等方法将会阻塞，直到队列达到期望的状态。所有的同步工具类都包含一些特定的属性：它们封装了一些状态，这些状态将决定同步工具类的线程是继续执行还是等待，此外还提供了一些方法对其状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。</p><h4 id="1-2-闭锁"><a href="#1-2-闭锁" class="headerlink" title="1.2 闭锁"></a>1.2 闭锁</h4><p>闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有线程通过。当闭锁到达结束状态后，将不会再次改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其它活动都完成后才继续执行。比如：</p><ul><li>确保某个计算机在其需要的所有资源初始化后才能继续执行。</li><li>确保某个服务在其依赖的所有服务都已经启动后才启动。</li><li>等待直到某个操作的所有参与者都就绪后再继续执行。<a id="more"></a></li></ul><h5 id="1-2-1-CountDownLatch"><a href="#1-2-1-CountDownLatch" class="headerlink" title="1.2.1 CountDownLatch"></a>1.2.1 CountDownLatch</h5><p><code>CountDownLatch</code> 是一种灵活的闭锁实现，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待事件的数量。<code>countDown()</code> 方法递减计数器，表示有一个事件已经发生了，而 <code>await()</code> 方法等待计数器达到 0 ，这表示所有需要等待的事件都已经发生。如果计数器的值非 0 ，那么 <code>await()</code> 方法会一直阻塞到计数器的值为 0 ，或者等待线程中断，或者等待超时。<br><code>CountDownLatch</code> 被用来同步一个或多个任务，强制它们等待由其它任务执行的一组操作完成。你可以向 <code>CountDownLatch</code> 对象设置一个初始计数值，任何在这个对象上调用 <code>await()</code> 的方法都将阻塞，直到这个计数值到达 0。其它任务在结束工作时，可以在该对象上调用 <code>countDown()</code> 方法来减小这个计数值。<code>CountDownLatch</code> 被设计为只触发一次，计数值不能重置。如果你需要重置计数值的版本，请看下文的 <code>CyclicBarrier</code>。把大象放入冰箱的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-11-03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步工具类 —— CountDownLatch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">"step 1：打开冰箱门..."</span>);</span><br><span class="line">      <span class="comment">// 对 countDownLatch1 倒计时 -1</span></span><br><span class="line">      countDownLatch1.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待 countDownLatch1 倒计时，计时为 0 则往下运行</span></span><br><span class="line">        countDownLatch1.await();</span><br><span class="line">        System.out.println(<span class="string">"step 2：把大象放入冰箱..."</span>);</span><br><span class="line">        <span class="comment">// 对 countDownLatch2 倒计时 -1</span></span><br><span class="line">        countDownLatch2.countDown();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对 countDownLatch2 倒计时，计时为 0 则往下进行</span></span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        System.out.println(<span class="string">"step 3：关上冰箱门..."</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"------- 把大象放入冰箱 --------"</span>);</span><br><span class="line">    thread3.start();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------- 把大象放入冰箱 --------</span><br><span class="line">step <span class="number">1</span>：打开冰箱门...</span><br><span class="line">step <span class="number">2</span>：把大象放入冰箱...</span><br><span class="line">step <span class="number">3</span>：关上冰箱门...</span><br></pre></td></tr></table></figure><h5 id="1-2-2-FutureTask"><a href="#1-2-2-FutureTask" class="headerlink" title="1.2.2 FutureTask"></a>1.2.2 FutureTask</h5><p><code>FutureTask</code> 也可以用作闭锁。它实现了 <code>Future</code> 的语义，表示一种抽象可生成结果的计算。 <code>FutureTask</code> 表示的计算是通过 <code>Callable</code> 来实现的，相当于一种可生成结果的 <code>Runnable</code> ，并且可以处于这三种状态：<code>等待运行（Waiting to run）</code>、<code>正在运行（Running）</code>和<code>运行完成（Completed）</code>。其中<code>执行完成</code>表示计算的所有可能结束方式，包括正常结束、由于取消结束和由于异常结束等。当 <code>FutureTask</code> 进入完成状态后，它就会永远停在这个状态上。<code>get()</code> 方法的行为取决于任务的状态。如果此时任务已经完成，那么 <code>get()</code> 方法会立即返回结果，否则将会阻塞直到任务进入到完成状态，然后返回结果或者抛出异常。<code>FutureTask</code> 将计算结果从执行计算的线程传递到获取这个结果的线程，而 <code>FutureTask</code> 的规范确保了这种传递过程能实现结果的安全发布。<br><code>FutureTask</code> 在 <code>Executor</code> 框架中表示异步任务，除此之外还可以用来表示一些耗时比较长的计算，这些计算可以在使用计算结果之前启动。以下示例使用其执行一个异步任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-11-03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步工具类 —— FutureTask</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"--------- 进入主线程执行任务"</span>);</span><br><span class="line">    ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">    System.out.println(<span class="string">"--------- 提交异步任务"</span>);</span><br><span class="line">    FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; <span class="string">"成功获取 future 异步任务结果"</span>);</span><br><span class="line">    threadPool.execute(future);</span><br><span class="line">    System.out.println(<span class="string">"--------- 提交异步任务之后，立马返回到主线程继续往下执行"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">"--------- 此时需要获取上面异步任务的执行结果"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">      <span class="keyword">if</span> (future.isDone() &amp;&amp; !future.isCancelled()) &#123;</span><br><span class="line">        String futureResult = future.get();</span><br><span class="line">        System.out.println(<span class="string">"--------- 异步任务返回的结果是："</span> + futureResult);</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!threadPool.isShutdown()) &#123;</span><br><span class="line">      threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------- 进入主线程执行任务</span><br><span class="line">--------- 提交异步任务</span><br><span class="line">--------- 提交异步任务之后，立马返回到主线程继续往下执行</span><br><span class="line">--------- 此时需要获取上面异步任务的执行结果</span><br><span class="line">--------- 异步任务返回的结果是：成功获取 future 异步任务结果</span><br></pre></td></tr></table></figure><h4 id="1-4-信号量"><a href="#1-4-信号量" class="headerlink" title="1.4 信号量"></a>1.4 信号量</h4><p>计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行指定操作的数量。计数信号量还可以用来实现某种资源池或者对容器施加边界。<code>Semaphore</code> 中管理着一组虚拟的许可（<code>permit</code>），许可的初始数量可以通过构造函数来指定，在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，那么 <code>acquire()</code> 将阻塞直到有许可或者直到终端或者直到超时。<code>release()</code> 方法将返回一个许可给信号量。<code>Semaphore</code> 可以用于实现资源池，例如数据库连接池。我们可以构造一个固定长度的资源池，当池为空时，请求资源将会失败，但你真正希望看到的行为是阻塞而不是失败，并且当池非空时解除阻塞。如果将 <code>Semaphore</code> 的计数值初始化为池的大小，并在从池中获取一个资源之前首先调用 <code>acquire()</code> 方法获取一个许可，在将资源返回给池之后调用 <code>release()</code> 方法释放许可，那么 <code>acquire()</code> 方法将一直阻塞直到资源池不为空。以下示例将使用 <code>Semaphore</code> 将 <code>HashSet</code> 容器变成有界的阻塞容器，信号量的计数值会初始化为容器容量的最大值。<code>add</code> 操作在向底层容器添加一个元素之前，首先要获取一个许可。如果 <code>add</code> 操作没有添加任何元素，那么会立刻释放许可。同样 <code>remove</code> 操作会释放一个许可，使更多的元素能够添加到容器中。底层的 <code>Set</code> 实现并不知道关于边界的任何信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> maguihai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-11-03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步工具类 —— Semaphore</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    <span class="keyword">this</span>.sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sem.acquire();</span><br><span class="line">    <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      wasAdded = set.add(o);</span><br><span class="line">      <span class="keyword">return</span> wasAdded;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!wasAdded) &#123;</span><br><span class="line">        sem.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> wasRemoved = set.remove(o);</span><br><span class="line">    <span class="keyword">if</span> (wasRemoved) &#123;</span><br><span class="line">      sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wasRemoved;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-栅栏"><a href="#1-5-栅栏" class="headerlink" title="1.5 栅栏"></a>1.5 栅栏</h4><p>我们已经看到通过<code>闭锁</code>来启动一组相关的操作，或者等待一组相关的操作结束。闭锁是一次性对象，一旦进入终止状态，就不能被重置。栅栏（Barrier）类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于：所有线程都必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其它线程。栅栏用于实现一些协议，例如几个家庭决定在某个地方集合：“所有人 6:00 在 KFC 碰头，到了以后要等其它人，之后再讨论下一步要做的事情”。<code>CyclicBarrier</code> 适用于这样的情况：你希望创建一组任务，他们并行执行工作，然后再运行下一个步骤之前等待，知道所有任务都完成（有点儿像线程的 <code>join</code> 方法）。它使得所有的并行任务都将处于栅栏处列队，因此可以一致的向前移动。这和上文的 <code>CountDownLatch</code> 非常像，只是 <code>CountDownLatch</code> 只是触发一次的事件，而 <code>CyclicBarrier</code> 可以重复使用。<br><code>CyclicBarrier</code> 可以使一定数量的参与方反复地在栅栏位置汇聚，它在并行迭代算法中非常有用：这种算法通常将一个问题拆分成一系列相互独立的子问题。当线程达到栅栏位置时将调用 <code>await()</code> 方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有栅栏都到达栅栏了位置，那么栅栏将打开，此时所有的线程都被释放，而栅栏将被重置以便下次使用。如果对 <code>await()</code> 方法调用超时，或者线程被中断，那么栅栏就认为是被打破了，所有阻塞 <code>await()</code> 的调用都将终止并抛出 <code>BrokenBarrierException</code>。如果成功通过栅栏，那么 <code>await()</code> 将为每一个线程返回一个唯一的到达索引号，我们可以利用这些索引来“选举”产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。<code>CyclicBarrier</code> 还可以使你将一个栅栏操作传递给构造函数，这个一个 <code>Runnable</code> ，当成功通过栅栏时会（在一个子任务线程中）执行它，但是它在阻塞线程被释放前是不能执行的。使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-11-03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 同步工具类 —— CyclicBarrier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrieDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// 创建 CyclicBarrier 对象并设置 3 个公共屏障点</span></span><br><span class="line">    <span class="keyword">final</span> CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">          System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() + <span class="string">" 即将到达集合地点1，当前已有 "</span> + cb.getNumberWaiting() + <span class="string">" 个已经到达，正在等候"</span>);</span><br><span class="line">          <span class="comment">// 到此如果没有达到公共屏障点，则该线程处于等待状态，如果达到公共屏障点则所有处于等待的线程都继续往下运行</span></span><br><span class="line">          cb.await();</span><br><span class="line">          Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">          System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() + <span class="string">" 即将到达集合地点2，当前已有 "</span> + cb.getNumberWaiting() + <span class="string">" 个已经到达，正在等候"</span>);</span><br><span class="line">          cb.await();</span><br><span class="line">          Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">          System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() + <span class="string">" 即将到达集合地点3，当前已有 "</span> + cb.getNumberWaiting() + <span class="string">" 个已经到达，正在等候"</span>);</span><br><span class="line">          cb.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      service.execute(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">    service.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">3</span> 即将到达集合地点<span class="number">1</span>，当前已有 <span class="number">0</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 即将到达集合地点<span class="number">1</span>，当前已有 <span class="number">1</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 即将到达集合地点<span class="number">1</span>，当前已有 <span class="number">2</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">3</span> 即将到达集合地点<span class="number">2</span>，当前已有 <span class="number">0</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 即将到达集合地点<span class="number">2</span>，当前已有 <span class="number">1</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 即将到达集合地点<span class="number">2</span>，当前已有 <span class="number">2</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">3</span> 即将到达集合地点<span class="number">3</span>，当前已有 <span class="number">0</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span> 即将到达集合地点<span class="number">3</span>，当前已有 <span class="number">1</span> 个已经到达，正在等候</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span> 即将到达集合地点<span class="number">3</span>，当前已有 <span class="number">2</span> 个已经到达，正在等候</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h4&gt;&lt;p&gt;同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。在容器中，有些也可以作为同步工具类，其它类型的同步工具类还包括闭锁（Latch）、信号量（Semaphore）以及栅栏（Barrier）。阻塞队列（eg: BlockQueue）是一种独特的类：它们不仅能作为保存对象的容器，还能协调生产者和消费者之间的控制流，因为它提供的 &lt;code&gt;take&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt; 等方法将会阻塞，直到队列达到期望的状态。所有的同步工具类都包含一些特定的属性：它们封装了一些状态，这些状态将决定同步工具类的线程是继续执行还是等待，此外还提供了一些方法对其状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。&lt;/p&gt;
&lt;h4 id=&quot;1-2-闭锁&quot;&gt;&lt;a href=&quot;#1-2-闭锁&quot; class=&quot;headerlink&quot; title=&quot;1.2 闭锁&quot;&gt;&lt;/a&gt;1.2 闭锁&lt;/h4&gt;&lt;p&gt;闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有线程通过。当闭锁到达结束状态后，将不会再次改变状态，因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其它活动都完成后才继续执行。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保某个计算机在其需要的所有资源初始化后才能继续执行。&lt;/li&gt;
&lt;li&gt;确保某个服务在其依赖的所有服务都已经启动后才启动。&lt;/li&gt;
&lt;li&gt;等待直到某个操作的所有参与者都就绪后再继续执行。
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java, 并发" scheme="https://www.mghio.cn/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 运行时数据区域</title>
    <link href="https://www.mghio.cn/post/8a061473.html"/>
    <id>https://www.mghio.cn/post/8a061473.html</id>
    <published>2019-10-26T14:10:10.000Z</published>
    <updated>2019-12-07T15:45:52.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-为什么要进行内存区域划分"><a href="#1-1-为什么要进行内存区域划分" class="headerlink" title="1.1 为什么要进行内存区域划分"></a>1.1 为什么要进行内存区域划分</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/" target="_blank" rel="noopener">JVM规范</a> 规定，JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间，有的区域随着虚拟机进程的启动就存在了，而有些区域则依赖用户线程的启动和结束而建立和销毁。JVM 规范对 JVM 定义了运行时统一的内存划分规范，统一了标准，类似于 JDBC 规范一样。JVM 也有许多厂商的不同产品。比如下面的这些：</p><table><thead><tr><th align="center">厂商</th><th align="left">JVM</th></tr></thead><tbody><tr><td align="center">Oracle-SUN</td><td align="left">Hotspot</td></tr><tr><td align="center">Oracle</td><td align="left">JRocket</td></tr><tr><td align="center">IBM</td><td align="left">J9 JVM</td></tr><tr><td align="center">阿里</td><td align="left">Taobao JVM</td></tr></tbody></table><p>其内存区域划分规范对于 JVM 的含义类似于我们 Java 中的接口，都是起到了规范的作用，JVM 是一台可以运行 Java 应用程序的抽象的计算机。在 JVM 中存在三个重要的概念：</p><ul><li>JVM 规范：它定义了虚拟机运行的规范，但是由 Oracle（SUN）或者其它厂商实现</li><li>Java 运行时环境(JRE：Java Runtime Environment)：它是 JVM 规范的具体实现</li><li>JVM 实例：编写好 Java 代码之后，运行 Java 程序，此时就会创建 JMV 实例</li></ul><p>对于 Java 程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个对象去编写内存释放的代码，不要像 C 或者 C++ 要时刻注意着内存泄漏和内存溢出的问题，这种由虚拟机去管理一切看起来都很美好。不过，也正是因为 Java 设计者把内存控制全部交给了 JVM，一旦出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎么分配运行时内存的，那么排查错误将是一项非常艰难的工作。</p><a id="more"></a><h4 id="1-2-运行时数据区域的组成"><a href="#1-2-运行时数据区域的组成" class="headerlink" title="1.2 运行时数据区域的组成"></a>1.2 运行时数据区域的组成</h4><p>为什么我们经常把运行时数据区叫做 Java 内存模型（JMM：Java Memory Model），是因为运行时数据区太过于分散，没有联系，所以才会有 JVM 内存模型这个词，让我们把这些东西联系起来，方便记忆。JVM 运行时数据区中有些数据是一直存在的，被所有线程所共享。而有些区域则是线程私有的，伴随着线程的开始而创建，线程的结束而销毁。所以我们可以把JMM 分为两类：<code>线程共享的</code>、<code>线程私有的</code>。根据 JVM 虚拟机规范的规定，JVM 虚拟机运行时数据区划分如下图所示：</p><p><img src="https://i.loli.net/2019/10/27/2TGhQutDpMkinlo.png" alt="jmm-structure.png"> 运行时数据区主要分为以下几个部分：</p><ul><li>方法区</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>程序计数器</li></ul><p>其中，按照线程在各个区域的数据是否共享划分为：</p><ul><li>线程共享部分：方法区、Java 堆以及运行时常量池（归属于方法区）</li><li>线程私有部分：虚拟机栈、本地方法栈、程序计数器</li></ul><p>接下来看看 Java 运行时数据区中各个部分的用途和特点：</p><blockquote><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4></blockquote><h5 id="1-1-什么是方法区"><a href="#1-1-什么是方法区" class="headerlink" title="1.1 什么是方法区"></a>1.1 什么是方法区</h5><p>在 JVM 中，方法区是可供各个线程共享运行时的内存区域。方法区域传统语言中的编译代码存储区或者操作系统进程的正文段的作用非常类似，它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、类的构造函数和普通方法的字节码内容、还包括一些类、实例、接口初始化的时候用到的特殊方法。在 Hotspot 虚拟机中，JDK 1.7 版本称作<code>永久代（Permanent Generation）</code>，而在 JDK 1.8 则称为 <code>元空间（Metapace）</code>。<br>方法区有个别名叫做非堆（Non-Heap），用于区别于 Java 堆区。默认最小值为 16 MB，最大值为 64 MB，可通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 参数设置方法的大小。<br>JDK 1.7 及之前的版本设置为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=<span class="number">10</span>m</span><br><span class="line">-XX:MaxPermSize=<span class="number">55</span>m</span><br></pre></td></tr></table></figure><p>JDK 1.8 及之后的版本设置为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=<span class="number">10</span>m</span><br><span class="line">-XX:MaxMetaspaceSize=<span class="number">55</span>m</span><br></pre></td></tr></table></figure><h5 id="1-2-方法区的特点"><a href="#1-2-方法区的特点" class="headerlink" title="1.2 方法区的特点"></a>1.2 方法区的特点</h5><ul><li>线程共享：方法区是堆的一个逻辑部分，因此和对一样是线程共享的。整个虚拟机中只有一个方法区。</li><li>永久代：方法区中的信息一般要长期存在，而且它又是堆的逻辑部分，因此用堆的划分方法，我们把方法区称作永久代（方法区是规范，永久代是实现）。</li><li>内存回收低：方法区中的信息一般需要长期存在，回收一遍内存之后可能之后少量信息无效。对方法区的内存回收主要是 <code>对常量池的回收和对类型的卸载</code>。</li><li>JVM 规范对方法区的定义比较宽松：和堆一样，允许固定大小，也允许可扩展大小，还允许不实现垃圾回收。</li></ul><p>方法区是所有都线程共享的，在一定的条件下它也会被 GC，当方法区域需要使用的内存超过其允许的大小时，会抛出 OOM（OutOfMemory）错误信息。</p><h5 id="1-3-运行时常量池"><a href="#1-3-运行时常量池" class="headerlink" title="1.3 运行时常量池"></a>1.3 运行时常量池</h5><p>类加载后，Class 文件结构中常量池中的数据将被存储在运行时常量池中。我们一般在一个类中通过 <code>public static final</code> 来声明一个常量或者声明一个字符串 <code>String str = &quot;abc&quot;</code>。这个类编译后产生的 Class 文件，这个类的所有信息都存储在这个 class 文件中，当这个类被 JVM 加载之后，class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池添加新的常量。比如，String 类的 intern() 方法就能在运行期间向常量池中添加新的常量。当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用时，那么就需要垃圾收集器回收。JVM 为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。其包括直接常量(基本类型，String)和对其他类型、方法、字段的符号引用。即字面量和符号引用，其中字面量指的是整个类中的字面量。包含成员变量、静态方法、非静态方法等中的字面量。池中的数据和数组一样通过索引访问。</p><blockquote><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4></blockquote><h5 id="1-1-什么是虚拟机栈"><a href="#1-1-什么是虚拟机栈" class="headerlink" title="1.1 什么是虚拟机栈"></a>1.1 什么是虚拟机栈</h5><p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。Java 虚拟机栈会为每一个即将运行的方法创建一块叫做 <code>栈帧</code> 的区域，这块区域用于存储用于方法在运行时所需要的一些信息，这些信息具体包括：</p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法出口信息</li><li>其它信息</li></ul><p>当一个方法即将被运行时，Java 虚拟机栈首先会在 Java 虚拟机栈中为该方法创建一块”栈帧”，栈帧中包含局部变量表，操作数栈，动态链接，方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。<code>Java 虚拟机栈上数据都是私有的</code>，其他线程都不能访问该线程的栈数据。在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。当在一段代码块中定义一个变量时，Java 就会在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java 会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p><h5 id="1-2-Java-虚拟机栈的特点"><a href="#1-2-Java-虚拟机栈的特点" class="headerlink" title="1.2 Java 虚拟机栈的特点"></a>1.2 Java 虚拟机栈的特点</h5><ul><li>局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。局部变量表的大小在程序的编译期间就确定下来了，在创建的时候需要事先指定好大小，在方法运行的过程中局部变量表的大小是不会发生改变的。</li><li>Java虚拟机栈会出现两种错误（StackOverFlowError 和 OutOfMemoryError），<code>StackOverFlowError</code>：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候就会抛出 StackOverFlowError。<code>OutOfMemoryError</code>：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展了，此时就会抛出 StackOverFlowError。</li><li>虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</li><li>栈中的数据在线程内部是共享的，要注意这种数据的共享与两个对象引用同 时指向一个对象的这种共享是不同的。它是由编译器完成的，它有利于节省空间。</li></ul><blockquote><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4></blockquote><p>本地方法指的是使用 Java 以外的其他语言编写的代码，因为有些时候 Java 无法直接操作一些底层资源，只能通过 C 或汇编操作。因此需要通过本地方法来实现。而本地方法栈就是设计用来调用这些非 Java 语言方法的。会存放对应的局部变量信息、返回结果等。本地方法栈和 Java 虚拟机栈实现的功能类似，只不过本地方法栈是本地方法运行的内存模型。区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则是为虚拟机用到的 Native 方法服务，本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接以及出口信息等。方法执行完毕后相应的栈帧也会出栈并释放内存空间。也会抛出两种错误，StackOverFlowError 和 OutOfMemoryError。</p><blockquote><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4></blockquote><h5 id="1-1-什么是堆"><a href="#1-1-什么是堆" class="headerlink" title="1.1 什么是堆"></a>1.1 什么是堆</h5><p>堆是用来存放对象（类、接口、数组）的内存空间。几乎所有的对象都存储在堆中（实例创建后，成员变量也随对象存在堆中，随着垃圾回收进行释放）。堆是一个运行时数据区，在程序运行时动态分配内存。<br>在堆中产生了一个数组对对象后，还可以在栈中定义一个特殊的变量，让栈用这个变量的取值等于数组或对象在堆地址内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组和对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中数组或对象。<br>引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域外后释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码之外，数组和对象本身占据的内存空间不会被释放，数组和对象在没有引用指向它的时候才会变为垃圾，不能再被使用。仍然占据内存空间不放，在随后的一个不确定的时期被 GC 垃圾回收收走。这也是 Java 比较占用内存的原因之一，实际上，栈中的变量指向堆内存的变量，这就是 Java 中的指针。</p><h5 id="1-2-堆的特点"><a href="#1-2-堆的特点" class="headerlink" title="1.2 堆的特点"></a>1.2 堆的特点</h5><ul><li>线程共享：整个 JVM 只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li><li>在虚拟机启动的时候创建。</li><li>垃圾回收的主要场所。</li><li>堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的。</li><li>堆可以分为：新生代和老年代<br>新生代：新生代程序新创建的对象都在新生代分配的，新生代由 <code>Eden Space</code> 和两块大小相同的 <code>Survivor Space</code>（通常又称 S0 和 S1或 FROM 和 To ）构成，可通过 -Xmn 参数来指定新生代的大小，也可以通过 -XX:SurvivorRation 来调整 Eden Space 及 Survivor Space 的大小，因此新生代又可被分为：Eden，From Survivor，To Survivor。<br>老年代：老年代用户存放经过多次新生代垃圾回收仍然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代。主要有两种情况：一种是 <code>大对象</code>，可通过启动参数设置 -XX:PretenureSizeThreshold=1024（单位为字节，默认为 0）来代表超过多大时就不再在新生代分配，而是直接在老年代分配。另一种是 <code>大的数组对象</code>，且数组中无引用外部对象。老年代所占的内存大小为 -Xmx 对应的值减去 -Xmn（新生代）对应的值。不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更加高效。</li><li>JDK 1.8 及之后版本堆的内存空间分配<br>老年代：三分之二的堆空间<br>年轻代：三分之一的堆空间<ul><li>eden 区： 十分之八的年轻代空间</li><li>survivor 0：十分之一的年轻代空间</li><li>survivor 1：十分之一的年轻代空间</li></ul></li></ul><blockquote><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4></blockquote><h5 id="1-1-什么是程序计数器"><a href="#1-1-什么是程序计数器" class="headerlink" title="1.1 什么是程序计数器"></a>1.1 什么是程序计数器</h5><p>程序计数器是一块比较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。当然，<code>程序计数器是线程私有的</code>。但是，如果当前线程执行的是一个线程本地的方法，那么此时这个线程的程序计数器为空。</p><blockquote><p>本地方法为 Native Method，即由 native 修饰的方法。在定义一个 native 方法时，并不提供实现（类似 Java 中的接口或者抽象方法），因为其实现往往是由外面的 C 或者 C++ 等非 Java 语言实现的。</p></blockquote><h5 id="1-2-程序计数器的作用"><a href="#1-2-程序计数器的作用" class="headerlink" title="1.2 程序计数器的作用"></a>1.2 程序计数器的作用</h5><p>程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如顺序执行、选择、循环、异常处理等。</li><li>在多线程的条件下，程序计数器用来记录当前线程执行的位置，从而当线程被切换回来的时候能够知道这个线程上次运行到哪个地方了。</li></ul><h5 id="1-3-程序计数器的特点"><a href="#1-3-程序计数器的特点" class="headerlink" title="1.3 程序计数器的特点"></a>1.3 程序计数器的特点</h5><ul><li>是一块比较小的存储空间</li><li>是线程私有的，即每一个线程都有一个独立程序计数器</li><li>是唯一一个不会出现 OOM（OutOfMemoryError）的内存区域</li><li>声明周期随着线程的开始而创建，随着线程的终止而结束</li></ul><blockquote><h4 id="方法区、永久代和元空间"><a href="#方法区、永久代和元空间" class="headerlink" title="方法区、永久代和元空间"></a>方法区、永久代和元空间</h4></blockquote><h5 id="1-1-方法区和永久代的关系"><a href="#1-1-方法区和永久代的关系" class="headerlink" title="1.1 方法区和永久代的关系"></a>1.1 方法区和永久代的关系</h5><p>涉及到内存模型，往往都会提到永久代，那么它和方法区又是什么关系呢？<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener">JVM 虚拟机规范</a> 只是规定了有方法区这个概念和它的作用，并没有规定如何实现它。那么，在不同 JVM 上方法区的实现肯定是不同的。同时大多数公司用的 JVM 都是 Oracle 公司的 HotSpot。在 HotSpot 上把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区。因此，我们可以得到结论，永久代是 HotSpot 的概念，方式区是 JVM 规范的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。其它的虚拟机实现并没有永久代这么一说。在 JDK 1.7 及之前的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC 分代来实现方法区内存回收，可以使用以下参数来调准方法区的大小：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize     # 方法区初始大小</span><br><span class="line">-XX:MaxPermSize  # 方法区最大大小（超过这个值会抛出 OutOfMemoryError 异常：java.lang.OutOfMemoryError：PermGen）</span><br></pre></td></tr></table></figure><h5 id="1-2-元空间"><a href="#1-2-元空间" class="headerlink" title="1.2 元空间"></a>1.2 元空间</h5><p>对于 Java 8，HotSpot 取消了永久代，那么是不是也就没有方法了吗？<br>当然不是，方法区是一个规范，规范没变，它就会一直在。那么取代永久代的就是元空间。它和永久代有什么不同呢？</p><ul><li>存储位置不同，永久代物理上是堆的一部分，和新生代、老年代地址是连续的，而元空间属于本地内存</li><li>存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。</li></ul><h4 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h4><h6 id="1-1-JVM-内存模型一共有两个“栈”，分别是-Java-虚拟机栈和本地方法栈"><a href="#1-1-JVM-内存模型一共有两个“栈”，分别是-Java-虚拟机栈和本地方法栈" class="headerlink" title="1.1 JVM 内存模型一共有两个“栈”，分别是 Java 虚拟机栈和本地方法栈"></a>1.1 JVM 内存模型一共有两个“栈”，分别是 Java 虚拟机栈和本地方法栈</h6><p>两个“栈”功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是方法私有的。只不过 Java 虚拟机栈描述的是 Java 方法运行过程的内存模型，而本地方法栈是描述 Java 本地方法运行过程的内存模型。</p><h6 id="1-2-JVM-内存模型中一共有两个“堆”，分别是原本的堆和方法区"><a href="#1-2-JVM-内存模型中一共有两个“堆”，分别是原本的堆和方法区" class="headerlink" title="1.2 JVM 内存模型中一共有两个“堆”，分别是原本的堆和方法区"></a>1.2 JVM 内存模型中一共有两个“堆”，分别是原本的堆和方法区</h6><p>方法区本质上还是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量，即时编译器编译后的代码等。</p><h6 id="1-3-堆是-JVM-中最大的一块内存区域，也是垃圾收集器主要工作的地方"><a href="#1-3-堆是-JVM-中最大的一块内存区域，也是垃圾收集器主要工作的地方" class="headerlink" title="1.3 堆是 JVM 中最大的一块内存区域，也是垃圾收集器主要工作的地方"></a>1.3 堆是 JVM 中最大的一块内存区域，也是垃圾收集器主要工作的地方</h6><p>在创建对象的时候，非静态成员会被加载到堆内存中，并完成成员变量的初始化。也就是说所有的非静态成员（成员变量、成员方法、构造方法、构造代码块和普通代码块）都是保存在堆内存中的。但是方法调用的时候，调用的方法会在栈内存中执行，构造代码块也会在栈内存中执行。</p><h6 id="1-4-线程私有与共享"><a href="#1-4-线程私有与共享" class="headerlink" title="1.4 线程私有与共享"></a>1.4 线程私有与共享</h6><p>Java 虚拟机栈、程序计数器和本地方法栈都是线程私有的，也就是说每个线程都是各自的程序计数器、Java 虚拟机栈和本地方法栈。他们的生命周期和线程的生命周期一样。而堆、方法区则是线程共享的，在 JVM 中只有一个堆，一个方法区。并在 JVM 启动的时候就创建，直到 JVM 停止的时候才销毁。</p><hr><p>参考文章</p><ul><li><a href="https://betsol.com/2017/06/java-memory-management-for-java-virtual-machine-jvm/" target="_blank" rel="noopener">Java Memory Management for Java Virtual Machine (JVM)</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html" target="_blank" rel="noopener">The Java® Virtual Machine Specification（Java SE 8 Edition）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-为什么要进行内存区域划分&quot;&gt;&lt;a href=&quot;#1-1-为什么要进行内存区域划分&quot; class=&quot;headerlink&quot; title=&quot;1.1 为什么要进行内存区域划分&quot;&gt;&lt;/a&gt;1.1 为什么要进行内存区域划分&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVM规范&lt;/a&gt; 规定，JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途。以及创建和销毁的时间，有的区域随着虚拟机进程的启动就存在了，而有些区域则依赖用户线程的启动和结束而建立和销毁。JVM 规范对 JVM 定义了运行时统一的内存划分规范，统一了标准，类似于 JDBC 规范一样。JVM 也有许多厂商的不同产品。比如下面的这些：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;厂商&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;JVM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Oracle-SUN&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Hotspot&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;Oracle&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;JRocket&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;IBM&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;J9 JVM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;阿里&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;Taobao JVM&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;其内存区域划分规范对于 JVM 的含义类似于我们 Java 中的接口，都是起到了规范的作用，JVM 是一台可以运行 Java 应用程序的抽象的计算机。在 JVM 中存在三个重要的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM 规范：它定义了虚拟机运行的规范，但是由 Oracle（SUN）或者其它厂商实现&lt;/li&gt;
&lt;li&gt;Java 运行时环境(JRE：Java Runtime Environment)：它是 JVM 规范的具体实现&lt;/li&gt;
&lt;li&gt;JVM 实例：编写好 Java 代码之后，运行 Java 程序，此时就会创建 JMV 实例&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 Java 程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个对象去编写内存释放的代码，不要像 C 或者 C++ 要时刻注意着内存泄漏和内存溢出的问题，这种由虚拟机去管理一切看起来都很美好。不过，也正是因为 Java 设计者把内存控制全部交给了 JVM，一旦出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎么分配运行时内存的，那么排查错误将是一项非常艰难的工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="JVM" scheme="https://www.mghio.cn/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.mghio.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 ThreadLocal</title>
    <link href="https://www.mghio.cn/post/bfcdfeaf.html"/>
    <id>https://www.mghio.cn/post/bfcdfeaf.html</id>
    <published>2019-10-19T14:14:50.000Z</published>
    <updated>2019-10-21T10:42:08.910Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-什么是-ThreadLocal"><a href="#1-1-什么是-ThreadLocal" class="headerlink" title="1.1 什么是 ThreadLocal"></a>1.1 什么是 ThreadLocal</h4><p>ThreadLocal 简单理解 <code>Thread</code> 即线程，<code>Local</code> 即本地，结合起来理解就是 <code>每个线程都是本地独有的</code>。在早期的计算机中不包含操作系统，从头到尾只执行一个程序，并且这个程序能访问计算中的所有资源，这对于计算机资源来说是一种浪费。要想充分发挥多处理器的强大计算能力，最简单的方式就是使用多线程。与串行程序相比，在并发程序中存在更多容易出错的地方。当访问共享数据时，通常需要使用同步来控制并发程序的访问。一种避免使用同步的方式就是让这部分共享数据变成不共享的，试想一下，如果只是在单个线程内对数据进行访问，那么就可以不用同步了，这种技术称为<code>线程封闭（Thread Confinement）</code>，它是实现线程安全最简单的方式之一。<br>当某个对象封闭在一个单个线程中时，这种用法会自动实现了线程安全，因为只有一个线程访问数据，从根本上避免了共享数据的线程安全问题，即使被封闭的对象本身不是线程安全的。要保证线程安全，并不是一定就需要同步，两者没有因果关系，同步只是保证共享数据征用时正确性的手段，如果一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证正确性。而维持线程封闭的一种规范用法就是使用 <strong>ThreadLoal</strong>，这个类能使当前线程中的某个值与保存的值关联起来。ThreadLocal 提供了 <code>get()</code> 与 <code>set(T value)</code> 等方法，<code>set</code> 方法为每个使用了该变量的线程都存有一份独立的副本，因此当我们调用 <code>get</code> 方法时总是返回由当前线程在调用 <code>set</code> 方法的时候设置的最新值。</p><h4 id="1-2-ThreadLocal-的用法"><a href="#1-2-ThreadLocal-的用法" class="headerlink" title="1.2 ThreadLocal 的用法"></a>1.2 ThreadLocal 的用法</h4><p>接下来通过一个示例代码说明 ThreadLocal 的使用方式，该示例使用了三个不同的线程 <code>Main Thread</code>、<code>Thread-1</code> 和 <code>Thread-2</code> 分别对同一个 ThreadLocal 对象中存储副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 并发之 ThreadLocal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemoTests</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ThreadLocal&lt;String&gt; boolThreadLocal = ThreadLocal.withInitial(() -&gt; <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUseCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boolThreadLocal.set(<span class="string">"main-thread-set"</span>);</span><br><span class="line">    System.out.printf(<span class="string">"Main Thread: %s\n"</span>, boolThreadLocal.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-1"</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boolThreadLocal.set(<span class="string">"thread-1-set"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"Thread-1: %s\n"</span>, boolThreadLocal.get());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-2"</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Thread-2: %s\n"</span>, boolThreadLocal.get());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>打印的输出结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main Thread: main-thread-set</span><br><span class="line">Thread-<span class="number">1</span>: thread-<span class="number">1</span>-set</span><br><span class="line">Thread-<span class="number">2</span>:</span><br></pre></td></tr></table></figure><p>我们从输出结果可以看出，ThreadLocal 把不同的线程的数据进行隔离，互不影响，Thread-2 的线程因为我们没有重新设置值会使用 <code>withInitial</code> 方法设置的默认初始值 <code>&quot;&quot;</code>，在不同的线程对同一个 ThreadLocal 对象设置值，对不同的线程取出来的值不一样。接下来我们来分析一下源码，看看它是如何实现的。</p><h4 id="1-3-ThreadLocal-的实现原理"><a href="#1-3-ThreadLocal-的实现原理" class="headerlink" title="1.3 ThreadLocal 的实现原理"></a>1.3 ThreadLocal 的实现原理</h4><p>既然要对每个访问 ThreadLocal 变量的线程都要有自己的一份<code>本地独立副本</code>。我们很容易想到可以用一个 Map 结构去存储，它的键就是我们当前的线程，值是它在该线程内的实例。然后当我们使用该 ThreadLocal 的 get 方法获取实例值时，只需要使用 <code>Thread.currentThread()</code> 获取当前线程，以当前线程为键，从我们的 Map 中获取对应的实例值即可。结构示意图如下所示：<br><img src="https://i.loli.net/2019/10/20/8A1nO9vTaxcgpz7.png" alt="threadlocal-one.png"><br>上面这个方案可以满足前文所说的每个线程本地独立副本的要求。每个新的线程访问该 ThreadLocal 的时候，就会向 Map 中添加一条映射记录，而当线程运行结束时，应该从 Map 中清除该条记录，那么就会存在如下问题：</p><ol><li>因为新增线程或者线程执行完都要操作这个 Map，所以需要保证 Map 是线程安全的。虽然可以使用 JDK 提供的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="noopener">ConcurrentHashMap</a> 来保证线程安全，但是它还是要通过使用锁来保证线程安全的。</li><li>当一个线程运行结束时要及时移除 Map 中对应的记录，不然可能会发生 <a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" target="_blank" rel="noopener">内存泄漏</a> 问题。</li></ol><p>由于存在锁的问题，所有最终 JDK 并没有采用这个方案，而是使用无锁的 <code>ThreadLocal</code>。上述方案出现锁的原因是因为有两一个以上的线程同时访问同一个 Map 导致的。我们可以换一种思路来看这个问题，如果将这个 Map 由每个 Thread 维护，从而使得每个 Thread 只访问自己的 Map，那样就不会存在线程安全的问题，也不会需要锁了，因为是每个线程自己独有的，其它线程根本看不到其它线程的 Map 。这个方案如下图所示：<br><img src="https://i.loli.net/2019/10/20/z1ybDCfWicRF9G2.png" alt="threalocal-two.png"> 这个方案虽然不存在锁的问题，但是由于每个线程访问 ThreadLocal 变量后，都会在自己的 Map 内维护该 ThreadLoal 变量与具体存储实例的映射，如果我们不手动删除这些实例，可能会造成内存泄漏。<br>我们进入到 Thread 的源码内可以看到其内部定义了一个 <code>ThreadLocalMap</code> 成员变量，如下图所示：<br><img src="https://i.loli.net/2019/10/20/OLmpZnfePybKkBr.png" alt="thread-codesource.png"> ThreadLoalMap 类是一个类似 Map 的类，是 ThreadLocal 的内部类。它的 key 是 ThreadLocal ，一个 ThreadLocalMap 可以存储多个 key（ThreadLocal），它的 value 就对应着在 ThreadLocal 存储的 value。因此我们可以看出：每一个 Thread 都对应自己的一个 ThreadLocalMap ，而 ThreadLocalMap 可以存储多个以 ThreadLocal 为 key 的键值对。这里也解释了为什么我们使用多个线程访问同一个 ThreadLocal ，然后 get 到的确是不同数值。</p><p>上面对 ThreadLocal 进行了一些解释，接下来我们看看 ThreadLocal 具体是如何实现的。先看一下 ThreadLocal 类提供的几个常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><ol><li><code>initialValue</code> 方法是一个 protected 方法，一般是用来使用时进行重写，设置默认初始值的方法，它是一个延迟加载的方法，在。</li><li><code>set</code> 方法是用来设置当前线程的变量副本的方法</li><li><code>get</code> 方法是用获取 ThreadLocal 在当前线程中保存的变量副本</li><li><code>remove</code> 方法是 JDK1.5+ 才提供的方法，是用来移除当前线程中的变量副本</li></ol><p><code>initialValue</code> 方法是在 <code>setInitialValue</code> 方法被调用的，由于 setInitialValue 方法是 private 方法，所以我们只能重写 initialValue 方法，我们看看 setInitialValue 的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment"> * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   T value = initialValue();</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map = getMap(t);</span><br><span class="line">   <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">       map.set(<span class="keyword">this</span>, value);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       createMap(t, value);</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过以上代码我们知道，会先调用 initialValue 获取初始值，然后使用当前线程从 Map 中获取线程对应 ThreadLocalMap，如果 map 不为 <code>null</code>，就设置键值对，如果为 <code>null</code>，就再创建一个 Map。<br>首先我们看下在 getMap 方法中干了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> t.threadLocals;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可能大家没有想到的是，在 getMap 方法中，是调用当期线程 t，返回当前线程 t 中的一个成员变量 threadLocals 。那么我们继续到 Thread 类中源代码中看一下成员变量 threadLocals 到底是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>它实际上就是一个 ThreadLocalMap ，这个类型是 ThreadLocal 类内定义的一个内部类，我们看一下 ThreadLocalMap 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocalMap is a customized hash map suitable only for</span></span><br><span class="line"><span class="comment"> * maintaining thread local values. No operations are exported</span></span><br><span class="line"><span class="comment"> * outside of the ThreadLocal class. The class is package private to</span></span><br><span class="line"><span class="comment"> * allow declaration of fields in class Thread.  To help deal with</span></span><br><span class="line"><span class="comment"> * very large and long-lived usages, the hash table entries use</span></span><br><span class="line"><span class="comment"> * WeakReferences for keys. However, since reference queues are not</span></span><br><span class="line"><span class="comment"> * used, stale entries are guaranteed to be removed only when</span></span><br><span class="line"><span class="comment"> * the table starts running out of space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">       <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">       Object value;</span><br><span class="line"></span><br><span class="line">       Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">           <span class="keyword">super</span>(k);</span><br><span class="line">           value = v;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 ThreadLocalMap 的 Entry 继承了 WeakReference (<a href="https://zh.wikipedia.org/wiki/%E5%BC%B1%E5%BC%95%E7%94%A8" target="_blank" rel="noopener">弱引用</a>)，并且使用 ThreadLocal 作为键值。</p><p>下面我们看下 createMap 方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">   t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>直接 new 一个 ThreadLoalMap 对象，然后赋值给当前线程的 threadLocals 属性。</p><p>然后我们看一下 <code>set</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map = getMap(t);</span><br><span class="line">   <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">       map.set(<span class="keyword">this</span>, value);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       createMap(t, value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先获取当前线程，然后从线程的属性 <code>threadLocals</code> 获取当前线程对应的 ThreadLocalMap 对象，如果不为空，就以 <strong>this (ThreadLocal)</strong> 而不是当前线程 t 为 key，添加到 ThreadLocalMap 中。如果为空，那么就先创建后再加入。ThreadLocal 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏。</p><p>接下来我们看一下 <code>get</code> 方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Thread t = Thread.currentThread();</span><br><span class="line">   ThreadLocalMap map = getMap(t);</span><br><span class="line">   <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">       ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">           T result = (T)e.value;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> setInitialValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>先获取当前线程，然后通过 getMap 方法传入当前线程获取到 ThreadLocalMap 。然后接着获取 Entry (key，value) 键值对，<strong>这里传入的是 this，而不是当前线程 t</strong> ，如果获取成功，则返回对应的 value，如果没有获取到，返回空，则调用 setInitialValue 方法返回 value。</p><p>至此，我们总结一下 <code>ThreadLocal</code> 是如何为每个线程创建变量副本的：首先，在每个线程 Thread 内部有个 ThreadLocal.ThreadLocalMap 类型的成员变量 threadLocals，这个 threadLocals 变量就是用来存储实际变量的副本的，它的键为当前 ThreadLocal ，value 为变量副本（即 T 类型的变量）。<br>初始时，在 Thread 类里面， threadLocals 为 <code>null</code>，当通过 ThreadLocal 调用 set 或者 get 方法时，如果此前没有对当前线程的 threadLocals 进行过初始化操作，那么就会以当前 ThreadLocal 变量为键值，以 ThreadLocal 要保存的副本变量为 value，存到当前线程的 threadLocals 变量中。以后在当前线程中，如果要用到当前线程的副本变量，就可以通过 get 方法在当前线程的 threadLocals 变量中查找了。</p><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><p><code>ThreadLocal</code> 设计的目的就是为了能够在当前线程中有属于自己的变量，并不是为了解决并发或者共享变量的问题。</p><ol><li>通过 ThreadLocal 创建的副本是存储在每个线程自己的 threadLocals 变量中的</li><li>为何 threadLocals 的类型 ThreadLocalMap 的键值为 ThreadLocal 对象，因为每个线程中可有多个 threadLocal 变量，就像前文图片中的 ThreadLocal<string> 和 ThreadLocal<integer> ，就是一个线程存在两个 threadLocal 变量</integer></string></li><li>在进行 get 之前，必须先 set ，否则会报空指针异常，如果想在 get 之前不需要调用 set 就能正常访问的话，必须重写 initialValue 方法</li><li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li></ol><hr><p>另外，内存泄漏的问题请参考博文：<a href="https://www.javazhiyin.com/18072.html" target="_blank" rel="noopener">ThreadLocal 内存泄漏问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-什么是-ThreadLocal&quot;&gt;&lt;a href=&quot;#1-1-什么是-ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是 ThreadLocal&quot;&gt;&lt;/a&gt;1.1 什么是 ThreadLocal&lt;/h4&gt;&lt;p&gt;ThreadLocal 简单理解 &lt;code&gt;Thread&lt;/code&gt; 即线程，&lt;code&gt;Local&lt;/code&gt; 即本地，结合起来理解就是 &lt;code&gt;每个线程都是本地独有的&lt;/code&gt;。在早期的计算机中不包含操作系统，从头到尾只执行一个程序，并且这个程序能访问计算中的所有资源，这对于计算机资源来说是一种浪费。要想充分发挥多处理器的强大计算能力，最简单的方式就是使用多线程。与串行程序相比，在并发程序中存在更多容易出错的地方。当访问共享数据时，通常需要使用同步来控制并发程序的访问。一种避免使用同步的方式就是让这部分共享数据变成不共享的，试想一下，如果只是在单个线程内对数据进行访问，那么就可以不用同步了，这种技术称为&lt;code&gt;线程封闭（Thread Confinement）&lt;/code&gt;，它是实现线程安全最简单的方式之一。&lt;br&gt;当某个对象封闭在一个单个线程中时，这种用法会自动实现了线程安全，因为只有一个线程访问数据，从根本上避免了共享数据的线程安全问题，即使被封闭的对象本身不是线程安全的。要保证线程安全，并不是一定就需要同步，两者没有因果关系，同步只是保证共享数据征用时正确性的手段，如果一个方法本来就不涉及共享数据，那它就不需要任何同步措施去保证正确性。而维持线程封闭的一种规范用法就是使用 &lt;strong&gt;ThreadLoal&lt;/strong&gt;，这个类能使当前线程中的某个值与保存的值关联起来。ThreadLocal 提供了 &lt;code&gt;get()&lt;/code&gt; 与 &lt;code&gt;set(T value)&lt;/code&gt; 等方法，&lt;code&gt;set&lt;/code&gt; 方法为每个使用了该变量的线程都存有一份独立的副本，因此当我们调用 &lt;code&gt;get&lt;/code&gt; 方法时总是返回由当前线程在调用 &lt;code&gt;set&lt;/code&gt; 方法的时候设置的最新值。&lt;/p&gt;
&lt;h4 id=&quot;1-2-ThreadLocal-的用法&quot;&gt;&lt;a href=&quot;#1-2-ThreadLocal-的用法&quot; class=&quot;headerlink&quot; title=&quot;1.2 ThreadLocal 的用法&quot;&gt;&lt;/a&gt;1.2 ThreadLocal 的用法&lt;/h4&gt;&lt;p&gt;接下来通过一个示例代码说明 ThreadLocal 的使用方式，该示例使用了三个不同的线程 &lt;code&gt;Main Thread&lt;/code&gt;、&lt;code&gt;Thread-1&lt;/code&gt; 和 &lt;code&gt;Thread-2&lt;/code&gt; 分别对同一个 ThreadLocal 对象中存储副本。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; mghio&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@date&lt;/span&gt;: 2019-10-20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@version&lt;/span&gt;: 1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@description&lt;/span&gt;: Java 并发之 ThreadLocal&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@since&lt;/span&gt; JDK 1.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadLocalDemoTests&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; boolThreadLocal = ThreadLocal.withInitial(() -&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testUseCase&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boolThreadLocal.set(&lt;span class=&quot;string&quot;&gt;&quot;main-thread-set&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.printf(&lt;span class=&quot;string&quot;&gt;&quot;Main Thread: %s\n&quot;&lt;/span&gt;, boolThreadLocal.get());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;string&quot;&gt;&quot;Thread-1&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        boolThreadLocal.set(&lt;span class=&quot;string&quot;&gt;&quot;thread-1-set&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.printf(&lt;span class=&quot;string&quot;&gt;&quot;Thread-1: %s\n&quot;&lt;/span&gt;, boolThreadLocal.get());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;string&quot;&gt;&quot;Thread-2&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.printf(&lt;span class=&quot;string&quot;&gt;&quot;Thread-2: %s\n&quot;&lt;/span&gt;, boolThreadLocal.get());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 字符串 split 踩坑记</title>
    <link href="https://www.mghio.cn/post/8bd965a0.html"/>
    <id>https://www.mghio.cn/post/8bd965a0.html</id>
    <published>2019-10-13T02:33:40.000Z</published>
    <updated>2019-10-16T12:59:36.969Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-split-的坑"><a href="#1-1-split-的坑" class="headerlink" title="1.1 split 的坑"></a>1.1 split 的坑</h4><p>前几天在公司对通过 <a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">FTP</a> 方式上传的数据文件按照事先规定的格式进行解析后入库，代码的大概实现思路是这样的：先使用流进行文件读取，对文件的每一行数据解析封装成一个个对象，然后进行入库操作。本以为很简单的一个操作，然后写完代码后自己测试发现对文件的每一行进行字符串分割的时候存在问题，在这里做个简单的记录总结。在 Java 中使用 split 方法对字符串进行分割是经常使用的方法，经常在一些文本处理、字符串分割的逻辑中，需要按照一定的分隔符进行分割拆解。这样的功能，大多数情况下我们都会使用 String 中的 split 方法。关于这个方法，稍不注意很容易踩坑。</p><p><strong>（1）split 的参数是正则表达式</strong><br>首先一个常见的问题，就是忘记了 String 的 split 方法的参数不是普通的字符串，而是正则表达式，例如下面的这两种使用方式都达不到我们的预期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringSplitRegexArg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m.g.h.i.o"</span>.split(<span class="string">"."</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m|g|h|i|o"</span>.split(<span class="string">"|"</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>以上代码的结果输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[m, |, g, |, h, |, i, |, o]</span><br></pre></td></tr></table></figure><p>上面出错的原因是因为 <strong>.</strong> 和 <strong>|</strong> 都是正则表达式，应该用转义字符进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"m.g.h.i.o"</span>.split(<span class="string">"\\."</span>)</span><br><span class="line"><span class="string">"m|g|h|i|o"</span>.split(<span class="string">"\\|"</span>)</span><br></pre></td></tr></table></figure><p>在 String 类中还有其它的和这个相似的方法，例如：replaceAll。</p><p><strong>（2）split 会忽略分割后的空字符串</strong><br>大多数情况下我们都只会使用带一个参数的 split 方法，但是只带一个参数的 split 方法有个坑：就是此方法只会匹配到最后一个有值的地方，后面的会忽略掉，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringSplitSingleArg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m_g_h_i_o"</span>.split(<span class="string">"_"</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m_g_h_i_o__"</span>.split(<span class="string">"_"</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m__g_h_i_o_"</span>.split(<span class="string">"_"</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[m, g, h, i, o]</span><br><span class="line">[m, g, h, i, o]</span><br><span class="line">[m, , g, h, i, o]</span><br></pre></td></tr></table></figure><p>像第二、三个输出结果其实和我们的预期是不符的，因为像一些文件上传其实有的字段通常是可以为空的，如果使用单个参数的 split 方法进行处理就会有问题。通过查看 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">API 文档</a> 后，发现其实 String 中的 split 方法还有一个带两个参数的方法。第二个参数是一个整型类型变量，代表最多匹配上多少个，0 表示只匹配到最后一个有值的地方，单个参数的 split 方法的第二个参数其实就是 0，要想强制匹配可以选择使用负数（通常传入 -1 ），换成以下的写法，输出结果就和我们的预期一致了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"m_g_h_i_o"</span>.split(<span class="string">"_"</span>, -<span class="number">1</span>)      <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line"><span class="string">"m_g_h_i_o__"</span>.split(<span class="string">"_"</span>, -<span class="number">1</span>)    <span class="comment">// [m, g, h, i, o, , ]</span></span><br><span class="line"><span class="string">"m__g_h_i_o_"</span>.split(<span class="string">"_"</span>, -<span class="number">1</span>)    <span class="comment">// [m, , g, h, i, o, ]</span></span><br></pre></td></tr></table></figure><p><strong>（3）JDK 中字符串切割的其它 API</strong><br>在 JDK 中还有一个叫做 <strong>StringTokenizer</strong> 的类也可以对字符串进行切割，用法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringTokenizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         StringTokenizer st = <span class="keyword">new</span> StringTokenizer(<span class="string">"This|is|a|mghio's|blog"</span>, <span class="string">"|"</span>);</span><br><span class="line">         <span class="keyword">while</span> (st.hasMoreElements()) &#123;</span><br><span class="line">         System.out.println(st.nextElement());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>不过，我们从源码的 javadoc 上得知，这是从 JDK 1.0 开始就已经存在了，属于历史遗留的类，并且推荐使用 String 的 split 方法。</p><h4 id="1-2-JDK-源码探究"><a href="#1-2-JDK-源码探究" class="headerlink" title="1.2 JDK 源码探究"></a>1.2 JDK 源码探究</h4><p>通过查看 JDK 中 String 类的源码，我们得知在 String 类中单个参数的 split 方法（<strong>split(String regex)</strong>）里面调用了两个参数的 split 方法（<strong>split(String regex, int limit)</strong>），两个参数的 split 方法，先根据传入第一个参数 <strong>regex</strong> 正则表达式分割字符串，第二个参数 <strong>limit</strong> 限定了分割后的字符串个数，超过数量限制的情况下前limit-1个子字符串正常分割，最后一个子字符串包含剩下所有字符。单个参数的重载方法将 <strong>limit</strong> 设置为 0。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">         <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">         (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">          (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">        (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">         ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> limited = limit &gt; <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!limited || list.size() &lt; limit - <span class="number">1</span>) &#123;</span><br><span class="line">                list.add(substring(off, next));</span><br><span class="line">                off = next + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></span><br><span class="line">                <span class="comment">//assert (list.size() == limit - 1);</span></span><br><span class="line">                list.add(substring(off, value.length));</span><br><span class="line">                off = value.length;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If no match was found, return this</span></span><br><span class="line">        <span class="keyword">if</span> (off == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add remaining segment</span></span><br><span class="line">        <span class="keyword">if</span> (!limited || list.size() &lt; limit)</span><br><span class="line">            list.add(substring(off, value.length));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Construct result</span></span><br><span class="line">        <span class="keyword">int</span> resultSize = list.size();</span><br><span class="line">        <span class="keyword">if</span> (limit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] result = <span class="keyword">new</span> String[resultSize];</span><br><span class="line">        <span class="keyword">return</span> list.subList(<span class="number">0</span>, resultSize).toArray(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来让我们一起看看 String 的 split 方法是如何实现的。</p><p><strong>（1）特殊情况判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">         <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">         (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">          (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">        (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">         ch &gt; Character.MAX_LOW_SURROGATE))</span><br></pre></td></tr></table></figure><ul><li>第一个参数 <strong>regex</strong> 为单个字符时，将其赋值给 ch，并判断是否在元字符：「.$|()[{^?*+\」中</li><li>第一个参数 <strong>regex</strong> 为两个字符时，第一个字符为 \\（要表示一个\需要用两个\转义得到），第二个字符不在数字、大小写字母和 <a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode 编码</a> Character.MIN_HIGH_SURROGATE（’\uD800’）和 Character.MAX_LOW_SURROGATE（’\uDBFF’）之间。</li></ul><p><strong>（2）字符串分割</strong><br>第一次分割时，使用 off 和 next，off 指向每次分割的起始位置，next 指向分隔符的下标，完成一次分割后更新 off 的值，当 list  的大小等于 limit - 1 时，直接添加剩下的子字符串。</p><ul><li>如果字符串不含有分隔符，则直接返回原字符串</li><li>如果字符串进行完第一次分割后，数量没有达到 limit - 1 的话，则剩余的字符串在第二次添加</li><li>如果传入的第二个参数 <strong>limit</strong> 等于 0 ，则从最后的字符串往前移动，将所有的空字符串（”“）全部清除</li></ul><p><strong>（3）正则匹配</strong><br>String 的 split 方法在不是上面的特殊情况下，会使用两个类 <strong>Pattern</strong> 与 <strong>Matcher</strong> 进行分割匹配处理，而且 Strig 中涉及正则的操作都是调用这两个类进行处理的。</p><ul><li>Pattern 类我们可以将其理解为模式类，它主要是用来创建一个匹配模式，它的构造方法是私有的，不能直接创建该对象，可以通过 <strong>Pattern.complie(String regex)</strong> 简单的工厂方法创建一个正则表达式。</li><li>Matcher 类我们可以将其理解为匹配器类，它是用来解释 Pattern 类对字符串执行匹配操作的引擎，它的构造方法也是私有的，不能直接创建该对象，可以通过 <strong>Pattern.matcher(CharSequence input)</strong> 方法得到该类的实例。String 类的双参数 split 方法最后使用 Pattern 类的 compile 和 split 方法，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br></pre></td></tr></table></figure></li></ul><p>首先调用 Pattern 类的静态方法 compile 获取 Pattern 模式类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pattern(regex, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用 Pattern 的 split(CharSequence input, int limit) 方法，在这个方法中调 matcher(CharSequence input) 方法返回一个 Matcher 匹配器类的实例 m，与 String 类中 split 方法的特殊情况有些类似。</p><ul><li>使用 m.find()、m.start()、m.end() 方法</li><li>每找到一个分割符，则更新 start 和 end 的位置</li><li>然后处理没找到分隔符、子字符串数量小于 limit 以及 limit = 0 的情况</li></ul><h4 id="1-3-其它的字符串分割方式"><a href="#1-3-其它的字符串分割方式" class="headerlink" title="1.3 其它的字符串分割方式"></a>1.3 其它的字符串分割方式</h4><ul><li>方式一：使用 org.apache.commons.lang3.StringUtils#split，此方法使用完整的字符串作为参数，而不是正则表达式。底层调用 splitWorker 方法（<strong><font color="#dd0000">注意：</font></strong>此方法会忽略分割后的空字符串）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testApacheCommonsLangStringUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Arrays.toString(StringUtils.split(<span class="string">"m.g.h.i.o"</span>, <span class="string">"."</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(StringUtils.split(<span class="string">"m__g_h_i_o_"</span>, <span class="string">"_"</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[m, g, h, i, o]</span><br><span class="line">[m, g, h, i, o]</span><br></pre></td></tr></table></figure><ul><li>方式二：使用 com.google.common.base.Splitter，使用 Google Guava 包中提供的分割器 splitter，它提供了更加丰富的分割结果处理的方法，比如对结果前后去除空格，去除空字符串等<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testApacheCommonsLangStringUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Iterable&lt;String&gt; result = Splitter.on(<span class="string">"_"</span>).split(<span class="string">"m__g_h_i_o_"</span>);</span><br><span class="line">         List&lt;String&gt; resultList = Lists.newArrayList();</span><br><span class="line">         result.forEach(resultList::add);</span><br><span class="line">         System.out.println(<span class="string">"stringList's size: "</span> + resultList.size());</span><br><span class="line">         result.forEach(System.out::println);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringList<span class="string">'s size: 7</span></span><br><span class="line"><span class="string">m</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string">h</span></span><br><span class="line"><span class="string">i</span></span><br><span class="line"><span class="string">o</span></span><br></pre></td></tr></table></figure><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><p>String 类中除了 split 方法外，有正则表达式接口的方法都是调用 Pattern（模式类）和 Matcher（匹配器类）进行实现的。JDK 源码的每一个如 <strong>final</strong>、<strong>private</strong> 的关键字都设计的十分严谨，多读类和方法中的javadoc，多注意这些细节对于阅读代码和自己写代码都有很大的帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-split-的坑&quot;&gt;&lt;a href=&quot;#1-1-split-的坑&quot; class=&quot;headerlink&quot; title=&quot;1.1 split 的坑&quot;&gt;&lt;/a&gt;1.1 split 的坑&lt;/h4&gt;&lt;p&gt;前几天在公司对通过 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FTP&lt;/a&gt; 方式上传的数据文件按照事先规定的格式进行解析后入库，代码的大概实现思路是这样的：先使用流进行文件读取，对文件的每一行数据解析封装成一个个对象，然后进行入库操作。本以为很简单的一个操作，然后写完代码后自己测试发现对文件的每一行进行字符串分割的时候存在问题，在这里做个简单的记录总结。在 Java 中使用 split 方法对字符串进行分割是经常使用的方法，经常在一些文本处理、字符串分割的逻辑中，需要按照一定的分隔符进行分割拆解。这样的功能，大多数情况下我们都会使用 String 中的 split 方法。关于这个方法，稍不注意很容易踩坑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）split 的参数是正则表达式&lt;/strong&gt;&lt;br&gt;首先一个常见的问题，就是忘记了 String 的 split 方法的参数不是普通的字符串，而是正则表达式，例如下面的这两种使用方式都达不到我们的预期：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; mghio&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@date&lt;/span&gt;: 2019-10-13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@version&lt;/span&gt;: 1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@description&lt;/span&gt;: Java 字符串 split 踩坑记&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@since&lt;/span&gt; JDK 1.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;JavaStringSplitTests&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testStringSplitRegexArg&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         System.out.println(Arrays.toString(&lt;span class=&quot;string&quot;&gt;&quot;m.g.h.i.o&quot;&lt;/span&gt;.split(&lt;span class=&quot;string&quot;&gt;&quot;.&quot;&lt;/span&gt;)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         System.out.println(Arrays.toString(&lt;span class=&quot;string&quot;&gt;&quot;m|g|h|i|o&quot;&lt;/span&gt;.split(&lt;span class=&quot;string&quot;&gt;&quot;|&quot;&lt;/span&gt;)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 字节码</title>
    <link href="https://www.mghio.cn/post/192cb539.html"/>
    <id>https://www.mghio.cn/post/192cb539.html</id>
    <published>2019-10-02T07:45:32.000Z</published>
    <updated>2019-10-03T07:10:43.847Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-什么是字节码？"><a href="#1-1-什么是字节码？" class="headerlink" title="1.1 什么是字节码？"></a>1.1 什么是字节码？</h4><p>Java 在刚刚诞生之时曾经提出过一个非常著名的口号: “<strong>一次编写，到处运行（write once，run anywhere）</strong>”，这句话充分表达了软件开发人员对冲破平台界限的渴求。“与平台无关”的理想最终实现在操作系统的运用层上: 虚拟机提供商开发了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写到处运行”。<br><br>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—<strong>字节码（ByteCode）</strong>，因此，可以看出字节码对 Java 生态的重要性。之所以被称为字节码，是因为字节码是由十六进制组成的，而 JVM（Java Virtual Machine）以两个十六进制为一组，即以字节为单位进行读取。在 Java 中使用 <strong><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html" target="_blank" rel="noopener">javac</a></strong> 命令把源代码编译成字节码文件，一个 .java 源文件从编译成 .class 字节码文件的示例如图 1 所示:<br><img src="https://i.loli.net/2019/10/03/jcIPJSvYnd2ayOi.png" alt="图1"><center>图 1</center></p><a id="more"></a><p>对于从事基于 JVM 的语言的开发人员来说，比如: Java，了解字节码可以更准确、更直观的理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观的看到 <strong>volatile</strong> 关键字如何在字节码上生效。另外，字节码增强技术在各种 ORM 框架、Spring AOP、热部署等一些应用中经常使用，深入理解其原理对于我们来说大有裨益。由于 JVM 规范的存在，只要最终生成了符合 JVM 字节码规范的文件都可以在 JVM 上运行，因此，这个也给其它各种运行在 JVM 上的语言（如: <a href="https://www.scala-lang.org/" target="_blank" rel="noopener">Scala</a>、<a href="https://groovy-lang.org/" target="_blank" rel="noopener">Groovy</a>、<a href="https://kotlinlang.org/" target="_blank" rel="noopener">Kotlin</a>）提供了一个机会，可以扩展 Java 没有实现的特性或者实现一些语法糖。<br><br>接下来就让我们就一起看看这个字节码文件结构到底是什么样的。</p><h4 id="1-2-Java-字节码结构"><a href="#1-2-Java-字节码结构" class="headerlink" title="1.2 Java 字节码结构"></a>1.2 Java 字节码结构</h4><p>Java 源文件通过用 <strong><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html" target="_blank" rel="noopener">javac</a></strong> 命令编译后就会得到 .class 结尾的字节码文件，比如一个简单的 <strong>JavaCodeCompilerDemo</strong> 类如图 2 所示:<br><img src="https://i.loli.net/2019/10/03/raIK3DpwS67lTsZ.png" alt="图2"><center>图 2</center><br>编译后生成的 .class 字节码文件，打开后是一堆 <a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6" target="_blank" rel="noopener">十六进制</a> 数，如图 3 所示:<br><img src="https://i.loli.net/2019/10/03/gZfiXKmzI7o628x.png" alt="图3"><center>图 3</center><br>在上节提过，JVM 对于字节码规范是有要求的，打开编译后的字节码文件看似混乱无章，其实它是符合一定的结构规范的，JVM 规范要求每一个字节码文件都要由十部分固定的顺序组成的，接下来我们将一一介绍这部分，整体的组成结构如图 4 所示:<br><img src="https://i.loli.net/2019/10/03/f8NnQeZ6BuqGRHC.png" alt="图4"><center>图 4</center></p><p><strong>（1）魔数（Magic Number）</strong><br>每个字节码文件的头 4 个字节称为 <strong>魔数（Magic Number）</strong>，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如 gif 或者 jpg 等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意改动。魔数的固定值为: <strong>0xCAFEBABE</strong>，魔数放在文件头，JVM 可以根据文件的开头来判断这个文件是否可能是一个字节码文件，如果是，才会进行之后的操作。</p><blockquote><p>有趣的是，魔数的固定值是 Java 之父 <a href="https://zh.wikipedia.org/wiki/%E8%A9%B9%E5%A7%86%E6%96%AF%C2%B7%E9%AB%98%E6%96%AF%E6%9E%97" target="_blank" rel="noopener">James Gosling</a> 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡。</p></blockquote><p><strong>（2）版本号（Version）</strong><br>版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version），上图 3 中版本号为: “00 00 00 34”，次版本号转化为十进制为 0，主版本号转化为十进制 52（3 * 16^1 + 4 * 16^0 = 52），在 Oracle 官网中查询序号 52 对应的 JDK 版本为 1.8，所以编译该源代码文件的 Java 版本为 1.8.0。</p><p><strong>（3）常量池（Constant Pool）</strong><br>紧接着主版本号之后的字节是常量池入口。常量池中存储两种类型常量: 字面量和符号运用。字面量为代码中声明为 <strong>final</strong> 的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。常量池整体上分为两部分: 常量池计数器和常量池数据区，如图 5 所示：<br><img src="https://i.loli.net/2019/10/03/drScelTF6xN3Uoa.png" alt="图5"><center>图 5</center><br><strong>常量池计数器（constant_pool_count）</strong>: 由于常量池的数量不固定，所以需要先放置两个字节来表示常量池容量计数值，图 2 示例代码的字节码的前十个字节如下图 6 所示，将十六进制的 17 转为十进制的值为 33 (1 * 16^1 + 7 * 16^0 = 33)，排除下标 0，也就是说这个类文件有 32 个常量。<br><img src="https://i.loli.net/2019/10/03/IGVoJLYUSP9a3uH.png" alt="图6"><center>图 6</center><br><strong>常量池数据区</strong>: 数据区是由（constant_pool_count - 1）个 cp_info 结构组成，一个 cp_info 的结构对应一个常量。在字节码中共有 14 种类型的 cp_info ，每种类型的结构都是固定的，如图 7 所示:<br><img src="https://i.loli.net/2019/10/03/VB8KPSiEh6Zzav7.png" alt="图7"><center>图 7</center><br>以 CONSTANT_Utf8_info 为例，它的结构如表 1 所示:</p><table><thead><tr><th>名称</th><th align="left">长度</th><th align="center">值</th></tr></thead><tbody><tr><td>tag</td><td align="left">1 字节</td><td align="center">01 对应图 7 中 CONSTANT_Utf8_info 的<strong>标志栏</strong>中的值</td></tr><tr><td>length</td><td align="left">2 字节</td><td align="center">该 utf8 字符串的长度</td></tr><tr><td>bytes</td><td align="left">length 字节</td><td align="center">length 个字节的具体数据</td></tr></tbody></table><center>表 1</center>首先第一个字节 tag，它的取值对应图 7 中的 Tag，由于它的类型是 CONSTANT_Utf8_info，所以值为 01（十六进制）。接下来两个字节标识该字符串的长度 length，然后 length 个字节为这个字符串具体的值。从图 3 的字节码中摘取一个 cp_info 结构，将它翻译过来后，其含义为: 该常量为 utf8 字符串，长度为 7 字节，数据为: numberA，如图 8 所示:<p><img src="https://i.loli.net/2019/10/03/cgUGTEs5rqm4wQ6.png" alt="图8"><center>图 8</center><br>其它类型的 cp_info 结构在本文不在细说，和 CONSTANT_Utf8_info 的结构大同小异，都是先通过 tag 来标识类型，然后后续的 n 个字节来描述长度和数据。等我们对这些结构比较了解了之后，我们可以通过: <strong>javap -verbose JavaCodeCompilerDemo</strong> 命令查看 JVM 反编译后的完整常量池，可以看到反编译结果可以将每一个 cp_info 结构的类型和值都很明确的呈现出来，如图 9 所示:<br><img src="https://i.loli.net/2019/10/03/XLOV4PnltSoEQ8A.png" alt="图9"><center>图 9</center></p><p><strong>（4）访问标志（access_flag）</strong><br>常量池结束之后的两个字节，描述该 Class 是类还是接口，以及是否被 <strong>Public</strong>、<strong>Abstract</strong>、<strong>Final</strong> 等修饰符修饰。JVM 规范规定了如下表 2 所示的 9 种访问标志。需要注意的是，JVM 并没有穷举所有的访问标志，而是使用 <a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%93%8D%E4%BD%9C#%E6%8C%89%E4%BD%8D%E6%88%96%EF%BC%88OR%EF%BC%89" target="_blank" rel="noopener">按位或</a> 操作来进行描述的，比如某个类的修饰符为 public final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 <strong>0x0001 | 0x0010 = 0x0011</strong>。</p><table><thead><tr><th>标志名称</th><th align="left">标志值</th><th align="center">含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td align="left">0x0001</td><td align="center">字段是否为 public</td></tr><tr><td>ACC_PRIVATE</td><td align="left">0x0002</td><td align="center">字段是否为 private</td></tr><tr><td>ACC_PROTECTED</td><td align="left">0x0004</td><td align="center">字段是否为 protected</td></tr><tr><td>ACC_STATIC</td><td align="left">0x0008</td><td align="center">字段是否为 static</td></tr><tr><td>ACC_FINAL</td><td align="left">0x0010</td><td align="center">字段是否为 final</td></tr><tr><td>ACC_VOLATILE</td><td align="left">0x0040</td><td align="center">字段是否为 volatile</td></tr><tr><td>ACC_TRANSIENT</td><td align="left">0x0080</td><td align="center">字段是否为 transient</td></tr><tr><td>ACC_SYNCHETIC</td><td align="left">0x1000</td><td align="center">字段是否为编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td align="left">0x4000</td><td align="center">字段是否为 enum</td></tr></tbody></table><center>表 2</center><p><strong>（5）当前类名（this_class）</strong><br>访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。</p><p><strong>（6）父类名称（super_class）</strong><br>当前类名的后两个字节，描述父类的全限定名。这两个字节保存的值也是在常量池中的索引值，根据索引值就能在常量池中找到这个类的父类的全限定名。</p><p><strong>（7）接口信息（interfaces）</strong><br>父类名称后的两个字节，描述这个类的接口计数器，即: 当前类或父类实现的接口数量。紧接着的 n 个字节是所有的接口名称的字符串常量在常量池的索引值。</p><p><strong>（8）字段表（field_table）</strong><br>字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的 <a href="https://zh.wikipedia.org/wiki/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">局部变量</a>。字段表也分为两部分，第一部分是两个字节，描述字段个数，第二部分是每个字段的详细信息 <strong>field_info</strong>。字段表结构如图 10 所示:<br><img src="https://i.loli.net/2019/10/03/7qSyCJugf6iWLNc.png" alt="图10"><center>图 10</center><br>以图 3 中的字节码字段表为例，如下图 11 所示。其中字段的访问标志查表 2，002 对应为 Private，通过索引下标在图 9 中常量池分别得到字段名为: numberA，描述符为: I（在JVM 中的I代表 Java 中的 int）。综上，就可以唯一确定出类 <strong>JavaCodeCompilerDemo</strong> 中声明的变量为: <strong>private int numberA</strong> 。<br><img src="https://i.loli.net/2019/10/03/JcOBekuzqwMovAb.png" alt="图11"><center>图 11</center></p><p><strong>（9）方法表（method_table）</strong><br>字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数，第二个部分为每个方法的详细信息。方法的详细信息包括：方法的访问标志、方法名、方法的描述符以及方法的属性，如图 12 所示:<br><img src="https://i.loli.net/2019/10/03/2zmkgxBdhCrweL9.png" alt="图12"><center>图 12</center><br>方法的权限修饰符依然可以通过图 9 的值查询到，方法名和方法的描述符都是常量池的索引值，可以通过索引值在常量池中查询得到。而方法属性这个部分比较复杂，我们可以借助 <strong>javap -verbose</strong> 将其反编译为人们可读的信息进行解读。如图 13 所示。我们可以看到属性中包含三个部分:</p><ol><li><strong>Code 区</strong>: 源代码对应的 JVM 指令操作码，我们在字节码增强的时候重点操作的就是这个部分。</li><li><strong>LineNumberTable</strong>: 行号表，将 Code 区的操作码和源代码的行号对应，Debug 时会起到作用（即: 当源代码向下走一行，相应的需要走几个 JVM 指令操作码）。 </li><li><strong>LocalVariableTable</strong>: 本地变量表，包含 this 和局部变量，之所以可以在每一个非 static 的方法内部都可以调用到 this，是因为 JVM 将 this 作为每个方法的第一个参数隐式进行传入。<br><img src="https://i.loli.net/2019/10/03/Vza6e1xhFGsg9HJ.png" alt="图13"><center>图 13</center></li></ol><p><strong>（10）附加属性表（additional_attribute_table）</strong><br>字节码的最后一部分，存放了在文件中类或接口所定义的属性的基本信息。</p><h4 id="1-3-Java-字节码操作集合"><a href="#1-3-Java-字节码操作集合" class="headerlink" title="1.3 Java 字节码操作集合"></a>1.3 Java 字节码操作集合</h4><p>在图 13 中，Code 区的编号是 0 ~ 10，就是 .java 源文件的方法源代码编译后让 JVM 真正执行的操作码。为了帮助人们理解，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码和助记符的对应关系，以及每个操作码的具体作用可以查看 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Oracle 官网</a>，在需要的时候查阅即可。比如上图 13 的助记符为 iconst_2，对应图 3 中的字节码 0x05，作用是将 int 值 2 压入操作数栈中。以此类推，对 0 ~ 10 的助记符理解后就是整个 <strong>sum()</strong> 方法的操作数码实现。</p><h4 id="1-4-查看字节码工具"><a href="#1-4-查看字节码工具" class="headerlink" title="1.4 查看字节码工具"></a>1.4 查看字节码工具</h4><p>如果我们每次反编译都要使用 <strong>javap</strong> 命令的话，确实比较繁琐，这里我推荐大家一个 IDEA 插件: <a href="https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer" target="_blank" rel="noopener">jclasslib</a>。使用效果如图 14 所示: 代码编译后在菜单栏: <strong>View</strong> -&gt; <strong>Show Bytecode With jclasslib</strong>，可以很直观地看到当前字节码文件的类信息、常量池、方法区等信息，非常方便。<br><img src="https://i.loli.net/2019/10/03/Xj5kUt6eO2ysYCb.png" alt="图14"><center>图 14</center></p><h4 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h4><p>Java 中字节码文件是 JVM 执行引擎的数据入口，也是 Java 技术体系的基础构成之一。了解字节码文件的组成结构对后面进一步了解虚拟机和深入学习 Java 有很重要的意义。本文较为详细的讲解了字节码文件结构的各个组成部分，以及每个部分的定义、数据结构和使用方法。强烈建议自己动手分析一下，会理解得更加深入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-什么是字节码？&quot;&gt;&lt;a href=&quot;#1-1-什么是字节码？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是字节码？&quot;&gt;&lt;/a&gt;1.1 什么是字节码？&lt;/h4&gt;&lt;p&gt;Java 在刚刚诞生之时曾经提出过一个非常著名的口号: “&lt;strong&gt;一次编写，到处运行（write once，run anywhere）&lt;/strong&gt;”，这句话充分表达了软件开发人员对冲破平台界限的渴求。“与平台无关”的理想最终实现在操作系统的运用层上: 虚拟机提供商开发了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写到处运行”。&lt;br&gt;&lt;br&gt;各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—&lt;strong&gt;字节码（ByteCode）&lt;/strong&gt;，因此，可以看出字节码对 Java 生态的重要性。之所以被称为字节码，是因为字节码是由十六进制组成的，而 JVM（Java Virtual Machine）以两个十六进制为一组，即以字节为单位进行读取。在 Java 中使用 &lt;strong&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;javac&lt;/a&gt;&lt;/strong&gt; 命令把源代码编译成字节码文件，一个 .java 源文件从编译成 .class 字节码文件的示例如图 1 所示:&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/10/03/jcIPJSvYnd2ayOi.png&quot; alt=&quot;图1&quot;&gt;&lt;center&gt;图 1&lt;/center&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="https://www.mghio.cn/post/b1d4025b.html"/>
    <id>https://www.mghio.cn/post/b1d4025b.html</id>
    <published>2019-10-01T15:24:11.000Z</published>
    <updated>2019-10-03T05:23:44.943Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Hello World ~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloWorld&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello World ~~~&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
</feed>
