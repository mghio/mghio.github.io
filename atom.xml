<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mghio</title>
  
  <subtitle>JAVA 搬运工 &amp; 终身学习者。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mghio.cn/"/>
  <updated>2019-10-13T15:50:24.994Z</updated>
  <id>https://www.mghio.cn/</id>
  
  <author>
    <name>mghio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 字符串 split 踩坑记</title>
    <link href="https://www.mghio.cn/post/8bd965a0.html"/>
    <id>https://www.mghio.cn/post/8bd965a0.html</id>
    <published>2019-10-13T02:33:40.000Z</published>
    <updated>2019-10-13T15:50:24.994Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-split-的坑"><a href="#1-1-split-的坑" class="headerlink" title="1.1 split 的坑"></a>1.1 split 的坑</h4><p>前几天在公司对通过 <a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">FTP</a> 方式上传的数据文件按照事先规定的格式进行解析后入库，代码的大概实现思路是这样的：先使用流进行文件读取，对文件的每一行数据解析封装成一个个对象，然后进行入库操作。本以为很简单的一个操作，然后写完代码后自己测试发现对文件的每一行进行字符串分割的时候存在问题，在这里做个简单的记录总结。在 Java 中使用 split 方法对字符串进行分割是经常使用的方法，经常在一些文本处理、字符串分割的逻辑中，需要按照一定的分隔符进行分割拆解。这样的功能，大多数情况下我们都会使用 String 中的 split 方法。关于这个方法，稍不注意很容易踩坑。</p><p><strong>（1）split 的参数是正则表达式</strong><br>首先一个常见的问题，就是忘记了 String 的 split 方法的参数不是普通的字符串，而是正则表达式，例如下面的这两种使用方式都达不到我们的预期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringSplitRegexArg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m.g.h.i.o"</span>.split(<span class="string">"."</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m|g|h|i|o"</span>.split(<span class="string">"|"</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>以上代码的结果输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[m, |, g, |, h, |, i, |, o]</span><br></pre></td></tr></table></figure><p>上面出错的原因是因为 <strong>.</strong> 和 <strong>|</strong> 都是正则表达式，应该用转义字符进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"m.g.h.i.o"</span>.split(<span class="string">"\\."</span>)</span><br><span class="line"><span class="string">"m|g|h|i|o"</span>.split(<span class="string">"\\|"</span>)</span><br></pre></td></tr></table></figure><p>在 String 类中还有其它的和这个相似的方法，例如：replaceAll。</p><p><strong>（2）split 会忽略分割后的空字符串</strong><br>大多数情况下我们都只会使用带一个参数的 split 方法，但是只带一个参数的 split 方法有个坑：就是此方法只会匹配到最后一个有值的地方，后面的会忽略掉，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringSplitSingleArg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m_g_h_i_o"</span>.split(<span class="string">"_"</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m_g_h_i_o__"</span>.split(<span class="string">"_"</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(<span class="string">"m__g_h_i_o_"</span>.split(<span class="string">"_"</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[m, g, h, i, o]</span><br><span class="line">[m, g, h, i, o]</span><br><span class="line">[m, , g, h, i, o]</span><br></pre></td></tr></table></figure><p>像第二、三个输出结果其实和我们的预期是不符的，因为像一些文件上传其实有的字段通常是可以为空的，如果使用单个参数的 split 方法进行处理就会有问题。通过查看 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">API 文档</a> 后，发现其实 String 中的 split 方法还有一个带两个参数的方法。第二个参数是一个整型类型变量，代表最多匹配上多少个，0 表示只匹配到最后一个有值的地方，单个参数的 split 方法的第二个参数其实就是 0，要想强制匹配可以选择使用负数（通常传入 -1 ），换成以下的写法，输出结果就和我们的预期一致了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"m_g_h_i_o"</span>.split(<span class="string">"_"</span>, -<span class="number">1</span>)      <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line"><span class="string">"m_g_h_i_o__"</span>.split(<span class="string">"_"</span>, -<span class="number">1</span>)    <span class="comment">// [m, g, h, i, o, , ]</span></span><br><span class="line"><span class="string">"m__g_h_i_o_"</span>.split(<span class="string">"_"</span>, -<span class="number">1</span>)    <span class="comment">// [m, , g, h, i, o, ]</span></span><br></pre></td></tr></table></figure><p><strong>（3）JDK 中字符串切割的其它 API</strong><br>在 JDK 中还有一个叫做 <strong>StringTokenizer</strong> 的类也可以对字符串进行切割，用法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringTokenizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringTokenizer st = <span class="keyword">new</span> StringTokenizer(<span class="string">"This|is|a|mghio's|blog"</span>, <span class="string">"|"</span>);</span><br><span class="line">    <span class="keyword">while</span> (st.hasMoreElements()) &#123;</span><br><span class="line">      System.out.println(st.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我们从源码的 javadoc 上得知，这是从 JDK 1.0 开始就已经存在了，属于历史遗留的类，并且推荐使用 String 的 split 方法。</p><h4 id="1-2-JDK-源码探究"><a href="#1-2-JDK-源码探究" class="headerlink" title="1.2 JDK 源码探究"></a>1.2 JDK 源码探究</h4><p>通过查看 JDK 中 String 类的源码，我们得知在 String 类中单个参数的 split 方法（<strong>split(String regex)</strong>）里面调用了两个参数的 split 方法（<strong>split(String regex, int limit)</strong>），两个参数的 split 方法，先根据传入第一个参数 <strong>regex</strong> 正则表达式分割字符串，第二个参数 <strong>limit</strong> 限定了分割后的字符串个数，超过数量限制的情况下前limit-1个子字符串正常分割，最后一个子字符串包含剩下所有字符。单个参数的重载方法将 <strong>limit</strong> 设置为 0。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">         <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">         (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">          (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">        (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">         ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> limited = limit &gt; <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> ((next = indexOf(ch, off)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!limited || list.size() &lt; limit - <span class="number">1</span>) &#123;</span><br><span class="line">                list.add(substring(off, next));</span><br><span class="line">                off = next + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// last one</span></span><br><span class="line">                <span class="comment">//assert (list.size() == limit - 1);</span></span><br><span class="line">                list.add(substring(off, value.length));</span><br><span class="line">                off = value.length;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If no match was found, return this</span></span><br><span class="line">        <span class="keyword">if</span> (off == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add remaining segment</span></span><br><span class="line">        <span class="keyword">if</span> (!limited || list.size() &lt; limit)</span><br><span class="line">            list.add(substring(off, value.length));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Construct result</span></span><br><span class="line">        <span class="keyword">int</span> resultSize = list.size();</span><br><span class="line">        <span class="keyword">if</span> (limit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line">                resultSize--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] result = <span class="keyword">new</span> String[resultSize];</span><br><span class="line">        <span class="keyword">return</span> list.subList(<span class="number">0</span>, resultSize).toArray(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来让我们一起看看 String 的 split 方法是如何实现的。</p><p><strong>（1）特殊情况判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(((regex.value.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">         <span class="string">".$|()[&#123;^?*+\\"</span>.indexOf(ch = regex.charAt(<span class="number">0</span>)) == -<span class="number">1</span>) ||</span><br><span class="line">         (regex.length() == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          regex.charAt(<span class="number">0</span>) == <span class="string">'\\'</span> &amp;&amp;</span><br><span class="line">          (((ch = regex.charAt(<span class="number">1</span>))-<span class="string">'0'</span>)|(<span class="string">'9'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'a'</span>)|(<span class="string">'z'</span>-ch)) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          ((ch-<span class="string">'A'</span>)|(<span class="string">'Z'</span>-ch)) &lt; <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">        (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">         ch &gt; Character.MAX_LOW_SURROGATE))</span><br></pre></td></tr></table></figure><ul><li>第一个参数 <strong>regex</strong> 为单个字符时，将其赋值给 ch，并判断是否在元字符：「.$|()[{^?*+\」中</li><li>第一个参数 <strong>regex</strong> 为两个字符时，第一个字符为 \\（要表示一个\需要用两个\转义得到），第二个字符不在数字、大小写字母和 <a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode 编码</a> Character.MIN_HIGH_SURROGATE（’\uD800’）和 Character.MAX_LOW_SURROGATE（’\uDBFF’）之间。</li></ul><p><strong>（2）字符串分割</strong><br>第一次分割时，使用 off 和 next，off 指向每次分割的起始位置，next 指向分隔符的下标，完成一次分割后更新 off 的值，当 list  的大小等于 limit - 1 时，直接添加剩下的子字符串。</p><ul><li>如果字符串不含有分隔符，则直接返回原字符串</li><li>如果字符串进行完第一次分割后，数量没有达到 limit - 1 的话，则剩余的字符串在第二次添加</li><li>如果传入的第二个参数 <strong>limit</strong> 等于 0 ，则从最后的字符串往前移动，将所有的空字符串（”“）全部清除</li></ul><p><strong>（3）正则匹配</strong><br>String 的 split 方法在不是上面的特殊情况下，会使用两个类 <strong>Pattern</strong> 与 <strong>Matcher</strong> 进行分割匹配处理，而且 Strig 中涉及正则的操作都是调用这两个类进行处理的。</p><ul><li>Pattern 类我们可以将其理解为模式类，它主要是用来创建一个匹配模式，它的构造方法是私有的，不能直接创建该对象，可以通过 <strong>Pattern.complie(String regex)</strong> 简单的工厂方法创建一个正则表达式。</li><li>Matcher 类我们可以将其理解为匹配器类，它是用来解释 Pattern 类对字符串执行匹配操作的引擎，它的构造方法也是私有的，不能直接创建该对象，可以通过 <strong>Pattern.matcher(CharSequence input)</strong> 方法得到该类的实例。String 类的双参数 split 方法最后使用 Pattern 类的 compile 和 split 方法，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br></pre></td></tr></table></figure></li></ul><p>首先调用 Pattern 类的静态方法 compile 获取 Pattern 模式类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pattern(regex, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用 Pattern 的 split(CharSequence input, int limit) 方法，在这个方法中调 matcher(CharSequence input) 方法返回一个 Matcher 匹配器类的实例 m，与 String 类中 split 方法的特殊情况有些类似。</p><ul><li>使用 m.find()、m.start()、m.end() 方法</li><li>每找到一个分割符，则更新 start 和 end 的位置</li><li>然后处理没找到分隔符、子字符串数量小于 limit 以及 limit = 0 的情况</li></ul><h4 id="1-3-其它的字符串分割方式"><a href="#1-3-其它的字符串分割方式" class="headerlink" title="1.3 其它的字符串分割方式"></a>1.3 其它的字符串分割方式</h4><ul><li>方式一：使用 org.apache.commons.lang3.StringUtils#split，此方法使用完整的字符串作为参数，而不是正则表达式。底层调用 splitWorker 方法（<strong><font color="#dd0000">注意：</font></strong>此方法会忽略分割后的空字符串）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testApacheCommonsLangStringUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Arrays.toString(StringUtils.split(<span class="string">"m.g.h.i.o"</span>, <span class="string">"."</span>)));</span><br><span class="line">         System.out.println(Arrays.toString(StringUtils.split(<span class="string">"m__g_h_i_o_"</span>, <span class="string">"_"</span>)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[m, g, h, i, o]</span><br><span class="line">[m, g, h, i, o]</span><br></pre></td></tr></table></figure><ul><li>方式二：使用 com.google.common.base.Splitter，使用Google Guava包中提供的分割器splitter，它提供了更加丰富的分割结果处理的方法，比如对结果前后去除空格，去除空字符串等<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-10-13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Java 字符串 split 踩坑记</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaStringSplitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testApacheCommonsLangStringUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         Iterable&lt;String&gt; result = Splitter.on(<span class="string">"_"</span>).split(<span class="string">"m__g_h_i_o_"</span>);</span><br><span class="line">         List&lt;String&gt; resultList = Lists.newArrayList();</span><br><span class="line">         result.forEach(resultList::add);</span><br><span class="line">         System.out.println(<span class="string">"stringList's size: "</span> + resultList.size());</span><br><span class="line">         result.forEach(System.out::println);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringList<span class="string">'s size: 7</span></span><br><span class="line"><span class="string">m</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">g</span></span><br><span class="line"><span class="string">h</span></span><br><span class="line"><span class="string">i</span></span><br><span class="line"><span class="string">o</span></span><br></pre></td></tr></table></figure><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><p>String 类中除了 split 方法外，有正则表达式接口的方法都是调用 Pattern（模式类）和 Matcher（匹配器类）进行实现的。JDK 源码的每一个如 <strong>final</strong>、<strong>private</strong> 的关键字都设计的十分严谨，多读类和方法中的javadoc，多注意这些细节对于阅读代码和自己写代码都有很大的帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-split-的坑&quot;&gt;&lt;a href=&quot;#1-1-split-的坑&quot; class=&quot;headerlink&quot; title=&quot;1.1 split 的坑&quot;&gt;&lt;/a&gt;1.1 split 的坑&lt;/h4&gt;&lt;p&gt;前几天在公司对通过 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FTP&lt;/a&gt; 方式上传的数据文件按照事先规定的格式进行解析后入库，代码的大概实现思路是这样的：先使用流进行文件读取，对文件的每一行数据解析封装成一个个对象，然后进行入库操作。本以为很简单的一个操作，然后写完代码后自己测试发现对文件的每一行进行字符串分割的时候存在问题，在这里做个简单的记录总结。在 Java 中使用 split 方法对字符串进行分割是经常使用的方法，经常在一些文本处理、字符串分割的逻辑中，需要按照一定的分隔符进行分割拆解。这样的功能，大多数情况下我们都会使用 String 中的 split 方法。关于这个方法，稍不注意很容易踩坑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）split 的参数是正则表达式&lt;/strong&gt;&lt;br&gt;首先一个常见的问题，就是忘记了 String 的 split 方法的参数不是普通的字符串，而是正则表达式，例如下面的这两种使用方式都达不到我们的预期：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; mghio&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@date&lt;/span&gt;: 2019-10-13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@version&lt;/span&gt;: 1.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@description&lt;/span&gt;: Java 字符串 split 踩坑记&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@since&lt;/span&gt; JDK 1.8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;JavaStringSplitTests&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testStringSplitRegexArg&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         System.out.println(Arrays.toString(&lt;span class=&quot;string&quot;&gt;&quot;m.g.h.i.o&quot;&lt;/span&gt;.split(&lt;span class=&quot;string&quot;&gt;&quot;.&quot;&lt;/span&gt;)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         System.out.println(Arrays.toString(&lt;span class=&quot;string&quot;&gt;&quot;m|g|h|i|o&quot;&lt;/span&gt;.split(&lt;span class=&quot;string&quot;&gt;&quot;|&quot;&lt;/span&gt;)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 字节码</title>
    <link href="https://www.mghio.cn/post/192cb539.html"/>
    <id>https://www.mghio.cn/post/192cb539.html</id>
    <published>2019-10-02T07:45:32.000Z</published>
    <updated>2019-10-03T07:10:43.847Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-什么是字节码？"><a href="#1-1-什么是字节码？" class="headerlink" title="1.1 什么是字节码？"></a>1.1 什么是字节码？</h4><p>Java 在刚刚诞生之时曾经提出过一个非常著名的口号: “<strong>一次编写，到处运行（write once，run anywhere）</strong>”，这句话充分表达了软件开发人员对冲破平台界限的渴求。“与平台无关”的理想最终实现在操作系统的运用层上: 虚拟机提供商开发了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写到处运行”。<br><br>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—<strong>字节码（ByteCode）</strong>，因此，可以看出字节码对 Java 生态的重要性。之所以被称为字节码，是因为字节码是由十六进制组成的，而 JVM（Java Virtual Machine）以两个十六进制为一组，即以字节为单位进行读取。在 Java 中使用 <strong><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html" target="_blank" rel="noopener">javac</a></strong> 命令把源代码编译成字节码文件，一个 .java 源文件从编译成 .class 字节码文件的示例如图 1 所示:<br><img src="https://i.loli.net/2019/10/03/jcIPJSvYnd2ayOi.png" alt="图1"><center>图 1</center></p><a id="more"></a><p>对于从事基于 JVM 的语言的开发人员来说，比如: Java，了解字节码可以更准确、更直观的理解 Java 语言中更深层次的东西，比如通过字节码，可以很直观的看到 <strong>volatile</strong> 关键字如何在字节码上生效。另外，字节码增强技术在各种 ORM 框架、Spring AOP、热部署等一些应用中经常使用，深入理解其原理对于我们来说大有裨益。由于 JVM 规范的存在，只要最终生成了符合 JVM 字节码规范的文件都可以在 JVM 上运行，因此，这个也给其它各种运行在 JVM 上的语言（如: <a href="https://www.scala-lang.org/" target="_blank" rel="noopener">Scala</a>、<a href="https://groovy-lang.org/" target="_blank" rel="noopener">Groovy</a>、<a href="https://kotlinlang.org/" target="_blank" rel="noopener">Kotlin</a>）提供了一个机会，可以扩展 Java 没有实现的特性或者实现一些语法糖。<br><br>接下来就让我们就一起看看这个字节码文件结构到底是什么样的。</p><h4 id="1-2-Java-字节码结构"><a href="#1-2-Java-字节码结构" class="headerlink" title="1.2 Java 字节码结构"></a>1.2 Java 字节码结构</h4><p>Java 源文件通过用 <strong><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html" target="_blank" rel="noopener">javac</a></strong> 命令编译后就会得到 .class 结尾的字节码文件，比如一个简单的 <strong>JavaCodeCompilerDemo</strong> 类如图 2 所示:<br><img src="https://i.loli.net/2019/10/03/raIK3DpwS67lTsZ.png" alt="图2"><center>图 2</center><br>编译后生成的 .class 字节码文件，打开后是一堆 <a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6" target="_blank" rel="noopener">十六进制</a> 数，如图 3 所示:<br><img src="https://i.loli.net/2019/10/03/gZfiXKmzI7o628x.png" alt="图3"><center>图 3</center><br>在上节提过，JVM 对于字节码规范是有要求的，打开编译后的字节码文件看似混乱无章，其实它是符合一定的结构规范的，JVM 规范要求每一个字节码文件都要由十部分固定的顺序组成的，接下来我们将一一介绍这部分，整体的组成结构如图 4 所示:<br><img src="https://i.loli.net/2019/10/03/f8NnQeZ6BuqGRHC.png" alt="图4"><center>图 4</center></p><p><strong>（1）魔数（Magic Number）</strong><br>每个字节码文件的头 4 个字节称为 <strong>魔数（Magic Number）</strong>，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如 gif 或者 jpg 等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意改动。魔数的固定值为: <strong>0xCAFEBABE</strong>，魔数放在文件头，JVM 可以根据文件的开头来判断这个文件是否可能是一个字节码文件，如果是，才会进行之后的操作。</p><blockquote><p>有趣的是，魔数的固定值是 Java 之父 <a href="https://zh.wikipedia.org/wiki/%E8%A9%B9%E5%A7%86%E6%96%AF%C2%B7%E9%AB%98%E6%96%AF%E6%9E%97" target="_blank" rel="noopener">James Gosling</a> 制定的，为 CafeBabe（咖啡宝贝），而 Java 的图标为一杯咖啡。</p></blockquote><p><strong>（2）版本号（Version）</strong><br>版本号为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version），上图 3 中版本号为: “00 00 00 34”，次版本号转化为十进制为 0，主版本号转化为十进制 52（3 * 16^1 + 4 * 16^0 = 52），在 Oracle 官网中查询序号 52 对应的 JDK 版本为 1.8，所以编译该源代码文件的 Java 版本为 1.8.0。</p><p><strong>（3）常量池（Constant Pool）</strong><br>紧接着主版本号之后的字节是常量池入口。常量池中存储两种类型常量: 字面量和符号运用。字面量为代码中声明为 <strong>final</strong> 的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。常量池整体上分为两部分: 常量池计数器和常量池数据区，如图 5 所示：<br><img src="https://i.loli.net/2019/10/03/drScelTF6xN3Uoa.png" alt="图5"><center>图 5</center><br><strong>常量池计数器（constant_pool_count）</strong>: 由于常量池的数量不固定，所以需要先放置两个字节来表示常量池容量计数值，图 2 示例代码的字节码的前十个字节如下图 6 所示，将十六进制的 17 转为十进制的值为 33 (1 * 16^1 + 7 * 16^0 = 33)，排除下标 0，也就是说这个类文件有 32 个常量。<br><img src="https://i.loli.net/2019/10/03/IGVoJLYUSP9a3uH.png" alt="图6"><center>图 6</center><br><strong>常量池数据区</strong>: 数据区是由（constant_pool_count - 1）个 cp_info 结构组成，一个 cp_info 的结构对应一个常量。在字节码中共有 14 种类型的 cp_info ，每种类型的结构都是固定的，如图 7 所示:<br><img src="https://i.loli.net/2019/10/03/VB8KPSiEh6Zzav7.png" alt="图7"><center>图 7</center><br>以 CONSTANT_Utf8_info 为例，它的结构如表 1 所示:</p><table><thead><tr><th>名称</th><th align="left">长度</th><th align="center">值</th></tr></thead><tbody><tr><td>tag</td><td align="left">1 字节</td><td align="center">01 对应图 7 中 CONSTANT_Utf8_info 的<strong>标志栏</strong>中的值</td></tr><tr><td>length</td><td align="left">2 字节</td><td align="center">该 utf8 字符串的长度</td></tr><tr><td>bytes</td><td align="left">length 字节</td><td align="center">length 个字节的具体数据</td></tr></tbody></table><center>表 1</center>首先第一个字节 tag，它的取值对应图 7 中的 Tag，由于它的类型是 CONSTANT_Utf8_info，所以值为 01（十六进制）。接下来两个字节标识该字符串的长度 length，然后 length 个字节为这个字符串具体的值。从图 3 的字节码中摘取一个 cp_info 结构，将它翻译过来后，其含义为: 该常量为 utf8 字符串，长度为 7 字节，数据为: numberA，如图 8 所示:<p><img src="https://i.loli.net/2019/10/03/cgUGTEs5rqm4wQ6.png" alt="图8"><center>图 8</center><br>其它类型的 cp_info 结构在本文不在细说，和 CONSTANT_Utf8_info 的结构大同小异，都是先通过 tag 来标识类型，然后后续的 n 个字节来描述长度和数据。等我们对这些结构比较了解了之后，我们可以通过: <strong>javap -verbose JavaCodeCompilerDemo</strong> 命令查看 JVM 反编译后的完整常量池，可以看到反编译结果可以将每一个 cp_info 结构的类型和值都很明确的呈现出来，如图 9 所示:<br><img src="https://i.loli.net/2019/10/03/XLOV4PnltSoEQ8A.png" alt="图9"><center>图 9</center></p><p><strong>（4）访问标志（access_flag）</strong><br>常量池结束之后的两个字节，描述该 Class 是类还是接口，以及是否被 <strong>Public</strong>、<strong>Abstract</strong>、<strong>Final</strong> 等修饰符修饰。JVM 规范规定了如下表 2 所示的 9 种访问标志。需要注意的是，JVM 并没有穷举所有的访问标志，而是使用 <a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E6%93%8D%E4%BD%9C#%E6%8C%89%E4%BD%8D%E6%88%96%EF%BC%88OR%EF%BC%89" target="_blank" rel="noopener">按位或</a> 操作来进行描述的，比如某个类的修饰符为 public final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 <strong>0x0001 | 0x0010 = 0x0011</strong>。</p><table><thead><tr><th>标志名称</th><th align="left">标志值</th><th align="center">含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td align="left">0x0001</td><td align="center">字段是否为 public</td></tr><tr><td>ACC_PRIVATE</td><td align="left">0x0002</td><td align="center">字段是否为 private</td></tr><tr><td>ACC_PROTECTED</td><td align="left">0x0004</td><td align="center">字段是否为 protected</td></tr><tr><td>ACC_STATIC</td><td align="left">0x0008</td><td align="center">字段是否为 static</td></tr><tr><td>ACC_FINAL</td><td align="left">0x0010</td><td align="center">字段是否为 final</td></tr><tr><td>ACC_VOLATILE</td><td align="left">0x0040</td><td align="center">字段是否为 volatile</td></tr><tr><td>ACC_TRANSIENT</td><td align="left">0x0080</td><td align="center">字段是否为 transient</td></tr><tr><td>ACC_SYNCHETIC</td><td align="left">0x1000</td><td align="center">字段是否为编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td align="left">0x4000</td><td align="center">字段是否为 enum</td></tr></tbody></table><center>表 2</center><p><strong>（5）当前类名（this_class）</strong><br>访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。</p><p><strong>（6）父类名称（super_class）</strong><br>当前类名的后两个字节，描述父类的全限定名。这两个字节保存的值也是在常量池中的索引值，根据索引值就能在常量池中找到这个类的父类的全限定名。</p><p><strong>（7）接口信息（interfaces）</strong><br>父类名称后的两个字节，描述这个类的接口计数器，即: 当前类或父类实现的接口数量。紧接着的 n 个字节是所有的接口名称的字符串常量在常量池的索引值。</p><p><strong>（8）字段表（field_table）</strong><br>字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的 <a href="https://zh.wikipedia.org/wiki/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">局部变量</a>。字段表也分为两部分，第一部分是两个字节，描述字段个数，第二部分是每个字段的详细信息 <strong>field_info</strong>。字段表结构如图 10 所示:<br><img src="https://i.loli.net/2019/10/03/7qSyCJugf6iWLNc.png" alt="图10"><center>图 10</center><br>以图 3 中的字节码字段表为例，如下图 11 所示。其中字段的访问标志查表 2，002 对应为 Private，通过索引下标在图 9 中常量池分别得到字段名为: numberA，描述符为: I（在JVM 中的I代表 Java 中的 int）。综上，就可以唯一确定出类 <strong>JavaCodeCompilerDemo</strong> 中声明的变量为: <strong>private int numberA</strong> 。<br><img src="https://i.loli.net/2019/10/03/JcOBekuzqwMovAb.png" alt="图11"><center>图 11</center></p><p><strong>（9）方法表（method_table）</strong><br>字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数，第二个部分为每个方法的详细信息。方法的详细信息包括：方法的访问标志、方法名、方法的描述符以及方法的属性，如图 12 所示:<br><img src="https://i.loli.net/2019/10/03/2zmkgxBdhCrweL9.png" alt="图12"><center>图 12</center><br>方法的权限修饰符依然可以通过图 9 的值查询到，方法名和方法的描述符都是常量池的索引值，可以通过索引值在常量池中查询得到。而方法属性这个部分比较复杂，我们可以借助 <strong>javap -verbose</strong> 将其反编译为人们可读的信息进行解读。如图 13 所示。我们可以看到属性中包含三个部分:</p><ol><li><strong>Code 区</strong>: 源代码对应的 JVM 指令操作码，我们在字节码增强的时候重点操作的就是这个部分。</li><li><strong>LineNumberTable</strong>: 行号表，将 Code 区的操作码和源代码的行号对应，Debug 时会起到作用（即: 当源代码向下走一行，相应的需要走几个 JVM 指令操作码）。 </li><li><strong>LocalVariableTable</strong>: 本地变量表，包含 this 和局部变量，之所以可以在每一个非 static 的方法内部都可以调用到 this，是因为 JVM 将 this 作为每个方法的第一个参数隐式进行传入。<br><img src="https://i.loli.net/2019/10/03/Vza6e1xhFGsg9HJ.png" alt="图13"><center>图 13</center></li></ol><p><strong>（10）附加属性表（additional_attribute_table）</strong><br>字节码的最后一部分，存放了在文件中类或接口所定义的属性的基本信息。</p><h4 id="1-3-Java-字节码操作集合"><a href="#1-3-Java-字节码操作集合" class="headerlink" title="1.3 Java 字节码操作集合"></a>1.3 Java 字节码操作集合</h4><p>在图 13 中，Code 区的编号是 0 ~ 10，就是 .java 源文件的方法源代码编译后让 JVM 真正执行的操作码。为了帮助人们理解，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码和助记符的对应关系，以及每个操作码的具体作用可以查看 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Oracle 官网</a>，在需要的时候查阅即可。比如上图 13 的助记符为 iconst_2，对应图 3 中的字节码 0x05，作用是将 int 值 2 压入操作数栈中。以此类推，对 0 ~ 10 的助记符理解后就是整个 <strong>sum()</strong> 方法的操作数码实现。</p><h4 id="1-4-查看字节码工具"><a href="#1-4-查看字节码工具" class="headerlink" title="1.4 查看字节码工具"></a>1.4 查看字节码工具</h4><p>如果我们每次反编译都要使用 <strong>javap</strong> 命令的话，确实比较繁琐，这里我推荐大家一个 IDEA 插件: <a href="https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer" target="_blank" rel="noopener">jclasslib</a>。使用效果如图 14 所示: 代码编译后在菜单栏: <strong>View</strong> -&gt; <strong>Show Bytecode With jclasslib</strong>，可以很直观地看到当前字节码文件的类信息、常量池、方法区等信息，非常方便。<br><img src="https://i.loli.net/2019/10/03/Xj5kUt6eO2ysYCb.png" alt="图14"><center>图 14</center></p><h4 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h4><p>Java 中字节码文件是 JVM 执行引擎的数据入口，也是 Java 技术体系的基础构成之一。了解字节码文件的组成结构对后面进一步了解虚拟机和深入学习 Java 有很重要的意义。本文较为详细的讲解了字节码文件结构的各个组成部分，以及每个部分的定义、数据结构和使用方法。强烈建议自己动手分析一下，会理解得更加深入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-什么是字节码？&quot;&gt;&lt;a href=&quot;#1-1-什么是字节码？&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是字节码？&quot;&gt;&lt;/a&gt;1.1 什么是字节码？&lt;/h4&gt;&lt;p&gt;Java 在刚刚诞生之时曾经提出过一个非常著名的口号: “&lt;strong&gt;一次编写，到处运行（write once，run anywhere）&lt;/strong&gt;”，这句话充分表达了软件开发人员对冲破平台界限的渴求。“与平台无关”的理想最终实现在操作系统的运用层上: 虚拟机提供商开发了许多可以运行在不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写到处运行”。&lt;br&gt;&lt;br&gt;各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—&lt;strong&gt;字节码（ByteCode）&lt;/strong&gt;，因此，可以看出字节码对 Java 生态的重要性。之所以被称为字节码，是因为字节码是由十六进制组成的，而 JVM（Java Virtual Machine）以两个十六进制为一组，即以字节为单位进行读取。在 Java 中使用 &lt;strong&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;javac&lt;/a&gt;&lt;/strong&gt; 命令把源代码编译成字节码文件，一个 .java 源文件从编译成 .class 字节码文件的示例如图 1 所示:&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2019/10/03/jcIPJSvYnd2ayOi.png&quot; alt=&quot;图1&quot;&gt;&lt;center&gt;图 1&lt;/center&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="https://www.mghio.cn/post/b1d4025b.html"/>
    <id>https://www.mghio.cn/post/b1d4025b.html</id>
    <published>2019-10-01T15:24:11.000Z</published>
    <updated>2019-10-03T05:23:44.943Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Hello World ~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloWorld&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello World ~~~&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
</feed>
