<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mghio</title>
  
  <subtitle>Java 搬运工 &amp; 终身学习者。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mghio.cn/"/>
  <updated>2020-05-30T16:48:57.821Z</updated>
  <id>https://www.mghio.cn/</id>
  
  <author>
    <name>mghio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文让你快速上手 Mockito 单元测试框架</title>
    <link href="https://www.mghio.cn/post/24042edf.html"/>
    <id>https://www.mghio.cn/post/24042edf.html</id>
    <published>2020-05-29T11:27:50.000Z</published>
    <updated>2020-05-30T16:48:57.821Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在计算机编程中，单元测试是一种软件测试方法，我们通过该方法可以测试源代码的各个单元功能是否适合使用。为代码编写单元测试有很多好处，包括可以及早的发现代码错误，促进更改，简化集成，方便代码重构以及许多其他功能。使用 <code>Java</code> 语言编码的朋友应该用过或者听过 <code>Junit</code> 就是用来做单元测试的，那么为什么我们还需要 <code>Mockito</code> 测试框架呢？想象一下这样的一个常见的场景，当前要测试的类依赖于其它一些类对象时，如果使用仅仅 <code>Junit</code> 来进行单元测试的话，我们就必须手动创建出这些依赖的对象，这其实是个比较麻烦的工作，此时就可以使用 <code>Mockito</code> 测试框架来模拟那些依赖的类，这些被模拟的对象在测试中充当真实对象的虚拟对象或克隆对象，而且 Mockito 同时也提供了方便的测试行为验证。这样就可以让我们更多地去关注当前测试的类的逻辑，而不是它所依赖的对象。</p><a id="more"></a><h4 id="生成-Mock-对象方式"><a href="#生成-Mock-对象方式" class="headerlink" title="生成 Mock 对象方式"></a>生成 Mock 对象方式</h4><p>要使用 <code>Mockito</code>，首先需要在我们的项目中引入 <code>Mockito</code> 测试框架依赖，基于 <code>Maven</code> 构建的项目引入如下依赖即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.3&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>如果是基于 <code>Gradle</code> 构建的项目，引入如下依赖即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testCompile group: <span class="string">'org.mockito'</span>, name: <span class="string">'mockito-core'</span>, version: <span class="string">'3.3.3'</span></span><br></pre></td></tr></table></figure><p>使用 <code>Mockito</code> 通常有两种常见的方式来创建 <code>Mock</code> 对象。</p><h5 id="1、使用-Mockito-mock-clazz-方式"><a href="#1、使用-Mockito-mock-clazz-方式" class="headerlink" title="1、使用 Mockito.mock(clazz) 方式"></a>1、使用 Mockito.mock(clazz) 方式</h5><p>通过 <code>Mockito</code> 类的静态方法会 <code>mock</code> 来创建 <code>Mock</code> 对象，例如以下创建了一个 <code>List</code> 类型的 <code>Mock</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; mockList = Mockito.mock(List.class);</span><br></pre></td></tr></table></figure><p>由于 <code>mock</code> 方法是一个静态方法，所以通常会写成静态导入方法的方式，即 <code>List&lt;String&gt; mockList = mock(List.class)</code>。</p><h5 id="2、使用-Mock-注解方式"><a href="#2、使用-Mock-注解方式" class="headerlink" title="2、使用 @Mock 注解方式"></a>2、使用 @Mock 注解方式</h5><p>第二种方式就是使用注解 <code>@Mock</code> 方式来创建 <code>Mock</code> 对象，使用该方式创需要注意的是要在运行测试方法前使用 <code>MockitoAnnotations.initMocks(this);</code> 或者单元测试类上加上 <code>@ExtendWith(MockitoExtension.class)</code> 注解，如下所示代码创建了一个 <code>List</code> 类型的 <code>Mock</code> 对象(<code>PS: @BeforeEach 是 Junit 5 的注解功能类似于 Junit 4 的 @Before 注解。</code>)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mock</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; mockList;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@BeforeEach</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeEach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证性测试"><a href="#验证性测试" class="headerlink" title="验证性测试"></a>验证性测试</h4><p><code>Mockito</code> 测试框架中提供了 <code>Mockito.verify</code> 静态方法让我们可以方便的进行验证性测试，比如方法调用验证、方法调用次数验证、方法调用顺序验证等，下面看看具体的代码。</p><h6 id="验证方法单次调用"><a href="#验证方法单次调用" class="headerlink" title="验证方法单次调用"></a>验证方法单次调用</h6><p>验证方法单次调用的话直接 <code>verify</code> 方法后加上待验证调用方法即可，以下代码的功能就是验证 <code>mockList</code> 对象的 <code>size</code> 方法被调用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(MockitoExtension.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoVerifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mock</span></span><br><span class="line">  List&lt;String&gt; mockList;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">verify_SimpleInvocationOnMock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mockList.size();</span><br><span class="line">    verify(mockList).size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="验证方法调用指定次数"><a href="#验证方法调用指定次数" class="headerlink" title="验证方法调用指定次数"></a>验证方法调用指定次数</h6><p>除了验证单次调用，我们有时候还需要验证一些方法被调用多次或者指定的次数，那么此时就可以使用 <code>verify</code> + <code>times</code> 方法来验证方法调用指定次数，同时还可以结合 <code>atLeast</code> + <code>atMost</code> 方法来提供调用次数范围，同时还有 <code>never</code> 等方法验证不被调用等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(MockitoExtension.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoVerifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mock</span></span><br><span class="line">  List&lt;String&gt; mockList;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">verify_NumberOfInteractionsWithMock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mockList.size();</span><br><span class="line">    mockList.size();</span><br><span class="line"></span><br><span class="line">    verify(mockList, times(<span class="number">2</span>)).size();</span><br><span class="line">    verify(mockList, atLeast(<span class="number">1</span>)).size();</span><br><span class="line">    verify(mockList, atMost(<span class="number">10</span>)).size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="验证方法调用顺序"><a href="#验证方法调用顺序" class="headerlink" title="验证方法调用顺序"></a>验证方法调用顺序</h6><p>同时还可以使用 <code>inOrder</code> 方法来验证方法的调用顺序，下面示例验证 <code>mockList</code> 对象的 <code>size</code>、<code>add</code> 和 <code>clear</code> 方法的调用顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(MockitoExtension.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoVerifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mock</span></span><br><span class="line">  List&lt;String&gt; mockList;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">verify_OrderedInvocationsOnMock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mockList.size();</span><br><span class="line">    mockList.add(<span class="string">"add a parameter"</span>);</span><br><span class="line">    mockList.clear();</span><br><span class="line"></span><br><span class="line">    InOrder inOrder = inOrder(mockList);</span><br><span class="line"></span><br><span class="line">    inOrder.verify(mockList).size();</span><br><span class="line">    inOrder.verify(mockList).add(<span class="string">"add a parameter"</span>);</span><br><span class="line">    inOrder.verify(mockList).clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只是列举了一些简单的验证性测试，还有验证测试方法调用超时以及更多的验证测试可以通过相关官方文档探索学习。</p><h4 id="验证方法异常"><a href="#验证方法异常" class="headerlink" title="验证方法异常"></a>验证方法异常</h4><p>异常测试我们需要使用 <code>Mockito</code> 框架提供的一些调用行为定义，<code>Mockito</code> 提供了 <code>when(...).thenXXX(...)</code> 来让我们定义方法调用行为，以下代码定义了当调用 <code>mockMap</code> 的 <code>get</code> 方法无论传入任何参数都会抛出一个空指针 <code>NullPointerException</code> 异常，然后通过 <code>Assertions.assertThrows</code> 来验证调用结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(MockitoExtension.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoExceptionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mock</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, Integer&gt; mockMap;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenConfigNonVoidReturnMethodToThrowEx_thenExIsThrown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    when(mockMap.get(anyString())).thenThrow(NullPointerException.class);</span><br><span class="line"></span><br><span class="line">    assertThrows(NullPointerException.class, () -&gt; mockMap.get(<span class="string">"mghio"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时 <code>when(...).thenXXX(...)</code> 不仅可以定义方法调用抛出异常，还可以定义调用方法后的返回结果，比如 <code>when(mockMap.get(&quot;mghio&quot;)).thenReturn(21);</code> 定义了当我们调用 <code>mockMap</code> 的 <code>get</code> 方法并传入参数 <code>mghio</code> 时的返回结果是 <code>21</code>。这里有一点需要注意，使用以上这种方式定义的 <code>mock</code> 对象测试实际并不会影响到对象的内部状态，如下图所示：</p><p><img src="https://i.loli.net/2020/05/30/VncOvo3tm8b7CyT.png" alt="mockito_mock_object_thennoaffect.png"></p><p>虽然我们已经在 <code>mockList</code> 对象上调用了 <code>add</code> 方法，但是实际上 <code>mockList</code> 集合中并没有加入 <code>mghio</code>，这时候如果需要对 <code>mock</code> 对象有影响，那么需要使用 <code>spy</code> 方式来生成 <code>mock</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockitoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; mockList = spy(ArrayList.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add_spyMockList_thenAffect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mockList.add(<span class="string">"mghio"</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">0</span>, mockList.size());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>端点后可以发现当使用 <code>spy</code> 方法创建出来的 <code>mock</code> 对象调用 <code>add</code> 方法后，<code>mghio</code> 被成功的加入到 <code>mockList</code> 集合当中。</p><p><img src="https://i.loli.net/2020/05/30/xTAY1noigGcQ5vU.png" alt="mockito_mock_object_thenhasaffect.png"></p><h4 id="与-Spring-框架集成"><a href="#与-Spring-框架集成" class="headerlink" title="与 Spring 框架集成"></a>与 Spring 框架集成</h4><p><code>Mockito</code> 框架提供了 <code>@MockBean</code> 注解用来将 <code>mock</code> 对象注入到 <code>Spring</code> 容器中，该对象会替换容器中任何现有的相同类型的 <code>bean</code>，该注解在需要模拟特定<code>bean</code>（例如外部服务）的测试场景中很有用。如果使用的是 <code>Spring Boot 2.0+</code> 并且当前容器中已有相同类型的 <code>bean</code> 的时候，需要设置 <code>spring.main.allow-bean-definition-overriding</code> 为 <code>true</code>（默认为 <code>false</code>）允许 <code>bean</code> 定义覆盖。下面假设要测试通过用户编码查询用户的信息，有一个数据库操作层的 <code>UserRepository</code>，也就是我们等下要 <code>mock</code> 的对象，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">findUserById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有用户操作的相关服务 <code>UserService</code> 类，其定义如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.findUserById(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中使用 <code>@MockBean</code> 来标注 <code>UserRepository</code> 属性表示这个类型的 <code>bean</code> 使用的是 <code>mock</code> 对象，使用 <code>@Autowired</code> 标注表示 <code>UserService</code> 属性使用的是 <code>Spring</code> 容器中的对象，然后使用 <code>@SpringBootTest</code> 启用 <code>Spring</code> 环境即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceUnitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MockBean</span></span><br><span class="line">  <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenUserIdIsProvided_thenRetrievedNameIsCorrect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User expectedUser = <span class="keyword">new</span> User(<span class="number">9527L</span>, <span class="string">"mghio"</span>, <span class="string">"18288888880"</span>);</span><br><span class="line">    when(userRepository.findUserById(<span class="number">9527L</span>)).thenReturn(expectedUser);</span><br><span class="line">    User actualUser = userService.findUserById(<span class="number">9527L</span>);</span><br><span class="line">    assertEquals(expectedUser, actualUser);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mockito-框架的工作原理"><a href="#Mockito-框架的工作原理" class="headerlink" title="Mockito 框架的工作原理"></a>Mockito 框架的工作原理</h4><p>通过以上介绍可以发现， <code>Mockito</code> 非常容易使用并且可以方便的验证一些方法的行为，相信你已经看出来了，使用的步骤是先创建一个需要 <code>mock</code> 的对象 <code>Target</code> ，该对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">foo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"Hello, %s"</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们直接使用 <code>Mockito.mock</code> 方法和 <code>when(...).thenReturn(...)</code> 来生成 <code>mock</code> 对象并指定方法调用时的行为，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String expectedResult = <span class="string">"Mocked mghio"</span>;</span><br><span class="line">  when(mockTarget.foo(<span class="string">"mghio"</span>)).thenReturn(expectedResult);</span><br><span class="line">  String actualResult = mockTarget.foo(<span class="string">"mghio"</span>);</span><br><span class="line">  assertEquals(expectedResult, actualResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察以上 <code>when(mockTarget.foo(&quot;mghio&quot;)).thenReturn(expectedResult)</code> 这行代码，首次使用我也觉得很奇怪，<code>when</code> 方法的入参竟然是方法的返回值 <code>mockTarget.foo(&quot;mghio&quot;)</code>，觉得正确的代码应该是这样 <code>when(mockTarget).foo(&quot;mghio&quot;)</code>，但是这个写法事实上无法进行编译。既然 <code>Target.foo</code> 方法的返回值是 <code>String</code> 类型，那是不是可以使用如下方式呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mockito.when(<span class="string">"Hello, I am mghio"</span>).thenReturn(<span class="string">"Mocked mghio"</span>);</span><br></pre></td></tr></table></figure><p>结果是编译通过，但是在运行时报错：</p><p><img src="https://i.loli.net/2020/05/30/9zc3GyJoeQ8gB5v.png" alt="mockito_when_method_runtime_error.png"></p><p>从错误提示可以看出，<code>when</code> 方法需要一个方法调用的参数，实际上它只需要 <code>more</code> 对象方法调用在 <code>when</code> 方法之前就行，我们看看下面这个测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_mockitoWhenMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String expectedResult = <span class="string">"Mocked mghio"</span>;</span><br><span class="line">  mockTarget.foo(<span class="string">"mghio"</span>);</span><br><span class="line">  when(<span class="string">"Hello, I am mghio"</span>).thenReturn(expectedResult);</span><br><span class="line">  String actualResult = mockTarget.foo(<span class="string">"mghio"</span>);</span><br><span class="line">  assertEquals(expectedResult, actualResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以正常测试通过，结果如下：</p><p><img src="https://i.loli.net/2020/05/30/njTsc6QCgFSreYi.png" alt="mockito_mock_when_method_pass.png"></p><p>为什么这样可以正常测试通过？是因为当我们调用 <code>mock</code> 对象的 <code>foo</code> 方法时，<code>Mockito</code> 会拦截方法的调用然后将方法调用详细信息保存到 <code>mock</code> 对象的上下文中，当调用到 <code>Mockito.when</code> 方法时，实际上是从该上下文中获取最后一个注册的方法调用，然后把 <code>thenReturn</code> 的参数作为其返回值保存，然后当我们的再次调用 <code>mock</code> 对象的该方法时，之前已经记录的方法行为将被再次回放，该方法触发拦截器重新调用并且返回我们在 <code>thenReturn</code> 方法指定的返回值。以下是 <code>Mockito.when</code> 方法的源码：</p><p><img src="https://i.loli.net/2020/05/30/Q7mVFiKrg8Zd2Ov.png" alt="mockito_when_sourcecode.png"></p><p>该方法里面直接使用了 <code>MockitoCore.when</code> 方法，继续跟进，该方法源码如下：</p><p><img src="https://i.loli.net/2020/05/30/U6nTHWx7YDQ3uLe.png" alt="mockito_when_method_mockitocore_sourcecode.png"></p><p>仔细观察可以发现，在源码中并没有用到参数 <code>methodCall</code>，而是从 <code>MockingProgress</code> 实例中获取 <code>OngoingStubbing</code> 对象，这个 <code>OngoingStubbing</code> 对象就是前文所提到的上下文对象。个人感觉是 <code>Mockito</code> 为了提供简洁易用的 <code>API</code> 然后才制造了 <code>when</code> 方法调用的这种”幻象”，简而言之，<code>Mockito</code> 框架通过方法拦截在上下文中存储和检索方法调用详细信息来工作的。</p><h4 id="如何实现一个微型的-Mock-框架"><a href="#如何实现一个微型的-Mock-框架" class="headerlink" title="如何实现一个微型的 Mock 框架"></a>如何实现一个微型的 Mock 框架</h4><p>知道了 <code>Mockito</code> 的运行原理之后，接下来看看要如何自己去实现一个类似功能的 <code>mock</code> 框架出来，看到<code>方法拦截</code>这里我相信你可能已经知道了，其实这就是 <code>AOP</code> 啊，但是通过阅读其源码发现 <code>Mockito</code> 其实并没有使用我们熟悉的 <code>Spring AOP</code> 或者 <code>AspectJ</code> 做的方法拦截，而是通过运行时增强库 <a href="https://bytebuddy.net" target="_blank" rel="noopener">Byte Buddy</a> 和反射工具库 <a href="http://objenesis.org" target="_blank" rel="noopener">Objenesis</a> 生成和初始化 <code>mock</code> 对象的。<br>现在，通过以上分析和源码阅读可以定义出一个简单版本的 <code>mock</code> 框架了，将自定义的 <code>mock</code> 框架命名为 <code>imock</code>。这里有一点需要注意的是，<code>Mockito</code> 有一个好处是，它不需要进行初始化，可以直接通过其提供的静态方法来立即使用它。在这里我们也使用相同名称的静态方法，通过 <code>Mockito</code> 源码：</p><p><img src="https://i.loli.net/2020/05/30/waKFURI1tvhi5Ex.png" alt="mockito_delegate_mockitocore.png"></p><p>很容易看出 <code>Mockito</code> 类最终都是委托给 <code>MockitoCore</code> 去实现的功能，而其只提供了一些面向使用者易用的静态方法，在这里我们也定义一个这样的代理对象 <code>IMockCore</code>，这个类中需要一个创建 <code>mock</code> 对象的方法 <code>mock</code> 和一个给方法设定返回值的 <code>thenReturn</code> 方法，同时该类中持有一个方法调用详情 <code>InvocationDetails</code> 集合列表，这个类是用来记录方法调用详细信息的，然后 <code>when</code> 方法仅返回列表中的最后一个 <code>InvocationDetails</code>，这里列表可以直接使用 <code>Java</code> 中常用的 <code>ArrayList</code> 即可，这里的 <code>ArrayList</code> 集合列表就实现了 <code>Mockito</code> 中的 <code>OngoingStubbing</code> 的功能。<br>根据方法的三要素<code>方法名</code>、<code>方法参数</code>和<code>方法返回值</code>很容易就可以写出 <code>InvocationDetail</code> 类的代码，为了对方法在不同类有同名的情况区分，还需要加上类全称字段和重写该类的 <code>equals</code> 和 <code>hashCode</code> 方法（判断是否在调用方法集合列表时需要根据该方法判断），代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationDetail</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String attachedClassName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object[] arguments;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T result;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InvocationDetail</span><span class="params">(String attachedClassName, String methodName, Object[] arguments)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.attachedClassName = attachedClassName;</span><br><span class="line">    <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">    <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenReturn</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.result = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    InvocationDetail&lt;?&gt; behaviour = (InvocationDetail&lt;?&gt;) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(attachedClassName, behaviour.attachedClassName) &amp;&amp;</span><br><span class="line">        Objects.equals(methodName, behaviour.methodName) &amp;&amp;</span><br><span class="line">        Arrays.equals(arguments, behaviour.arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Objects.hash(attachedClassName, methodName);</span><br><span class="line">    result = <span class="number">31</span> * result + Arrays.hashCode(arguments);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是如何去创建我们的 <code>mock</code> 对象了，在这里我们也使用 <code>Byte Buddy</code> 和 <code>Objenesis</code> 库来创建 <code>mock</code> 对象，<code>IMockCreator</code> 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMockCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">createMock</span><span class="params">(Class&lt;T&gt; mockTargetClass, List&lt;InvocationDetail&gt; behaviorList)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类 <code>ByteBuddyIMockCreator</code> 使用 <code>Byte Buddy</code> 库在运行时动态生成 <code>mock</code> 类对象代码然后使用 <code>Objenesis</code> 去实例化该对象。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuddyIMockCreator</span> <span class="keyword">implements</span> <span class="title">IMockCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ObjenesisStd objenesisStd = <span class="keyword">new</span> ObjenesisStd();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">createMock</span><span class="params">(Class&lt;T&gt; mockTargetClass, List&lt;InvocationDetail&gt; behaviorList)</span> </span>&#123;</span><br><span class="line">    ByteBuddy byteBuddy = <span class="keyword">new</span> ByteBuddy();</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends T&gt; classWithInterceptor = byteBuddy.subclass(mockTargetClass)</span><br><span class="line">        .method(ElementMatchers.any())</span><br><span class="line">        .intercept(MethodDelegation.to(InterceptorDelegate.class))</span><br><span class="line">        .defineField(<span class="string">"interceptor"</span>, IMockInterceptor.class, Modifier.PRIVATE)</span><br><span class="line">        .implement(IMockIntercepable.class)</span><br><span class="line">        .intercept(FieldAccessor.ofBeanProperty())</span><br><span class="line">        .make()</span><br><span class="line">        .load(getClass().getClassLoader(), Default.WRAPPER).getLoaded();</span><br><span class="line"></span><br><span class="line">    T mockTargetInstance = objenesisStd.newInstance(classWithInterceptor);</span><br><span class="line">    ((IMockIntercepable) mockTargetInstance).setInterceptor(<span class="keyword">new</span> IMockInterceptor(behaviorList));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mockTargetInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以很容易写出创建 <code>mock</code> 对象的 <code>IMockCore</code> 类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMockCore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;InvocationDetail&gt; invocationDetailList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> IMockCreator mockCreator = <span class="keyword">new</span> ByteBuddyIMockCreator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">mock</span><span class="params">(Class&lt;T&gt; mockTargetClass)</span> </span>&#123;</span><br><span class="line">    T result = mockCreator.createMock(mockTargetClass, invocationDetailList);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">InvocationDetail&lt;T&gt; <span class="title">when</span><span class="params">(T methodCall)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentSize = invocationDetailList.size();</span><br><span class="line">    <span class="keyword">return</span> (InvocationDetail&lt;T&gt;) invocationDetailList.get(currentSize - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供给使用者的类 <code>IMock</code> 只是对 <code>IMockCore</code> 进行的简单调用而已，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IMockCore IMOCK_CORE = <span class="keyword">new</span> IMockCore();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">mock</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IMOCK_CORE.mock(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">InvocationDetail <span class="title">when</span><span class="params">(T methodCall)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IMOCK_CORE.when(methodCall);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上步骤，我们就已经实现了一个微型的 <code>mock</code> 框架了，下面来个实际例子测试一下，首先创建一个 <code>Target</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">foo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"Hello, %s"</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写其对应的测试类 <code>IMockTest</code> 类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2020-05-30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_foo_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String exceptedResult = <span class="string">"Mocked mghio"</span>;</span><br><span class="line">    Target mockTarget = IMock.mock(Target.class);</span><br><span class="line"></span><br><span class="line">    IMock.when(mockTarget.foo(<span class="string">"mghio"</span>)).thenReturn(exceptedResult);</span><br><span class="line"></span><br><span class="line">    String actualResult = mockTarget.foo(<span class="string">"mghio"</span>);</span><br><span class="line"></span><br><span class="line">    assertEquals(exceptedResult, actualResult);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上测试的可以正常运行，达到了和 <code>Mockito</code> 测试框架一样的效果，运行结果如下：</p><p><img src="https://i.loli.net/2020/05/31/YnuEAzr7OpHPhVW.png" alt="mockito_imock_test_pass.png"></p><p>上面只是列出了一些关键类的源码，自定义 <code>IMock</code> 框架的所有代码已上传至 <code>Github</code> 仓库 <a href="https://github.com/mghio/imock" target="_blank" rel="noopener">imock</a> ，感兴趣的朋友可以去看看。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文只是介绍了 <code>Mockito</code> 的一些使用方法，这只是该框架提供的最基础功能，更多高级的用法可以去官网阅读相关的文档，然后介绍了框架中 <code>when(...).thenReturn(...)</code> 定义行为方法的实现方式并按照其源码思路实现了一个相同功能的简易版 <code>mock</code> 框架。虽然进行单元测试有很多优点，但是也不可盲目的进行单元测试，在大部分情况下只要做好对项目中逻辑比较复杂、不容易理解的核心业务模块以及项目中公共依赖的模块的单元测试就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在计算机编程中，单元测试是一种软件测试方法，我们通过该方法可以测试源代码的各个单元功能是否适合使用。为代码编写单元测试有很多好处，包括可以及早的发现代码错误，促进更改，简化集成，方便代码重构以及许多其他功能。使用 &lt;code&gt;Java&lt;/code&gt; 语言编码的朋友应该用过或者听过 &lt;code&gt;Junit&lt;/code&gt; 就是用来做单元测试的，那么为什么我们还需要 &lt;code&gt;Mockito&lt;/code&gt; 测试框架呢？想象一下这样的一个常见的场景，当前要测试的类依赖于其它一些类对象时，如果使用仅仅 &lt;code&gt;Junit&lt;/code&gt; 来进行单元测试的话，我们就必须手动创建出这些依赖的对象，这其实是个比较麻烦的工作，此时就可以使用 &lt;code&gt;Mockito&lt;/code&gt; 测试框架来模拟那些依赖的类，这些被模拟的对象在测试中充当真实对象的虚拟对象或克隆对象，而且 Mockito 同时也提供了方便的测试行为验证。这样就可以让我们更多地去关注当前测试的类的逻辑，而不是它所依赖的对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="unit test" scheme="https://www.mghio.cn/categories/Java/unit-test/"/>
    
      <category term="mockito" scheme="https://www.mghio.cn/categories/Java/unit-test/mockito/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="test" scheme="https://www.mghio.cn/tags/test/"/>
    
      <category term="mockito" scheme="https://www.mghio.cn/tags/mockito/"/>
    
  </entry>
  
  <entry>
    <title>如何在一台计算机上安装多个 JDK 版本</title>
    <link href="https://www.mghio.cn/post/51e5bd99.html"/>
    <id>https://www.mghio.cn/post/51e5bd99.html</id>
    <published>2020-05-16T12:52:22.000Z</published>
    <updated>2020-05-17T09:42:06.027Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>对于使用 <code>Java</code> 语言开发的朋友可能会遇到这种情况，有时想学习和探索 <code>Java</code> 的最新版本提供的一些新特性，比如 <code>Java 11</code>，但你无法将其安装在自己的计算机上，因为你的团队正在使用比这个旧的版本（我们目前用的 <code>Java 8</code>)，你并不想影响目前的项目。或者你目前是在维护和开发多个项目，而这些不同的项目使用的 <code>JDK</code> 版本不一样，比如那些维护的老项目使用的是 <code>JDK 8</code>，而新项目你打算使用比较新的版本 <code>JDK 11</code>，以上这些情况都需要在计算机上安装多个 <code>JDK</code>，并且应该能够在多个版本之间方便快速的切换。今天要介绍的主角 <a href="https://sdkman.io" target="_blank" rel="noopener">SDKMAN</a> 可以很好的解决上面这种问题，它提供了在同一台计算机上对多个版本的开发工具包管理。需要注意的是：这个工具只适用于类 <code>Unix</code> 的系统（比如：Mac OSX、Linux、Cygwin、Solaris、FreeBSD 等）。</p><a id="more"></a><h4 id="SDKMan-简介"><a href="#SDKMan-简介" class="headerlink" title="SDKMan 简介"></a>SDKMan 简介</h4><p>直接引用 <a href="https://sdkman.io" target="_blank" rel="noopener">SDKMan</a> 官网上的介绍如下：</p><blockquote><p>SDKMAN! is a tool for managing parallel versions of multiple Software Development Kits on most Unix based systems. It provides a convenient Command Line Interface (CLI) and API for installing, switching, removing and listing Candidates.</p></blockquote><p>简单来说就是其提供了管理多个版本开发工具包的能力，同时也提供了一些命令行接口让我们方便安装、版本切换、版本移除和显示版本列表。关于 <code>SDKMan</code> 还有几个要点如下：</p><ol><li><code>SDKMan</code> 是由开源社区开发的，免费使用，。</li><li><code>SDKMan</code> 是用 <code>bash</code> 编写的，它只需要您的系统上安装了 <code>curl</code> 和 <code>zip / unzip</code> 命令即可。</li><li><code>SDKMan</code> 可以为 <code>JVM</code> 安装大约 29 个软件开发包，比如 <code>Java</code>、<code>Groovy</code>、<code>Scala</code>、<code>Kotlin</code>、<code>Gradle</code>、<code>Maven</code>、<code>Spark</code>、<code>Spring Boot</code> 等。</li><li><code>SDKMan</code> 可以自动处理帮我们配置 <code>*_HOME(e.g.:JAVA_HOME)</code> 和 <code>PATH</code> 环境变量，因此我们不需要担心切换版本后这些环境变量的设置。</li></ol><h4 id="安装-SDKMan"><a href="#安装-SDKMan" class="headerlink" title="安装 SDKMan"></a>安装 SDKMan</h4><p><code>SDKMan</code> 可以运行在任何类 <code>Unix</code> 系统上，我们只需要在命令行输入以下命令即可安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s <span class="string">"https://get.sdkman.io"</span> | bash</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/16/ZKIvQfl4syq5S7J.png" alt="install-sdkman.png"></p><p>然后执行以下命令，加载文件 <code>sdkman-init.sh</code> 到当前环境，执行完该命令之后我们可以通过 <code>sdk version</code> 来验证是否安装成功，同时还可以通过 <code>sdk help</code> 命令显示有关 <code>sdk</code> 命令用法和帮助（<code>PS: 对于使用 Windows 环境的朋友可以安装 Cygwin 或 Git Bash 运行以上命令</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">"<span class="variable">$HOME</span>/.sdkman/bin/sdkman-init.sh"</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/16/xczL8U7qCfbwOrP.png" alt="verify-sdkman-install.png"></p><h4 id="使用-SDKMan-安装-JDK"><a href="#使用-SDKMan-安装-JDK" class="headerlink" title="使用 SDKMan 安装 JDK"></a>使用 SDKMan 安装 JDK</h4><p>前面已经介绍过，<code>SDKMan</code> 支持多达大约 29 个软件开发包管理，我们也可以使用 <code>sdk list</code> 命令来查看支持的完整列表，本文主要介绍 <code>Java</code> 相关的内容，可以通过命令 <code>sdk list java</code> 来查看支持安装的 <code>Java</code> 版本。</p><p><img src="https://i.loli.net/2020/05/16/BlFScVCmUDe8xNZ.png" alt="sdk-list-java.png"></p><p>使用以下命令安装 <code>Java 11</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk install java 11.0.7.hs-adpt</span><br></pre></td></tr></table></figure><p>该命令会花费一些时间，因为它会在我们的计算机上下载对应版本的 <code>JDK</code>，执行完成之后 <code>SDKman</code> 会自动给我们配置好 <code>JAVA_HOME</code> 和 <code>PATH</code> 等环境变量，可以通过 <code>Java -version</code> 命令验证。</p><p><img src="http://pic.cnw.me/imgs/2020/05/0ebcf0d26ce111fa.png" alt="sdk-install-jdk-11"></p><p>现在，如果检查 <code>Java</code> 版本和 <code>JAVA_HOME</code> 环境变量，可以看到当前 <code>Java</code> 的版本已更新为 <code>11.0.7</code>。</p><p><img src="http://pic.cnw.me/imgs/2020/05/a3a8fce8f227dbbb.png" alt="java-version-verify"></p><p>可以使用以下命令来设置默认使用的 <code>JDK</code> 版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk default java 11.0.7.hs-adpt</span><br></pre></td></tr></table></figure><h4 id="将-SDKMan-指向已安装-Java-版本"><a href="#将-SDKMan-指向已安装-Java-版本" class="headerlink" title="将 SDKMan 指向已安装 Java 版本"></a>将 SDKMan 指向已安装 Java 版本</h4><p>如果在你安装 <code>SDKMan</code> 之前本地电脑已经安装了 <code>JDK</code> 版本，默认是无法识别到的，那么你需要进行以下配置才能让 <code>SDKMan</code> 识别已安装的版本，首先，第一步你要先找到你的 <code>Java</code> 安装目录，我本地 <code>Mac</code> 的安装目录是 <code>/Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk</code>，然后使用命令 <code>ln -s</code> 来为 <code>Java</code> 安装目录建立符号链接。</p><p><img src="http://pic.cnw.me/imgs/2020/05/ff36347cb7a4dfe7.png" alt="point-sdkman-existing-installd-version.png"></p><h4 id="多个-JDK-版本切换示例"><a href="#多个-JDK-版本切换示例" class="headerlink" title="多个 JDK 版本切换示例"></a>多个 JDK 版本切换示例</h4><p><code>SDKMan</code> 提供了命令 <code>sdk use java &lt;version_want_to_use&gt;</code> 在多个版本之间进行切换，使用 <code>sdk use java jdk1.8.0_181.jdk</code> 命令来使用之前本地安装的 <code>Java 8</code>。</p><p><img src="http://pic.cnw.me/imgs/2020/05/412ed30ac2283fa0.png" alt="sdk-use-jdk8.png"></p><p>使用命令 <code>sdk use java 11.0.7.hs-adpt</code> 来设置版本为 <code>Java 11</code>。</p><p><img src="http://pic.cnw.me/imgs/2020/05/b28c67cf63ad28cb.png" alt="sdk-use-java11"></p><blockquote><p>需要注意的是：使用命令 <code>sdk use java &lt;version&gt;</code> 只在当前会话有效，如果你关闭终端并再次打开它，则将使用以前安装的版本，不会改变你本地使用的版本，此时可以使用 <code>sdk default java &lt;version&gt;</code> 来设置永久生效。</p></blockquote><h4 id="如何卸载指定的-JDK-版本"><a href="#如何卸载指定的-JDK-版本" class="headerlink" title="如何卸载指定的 JDK 版本"></a>如何卸载指定的 JDK 版本</h4><p>如果你想要卸载任何已安装的 <code>JDK</code> 版本，比如： <code>11.0.7.hs-adpt</code>，可以使用以下命令卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdk uninstall java 11.0.7.hs-adpt</span><br></pre></td></tr></table></figure><p>此时，如果你想再次安装之前通过 <code>SDKMan</code> 卸载的版本，此时不会再次重新下载，会提示 <code>Found a previously downloaded java 11.0.7.hs-adpt archive. Not downloading it again...</code>，因为之前删除操作并没有真正的从你计算机上删除源压缩包文件。</p><h4 id="IntelliJ-IDEA-使用-SDMan-安装-JDK"><a href="#IntelliJ-IDEA-使用-SDMan-安装-JDK" class="headerlink" title="IntelliJ IDEA 使用 SDMan 安装 JDK"></a>IntelliJ IDEA 使用 SDMan 安装 JDK</h4><p><code>SDKMan</code> 所有安装的 <code>JDK</code> 都放在目录 <code>.sdkman/candidates/java/</code>，你可以在你当前用户的 <code>home</code> 文件夹下面看到该文件夹（注意是隐藏文件夹）。</p><p><img src="http://pic.cnw.me/imgs/2020/05/c37973b5619d90a3.png" alt="show-sdkman-directory.png"></p><p>在 <code>IntelliJ IDEA</code> 中打开任何一个 <code>Java</code> 项目后，您可以按 <code>Command + :</code> 快捷键打开项目结构窗口，在 <code>Project SDK</code> 模块选择新建一个 <code>JDK</code> 后输入你需要的 <code>JDK</code> 版本在 <code>SDKMan</code> 中的路径即可。</p><p><img src="http://pic.cnw.me/imgs/2020/05/6d3fb2245c19ecf2.png" alt="idea-set-jdk-version.png"></p><p>因为 <code>.sdkman</code> 是隐藏文件夹不太方便查找，可以使用以下命令创建一个非隐藏文件夹指向它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s ~/.sdkman ~/sdkman</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;对于使用 &lt;code&gt;Java&lt;/code&gt; 语言开发的朋友可能会遇到这种情况，有时想学习和探索 &lt;code&gt;Java&lt;/code&gt; 的最新版本提供的一些新特性，比如 &lt;code&gt;Java 11&lt;/code&gt;，但你无法将其安装在自己的计算机上，因为你的团队正在使用比这个旧的版本（我们目前用的 &lt;code&gt;Java 8&lt;/code&gt;)，你并不想影响目前的项目。或者你目前是在维护和开发多个项目，而这些不同的项目使用的 &lt;code&gt;JDK&lt;/code&gt; 版本不一样，比如那些维护的老项目使用的是 &lt;code&gt;JDK 8&lt;/code&gt;，而新项目你打算使用比较新的版本 &lt;code&gt;JDK 11&lt;/code&gt;，以上这些情况都需要在计算机上安装多个 &lt;code&gt;JDK&lt;/code&gt;，并且应该能够在多个版本之间方便快速的切换。今天要介绍的主角 &lt;a href=&quot;https://sdkman.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDKMAN&lt;/a&gt; 可以很好的解决上面这种问题，它提供了在同一台计算机上对多个版本的开发工具包管理。需要注意的是：这个工具只适用于类 &lt;code&gt;Unix&lt;/code&gt; 的系统（比如：Mac OSX、Linux、Cygwin、Solaris、FreeBSD 等）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JDK" scheme="https://www.mghio.cn/categories/JDK/"/>
    
      <category term="Java" scheme="https://www.mghio.cn/categories/JDK/Java/"/>
    
      <category term="版本管理工具" scheme="https://www.mghio.cn/categories/JDK/Java/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="JDK" scheme="https://www.mghio.cn/tags/JDK/"/>
    
      <category term="版本管理工具" scheme="https://www.mghio.cn/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>看了你就懂的同步与异步、阻塞与非阻塞</title>
    <link href="https://www.mghio.cn/post/34755d6c.html"/>
    <id>https://www.mghio.cn/post/34755d6c.html</id>
    <published>2020-04-26T02:04:04.000Z</published>
    <updated>2020-04-26T06:08:55.551Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在网上看到过很多讲有关<code>同步与异步</code>、<code>阻塞与非阻塞</code>的文章，但是很多都是抛出一堆相关定义，看了之后还是云里雾里的，对这几个概念还是不能很好的去区分它们。本文通过通俗易懂的语言和相关例子让你深入理解其本质。</p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>首先我们要明确的是，<code>同步和异步都是针对两个或者两个以上的事物来说的</code>。比如当我们在网上购物看中一件物品，然后去浏览该商品详情的时候，首先页面会先发送一个请求，后台服务器查询对应商品的相关数据，然后前端详情页面才根据返回数据展示该商品的详细信息。而此时你的网速比较差，一个详情页面等了将近一分钟才全部展示完成，这时候你问这个请求是同步还是异步？答案显然是同步请求，它给我们最直观的表现形式就是页面一直显示在加载中，商品的详情页面渲染必须要等待后台服务器返回商品详情数据后才能进行。也就是说<code>下一个操作必须要等待上一个操作完成才能进行</code>，它依赖于上一个操作的返回结果。</p><a id="more"></a><p>你可能会问，在同步的情况下，当一个事物正在进行操作的时候，其它的事物此时在干嘛呢？这个实际上并没有明确的规定，其实同步更多的是关注事物一个一个的串行执行的过程，保证不会交叉执行，至于某个时刻处于什么状态并不关心。这在计算机中大部分时候其它事物都是处于一个<code>等待</code>的状态，而我们人则要灵活得多，在我们日常生活中常用的同步手段就是<code>排队</code>，比如我们上下班坐地铁进行安检的时候，需要依次排队安检进站乘车，但是你在排队的过程是在看手机、聊天还是什么也不做都可以，安检人员并不会在意你在做什么，这种就是由于安检<code>资源有限</code>导致的同步。</p><p><img src="https://i.loli.net/2020/04/26/IBynqeRC93Qg5MA.png" alt="sync-async.jpg"></p><p>对于同步这里有两个点需要注意，一是<code>同步的范围</code>，有时候并不需要全局的大范围的去同步，只需要在特定的操作同步即可，这样可以提升执行效率，比如 <code>Java</code> 语言中的同步方法和同步代码块。另一个是<code>同步的粒度</code>，并不是在一些大的操作粒度上才需要同步操作，小的粒度操作也需要同步操作，只是有的小粒度操作天然就已经是同步操作，并不需要我们人为的去添加同步操作控制。比如 <code>Java</code> 语言中的同步都是针对有两个或者两个以上线程的程序来说的，因为单线程的程序里它天然就是同步的。<br>而<code>异步</code>则完全相反，在异步情况下多个事务可以同时进行，互不影响，你进行你的，我进行我的，谁都不用关心谁。总的来说就是:</p><ul><li><strong>同步</strong> 两个事物相互依赖，并且一个事物必须以依赖于另一事物的执行结果。比如在事物 <code>A-&gt;B</code> 事件模型中，你需要先完成事物 A 才能执行事物 B。也就是说，同步调用在被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</li><li><strong>异步</strong> 两个事物完全独立，一个事物的执行不需要等待另外一个事物的执行。也就是说，异步调用可以返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式带着调用结果再做相关事情。</li></ul><p>可以看出同步与异步是从<code>行为角度</code>描述事物的，你品，你细品。（PS：<code>这里的多个事务可以指代不同的操作、不同的方法或者不同的代码语句等等</code>）</p><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>所谓<code>阻塞</code>，简单来说就是发出一个请求不能立刻返回响应，要等所有的逻辑全处理完才能返回响应。<code>非阻塞</code>反之，发出一个请求立刻返回应答，不用等处理完所有逻辑。阻塞与非阻塞指的是<code>单个线程内</code>遇到同步等待时，是否在原地不做任何操作。<br><code>堵车</code>就是阻塞与非阻塞最好的例子，在一线城市生活过的朋友应该都有体会，在交通正常的时候汽车可以正常通行，就是<code>非阻塞</code>，上下班高峰的时候经常发生堵车，交通正常的时候半个小时车程，高峰期可能需要二、三个小时才能到。。。而且一旦发生交通堵塞，所有马路上的车子都一动不动，只能在车子里等待，就是<code>阻塞</code>，当然大多数人不会选择干等，他们会玩手机或者和朋友聊天等等，同样的在计算机里，阻塞就意味着停止执行停下来等待，非阻塞表明操作可以继续向下执行，但是在发生阻塞的时候计算机可就没有像人这么灵活了，通常计算机的处理方式就是挂起当前线程，然后干等着，阻塞结束后才继续执行该线程。可以看出阻塞和非阻塞描述的<code>当前事物的状态</code>（等待调用结果时的状态）。</p><p><img src="https://i.loli.net/2020/04/26/APB7ZoWlzqbnXCR.jpg" alt="recv-wait.jpeg"></p><p>结合前面介绍的<code>同步与异步</code>，两两组合就会有四种情况，分别是<code>同步阻塞</code>、<code>同步非阻塞</code>、<code>异步阻塞</code>和<code>异步非阻塞</code>。下面通过车道的例子来形象的解释这几种状态：</p><ul><li><strong>同步阻塞</strong> 只有一个车道，不能超车，所有车子依次行使，一次只能通过一辆车，尴尬的是这个车道还堵车了。</li><li><strong>同步非阻塞</strong> 只有一个车道，不能超车，所有车子依次行使，一次只能通过一辆车，不过比较幸运这个车道没有堵车，可以正常通行。</li><li><strong>异步阻塞</strong> 有两个或两个以上车道，每条马路都可以通行，不同车道上的车子可以并行行使，尴尬的是所有的车道都堵车了。</li><li><strong>异步非阻塞</strong> 有两个或两个以上车道，每条马路都可以通行，不同车道上的车子可以并行行使，不过比较幸运的是没有一个车道堵车，都可以正常通行。</li></ul><p>对应到我们计算机里也是一样的，同步阻塞相当于只有一个线程，而且该线程处于阻塞（Blocked）状态，同步非阻塞相当于只有一个线程，而且该线程处于运行（Running）状态。异步阻塞相当于有多个线程，而且所有线程都处于阻塞（Blocked）状态，异步非阻塞相当于有多个线程，而且所有线程都在正常运行。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>很多程序思想都来源于生活，需要我们自己去寻找身边的场景多类比思考、总结归纳，这样才会理解得更深刻。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在网上看到过很多讲有关&lt;code&gt;同步与异步&lt;/code&gt;、&lt;code&gt;阻塞与非阻塞&lt;/code&gt;的文章，但是很多都是抛出一堆相关定义，看了之后还是云里雾里的，对这几个概念还是不能很好的去区分它们。本文通过通俗易懂的语言和相关例子让你深入理解其本质。&lt;/p&gt;
&lt;h4 id=&quot;同步与异步&quot;&gt;&lt;a href=&quot;#同步与异步&quot; class=&quot;headerlink&quot; title=&quot;同步与异步&quot;&gt;&lt;/a&gt;同步与异步&lt;/h4&gt;&lt;p&gt;首先我们要明确的是，&lt;code&gt;同步和异步都是针对两个或者两个以上的事物来说的&lt;/code&gt;。比如当我们在网上购物看中一件物品，然后去浏览该商品详情的时候，首先页面会先发送一个请求，后台服务器查询对应商品的相关数据，然后前端详情页面才根据返回数据展示该商品的详细信息。而此时你的网速比较差，一个详情页面等了将近一分钟才全部展示完成，这时候你问这个请求是同步还是异步？答案显然是同步请求，它给我们最直观的表现形式就是页面一直显示在加载中，商品的详情页面渲染必须要等待后台服务器返回商品详情数据后才能进行。也就是说&lt;code&gt;下一个操作必须要等待上一个操作完成才能进行&lt;/code&gt;，它依赖于上一个操作的返回结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="IO模型" scheme="https://www.mghio.cn/categories/Java/IO%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="IO模型" scheme="https://www.mghio.cn/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何在亿级数据中判断一个元素是否存在？</title>
    <link href="https://www.mghio.cn/post/fe76043.html"/>
    <id>https://www.mghio.cn/post/fe76043.html</id>
    <published>2020-04-19T06:50:53.000Z</published>
    <updated>2020-04-19T13:47:57.996Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在日常工作中，经常要判断一个元素是否在一个集合中。假设你要向浏览器添加一项功能，该功能可以通知用户输入的网址是否是恶意网址，此时你手上有大约 1000 万个恶意 URL 的数据集，你该如何实现该功能。按我之前的思维，要判断一个元素在不在当前的数据集中，首先想到的就是使用 <code>hash table</code>，通过哈希函数运行所有的恶意网址以获取其哈希值，然后创建出一个哈希表（数组）。这个方案有个明显的缺点，就是需要存储原始元素本身，内存占用大，而我们其实主要是关注 <code>当前输入的网址在不在我们的恶意 URL 数据集中</code>，也就是之前的恶意 URL 数据集的具体值是什么并不重要，通过吴军老师的《数学之美》了解到，对于这种场景大数据领域有个用于在海量数据情况下判断某个元素是否已经存在的算法很适合，关键的一点是该算法并不存储元素本身，这个算法就是 — 布隆过滤器(Bloom filter)。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>布隆过滤器是由巴顿.布隆于一九七零年提出的，在 <a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">维基百科</a> 中的描述如下：</p><blockquote><p>A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set.</p></blockquote><a id="more"></a><p>布隆过滤器是一个数据结构，它可以用来判断某个元素是否在集合内，具有运行快速，内存占用小的特点，它由一个很长的二进制向量和一系列随机映射函数组成。而高效插入和查询的代价就是，它是一个基于概率的数据结构，只能告诉我们一个元素绝对不在集合内，布隆过滤器的好处在于快速，省空间，但是有一定的误判率。布隆过滤器的基础数据结构是一个比特向量，假设有一个长度为 16 的比特向量，下面我们通过一个简单的示例来看看其工作原理，：</p><p><img src="https://i.loli.net/2020/04/19/jpnTHrx42hG3MfI.png" alt="bloom-filter-bit-array.png"></p><p>上图比特向量中的每一个空格表示一个比特, 空格下面的数字表示当前位置的索引。只需要简单的对输入进行多次哈希操作，并把对应于其结果的比特置为 1，就完成了向 <code>Bloom filter</code> 添加一个元素的操作。下图表示向布隆过滤器中添加元素 <code>https://www.mghio.cn</code> 和 <code>https://www.abc.com</code> 的过程，它使用了 <code>func1</code> 和 <code>func2</code> 两个简单的哈希函数。</p><p><img src="https://i.loli.net/2020/04/19/6eJM1huLtsl8KUz.png" alt="bloom-filter-add-item.png"></p><p>当我们往集合里添加一个元素的时候, 可以检查该元素在应用对应哈希函数后的哈希值对比特向量的长度取余后的位置是否为 1，图中用 1 表示最新添加的元素对应位置。然后当我们要判断添加元素是否存在集合中的话，只需要简单的通过对该元素应用同样的哈希函数，然后看比特向量里对应的位置是否为 1 的方式来判断一个元素是否在集合里。如果不是，则该元素一定不再集合中，但是需要注意的是，如果是，你只知道元素可能在里面, 因为这些对应位置有可能恰巧是由其它元素或者其它元素的组合所引起的。以上就是布隆过滤器的实现原理。</p><h4 id="如何自己实现"><a href="#如何自己实现" class="headerlink" title="如何自己实现"></a>如何自己实现</h4><p>布隆过滤器的思想比较简单，首先在构造方法中初始化了一个指定长度的 <code>int</code> 数组，在添加元素的时候通过哈希函数 <code>func1</code> 和 <code>func2</code> 计算出对应的哈希值，对数组长度取余后将对应位置置为 1，判断元素是否存在于集合中时，同样也是对元素用同样的哈希函数进行两次计算，取到对应位置的哈希值，只要存在位置的值为 0，则认为元素不存在。下面使用 <code>Java</code> 语言实现了上面示例中简单版的布隆过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数组长度</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BloomFilter</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">this</span>.array = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstIndex = func1(item);</span><br><span class="line">    <span class="keyword">int</span> secondIndex = func2(item);</span><br><span class="line">    array[firstIndex % size] = <span class="number">1</span>;</span><br><span class="line">    array[secondIndex % size] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断数据 item 是否存在集合中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstIndex = func1(item);</span><br><span class="line">    <span class="keyword">int</span> secondIndex = func2(item);</span><br><span class="line">    <span class="keyword">int</span> firstValue = array[firstIndex % size];</span><br><span class="line">    <span class="keyword">int</span> secondValue = array[secondIndex % size];</span><br><span class="line">    <span class="keyword">return</span> firstValue != <span class="number">0</span> &amp;&amp; secondValue != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * hash 算法 func1</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">7</span>;</span><br><span class="line">    hash += <span class="number">61</span> * hash + key.hashCode();</span><br><span class="line">    hash ^= hash &gt;&gt; <span class="number">15</span>;</span><br><span class="line">    hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">    hash += hash &lt;&lt; <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * hash 算法 func2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = key.length(); i &lt; len; i++) &#123;</span><br><span class="line">      hash += key.charAt(i);</span><br><span class="line">      hash += (hash &lt;&lt; <span class="number">7</span>);</span><br><span class="line">      hash ^= (hash &gt;&gt; <span class="number">17</span>);</span><br><span class="line">      hash += (hash &lt;&lt; <span class="number">5</span>);</span><br><span class="line">      hash ^= (hash &gt;&gt; <span class="number">13</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(hash);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己实现虽然简单但是有一个问题就是检测的误判率比较高，通过其原理可以知道，可我们可以提高数组长度以及 <code>hash</code> 计算次数来降低误报率，但是相应的 <code>CPU</code>、内存的消耗也会相应的提高，这需要我们根据自己的业务需要去权衡选择。</p><h4 id="扎心一问"><a href="#扎心一问" class="headerlink" title="扎心一问"></a>扎心一问</h4><h5 id="哈希函数该如何设计？"><a href="#哈希函数该如何设计？" class="headerlink" title="哈希函数该如何设计？"></a>哈希函数该如何设计？</h5><p>布隆过滤器里的哈希函数最理想的情况就是需要尽量的<code>彼此独立且均匀分布</code>，同时，它们也需要尽可能的快 (虽然 <code>sha1</code> 之类的加密哈希算法被广泛应用，但是在这一点上考虑并不是一个很好的选择)。</p><h5 id="布隆过滤器应该设计为多大？"><a href="#布隆过滤器应该设计为多大？" class="headerlink" title="布隆过滤器应该设计为多大？"></a>布隆过滤器应该设计为多大？</h5><p>个人认为布隆过滤器的一个比较好特性就是我们可以修改过滤器的错误率。一个大的过滤器会拥有比一个小的过滤器更低的错误率。假设在布隆过滤器里面有 k 个哈希函数，m 个比特位（也就是位数组长度），以及 n 个已插入元素，错误率会近似于 (1-e<sup>kn/m</sup>)k，所以你只需要先确定可能插入的数据集的容量大小 n，然后再调整 k 和 m 来为你的应用配置过滤器。</p><h5 id="应该使用多少个哈希函数"><a href="#应该使用多少个哈希函数" class="headerlink" title="应该使用多少个哈希函数?"></a>应该使用多少个哈希函数?</h5><p>显然，布隆过滤器使用的哈希函数越多其运行速度就会越慢，但是如果哈希函数过少，又会遇到误判率高的问题。所以这个问题上需要认真考虑，在创建一个布隆过滤器的时候需要确定哈希函数的个数，也就是说你需要提前预估集合中元素的变动范围。然而你这样做了之后，你依然需要确定比特位个数和哈希函数的个数的值。看起来这似乎这是一个十分困难的优化问题，但幸运的是，对于给定的 m（比特位个数）和 n（集合元素个数），最优的 k（哈希函数个数）值为: (m/n)ln(2)（PS：<code>需要了解具体的推导过程的朋友可以参考维基百科</code>）。也就是我们可以通过以下步骤来确定布隆过滤器的哈希函数个数：</p><ol><li>确定 n（集合元素个数）的变动范围。</li><li>选定 m（比特位个数）的值。</li><li>计算 k（哈希函数个数）的最优值</li></ol><p>对于给定的 n、m 和 k 计算错误率，如果这个错误率不能接受的话，可以继续回到第二步。</p><h5 id="布隆过滤器的时间复杂度和空间复杂度"><a href="#布隆过滤器的时间复杂度和空间复杂度" class="headerlink" title="布隆过滤器的时间复杂度和空间复杂度?"></a>布隆过滤器的时间复杂度和空间复杂度?</h5><p>对于一个 m（比特位个数）和 k（哈希函数个数）值确定的布隆过滤器，添加和判断操作的时间复杂度都是 <code>O(k)</code>，这意味着每次你想要插入一个元素或者查询一个元素是否在集合中，只需要使用 k 个哈希函数对该元素求值，然后将对应的比特位标记或者检查对应的比特位即可。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>布隆过滤器的实际应用很广泛，特别是那些要在大量数据中判断一个元素是否存在的场景。可以看到，布隆过滤器的算法原理比较简单，但要实际做一个生产级别的布隆过滤器还是很复杂的，谷歌的开源库 <code>Guava</code> 的 <code>BloomFilter</code> 提供了 Java 版的实现，用法很简单。最后留给大家一个问题：布隆过滤器支持元素删除吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在日常工作中，经常要判断一个元素是否在一个集合中。假设你要向浏览器添加一项功能，该功能可以通知用户输入的网址是否是恶意网址，此时你手上有大约 1000 万个恶意 URL 的数据集，你该如何实现该功能。按我之前的思维，要判断一个元素在不在当前的数据集中，首先想到的就是使用 &lt;code&gt;hash table&lt;/code&gt;，通过哈希函数运行所有的恶意网址以获取其哈希值，然后创建出一个哈希表（数组）。这个方案有个明显的缺点，就是需要存储原始元素本身，内存占用大，而我们其实主要是关注 &lt;code&gt;当前输入的网址在不在我们的恶意 URL 数据集中&lt;/code&gt;，也就是之前的恶意 URL 数据集的具体值是什么并不重要，通过吴军老师的《数学之美》了解到，对于这种场景大数据领域有个用于在海量数据情况下判断某个元素是否已经存在的算法很适合，关键的一点是该算法并不存储元素本身，这个算法就是 — 布隆过滤器(Bloom filter)。&lt;/p&gt;
&lt;h4 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h4&gt;&lt;p&gt;布隆过滤器是由巴顿.布隆于一九七零年提出的，在 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bloom_filter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt; 中的描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Bloom filter" scheme="https://www.mghio.cn/categories/Java/Bloom-filter/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Bloom filter" scheme="https://www.mghio.cn/tags/Bloom-filter/"/>
    
  </entry>
  
  <entry>
    <title>字符串操作 — Google Guava</title>
    <link href="https://www.mghio.cn/post/3ae0ff4e.html"/>
    <id>https://www.mghio.cn/post/3ae0ff4e.html</id>
    <published>2020-04-12T07:15:39.000Z</published>
    <updated>2020-04-15T00:50:58.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><code>Java</code> 里字符串表示字符的不可变序列，创建后就不能更改。在我们日常的工作中，字符串的使用非常频繁，熟练的对其操作可以极大的提升我们的工作效率，今天要介绍的主角是 <code>Google</code> 开源的一个核心 <code>Java</code> 库 <a href="https://github.com/google/guava" target="_blank" rel="noopener">Guava</a>，它提供了集合类型、不可变的集合、并发、I / O、缓存、字符串等许多实用功能。在本文中，我们将学习使用 <code>Guava</code> 中的 <code>Strings</code> 和 <code>Splitter</code> 字符串操作工具类。</p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p><code>Google Guava</code> 会同步到 <a href="https://mvnrepository.com/" target="_blank" rel="noopener">Maven Central</a> 中，所以，如果你是 <code>Maven</code> 项目的话只需要在 <code>pom.xml</code> 文件中引入如下依赖即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;28.2-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>对于 <code>Gradle</code> 项目在 <code>build.gradle</code> 中引入如下依赖即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile group: <span class="string">'com.google.guava'</span>, name: <span class="string">'guava'</span>, version: <span class="string">'28.2-jre'</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>PS：<code>28.2-jre 是编写本文时的最新版本，你可以从</code> <a href="https://mvnrepository.com/" target="_blank" rel="noopener">Maven Central</a> <code>中查看当前的最新版本。</code></p><h4 id="为什么需要引入类库"><a href="#为什么需要引入类库" class="headerlink" title="为什么需要引入类库"></a>为什么需要引入类库</h4><p><code>Google Guava</code> 提供了很多实用的静态方法，这些可以解决开发人员在开发中所要完成的一些重复任务。当然，这个工作我们也可以自己做，但是引入类库它会降低错误发生的可能性，毕竟这些类库都是已经经过多年的生产验证。比如类库中 <code>Strings</code> 提供的一个方法 <code>commonPrefix</code>，它接受两个字符串并返回两个字符串之间的公共前缀（eg: <code>abcd</code> 和 <code>abef</code> 返回 <code>ab</code>）。你可以在脑子里想象一下在应用程序代码中面临这样的要求时，自己要如何编写代码来完成该操作，要自己实现这个功能，还是需要花费一些时间的，同时还需要考虑到各种边界异常情况。这就是类库提供给我们的最大价值之一，所以当我们需要的某种功能可以作为一种工具方法使用时，首先应该去寻找一些已存在的类库并去熟练使用的它们，而不是自己去实现。总结起来使用类库有如下几个原因：</p><ol><li><code>Google Guava</code> 类库有人已经对其进行了彻底的测试，<code>bug</code> 出现的概率会比我们自己实现的小很多。</li><li>作为 <code>Google Guava</code> 的一部分，已经存在各种测试用例，用于测试实用程序的实现。如果我们自己编写代码实现的话，可能还要去编写和维护它们的测试。</li></ol><h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><p><code>Google Guava</code> 有许多实用的工具类和方法，不可能在一篇文章中都有介绍完，在本文中，只会介绍和字符串操作相关的两个工具类。首先第一个是 <code>Strings</code> 类，该类提供了操作 <code>String</code> 和 <code>CharSequence</code> 的实用方法。</p><h5 id="nullToEmpty、emptyToNull-和-isNullOrEmpty"><a href="#nullToEmpty、emptyToNull-和-isNullOrEmpty" class="headerlink" title="nullToEmpty、emptyToNull 和 isNullOrEmpty"></a>nullToEmpty、emptyToNull 和 isNullOrEmpty</h5><p><code>nullToEmpty</code> 方法功能为：如果传入的字符串为 <code>null</code>，则返回一个空字符串 <code>&quot;&quot;</code>，否则按原样返回传入的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsOfNullToEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.nullToEmpty(<span class="string">"mghio"</span>));         <span class="comment">// mghio</span></span><br><span class="line">    System.out.println(Strings.nullToEmpty(<span class="string">""</span>));              <span class="comment">// ""</span></span><br><span class="line">    System.out.println(Strings.nullToEmpty(<span class="keyword">null</span>));            <span class="comment">// ""</span></span><br><span class="line">    System.out.println(Strings.nullToEmpty(<span class="keyword">null</span>).isEmpty());  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>emptyToNull</code> 方法功能为：它与 <code>nullToEmpty</code> 相反，如果传入了空字符串，则返回 <code>null</code>，否则返回原始字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsOfEmptyToNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.emptyToNull(<span class="string">"mghio"</span>));  <span class="comment">// mghio</span></span><br><span class="line">    System.out.println(Strings.emptyToNull(<span class="keyword">null</span>));     <span class="comment">// null</span></span><br><span class="line">    System.out.println(Strings.emptyToNull(<span class="string">""</span>));       <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isNullOrEmpty</code> 方法功能为：如果传入的字符串为 <code>null</code> 或为空，则返回 <code>true</code>，否则返回 <code>false</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsOfIsNullOrEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.isNullOrEmpty(<span class="string">"mghio"</span>));  <span class="comment">// false</span></span><br><span class="line">    System.out.println(Strings.isNullOrEmpty(<span class="string">""</span>));       <span class="comment">// true</span></span><br><span class="line">    System.out.println(Strings.isNullOrEmpty(<span class="keyword">null</span>));     <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="padStart-和-padEnd"><a href="#padStart-和-padEnd" class="headerlink" title="padStart 和 padEnd"></a>padStart 和 padEnd</h5><p>这两个方法有三个参数，分别为：输入字符串、最小长度和要填充的字符，它将字符根据需要多次插入到输入字符串的开头，以使输入字符串的长度等于传入的最小长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsOfPadStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.padStart(<span class="string">"9527"</span>, <span class="number">6</span>, <span class="string">'0'</span>));    <span class="comment">// 009527</span></span><br><span class="line">    System.out.println(Strings.padStart(<span class="string">"123456"</span>, <span class="number">6</span>, <span class="string">'0'</span>));  <span class="comment">// 123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一行代码中，将两次填充 <code>0</code> 以使最终的字符串长度等于我们传入的最小长度（6）。在第二行代码中，输入字符串长度本身具有所需的最小长度，因此未进行填充<code>padEnd</code> 方法和上面这个方法类似，只不过它是在字符的末尾而不是在开始处进行填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsOfPadEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.padEnd(<span class="string">"9527"</span>, <span class="number">6</span>, <span class="string">'0'</span>));    <span class="comment">// 952700</span></span><br><span class="line">    System.out.println(Strings.padEnd(<span class="string">"123456"</span>, <span class="number">6</span>, <span class="string">'0'</span>));  <span class="comment">// 123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h5><p>该方法需要传入一个字符串和一个重复次数 <code>count</code>，它返回一个由原始字符串组成的字符串，该字符串重复了 <code>count</code> 次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringsRepeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.repeat(<span class="string">"mghio"</span>, <span class="number">3</span>));  <span class="comment">// mghiomghiomghio</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="commonPrefix-和-commonSuffix"><a href="#commonPrefix-和-commonSuffix" class="headerlink" title="commonPrefix 和 commonSuffix"></a>commonPrefix 和 commonSuffix</h5><p><code>commonPrefix</code> 方法返回传入的两个字符串之间最大的公共前缀，而 <code>commonSuffix</code> 方法返回传入两个字符串之间最大的公共后缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStrings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(Strings.commonPrefix(<span class="string">"mghio9527"</span>, <span class="string">"mghio666"</span>));  <span class="comment">// mghio</span></span><br><span class="line">    System.out.println(Strings.commonSuffix(<span class="string">"iammghio"</span>, <span class="string">"nicemghio"</span>));  <span class="comment">// mghio</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h4><p><code>Splitter</code> 类提供的功能正如其名（<code>PS:一个好的命名很重要</code>），它用于根据提供的分割符将字符串拆分为多个子字符串。我们可以通过传入一个分割符来获一个 <code>Splitter</code> 的实例，有了分割器之后，我们可以根据分割器的配置方式对字符串进行分割。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfSplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterable&lt;String&gt; result = Splitter.on(<span class="string">","</span>).split(<span class="string">"m,g,h,i,o"</span>);</span><br><span class="line">    System.out.println(result);  <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中使用逗号进行分割，因此，它将传入的字符串 <code>m,g,h,i,o</code> 拆分为一个 <code>Iterable &lt;String&gt;</code>，然后当我们对其进行迭代遍历时会输出 <code>[m, g, h, i, o]</code>。</p><h4 id="获取-Splitter-实例"><a href="#获取-Splitter-实例" class="headerlink" title="获取 Splitter 实例"></a>获取 Splitter 实例</h4><h5 id="on-和-onPattern"><a href="#on-和-onPattern" class="headerlink" title="on 和 onPattern"></a>on 和 onPattern</h5><p>现在，我们来看看获得一个分割器 <code>Splitter</code> 的各种方法。<code>on</code> 方法有各种不同的重载版本，它们以字符、字符串或正则表达式作为分隔符，我们还可以将 <code>Pattern</code> 实例作为字符串传递给 <code>onPattern</code> 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter wordSplitter = Splitter.on(<span class="string">":;"</span>);</span><br><span class="line">    <span class="comment">// 下面这行输出结果 [the, text, is, separated, by, colon, semicolon]</span></span><br><span class="line">    System.out.println(wordSplitter.split(<span class="string">"the:;text:;is:;separated:;by:;colon:;semicolon"</span>));</span><br><span class="line">    Splitter patternBasedSplitter = Splitter.on(Pattern.compile(<span class="string">"\\s+"</span>));</span><br><span class="line">    System.out.println(patternBasedSplitter.split(<span class="string">"abc   dmg hio"</span>));         <span class="comment">// [abc, dmg, hio]</span></span><br><span class="line">    System.out.println(Splitter.onPattern(<span class="string">"\\s+"</span>).split(<span class="string">"www   mghio cn"</span>));  <span class="comment">// [www, mghio, cn]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="fixedLength"><a href="#fixedLength" class="headerlink" title="fixedLength"></a>fixedLength</h5><p><code>fixedLength</code> 也是最有用的方法之一，它可以将字符串分成给定长度的相等部分，需要注意的是，最后一个部分可能会小于给定的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfFixedLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter fixedLengthSplitter = Splitter.fixedLength(<span class="number">3</span>);</span><br><span class="line">    System.out.println(fixedLengthSplitter.split(<span class="string">"iammghiojava"</span>));          <span class="comment">// [iam, mgh, ioj, ava]</span></span><br><span class="line">    System.out.println(fixedLengthSplitter.split(<span class="string">"https://www.mghio.cn"</span>));  <span class="comment">// [htt, ps:, //w, ww., mgh, io., cn]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Splitter-修饰符方法"><a href="#Splitter-修饰符方法" class="headerlink" title="Splitter 修饰符方法"></a>Splitter 修饰符方法</h4><p><code>Splitter</code> 还提供了可以在更改或修改 <code>Splitter</code> 行为的常用方法。</p><h5 id="trimResults"><a href="#trimResults" class="headerlink" title="trimResults"></a>trimResults</h5><p>这个方法可以从生成的分割器的结果字符串中删除前面和末尾的空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfTrimResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter commaSplitter = Splitter.on(<span class="string">","</span>);</span><br><span class="line">    System.out.println(commaSplitter.split(<span class="string">"m, g, h, i, o"</span>));         <span class="comment">// [m,  g,  h,  i,  o]</span></span><br><span class="line">    Splitter commaSplitterWithTrim = commaSplitter.trimResults();</span><br><span class="line">    System.out.println(commaSplitterWithTrim.split(<span class="string">"m, g, h, i, o"</span>)); <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，第一个分割的结果在字符串 <code>g</code>、 <code>h</code>、<code>i</code>、<code>o</code> 之前有一个空格，使用 <code>trimResults</code> 方法后，将去除这些前导空格。</p><h5 id="omitEmptyStrings"><a href="#omitEmptyStrings" class="headerlink" title="omitEmptyStrings"></a>omitEmptyStrings</h5><p>这个方法会从结果中忽略所有空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfOmitEmptyStrings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter commaSplitter = Splitter.on(<span class="string">","</span>);</span><br><span class="line">    System.out.println(commaSplitter.split(<span class="string">"m,,g,h,i,o"</span>));                   <span class="comment">// [m, , g, h, i, o]</span></span><br><span class="line">    Splitter commaSplitterWithNoEmptyString = commaSplitter.omitEmptyStrings();</span><br><span class="line">    System.out.println(commaSplitterWithNoEmptyString.split(<span class="string">"m,,g,h,i,o"</span>));  <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>commaSplitterWithNoEmptyString</code> 会从输出中删除空字符串的结果。</p><h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><p>这个方法返回与原始分割器等效的分割器，但它会在达到指定的输入限制后将停止拆分，将后续剩余结果字符串作为一项输出，也就是说，我们可以通过的传入的参数指定结果中存在的最大项目数。需要注意的是：<code>该方法在省略空字符串时，省略的字符串不计算在内。</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter commaSplitter = Splitter.on(<span class="string">","</span>);</span><br><span class="line">    Splitter limitingCommaSplitter = commaSplitter.limit(<span class="number">3</span>);</span><br><span class="line">    System.out.println(limitingCommaSplitter.split(<span class="string">"i,m,g,h,i,o"</span>));  <span class="comment">// [i, m, g,h,i,o]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点需要注意，<code>Splitter</code> 是不可变的（这一点和 <code>String</code> 类似），因此，调用它的任何修饰符方法都将返回新的 <code>Splitter</code>，并且不会修改原始的 <code>Splitter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterImmutable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter splitter = Splitter.on(<span class="string">'/'</span>);</span><br><span class="line">    System.out.println(<span class="string">"Before: "</span> + splitter);  <span class="comment">// Before: com.google.common.base.Splitter@33b37288</span></span><br><span class="line">    splitter.trimResults();                     <span class="comment">// do nothing</span></span><br><span class="line">    System.out.println(<span class="string">"First: "</span> + splitter);   <span class="comment">// First: com.google.common.base.Splitter@33b37288</span></span><br><span class="line">    splitter = splitter.trimResults();          <span class="comment">// the returned splitter to be assigned</span></span><br><span class="line">    System.out.println(<span class="string">"Second: "</span> + splitter);  <span class="comment">// Second: com.google.common.base.Splitter@77a57272</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="splitToList"><a href="#splitToList" class="headerlink" title="splitToList"></a>splitToList</h5><p>我们前面已经使用的 <code>split</code> 方法，它返回的是一个 <code>Iterable&lt;String&gt;</code> 对象。而这里的 <code>splitToList</code> 方法返回一个 <code>List&lt;String&gt;</code>。由于分割方法返回的是  <code>Iterable</code>，因此它是<code>惰性</code>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfSplitToList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter commaSplitter = Splitter.on(<span class="string">","</span>);</span><br><span class="line">    List&lt;String&gt; result = commaSplitter.splitToList(<span class="string">"m,g,h,i,o"</span>);</span><br><span class="line">    System.out.println(result);  <span class="comment">// [m, g, h, i, o]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MapSplitter"><a href="#MapSplitter" class="headerlink" title="MapSplitter"></a>MapSplitter</h4><p><code>MapSplitter</code> 顾名思义就是用来将一个将字符串拆分为 <code>Map</code> 对象的。我们可以使用 <code>withKeyValueSeparator</code> 方法从 <code>Splitter</code> 中获取 <code>MapSplitter</code> 对象，该方法接收一个字符、字符串或者 <code>Splitter</code> 对象作为参数。首先，根据原始的分割器将字符串分割为多个项，然后，使用传给 <code>withKeyValueSeparator</code> 方法的分割符将各个项分为 <code>Map</code> 键-值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfWithKeyValueSeparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter commaSplitter = Splitter.on(<span class="string">','</span>);</span><br><span class="line">    Splitter.MapSplitter keyValueSplitter = commaSplitter.withKeyValueSeparator(<span class="string">'='</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = keyValueSplitter.split(<span class="string">"name=mghio,blog=mghio.cn"</span>);</span><br><span class="line">    System.out.println(map);  <span class="comment">// &#123;name=mghio, blog=mghio.cn&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看到，它分割为两个 <code>entry</code> （<code>name=mghio</code> 与 <code>blog=mghio.cn</code>）项，还有一个点需要注意的是：<code>如果我们在原始的分割器上指定了任何修改器，则它们仅适用于该分割器，而不适用于 MapSplitter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSplitterOfWithKeyValueSeparatorAndModifiers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Splitter originalSplitter = Splitter.on(<span class="string">","</span>).trimResults();</span><br><span class="line">    Splitter.MapSplitter keyValueSplitter = originalSplitter.withKeyValueSeparator(<span class="string">'='</span>);</span><br><span class="line">    <span class="comment">// 输出结果：&#123;name  =mghio, blog=   mghio.cn&#125;</span></span><br><span class="line">    System.out.println(keyValueSplitter.split(<span class="string">"name  =mghio,   blog=   mghio.cn"</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上结果可以看出 <code>trimResults</code> 修饰方法仅适用于原始拆分器。因此，<code>blog</code> 开头的空格已被移除（使用 <code>,</code> 分割原始字符串时），但是，<code>mghio.cn</code> 开头的空格不会被移除（使用 <code>=</code> 分割成键值时）。</p><p>最后需要注意的是：<code>MapSplitter</code> 类被标记为 <code>@Beta</code>，这意味着类库中与 <code>MapSplitter</code> 相关的类和方法是实验性的，可以更改（以中断的方式），甚至将来版本可能删除。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在本文中，介绍了 <a href="https://github.com/google/guava" target="_blank" rel="noopener">Google Guava</a> 库以及在项目或应用程序中使用它的好处，如何将其导入到我们的应用程序中使用。然后，介绍了 <code>Guava</code> 库中对字符串操作工具类（<code>Strings</code> 和 <code>Splitter</code> ）的一些基本用法，当然，这只是冰山一角，<code>Guava</code> 库还提供了其它很多有用的基础功能，需要我们自己去查询相关文档学习了解，感兴趣的朋友可以去看看它的实现源码，这个库的代码写得很优雅。</p><hr><p>参考</p><ul><li><a href="https://github.com/google/guava/wiki/StringsExplained" target="_blank" rel="noopener">StringsExplained</a></li><li><a href="https://www.javaworld.com/article/2074448/guava-s-strings-class.html" target="_blank" rel="noopener">Guava’s Strings Class</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 里字符串表示字符的不可变序列，创建后就不能更改。在我们日常的工作中，字符串的使用非常频繁，熟练的对其操作可以极大的提升我们的工作效率，今天要介绍的主角是 &lt;code&gt;Google&lt;/code&gt; 开源的一个核心 &lt;code&gt;Java&lt;/code&gt; 库 &lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Guava&lt;/a&gt;，它提供了集合类型、不可变的集合、并发、I / O、缓存、字符串等许多实用功能。在本文中，我们将学习使用 &lt;code&gt;Guava&lt;/code&gt; 中的 &lt;code&gt;Strings&lt;/code&gt; 和 &lt;code&gt;Splitter&lt;/code&gt; 字符串操作工具类。&lt;/p&gt;
&lt;h4 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Google Guava&lt;/code&gt; 会同步到 &lt;a href=&quot;https://mvnrepository.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maven Central&lt;/a&gt; 中，所以，如果你是 &lt;code&gt;Maven&lt;/code&gt; 项目的话只需要在 &lt;code&gt;pom.xml&lt;/code&gt; 文件中引入如下依赖即可：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;28.2-jre&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;对于 &lt;code&gt;Gradle&lt;/code&gt; 项目在 &lt;code&gt;build.gradle&lt;/code&gt; 中引入如下依赖即可：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile group: &lt;span class=&quot;string&quot;&gt;&#39;com.google.guava&#39;&lt;/span&gt;, name: &lt;span class=&quot;string&quot;&gt;&#39;guava&#39;&lt;/span&gt;, version: &lt;span class=&quot;string&quot;&gt;&#39;28.2-jre&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Guava" scheme="https://www.mghio.cn/categories/Java/Guava/"/>
    
      <category term="String" scheme="https://www.mghio.cn/categories/Java/Guava/String/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Guava" scheme="https://www.mghio.cn/tags/Guava/"/>
    
      <category term="String" scheme="https://www.mghio.cn/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>如何编写优雅的异步代码 — CompletableFuture</title>
    <link href="https://www.mghio.cn/post/7b9ead86.html"/>
    <id>https://www.mghio.cn/post/7b9ead86.html</id>
    <published>2020-04-06T06:17:55.000Z</published>
    <updated>2020-04-06T11:11:53.012Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在我们的意识里，同步执行的程序都比较符合人们的思维方式，而异步的东西通常都不好处理。在异步计算的情况下，以回调表示的动作往往会分散在代码中，也可能相互嵌套在内部，如果需要处理其中一个步骤中可能发生的错误时，情况变得更加糟糕。Java 8 引入了很多的新特性，其中就包含了 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="noopener">CompletableFuture</a> 类的引入，这让我们编写清晰可读的异步代码变得更加容易，该类功能非常强大，包含了超过 50 多个方法。。。</p><h4 id="什么是-CompletableFuture"><a href="#什么是-CompletableFuture" class="headerlink" title="什么是 CompletableFuture"></a>什么是 CompletableFuture</h4><p><code>CompletableFuture</code> 类的设计灵感来自于 <code>Google Guava</code> 的 <a href="https://guava.dev/releases/21.0/api/docs/com/google/common/util/concurrent/ListenableFuture.html" target="_blank" rel="noopener">ListenableFuture</a> 类，它实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口并且新增了许多方法，它支持 lambda，通过回调利用非阻塞方法，提升了异步编程模型。它允许我们通过在与主应用程序线程不同的线程上（也就是异步）运行任务，并向主线程通知任务的进度、完成或失败，来编写非阻塞代码。</p><a id="more"></a><h4 id="为什么要引入-CompletableFuture"><a href="#为什么要引入-CompletableFuture" class="headerlink" title="为什么要引入 CompletableFuture"></a>为什么要引入 CompletableFuture</h4><p><code>Java</code> 的 1.5 版本引入了 <code>Future</code>，你可以把它简单的理解为运算结果的占位符，它提供了两个方法来获取运算结果。</p><ul><li><code>get()</code>：调用该方法线程将会无限期等待运算结果。</li><li><code>get(long timeout, TimeUnit unit)</code>：调用该方法线程将仅在指定时间 <code>timeout</code> 内等待结果，如果等待超时就会抛出 <code>TimeoutException</code> 异常。</li></ul><p><code>Future</code> 可以使用 <code>Runnable</code> 或 <code>Callable</code> 实例来完成提交的任务，通过其源码可以看出，它存在如下几个问题：</p><ul><li><strong>阻塞</strong> 调用 <code>get()</code> 方法会一直阻塞，直到等待直到计算完成，它没有提供任何方法可以在完成时通知，同时也不具有附加回调函数的功能。</li><li><strong>链式调用和结果聚合处理</strong> 在很多时候我们想链接多个 <code>Future</code> 来完成耗时较长的计算，此时需要合并结果并将结果发送到另一个任务中，该接口很难完成这种处理。</li><li><strong>异常处理</strong> <code>Future</code> 没有提供任何异常处理的方式。</li></ul><p>以上这些问题在 <code>CompletableFuture</code> 中都已经解决了，接下来让我们看看如何去使用 <code>CompletableFuture</code>。</p><h4 id="如何创建-CompletableFuture"><a href="#如何创建-CompletableFuture" class="headerlink" title="如何创建 CompletableFuture"></a>如何创建 CompletableFuture</h4><p>最简单的创建方式就是调用 <code>CompletableFuture.completedFuture(U value)</code> 方法来获取一个已经完成的 <code>CompletableFuture</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleCompletableFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.completedFuture(<span class="string">"Hello mghio"</span>);</span><br><span class="line">    assertTrue(completableFuture.isDone());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        assertEquals(<span class="string">"Hello mghio"</span>, completableFuture.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是当我们对不完整的 <code>CompleteableFuture</code>调用 <code>get</code> 方法的话，会由于 <code>Future</code> 未完成，因此 <code>get</code> 调用将永远阻塞，此时可以使用 <code>CompletableFuture.complete</code> 方法手动完成 <code>Future</code>。</p><h4 id="任务异步处理"><a href="#任务异步处理" class="headerlink" title="任务异步处理"></a>任务异步处理</h4><p>当我们想让程序在后台异步执行任务而不关心任务的处理结果时，可以使用 <code>runAsync</code> 方法，该方法接收一个 <code>Runnable</code> 类型的参数返回 <code>CompletableFuture&lt;Void&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureRunAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AtomicInteger variable = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    CompletableFuture&lt;Void&gt; runAsync = CompletableFuture.runAsync(() -&gt; process(variable));</span><br><span class="line">    runAsync.join();</span><br><span class="line">    assertEquals(<span class="number">100</span>, variable.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AtomicInteger variable)</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread() + <span class="string">" Process..."</span>);</span><br><span class="line">    variable.set(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想让任务在后台异步执行而且需要获取任务的处理结果时，可以使用 <code>supplyAsync</code> 方法，该方法接收一个 <code>Supplier&lt;T&gt;</code> 类型的参数返回一个 <code>CompletableFuture&lt;T&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureSupplyAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(<span class="keyword">this</span>::process);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        assertEquals(<span class="string">"Hello mghio"</span>, supplyAsync.get()); <span class="comment">// Blocking</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello mghio"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里你可能会有个问题，上面执行 <code>runAsync</code> 和 <code>supplyAsync</code> 任务的线程是从哪里来的、谁创建的呢？实际上它和 Java 8 中的 <code>parallelStream</code> 类似，   <code>CompletableFuture</code> 也是从全局 <code>ForkJoinPool.commonPool()</code> 获得的线程中执行这些任务的。同时，上面的两个方法也提供了自定义线程池去执行任务，其实你如果去了解过 <code>CompletableFuture</code> 的源码的话，你会发现其 <code>API</code> 中的所有方法都有个重载的版本，有或没有自定义 <code>Executor</code> 执行器。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureSupplyAsyncWithExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(<span class="keyword">this</span>::process, newFixedThreadPool);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        assertEquals(<span class="string">"Hello mghio"</span>, supplyAsync.get()); <span class="comment">// Blocking</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello mghio"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式调用和结果聚合处理"><a href="#链式调用和结果聚合处理" class="headerlink" title="链式调用和结果聚合处理"></a>链式调用和结果聚合处理</h4><p>我们知道 <code>CompletableFuture</code> 的 <code>get()</code> 方法会一直<code>阻塞</code>直到获取到结果，<code>CompletableFuture</code> 提供了 <code>thenApply</code>、<code>thenAccept</code> 和 <code>thenRun</code> 等方法来避免这种情况，而且我们还可以添加任务完成后的回调通知。这几个方法的使用场景如下：</p><ul><li><strong>thenApply</strong> 当我们如果要在从 <code>Future</code> 接收值后任务之前运行自定义的业务代码，然后要为此任务返回一些值时，则可以使用该方法</li><li><strong>thenAccept</strong> 如果我们希望在从 <code>Future</code> 接收到一些值后执行任务之前运行自定义的业务代码而不关心返回结果值时，则可以使用该方法</li><li><strong>thenRun</strong> 如果我们想在Future完成后运行自定义的业务代码，并且不想为此返回任何值时，则可以使用该方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenApply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer notificationId = CompletableFuture.supplyAsync(<span class="keyword">this</span>::thenApplyProcess)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::thenApplyNotify) <span class="comment">// Non Blocking</span></span><br><span class="line">        .join();</span><br><span class="line">    assertEquals(<span class="keyword">new</span> Integer(<span class="number">1</span>), notificationId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>::processVariable)</span><br><span class="line">        .thenAccept(<span class="keyword">this</span>::thenAcceptNotify) <span class="comment">// Non Blocking</span></span><br><span class="line">        .join();</span><br><span class="line">    assertEquals(<span class="number">100</span>, variable.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>::processVariable)</span><br><span class="line">        .thenRun(<span class="keyword">this</span>::thenRunNotify)</span><br><span class="line">        .join();</span><br><span class="line">    assertEquals(<span class="number">100</span>, variable.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">processVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    variable.set(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thenRunNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"thenRun completed notify ...."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">thenApplyNotify</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> integer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thenAcceptNotify</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">    String.format(<span class="string">"Thread %s completed notify ...."</span>, Thread.currentThread().getName()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">thenApplyProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有大量的异步计算，那么我们可以继续将值从一个回调传递到另一个回调中去，也就是使用链式调用方式，使用方式很简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenApplyAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>::findAccountNumber)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::calculateBalance)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::notifyBalance)</span><br><span class="line">        .thenAccept((i) -&gt; notifyByEmail()).join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyByEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    System.out.println(<span class="string">"send notify by email ..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Double <span class="title">notifyBalance</span><span class="params">(Double d)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    System.out.println(String.format(<span class="string">"your balance is $%s"</span>, d));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9527</span>D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Double <span class="title">calculateBalance</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">9527</span>D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Double <span class="title">findAccountNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">9527</span>D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较细心的朋友可能注意到在所有前面的几个方法示例中，所有方法都是在同一线程上执行的。如果我们希望这些任务在单独的线程上运行时，那么我们可以使用这些方法对应的异步版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureApplyAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    ScheduledExecutorService newSingleThreadScheduledExecutor = Executors</span><br><span class="line">        .newSingleThreadScheduledExecutor();</span><br><span class="line">    CompletableFuture&lt;Double&gt; completableFuture =</span><br><span class="line">        CompletableFuture</span><br><span class="line">            .supplyAsync(<span class="keyword">this</span>::findAccountNumber,</span><br><span class="line">                newFixedThreadPool) <span class="comment">// 从线程池 newFixedThreadPool 获取线程执行任务</span></span><br><span class="line">            .thenApplyAsync(<span class="keyword">this</span>::calculateBalance,</span><br><span class="line">                newSingleThreadScheduledExecutor)</span><br><span class="line">            .thenApplyAsync(<span class="keyword">this</span>::notifyBalance);</span><br><span class="line">    Double balance = completableFuture.join();</span><br><span class="line">    assertEquals(<span class="number">9527</span>D, balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果处理"><a href="#执行结果处理" class="headerlink" title="执行结果处理"></a>执行结果处理</h4><p><code>thenCompose</code> 方法适合有依赖性的任务处理，比如一个计算账户余额的业务：首先我们要先找到帐号，然后为该帐户计算余额，然后计算完成后再发送通知。所有这些任务都是依赖前一个任务的返回 <code>CompletableFuture</code> 结果，此时我们需要使用 <code>thenCompose</code> 方法，其实有点类似于 Java 8 流的 <code>flatMap</code> 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenCompose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Double balance = <span class="keyword">this</span>.doFindAccountNumber()</span><br><span class="line">        .thenCompose(<span class="keyword">this</span>::doCalculateBalance)</span><br><span class="line">        .thenCompose(<span class="keyword">this</span>::doSendNotifyBalance).join();</span><br><span class="line">    assertEquals(<span class="number">9527</span>D, balance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Double&gt; <span class="title">doSendNotifyBalance</span><span class="params">(Double aDouble)</span> </span>&#123;</span><br><span class="line">    sleepSeconds(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    System.out.println(String.format(<span class="string">"%s doSendNotifyBalance ...."</span>, Thread.currentThread().getName()));</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="number">9527</span>D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Double&gt; <span class="title">doCalculateBalance</span><span class="params">(Double d)</span> </span>&#123;</span><br><span class="line">    sleepSeconds(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    System.out.println(String.format(<span class="string">"%s doCalculateBalance ...."</span>, Thread.currentThread().getName()));</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="number">9527</span>D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;Double&gt; <span class="title">doFindAccountNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sleepSeconds(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// business code</span></span><br><span class="line">    System.out.println(String.format(<span class="string">"%s doFindAccountNumber ...."</span>, Thread.currentThread().getName()));</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="number">9527</span>D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleepSeconds</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(timeout);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thenCombine</code> 方法主要是用于合并多个独立任务的处理结果。假设我们需要查找一个人的姓名和住址，则可以使用不同的任务来分别获取，然后要获得这个人的完整信息（姓名 + 住址），则需要合并这两种方法的结果，那么我们可以使用 <code>thenCombine</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenCombine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; thenCombine = <span class="keyword">this</span>.findName().thenCombine(<span class="keyword">this</span>.findAddress(), (name, address) -&gt; name + address);</span><br><span class="line">    String personInfo = thenCombine.join();</span><br><span class="line">    assertEquals(<span class="string">"mghio Shanghai, China"</span>, personInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;String&gt; <span class="title">findAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleepSeconds(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// business code</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Shanghai, China"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;String&gt; <span class="title">findName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleepSeconds(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// business code</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"mghio "</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待多个任务执行完成"><a href="#等待多个任务执行完成" class="headerlink" title="等待多个任务执行完成"></a>等待多个任务执行完成</h4><p>在许多情况下，我们希望并行运行多个任务，并在所有任务完成后再进行一些处理。假设我们要查找 3 个不同用户的姓名并将结果合并。此时就可以使用 <code>CompletableFuture</code> 的静态方法 <code>allOf</code>，该方法会等待所有任务完成，需要注意的是该方法它不会返回所有任务的合并结果，因此我们必须手动组合任务的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureAllof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; list = Lists.newArrayListWithCapacity(<span class="number">4</span>);</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">3</span>).forEach(num -&gt; list.add(findName(num)));</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; allFuture = CompletableFuture</span><br><span class="line">        .allOf(list.toArray(<span class="keyword">new</span> CompletableFuture[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;List&lt;String&gt;&gt; allFutureList = allFuture</span><br><span class="line">        .thenApply(val -&gt; list.stream().map(CompletableFuture::join).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; futureHavingAllValues = allFutureList</span><br><span class="line">        .thenApply(fn -&gt; String.join(<span class="string">""</span>, fn));</span><br><span class="line"></span><br><span class="line">    String result = futureHavingAllValues.join();</span><br><span class="line">    assertEquals(<span class="string">"mghio0mghio1mghio2"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CompletableFuture&lt;String&gt; <span class="title">findName</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleepSeconds(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// business code</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"mghio"</span> + num;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>在多线程中程序异常其实不太好处理，但是幸运的是在 <code>CompletableFuture</code> 中给我们提供了很方便的异常处理方式，在我们上面的例子代码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureThenCompose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Double balance = <span class="keyword">this</span>.doFindAccountNumber()</span><br><span class="line">        .thenCompose(<span class="keyword">this</span>::doCalculateBalance)</span><br><span class="line">        .thenCompose(<span class="keyword">this</span>::doSendNotifyBalance).join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，三个方法 <code>doFindAccountNumber</code>、<code>doCalculateBalance</code> 和 <code>doSendNotifyBalance</code> 只要任意一个发生异常了，则之后调用的方法将不会运行。<br><code>CompletableFuture</code> 提供了三种处理异常的方式，分别是 <code>exceptionally</code>、<code>handle</code> 和 <code>whenComplete</code> 方法。第一种方式是使用 <code>exceptionally</code> 方法处理异常，如果前面的方法失败并发生异常，则会调用异常回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureExceptionally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Double&gt; thenApply = CompletableFuture.supplyAsync(<span class="keyword">this</span>::findAccountNumber)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::calculateBalance)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::notifyBalance)</span><br><span class="line">        .exceptionally(ex -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception "</span> + ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>D;</span><br><span class="line">        &#125;);</span><br><span class="line">    Double join = thenApply.join();</span><br><span class="line">    assertEquals(<span class="number">9527</span>D, join);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式是使用 <code>handle</code> 方法处理异常，使用该方式处理异常比上面的 <code>exceptionally</code> 方式更为灵活，我们可以同时获取到异常对象和当前的处理结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>::findAccountNumber)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::calculateBalance)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::notifyBalance)</span><br><span class="line">        .handle((ok, ex) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"最终要运行的代码..."</span>);</span><br><span class="line">            <span class="keyword">if</span> (ok != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"No Exception !!"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception "</span> + ex.getMessage());</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>D;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ok;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种是使用 <code>whenComplete</code> 方法处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompletableFutureWhenComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>::findAccountNumber)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::calculateBalance)</span><br><span class="line">        .thenApply(<span class="keyword">this</span>::notifyBalance)</span><br><span class="line">        .whenComplete((result, ex) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"result = "</span> + result + <span class="string">", ex = "</span> + ex);</span><br><span class="line">            System.out.println(<span class="string">"最终要运行的代码..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在本文中，介绍了 <code>CompletableFuture</code> 类的部分方法和使用方式，这个类的方法很多同时提供的功能也非常强大，在异步编程中使用的比较多，熟悉了基本的使用方法之后要深入了解还是要深入源码分析其实现原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在我们的意识里，同步执行的程序都比较符合人们的思维方式，而异步的东西通常都不好处理。在异步计算的情况下，以回调表示的动作往往会分散在代码中，也可能相互嵌套在内部，如果需要处理其中一个步骤中可能发生的错误时，情况变得更加糟糕。Java 8 引入了很多的新特性，其中就包含了 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CompletableFuture&lt;/a&gt; 类的引入，这让我们编写清晰可读的异步代码变得更加容易，该类功能非常强大，包含了超过 50 多个方法。。。&lt;/p&gt;
&lt;h4 id=&quot;什么是-CompletableFuture&quot;&gt;&lt;a href=&quot;#什么是-CompletableFuture&quot; class=&quot;headerlink&quot; title=&quot;什么是 CompletableFuture&quot;&gt;&lt;/a&gt;什么是 CompletableFuture&lt;/h4&gt;&lt;p&gt;&lt;code&gt;CompletableFuture&lt;/code&gt; 类的设计灵感来自于 &lt;code&gt;Google Guava&lt;/code&gt; 的 &lt;a href=&quot;https://guava.dev/releases/21.0/api/docs/com/google/common/util/concurrent/ListenableFuture.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ListenableFuture&lt;/a&gt; 类，它实现了 &lt;code&gt;Future&lt;/code&gt; 和 &lt;code&gt;CompletionStage&lt;/code&gt; 接口并且新增了许多方法，它支持 lambda，通过回调利用非阻塞方法，提升了异步编程模型。它允许我们通过在与主应用程序线程不同的线程上（也就是异步）运行任务，并向主线程通知任务的进度、完成或失败，来编写非阻塞代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="异步" scheme="https://www.mghio.cn/categories/Java/%E5%BC%82%E6%AD%A5/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="异步" scheme="https://www.mghio.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>代码中的坏味道</title>
    <link href="https://www.mghio.cn/post/a38c0645.html"/>
    <id>https://www.mghio.cn/post/a38c0645.html</id>
    <published>2020-03-29T06:04:12.000Z</published>
    <updated>2020-03-29T11:26:55.617Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在日常生活中，当我们买的水果放久了之后会发出一种难闻的气味（“坏味道”），这个时候我们就应该把它扔掉。同样，代码也有“坏味道”，当然确定什么是和不是代码“坏味道”是主观的，它会随语言、开发人员和开发方法的不同而不同。在工作当中，很多时候都是在维护之前的项目和在此基础上增加一些新功能，为了能让项目代码易于理解和维护，要时刻注意代码中的“坏味道”，当发现代码如果有坏味道了，要及时去重构它使其变成优秀的整洁的代码。本文列举代码中一些常见的“坏味道”和相应的重构方案。</p><h4 id="过长方法-Long-Method"><a href="#过长方法-Long-Method" class="headerlink" title="过长方法 (Long Method)"></a>过长方法 (Long Method)</h4><p>这种“坏味道”表现为<code>方法代码行数过长</code>，方法行数越长，就越难以理解和维护它。一个比较有用的方案就是当你觉得需要对方法中的内容加注释的时候，你应该将这个代码段作为一个新方法提取出来，哪怕有时候仅仅是一行代码也可以这么做，而且方法的命名要尽量做到见名知意，如果局部变量和参数干扰到方法的提取，则可以使用引入参数对象来进行提取。一般情况下，方法中条件运算符和循环是可以将代码移至单独方法的一个很好的代码段，对于条件运算符，可以尝试分解条件，如果方法出现循环，可以尝试提取方法。</p><a id="more"></a><h4 id="过大的类-Large-Class"><a href="#过大的类-Large-Class" class="headerlink" title="过大的类 (Large Class)"></a>过大的类 (Large Class)</h4><p>这种“坏味道”表现为<code>一个定义了很多的变量、方法代码行数很长的大类</code>，刚开始的时候类通常都不“大”，一段时间之后，随着业务的发展新功能的增加，类通常都会就会变得越来越“大”，通常程序员都喜欢在原有的类上添加属性或者添加新的方法的方式来完成功能的开发，当一个类的代码行数过多或者功能职责过多的时候，就意味着我们应该将其拆分了，常用有以下三种不同的拆分方式：</p><ol><li>提取新类，当大类的部分行为可以分解为一​​个单独的组件，则可以使用提取类的方式拆分。</li><li>提取子类，当大类的部分行为可以以不同的方式实现或在极少数情况下使用，则可以使用提取子类方式拆分。</li><li>提取接口，当有必要列出客户端可以使用的操作和行为的列表的时候，则可以提取接口的方式拆分。</li></ol><p>通过重构大类，可以使开发人员无需记住一个类的大量属性，在许多情况下，将大类分成多个部分可以避免代码和功能的重复。</p><h4 id="过长参数列表-Long-Parameter-List"><a href="#过长参数列表-Long-Parameter-List" class="headerlink" title="过长参数列表 (Long Parameter List)"></a>过长参数列表 (Long Parameter List)</h4><p>这种“坏味道”表现为<code>一个方法超过三个以上的参数</code>，当一个方法合并了几个算法之后就会可能出现过多参数的情况，这些参数用来控制方法将要运行哪种算法以及如何运行的。长参数列表也可能是由于我们将类的对象创建过程拆分产生的，想象这么一个场景，当我们把用于创建方法所需对象的代码片段从方法内部移至用于调用方法的代码，然后创建的对象作为参数传入方法，这样，原始类就不再了解对象之间的关系，依赖性降低了。当有多个这种对象需要创建之后，每个对象将需要自己的参数，这意味着参数列表会更长。随着时间的流逝，我们就会越来越难于理解这种方法的长参数列表的具体含义了，清除这种“坏味道”的方式就是将方法的参数列表封装成一个对象的属性。通过重构之后，可以使代码的可读性更高，代码更简短，同时可能还会让你看到以前未被注意的重复代码。</p><h4 id="过多注释-Too-Many-Comments"><a href="#过多注释-Too-Many-Comments" class="headerlink" title="过多注释 (Too Many Comments)"></a>过多注释 (Too Many Comments)</h4><p>这种“坏味道”表现为<code>一种方法充满解释性的注释</code>，当开发者意识到自己的代码不直观或不明显时一般都会给代码加上相应的注释。写代码注释的意图通常都是好的，是为了可以有更好的可读性让后面易于维护，在这种情况下，代码注释就会掩盖了可以改进的可疑代码的“坏味道”，好的方法名或者类名就是最好的注释。</p><blockquote><p>The best comment is a good name for a method or class.</p></blockquote><p>当我们遇到没有注释就无法理解代码片段时，首先应该尝试以无需注释的方式更改代码结构，解决过多注释通常有以下几种方式：</p><ol><li>提取变量，当如果要使用注释来解释复杂的表达式的时候，则可以使用“提取变量”的方式将表达式拆分为可理解的子表达式。</li><li>提取方法，当如果注释解释了一段代码片段，则可以通过提取方法的方式来将这一部分变成一个单独的方法，这个时候往往方法的名称就是注释的内容。</li></ol><p>通过提取变量或者提取方法的方式可以使代码变得更加直观和明显。</p><h4 id="Switch-滥用（Switch-Abuse）"><a href="#Switch-滥用（Switch-Abuse）" class="headerlink" title="Switch 滥用（Switch Abuse）"></a>Switch 滥用（Switch Abuse）</h4><p>这种“坏味道”表现为<code>代码中存在一个复杂的 switch 运算符</code>，通常，<code>if</code> 条件语句的代码可以分散在程序中的不同位置，当需要添加新条件后，就必须找到所有开关代码并进行修改。根据经验，当看到 <code>switch</code> 时，你第一时间应该想到要用多态性去重构代码。如果 <code>switch</code> 是基于类型判断的，可以使用“用子类替换”或“用状态/策略替换”。但是当运算符中没有太多条件，并且它们都使用不同的参数调用相同的方法，那么多态其实是多余的。在这种情况下，则可以使用“将参数替换为方法”，然后将该方法分解为多个较小的方法，并相应地更改 <code>switch</code> ，代码经过重构之后改进其的组织方式。当然如果 <code>switch</code> 操作只是执行简单的判断时，则没有必要进行代码重构。还有就是，在工厂设计模式（工厂方法和抽象工厂）使用开关运算符来选择创建的类时，也没有必要对其进行重构。</p><h4 id="异曲同工类（Alternative-Classes-with-Different-Interfaces）"><a href="#异曲同工类（Alternative-Classes-with-Different-Interfaces）" class="headerlink" title="异曲同工类（Alternative Classes with Different Interfaces）"></a>异曲同工类（Alternative Classes with Different Interfaces）</h4><p>这种“坏味道”表现为<code>两个类有着相同的功能，但方法名称不同</code>，产生这种代码的原因通常是创建其中一个类的程序员可能并不知道功能上等效的类已经存在。清除这种“坏味道”有以下几种方式：</p><ol><li>方法重命名，重命名相同功能的方法，使它们在所有替代类中相同。</li><li>移动方法、添加参数和泛型方法使得方法的签名和实现相同。</li><li>如果仅仅是重复了方法的部分功能，可以使用提取相同父类的方式重构，在这种情况下，现有的类将成为该父类的子类。</li></ol><p>通过重构异曲同工类后，可以去除掉不必要的重复代码，从而减少代码的行数，同时代码也会有更好的可读更易于理解。</p><h4 id="临时变量滥用（Temporary-Field）"><a href="#临时变量滥用（Temporary-Field）" class="headerlink" title="临时变量滥用（Temporary Field）"></a>临时变量滥用（Temporary Field）</h4><p>这种“坏味道”表现为<code>一些临时变量仅在某些情况下才获得其值，在这些情况之外，它们都为空</code>，通常，当我们在创建一个算法后需要定义一些临时变量以供该算法输入使用。此时，程序员往往会决定在类中为此算法去创建变量，而不是在方法中创建大量参数，导致这些变量仅在算法当中才会使用，其它地方都不会使用这些变量。一个应对的方式就是将这些临时变量和对其进行操作的所有代码都提取出来放到单独的类中。</p><h4 id="重复代码（Duplicate-Code）"><a href="#重复代码（Duplicate-Code）" class="headerlink" title="重复代码（Duplicate Code）"></a>重复代码（Duplicate Code）</h4><p>这种“坏味道”表现为<code>两个或者多个代码片段看起来几乎相同</code>，当我们多个人同时在同一项目中的不同部分上工作时，通常就会发生复制，产生重复的代码。因为正在实现不同的功能，因此可能并不知道其他人已经编写了类似的代码，这些代码其实是可以根据自己的需要进行复用的。当代码中的一些特定部分看起来不同但实际上实现相同的功能时，这样的代码有着更多细微的重复，这种情况下的代码重复可能很难找到和修复。如果重复代码在<code>两个处于相同层次结构的子类</code>出现时，我们可以通过以下方式进行重构：</p><ol><li>提取方法，将重复的代码片段提取为方法然后放到共同的父类当中。</li><li>如果重复的代码在构造方法内部，则将其提取到父类的构造方法当中去，然后再在当前类的构造方法中使用 <code>super</code> 的方式调用父类构造方法。</li><li>如果重复的代码结构上相似但又不完全相同，那么则使用模板方法方式重构。</li></ol><p>如果重复代码在<code>两个或者多个不同的类</code>出现时，我们可以通过以下方式进行重构：</p><ol><li>如果这些类不是层次结构的一部分，可以使用提取共同父类的方式来为这些类创建一个保留所有之前的功能的单个父类。</li><li>当很难或者不可能创建父类，那么可以在其中的任意一个类中使用提取类的方式来重构，然后在其它类中使用刚刚创建出来的类。</li></ol><p>通过重构合并重复的代码可以简化代码的结构并使其更加简短和易于后期维护。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文总结了一些代码中常见的“坏味道”并给出了一些解决方法，重构是需要我们开发人员时刻都要去做的，要将重构始终贯穿在整个开发过程中，不断去发现代码中的“坏味道”，不断的持续的渐进重构。最后不管我们是如何去重构代码的，其背后的指导思想都是 <a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">Solid 原则</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在日常生活中，当我们买的水果放久了之后会发出一种难闻的气味（“坏味道”），这个时候我们就应该把它扔掉。同样，代码也有“坏味道”，当然确定什么是和不是代码“坏味道”是主观的，它会随语言、开发人员和开发方法的不同而不同。在工作当中，很多时候都是在维护之前的项目和在此基础上增加一些新功能，为了能让项目代码易于理解和维护，要时刻注意代码中的“坏味道”，当发现代码如果有坏味道了，要及时去重构它使其变成优秀的整洁的代码。本文列举代码中一些常见的“坏味道”和相应的重构方案。&lt;/p&gt;
&lt;h4 id=&quot;过长方法-Long-Method&quot;&gt;&lt;a href=&quot;#过长方法-Long-Method&quot; class=&quot;headerlink&quot; title=&quot;过长方法 (Long Method)&quot;&gt;&lt;/a&gt;过长方法 (Long Method)&lt;/h4&gt;&lt;p&gt;这种“坏味道”表现为&lt;code&gt;方法代码行数过长&lt;/code&gt;，方法行数越长，就越难以理解和维护它。一个比较有用的方案就是当你觉得需要对方法中的内容加注释的时候，你应该将这个代码段作为一个新方法提取出来，哪怕有时候仅仅是一行代码也可以这么做，而且方法的命名要尽量做到见名知意，如果局部变量和参数干扰到方法的提取，则可以使用引入参数对象来进行提取。一般情况下，方法中条件运算符和循环是可以将代码移至单独方法的一个很好的代码段，对于条件运算符，可以尝试分解条件，如果方法出现循环，可以尝试提取方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="重构" scheme="https://www.mghio.cn/categories/Java/%E9%87%8D%E6%9E%84/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="重构" scheme="https://www.mghio.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 垃圾收集技术</title>
    <link href="https://www.mghio.cn/post/4615256d.html"/>
    <id>https://www.mghio.cn/post/4615256d.html</id>
    <published>2020-03-21T01:55:11.000Z</published>
    <updated>2020-03-22T06:55:21.680Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在计算机科学中，垃圾回收（<code>GC: garbage collection</code>）是内存自动管理的一种方式，它并不是同 <code>Java</code> 语言一起诞生的，实际上，早在 1959 年为了简化 <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" target="_blank" rel="noopener">Lisp</a> 语言的手动内存管理，该语言的作者就开始使用了内存自动管理技术。 <code>垃圾收集</code>和<code>手动内存管理</code>刚好相反，后者需要编程人员自己去指定需要释放的对象然后将内存归还给操作系统，而前者不需要关心给对象分配的内存回收问题。<code>Java</code> 语言使用自动垃圾收集器来管理对象生命周期中的内存，要进行垃圾收集首先需要明确三个问题：<code>1. 哪些内存需要回收</code>、<code>2. 什么时候进行回收</code>、<code>3. 怎么进行内存回收</code>。接下来让我们一起看看 <code>Java</code> 语言对这些问题是如何处理的。</p><h4 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h4><p>为了方便管理和跨平台，<code>Java</code> 虚拟机规范规定在执行 <code>Java</code> 程序的时候把它所管理的内存划分为若干个不同的数据区域。这些区域都有着各自不同的用途以及创建和销毁的时间，有的数据区域随着用户线程的启动和结束而建立和销毁，有的区域会随着虚拟机进程的启动和停止而存在和销毁。更多有关运行时数据区域的内容请看 <a href="https://www.mghio.cn/post/8a061473.html">Java 运行时数据区域</a>。<br>由于 <code>Java</code> 运行时数据区域中的 <code>程序计数器</code>、<code>虚拟机栈</code>和<code>本地方法栈</code>和线程的生命周期一致，随线程的启动和结束而建立和销毁。而且当我们的类结构确定了之后，在编译期间，一个栈帧需要分配内存的大小基本上也就确定下来了，这三个区域的内存分配和收回都是具备确定性的，不需要我们过多的去考虑内存回收问题。主要考虑<code>Java 堆</code>和<code>方法区</code>的内存回收的问题。</p><a id="more"></a><h4 id="什么时候进行回收"><a href="#什么时候进行回收" class="headerlink" title="什么时候进行回收"></a>什么时候进行回收</h4><p>在 <code>Java</code> 语言中，一个对象的生命周期分为以下三个阶段：</p><ul><li><strong>对象创建阶段</strong> 通常我们使用 <code>new</code> 关键字进行对象创建 <code>e.g. Object obj = new Object();</code>，当我们创建对象时，<code>Java</code> 虚拟机将分配一定大小的内存来存储该对象，分配的内存量可能会根据虚拟机厂商的不同而有所不同。</li><li><strong>对象使用阶段</strong> 在这个阶段，对象被应用程序的其它对象使用（其它活动对象拥有指向它的引用）。在使用期间，该对象会一直驻留在内存当中，并且可能包含对其它对象的引用。</li><li><strong>对象销毁阶段</strong> 垃圾收集系统监视对象，如果发现对象不被任何对象引用了，则进行该对象内存回收操作。</li></ul><p>那么问题来了，该如何去判断一个对象有没有被引用呢？目前，主要有两种判断对象是否存活的算法，分别是 <code>引用计数算法（Reference counting algorithm）</code>和<code>可达性分析算法（Accessibility analysis algorithm）</code>。</p><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>首先我们看看<code>引用计数算法</code>是如何判断的，该算法的主要思想就是给每个对象都添加一个引用计数器，当该对象被变量或者另一个对象引用时该计数器值就会加 1，同时当对象的一个引用无效时，对象计数器的值会相应的减 1。当对象引用计数器的值为 0 时，说明该对象已经不再被引用了，那么就可以销毁对象进行内存回收操作了。这个算法的实现比较简单，对象是否“存活”的判断效率也比较高，这个算法看起来确实不错，但是它有个致命的缺点就是：<code>无法解决对象间相互引用的问题</code>。相互引用简单来说就是，有两个对象 <code>object1</code> 和 <code>object2</code> 都有一个引用类型字段 <code>ref</code>，并且做了如下赋值操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object1.ref = object2;</span><br><span class="line">object2.ref = object1;</span><br></pre></td></tr></table></figure><p>这两个对象除了上面这个赋值之外，不被其它任何对象引用，实际上这两个对象都不可能再被访问了，但是因为它们俩都互相引用了对方，导致引用计数器不为 0，导致使用引用计数器算法的 <code>垃圾收集器</code> 无法收集它们，它们就会一直存在于内存之中直到虚拟机进程结束。正是因为这个原因，市场上主流的 <code>Java</code> 虚拟机大部分都没有选用这个算法来管理内存，下面介绍的 <code>可达性分析算法</code> 就可以很好的避免了对象间相互引用的问题。</p><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p><code>Java</code> 虚拟机是通过<code>可达性分析算法</code>来判断对象是否存活的，该算法的主要思想是将一系列称为 <code>GC Root</code> 的对象作为起点，向下进行搜索，搜索经过的路径称为<code>引用链（Reference chain）</code>，当一个对象到 <code>GC Root</code> 对象没有任何引用链的时候，则表示该对象是不可达的，可以对其进行内存回收。</p><p><img src="https://i.loli.net/2020/03/21/aSIOt2ei6xHg1Zz.png" alt="accessibility-analysis-algorithm.png"></p><p>在 <code>Java</code> 虚拟机中，规定以下几种情况可以作为 <code>GC Root</code> 对象：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 <code>Native</code> 方法引用的对象</li></ul><h4 id="怎么进行内存回收"><a href="#怎么进行内存回收" class="headerlink" title="怎么进行内存回收"></a>怎么进行内存回收</h4><p>当我们创建的对象不可达之后，<code>Java</code> 虚拟机会在后台自动去收集回收不可达对象的内存，自 <code>Java</code> 语言诞生以来，在垃圾收集算法上进行了许多更新，主要有<code>标记-清除算法（Mark and sweep algorithm）</code>、<code>复制算法（Copying algorithm）</code>、<code>标记—整理算法（Mark and compact algorithm）</code>和<code>分代收集算法（Generational collection algorithm）</code>，根据这些算法实现的垃圾收集器在后台默默运行以释放内存，下面让我们看看它们是如何工作的。</p><h5 id="标记-清除算法（mark-and-sweep-algorithm）"><a href="#标记-清除算法（mark-and-sweep-algorithm）" class="headerlink" title="标记-清除算法（mark and sweep algorithm）"></a>标记-清除算法（mark and sweep algorithm）</h5><p><code>标记—清除算法</code>是初始且非常基本的算法，主要分为以下两个阶段：</p><ol><li>标记需要回收对象，找出程序中所有需要回收的对象并标记。</li><li>清除所有标记对象，在标记完成后统一回收被标记对象。</li></ol><p>首先标记出需要回收的对象，标记完成后再统一回收被标记对象。这个算法是最基础的垃圾收集算法，后面将要介绍的几个算法都是在它的基础上优化改进的，算法主要有两个不足的地方：① <code>效率不高</code>，标记和清除过程的效率都不高。② <code>空间利用率不高</code>，标记清除之后会产生大量不连续的内存碎片，后面如果要分配大对象的时候由于连续内存不足可能会再次触发垃圾收集操作。</p><h5 id="复制算法（copying-algorithm）"><a href="#复制算法（copying-algorithm）" class="headerlink" title="复制算法（copying algorithm）"></a>复制算法（copying algorithm）</h5><p><code>复制算法</code>就是为了解决<code>标记—清除算法</code>的效率问题的，主要思想就是将可用的内存分为大小相等的两个部分，每一次都只使用其中的一块，当这块内存使用完了之后，就将依然存活的对象复制到另一块内存上去，然后再把这块含有可回收对象的内存清理掉，这样每次都是清理一半的连续内存了，就不会存在内存碎片的情况。但是这个算法的缺点也很明显，它把可用内存的大小缩小到了一半。</p><h5 id="标记-整理算法（mark-and-compact-algorithm）"><a href="#标记-整理算法（mark-and-compact-algorithm）" class="headerlink" title="标记-整理算法（mark and compact algorithm）"></a>标记-整理算法（mark and compact algorithm）</h5><p>如果对象的存活率比较低的情况下，上面介绍的<code>复制算法</code>效率还是很高的，毕竟只要复制少部分存活对象到另一块内存中即可，但是当对象的存活率比较高时就会进行多次复制操作。比如老年代，老年代的对象是经过多次垃圾回收依然存活的对象，对象的存活率相对来说比较高，根据老年代的这个特点，于是针对这种情况就有了另一个算法称之为<code>标记-整理算法</code>，主要思想和其名字一样也是分为<code>标记</code>和<code>整理</code>两个阶段，第一个标记阶段依然和<code>标记—清除算法</code>一样，后面的第二个整理阶段就不是直接对可回收对象进行清理了，而是让所有存活的对象都向内存的同一侧移动，然后就直接清除掉另一侧的内存。</p><h5 id="分代收集算法（generational-collection-algorithm）"><a href="#分代收集算法（generational-collection-algorithm）" class="headerlink" title="分代收集算法（generational collection algorithm）"></a>分代收集算法（generational collection algorithm）</h5><p>根据不同分代的特点，现在商业上的虚拟机针对不同的分代采取适合的垃圾收集，一般是把 <code>Java</code> 堆分为新生代和老年代。在新生代中，对象大部分存活时间都很短每次垃圾收集都会有很多的对象被清除，只有少部分对象可以存活下来，那么此时就可以使用<code>复制算法</code>，只需要复制出少部分存活的对象即可效率高。然而在老年代中大部分对象的存活时间比较长，则需采用<code>标记-清除算法</code>或者<code>标记-整理算法</code>来进行垃圾收集。<br>垃圾收集算法对于垃圾回收来说类似于我们程序中的接口，是一套垃圾回收的指导算法，算法的具体实现我们称之为<code>垃圾收集器</code>。但是 <code>Java</code> 虚拟机规范中并没有对垃圾收集器的实现有任何规定。所以不同的厂商和不同版本的虚拟机实现的垃圾收集器也不一样，不过一般都会提供一些配置参数来让用户根据自身情况来设置所需的垃圾收集器。</p><h4 id="JVM-相关-GC-配置"><a href="#JVM-相关-GC-配置" class="headerlink" title="JVM 相关 GC 配置"></a>JVM 相关 GC 配置</h4><p><code>Java</code> 虚拟机部分垃圾收集（<code>Garbage Collection，GC</code>）相关配置如下</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-Xms2048m</td><td align="center">设置初始堆大小（新生代 + 老年代）</td></tr><tr><td align="center">-XX:InitialHeapSize=3g</td><td align="center">设置初始堆大小（新生代 + 老年代）</td></tr><tr><td align="center">-Xmx3g</td><td align="center">设置最大堆大小（新生代 + 老年代）</td></tr><tr><td align="center">-XX:MaxHeapSize=3g</td><td align="center">设置最大堆大小（新生代 + 老年代）</td></tr><tr><td align="center">-XX:NewSize=128m</td><td align="center">设置堆初始新生代大小</td></tr><tr><td align="center">-XX:MaxNewSize=128m</td><td align="center">设置堆最大新生代大小</td></tr><tr><td align="center">-XX:PermSize=512m（JDK 1.7）</td><td align="center">设置初始永久代（元空间）大小</td></tr><tr><td align="center">-XX:MetaspaceSize=512m（JDK 1.8+）</td><td align="center">设置初始永久代（元空间）大小</td></tr><tr><td align="center">-XX:MaxPermSize=1g（JDK 1.7）</td><td align="center">设置最大永久代（元空间）大小</td></tr><tr><td align="center">-XX:MaxMetaspaceSize=1g（JDK 1.8+）</td><td align="center">设置最大永久代（元空间）大小</td></tr><tr><td align="center">-XX:+DisableExplicitGC</td><td align="center">忽略应用程序对 <code>System.gc()</code> 方法的任何调用</td></tr><tr><td align="center">-XX:+PrintGCDetails</td><td align="center">打印输出 <code>GC</code> 收集相关信息</td></tr></tbody></table><hr><p>参考文章</p><ul><li><p><a href="https://book.douban.com/subject/24722612" target="_blank" rel="noopener">深入理解Java虚拟机（第2版）</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener">Garbage collection (computer science)</a></p></li><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html" target="_blank" rel="noopener">The Java® Virtual Machine Specification（Java SE 8 Edition）</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在计算机科学中，垃圾回收（&lt;code&gt;GC: garbage collection&lt;/code&gt;）是内存自动管理的一种方式，它并不是同 &lt;code&gt;Java&lt;/code&gt; 语言一起诞生的，实际上，早在 1959 年为了简化 &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lisp&lt;/a&gt; 语言的手动内存管理，该语言的作者就开始使用了内存自动管理技术。 &lt;code&gt;垃圾收集&lt;/code&gt;和&lt;code&gt;手动内存管理&lt;/code&gt;刚好相反，后者需要编程人员自己去指定需要释放的对象然后将内存归还给操作系统，而前者不需要关心给对象分配的内存回收问题。&lt;code&gt;Java&lt;/code&gt; 语言使用自动垃圾收集器来管理对象生命周期中的内存，要进行垃圾收集首先需要明确三个问题：&lt;code&gt;1. 哪些内存需要回收&lt;/code&gt;、&lt;code&gt;2. 什么时候进行回收&lt;/code&gt;、&lt;code&gt;3. 怎么进行内存回收&lt;/code&gt;。接下来让我们一起看看 &lt;code&gt;Java&lt;/code&gt; 语言对这些问题是如何处理的。&lt;/p&gt;
&lt;h4 id=&quot;哪些内存需要回收&quot;&gt;&lt;a href=&quot;#哪些内存需要回收&quot; class=&quot;headerlink&quot; title=&quot;哪些内存需要回收&quot;&gt;&lt;/a&gt;哪些内存需要回收&lt;/h4&gt;&lt;p&gt;为了方便管理和跨平台，&lt;code&gt;Java&lt;/code&gt; 虚拟机规范规定在执行 &lt;code&gt;Java&lt;/code&gt; 程序的时候把它所管理的内存划分为若干个不同的数据区域。这些区域都有着各自不同的用途以及创建和销毁的时间，有的数据区域随着用户线程的启动和结束而建立和销毁，有的区域会随着虚拟机进程的启动和停止而存在和销毁。更多有关运行时数据区域的内容请看 &lt;a href=&quot;https://www.mghio.cn/post/8a061473.html&quot;&gt;Java 运行时数据区域&lt;/a&gt;。&lt;br&gt;由于 &lt;code&gt;Java&lt;/code&gt; 运行时数据区域中的 &lt;code&gt;程序计数器&lt;/code&gt;、&lt;code&gt;虚拟机栈&lt;/code&gt;和&lt;code&gt;本地方法栈&lt;/code&gt;和线程的生命周期一致，随线程的启动和结束而建立和销毁。而且当我们的类结构确定了之后，在编译期间，一个栈帧需要分配内存的大小基本上也就确定下来了，这三个区域的内存分配和收回都是具备确定性的，不需要我们过多的去考虑内存回收问题。主要考虑&lt;code&gt;Java 堆&lt;/code&gt;和&lt;code&gt;方法区&lt;/code&gt;的内存回收的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="GC" scheme="https://www.mghio.cn/categories/Java/GC/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="GC" scheme="https://www.mghio.cn/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>服务发现组件之 — Eureka</title>
    <link href="https://www.mghio.cn/post/710bd10b.html"/>
    <id>https://www.mghio.cn/post/710bd10b.html</id>
    <published>2020-03-14T06:29:52.000Z</published>
    <updated>2020-03-17T11:47:13.241Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>现在流行的微服务体系结构正在改变我们构建应用程序的方式，从单一的单体服务转变为越来越小的可单独部署的服务（称为<code>微服务</code>），共同构成了我们的应用程序。当进行一个业务时不可避免就会存在多个服务之间调用，假如一个服务 A 要访问在另一台服务器部署的服务 B，那么前提是服务 A 要知道服务 B 所在机器的 IP 地址和服务对应的端口，最简单的方式就是让服务 A 自己去维护一份服务 B 的配置（包含 IP 地址和端口等信息），但是这种方式有几个明显的缺点：随着我们调用服务数量的增加，配置文件该如何维护；缺乏灵活性，如果服务 B 改变 IP 地址或者端口，服务 A 也要修改相应的文件配置；还有一个就是进行服务的动态扩容或缩小不方便。<br>一个比较好的解决方案就是 <code>服务发现（Service Discovery）</code>。它抽象出来了一个注册中心，当一个新的服务上线时，它会将自己的 IP 和端口注册到注册中心去，会对注册的服务进行定期的心跳检测，当发现服务状态异常时将其从注册中心剔除下线。服务 A 只要从注册中心中获取服务 B 的信息即可，即使当服务 B 的 IP 或者端口变更了，服务 A 也无需修改，从一定程度上解耦了服务。服务发现目前业界有很多开源的实现，比如 <code>apache</code> 的 <a href="https://github.com/apache/zookeeper" target="_blank" rel="noopener">zookeeper</a>、 <code>Netflix</code> 的 <a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">eureka</a>、<code>hashicorp</code> 的 <a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener">consul</a>、 <code>CoreOS</code> 的 <a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener">etcd</a>。</p><a id="more"></a><h4 id="Eureka-是什么"><a href="#Eureka-是什么" class="headerlink" title="Eureka 是什么"></a>Eureka 是什么</h4><p><code>Eureka</code> 在 <a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">github</a> 上对其的定义为</p><blockquote><p>Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers.<br>At Netflix, Eureka is used for the following purposes apart from playing a critical part in mid-tier load balancing.</p></blockquote><p><code>Eureka</code> 是由 <a href="https://www.netflix.com" target="_blank" rel="noopener">Netflix</a> 公司开源，采用的是 Client / Server 模式进行设计，基于 http 协议和使用 Restful Api 开发的服务注册与发现组件，提供了完整的服务注册和服务发现，可以和 <code>Spring Cloud</code> 无缝集成。其中 Server 端扮演着服务注册中心的角色，主要是为 Client 端提供服务注册和发现等功能，维护着 Client 端的服务注册信息，同时定期心跳检测已注册的服务当不可用时将服务剔除下线，Client 端可以通过 Server 端获取自身所依赖服务的注册信息，从而完成服务间的调用。遗憾的是从其官方的 <a href="https://github.com/Netflix/eureka/wik" target="_blank" rel="noopener">github wiki</a> 可以发现，2.0 版本已经不再开源。但是不影响我们对其进行深入了解，毕竟服务注册、服务发现相对来说还是比较基础和通用的，其它开源实现框架的思想也是想通的。</p><h4 id="服务注册中心（Eureka-Server）"><a href="#服务注册中心（Eureka-Server）" class="headerlink" title="服务注册中心（Eureka Server）"></a>服务注册中心（Eureka Server）</h4><p>我们在项目中引入 <code>Eureka Server</code> 的相关依赖，然后在启动类加上注解 <code>@EnableEurekaServer</code>，就可以将其作为注册中心，启动服务后访问页面如下：</p><p><img src="https://i.loli.net/2020/03/15/7TAmjGKnQ2PXuMd.png" alt="eureka-server-homepage.png"></p><p>我们继续添加两个模块 <code>service-provider</code>，<code>service-consumer</code>，然后在启动类加上注解 <code>@EnableEurekaClient</code> 并指定注册中心地址为我们刚刚启动的 <code>Eureka Server</code>，再次访问可以看到两个服务都已经注册进来了。</p><p><img src="https://i.loli.net/2020/03/15/O7QpAjDRsqEBcz1.png" alt="instance-registered-currently.png"></p><p><code>Demo</code> 仓库地址：<a href="https://github.com/mghio/depth-in-springcloud" target="_blank" rel="noopener">https://github.com/mghio/depth-in-springcloud</a></p><p>可以看到 <code>Eureka</code> 的使用非常简单，只需要添加几个注解和配置就实现了服务注册和服务发现，接下来我们看看它是如何实现这些功能的。</p><h5 id="服务注册（Register）"><a href="#服务注册（Register）" class="headerlink" title="服务注册（Register）"></a>服务注册（Register）</h5><p>注册中心提供了服务注册接口，用于当有新的服务启动后进行调用来实现服务注册，或者心跳检测到服务状态异常时，变更对应服务的状态。服务注册就是发送一个 <code>POST</code> 请求带上当前实例信息到类 <code>ApplicationResource</code> 的 <code>addInstance</code> 方法进行服务注册。</p><p><img src="https://i.loli.net/2020/03/15/fsuYMRQgdZJ2BjK.png" alt="eureka-server-applicationresource-addinstance.png"></p><p>可以看到方法调用了类 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>register</code> 方法，该方法主要分为两步：</p><ol><li>调用父类 <code>AbstractInstanceRegistry</code> 的 <code>register</code> 方法把当前服务注册到注册中心</li><li>调用 <code>replicateToPeers</code> 方法使用异步的方式向其它的 <code>Eureka Server</code> 节点同步服务注册信息</li></ol><p>服务注册信息保存在一个嵌套的 <code>map</code> 中，它的结构如下：</p><p><img src="https://i.loli.net/2020/03/15/j1JAOcCbUIn5hu3.png" alt="eureka-server-registry-structure.png"></p><p>第一层 <code>map</code> 的 <code>key</code> 是应用名称（对应 <code>Demo</code> 里的 <code>SERVICE-PROVIDER</code>），第二层 <code>map</code> 的 <code>key</code> 是应用对应的实例名称（对应 <code>Demo</code> 里的 <code>mghio-mbp:service-provider:9999</code>），一个应用可以有多个实例，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/fWbIeUM3FGsT7nE.png" alt="eureka-server-register-sequence-chart.png"></p><h5 id="服务续约（Renew）"><a href="#服务续约（Renew）" class="headerlink" title="服务续约（Renew）"></a>服务续约（Renew）</h5><p>服务续约会由服务提供者（比如 <code>Demo</code> 中的 <code>service-provider</code>）定期调用，类似于心跳，用来告知注册中心 <code>Eureka Server</code> 自己的状态，避免被 <code>Eureka Server</code> 认为服务时效将其剔除下线。服务续约就是发送一个 <code>PUT</code> 请求带上当前实例信息到类 <code>InstanceResource</code> 的 <code>renewLease</code> 方法进行服务续约操作。</p><p><img src="https://i.loli.net/2020/03/15/UXSiGIjPydWxuFD.png" alt="eureka-server-instanceresource-renew.png"></p><p>进入到 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>renew</code> 方法可以看到，服务续约步骤大体上和服务注册一致，先更新当前 <code>Eureka Server</code> 节点的状态，服务续约成功后再用异步的方式同步状态到其它 <code>Eureka Server</code> 节上，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/tDTNqfn8wsuU2XM.png" alt="eureka-server-renew-sequence-chart.png"></p><h5 id="服务下线（Cancel）"><a href="#服务下线（Cancel）" class="headerlink" title="服务下线（Cancel）"></a>服务下线（Cancel）</h5><p>当服务提供者（比如 <code>Demo</code> 中的 <code>service-provider</code>）停止服务时，会发送请求告知注册中心 <code>Eureka Server</code> 进行服务剔除下线操作，防止服务消费者从注册中心调用到不存在的服务。服务下线就是发送一个 <code>DELETE</code> 请求带上当前实例信息到类 <code>InstanceResource</code> 的 <code>cancelLease</code> 方法进行服务剔除下线操作。</p><p><img src="https://i.loli.net/2020/03/15/PqTHv1VyC98YnSh.png" alt="eureka-server-instanceresource-cancellease.png"></p><p>进入到 <code>PeerAwareInstanceRegistryImpl</code> 的 <code>cancel</code> 方法可以看到，服务续约步骤大体上和服务注册一致，先在当前 <code>Eureka Server</code> 节点剔除下线该服务，服务下线成功后再用异步的方式同步状态到其它 <code>Eureka Server</code> 节上，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/bViYUoXfKgcyMZB.png" alt="eureka-server-cancellease-sequence-chart.png"></p><h5 id="服务剔除（Eviction）"><a href="#服务剔除（Eviction）" class="headerlink" title="服务剔除（Eviction）"></a>服务剔除（Eviction）</h5><p>服务剔除是注册中心 <code>Eureka Server</code> 在启动时就启动一个守护线程 <code>evictionTimer</code> 来定期（默认为 <code>60</code> 秒）执行检测服务的，判断标准就是超过一定时间没有进行 <code>Renew</code> 的服务，默认的失效时间是 <code>90</code> 秒，也就是说当一个已注册的服务在 <code>90</code> 秒内没有向注册中心 <code>Eureka Server</code> 进行服务续约（Renew），就会被从注册中心剔除下线。失效时间可以通过配置 <code>eureka.instance.leaseExpirationDurationInSeconds</code> 进行修改，定期执行检测服务可以通过配置 <code>eureka.server.evictionIntervalTimerInMs</code> 进行修改，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/khRzlKOL2ZigUwa.png" alt="eureka-server-evict-sequence-chart.png"></p><h4 id="服务提供者（Service-Provider）"><a href="#服务提供者（Service-Provider）" class="headerlink" title="服务提供者（Service Provider）"></a>服务提供者（Service Provider）</h4><p>对于服务提供方（比如 <code>Demo</code> 中的 <code>service-provider</code> 服务）来说，主要有三大类操作，分别为 <code>服务注册（Register）</code>、<code>服务续约（Renew）</code>、<code>服务下线（Cancel）</code>，接下来看看这三个操作是如何实现的。</p><h5 id="服务注册（Register）-1"><a href="#服务注册（Register）-1" class="headerlink" title="服务注册（Register）"></a>服务注册（Register）</h5><p>一个服务要对外提供服务，首先要在注册中心 <code>Eureka Server</code> 进行服务相关信息注册，能进行这一步的前提是你要配置 <code>eureka.client.register-with-eureka=true</code>，这个默认值为 <code>true</code>，注册中心不需要把自己注册到注册中心去，把这个配置设为 <code>false</code>，这个调用比较简单，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/uv9GsO2JPeCMd3N.png" alt="service-provider-register-sequence-chart.png"></p><h5 id="服务续约（Renew）-1"><a href="#服务续约（Renew）-1" class="headerlink" title="服务续约（Renew）"></a>服务续约（Renew）</h5><p>服务续约是由服务提供者方定期（默认为 <code>30</code> 秒）发起心跳的，主要是用来告知注册中心 <code>Eureka Server</code> 自己状态是正常的还活着，可以通过配置 <code>eureka.instance.lease-renewal-interval-in-seconds</code> 来修改，当然服务续约的前提是要配置 <code>eureka.client.register-with-eureka=true</code>，将该服务注册到注册中心中去，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/1YVRCjrm45sPOag.png" alt="service-provider-renew-sequence-chart.png"></p><h5 id="服务下线（Cancel）-1"><a href="#服务下线（Cancel）-1" class="headerlink" title="服务下线（Cancel）"></a>服务下线（Cancel）</h5><p>当服务提供者方服务停止时，要发送 <code>DELETE</code> 请求告知注册中心 <code>Eureka Server</code> 自己已经下线，好让注册中心将自己剔除下线，防止服务消费方从注册中心获取到不可用的服务。这个过程实现比较简单，在类 <code>DiscoveryClient</code> 的 <code>shutdown</code> 方法加上注解 <code>@PreDestroy</code>，当服务停止时会自动触发服务剔除下线，执行服务下线逻辑，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/UGIsoMjSh9xu23t.png" alt="service-provider-cancel-sequence-chart.png"></p><h4 id="服务消费者（Service-Consumer）"><a href="#服务消费者（Service-Consumer）" class="headerlink" title="服务消费者（Service Consumer）"></a>服务消费者（Service Consumer）</h4><p>这里的服务消费者如果不需要被其它服务调用的话，其实只会涉及到两个操作，分别是从注册中心 <code>获取服务列表（Fetch）</code> 和 <code>更新服务列表（Update）</code>。如果同时也需要注册到注册中心对外提供服务的话，那么剩下的过程和上文提到的服务提供者是一致的，这里不再阐述，接下来看看这两个操作是如何实现的。</p><h5 id="获取服务列表（Fetch）"><a href="#获取服务列表（Fetch）" class="headerlink" title="获取服务列表（Fetch）"></a>获取服务列表（Fetch）</h5><p>服务消费者方启动之后首先肯定是要先从注册中心 <code>Eureka Server</code> 获取到可用的服务列表同时本地也会缓存一份。这个获取服务列表的操作是在服务启动后 <code>DiscoverClient</code> 类实例化的时候执行的。</p><p><img src="https://i.loli.net/2020/03/15/ImUKf8lScgj37ZN.png" alt="service-consumer-fetchregistry.png"></p><p>可以看出，能发生这个获取服务列表的操作前提是要保证配置了 <code>eureka.client.fetch-registry=true</code>，该配置的默认值为 <code>true</code>，主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/Dy5LA439fcpjYav.png" alt="service-consumer-fetch-sequence-chart.png"></p><h5 id="更新服务列表（Update）"><a href="#更新服务列表（Update）" class="headerlink" title="更新服务列表（Update）"></a>更新服务列表（Update）</h5><p>由上面的 <code>获取服务列表（Fetch）</code> 操作过程可知，本地也会缓存一份，所以这里需要定期的去到注册中心 <code>Eureka Server</code> 获取服务的最新配置，然后比较更新本地缓存，这个更新的间隔时间可以通过配置 <code>eureka.client.registry-fetch-interval-seconds</code> 修改，默认为 <code>30</code> 秒，能进行这一步更新服务列表的前提是你要配置 <code>eureka.client.register-with-eureka=true</code>，这个默认值为 <code>true</code>。主要调用流程如下图所示：</p><p><img src="https://i.loli.net/2020/03/15/5Zi6MstvO87UoSJ.png" alt="service-consumer-update-sequence-chart.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>工作中项目使用的是 <code>Spring Cloud</code> 技术栈，它有一套非常完善的开源代码来整合 <code>Eureka</code>，使用起来非常方便。之前都是直接加注解和修改几个配置属性一气呵成的，没有深入了解过源码实现，本文主要是阐述了服务注册、服务发现等相关过程和实现方式，对 <code>Eureka</code> 服务发现组件有了更近一步的了解。</p><hr><p>参考文章<br><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">Netflix Eureka</a><br><a href="https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture" target="_blank" rel="noopener">Service Discovery in a Microservices Architecture</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;现在流行的微服务体系结构正在改变我们构建应用程序的方式，从单一的单体服务转变为越来越小的可单独部署的服务（称为&lt;code&gt;微服务&lt;/code&gt;），共同构成了我们的应用程序。当进行一个业务时不可避免就会存在多个服务之间调用，假如一个服务 A 要访问在另一台服务器部署的服务 B，那么前提是服务 A 要知道服务 B 所在机器的 IP 地址和服务对应的端口，最简单的方式就是让服务 A 自己去维护一份服务 B 的配置（包含 IP 地址和端口等信息），但是这种方式有几个明显的缺点：随着我们调用服务数量的增加，配置文件该如何维护；缺乏灵活性，如果服务 B 改变 IP 地址或者端口，服务 A 也要修改相应的文件配置；还有一个就是进行服务的动态扩容或缩小不方便。&lt;br&gt;一个比较好的解决方案就是 &lt;code&gt;服务发现（Service Discovery）&lt;/code&gt;。它抽象出来了一个注册中心，当一个新的服务上线时，它会将自己的 IP 和端口注册到注册中心去，会对注册的服务进行定期的心跳检测，当发现服务状态异常时将其从注册中心剔除下线。服务 A 只要从注册中心中获取服务 B 的信息即可，即使当服务 B 的 IP 或者端口变更了，服务 A 也无需修改，从一定程度上解耦了服务。服务发现目前业界有很多开源的实现，比如 &lt;code&gt;apache&lt;/code&gt; 的 &lt;a href=&quot;https://github.com/apache/zookeeper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zookeeper&lt;/a&gt;、 &lt;code&gt;Netflix&lt;/code&gt; 的 &lt;a href=&quot;https://github.com/Netflix/eureka&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;eureka&lt;/a&gt;、&lt;code&gt;hashicorp&lt;/code&gt; 的 &lt;a href=&quot;https://github.com/hashicorp/consul&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;consul&lt;/a&gt;、 &lt;code&gt;CoreOS&lt;/code&gt; 的 &lt;a href=&quot;https://github.com/etcd-io/etcd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;etcd&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="服务发现" scheme="https://www.mghio.cn/categories/Java/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
      <category term="Eureka" scheme="https://www.mghio.cn/categories/Java/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/Eureka/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="服务发现" scheme="https://www.mghio.cn/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
      <category term="Eureka" scheme="https://www.mghio.cn/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>2020 年 JVM 生态报告解读</title>
    <link href="https://www.mghio.cn/post/e09f0428.html"/>
    <id>https://www.mghio.cn/post/e09f0428.html</id>
    <published>2020-03-04T01:47:56.000Z</published>
    <updated>2020-03-06T05:56:29.111Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>做过 <code>Java</code> 开发的同学都知道，<code>JVM（Java 虚拟机）</code> 是 <code>Java</code> 实现的基础，虽然在平时工作中真正运用到的时候可能并不多，但是一个程序员想要上升到高级层次，那就必须知道 <code>Java</code> 到底是怎么运行的，这就有必要去学习了解 <code>JVM</code> 的相关知识了。学习 <code>JVM</code> 可以能更深入的理解 <code>Java</code> 这门语言，可以清楚知道Java程序是如何执行的以及为未来排查线上问题打下坚实的基础。接下来我们看看 2020 年的 <code>JVM</code> 生态报告和最新趋势，值得我们每个 <code>Java</code> 开发者去关注了解。</p><h4 id="JDK-厂商占比"><a href="#JDK-厂商占比" class="headerlink" title="JDK 厂商占比"></a>JDK 厂商占比</h4><p><code>Oracle JDK</code> 和 <code>Open JDK</code> 加起来占比将近 <code>60%</code>，其中 <code>Oracle JDK</code> 占比略多一些，<code>Oracle JDK</code> 和 <code>Open JDK</code> 都是市场上的热门选择，我们看看二者之间的一些差异。<code>Oracle JDK</code> 更多的关注稳定性，更适合企业级用户，而 <code>Open JDK</code> 相对而言没有那么稳定，它会经常发布一些新特性。<code>Oracle JDK</code> 支持长期发布的更改，而 <code>Open JDK</code> 仅支持计划和完成下一个发行版，还有一个就是 <code>Oracle JDK</code> 是根据 <a href="https://zh.wikipedia.org/wiki/Zlib%E6%8E%88%E6%9D%83%E6%9D%A1%E6%AC%BE" target="_blank" rel="noopener">二进制代码许可协议</a> 获得许可，而 <code>Open JDK</code> 是根据 <a href="https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81" target="_blank" rel="noopener">GPL v2</a> 许可获得许可。使用 <code>Oracle</code> 平台时会产生一些许可影响。如 <code>Oracle</code> 宣布的那样，在没有商业许可的情况下，在 2019 年 1 月之后发布的 <code>Oracle Java SE 8</code> 的公开更新将无法用于商业，商业或生产用途。但是，<code>Open JDK</code> 是完全开源的，可以自由使用。</p><a id="more"></a><p><img src="https://i.loli.net/2020/03/04/YZDLa9Be6H1kOpW.png" alt="which-java-vendor-use.png"></p><h4 id="愿意付费用户占比很少"><a href="#愿意付费用户占比很少" class="headerlink" title="愿意付费用户占比很少"></a>愿意付费用户占比很少</h4><p>只有 <code>9%</code> 的用户表示愿意为 <code>JDK</code> 支付费用，还有 <code>86%</code> 的用户表示并不想为 <code>JDK</code> 支付费用，可以看出大部分用户其实对 <code>JDK</code> 的付费使用还是不赞同的，目前来看，如果要真正实行付费模式还是有点难。不过人们选择为 <code>JDK</code> 支付费用时，<code>Oracle</code> 还是当之无愧的大赢家的。自从 <code>JDK9</code> 发布之后，以后每年的 3 月和 9 月都会发布一个新的版本，这个发布节奏的改变，这个对许多用户的版本更新策略还是有一定的影响。调查结果显示这个发布节奏的变更影响了三分之一的开发者们是否决定为其支付费用。</p><p><img src="https://i.loli.net/2020/03/04/z5iKXwyclG48ZPF.png" alt="paying-for-jdk-support.png"></p><h4 id="Java-8-仍然是主流版本"><a href="#Java-8-仍然是主流版本" class="headerlink" title="Java 8 仍然是主流版本"></a>Java 8 仍然是主流版本</h4><p>从 <code>Java 9</code> 之后对 <code>JDK</code> 的结构做了很大的调整，这也是影响人们升级的原因之一，根据报告结果来看 <code>Java 8</code> 仍然是大家使用最多的版本，但是在 2018 年 9 月发布了第一个 <code>LTS(长期支持)</code> 版的 <code>Java 11</code> 之后，有四分之一的开发者在生产环境中使用了 <code>Java 11</code>。因为发布节奏的原因，大部分开发者还是不愿意每 6 个月就对版本进行一次更新，版本迁移成本其实也不低，还有新版本在生产环境的稳定性也是其中的一个考虑因素。</p><p><img src="https://i.loli.net/2020/03/04/ma1sHtEYzVOPU4v.png" alt="java-version-use-production.png"></p><h4 id="Kotlin-在-JVM-类语言中占比第二"><a href="#Kotlin-在-JVM-类语言中占比第二" class="headerlink" title="Kotlin 在 JVM 类语言中占比第二"></a>Kotlin 在 JVM 类语言中占比第二</h4><p>在 <code>JVM</code> 类语言语言中 <code>Java</code> 占比 <code>86.9%</code> 稳居第一，除了 <code>Java</code> 语言之外，<code>Kotlin</code> 语言在 <code>JVM</code> 类语言占比第二占比 <code>5.5%</code>，<code>Kotlin</code> 从去年的 <code>2.4%</code> 增加到今年的 <code>5.5%</code>，<code>JVM</code> 类语言的用户中 <code>Kotlin</code> 使用率的增长，因为它可以与 <code>Java</code> 无缝集成也不足为奇，像在 <code>Spring Boot</code> 框架中使用 <code>Kotlin</code> 进行开发也很容易。<code>Kotlin</code> 也一直在创新，积极拥抱 <code>Java</code> 的大腿，在 <code>Java</code> 的新版本中也在试图整合一些 <code>Kotlin</code> 的概念。</p><p><img src="https://i.loli.net/2020/03/04/KiqruXYm9AG6Nw2.png" alt="jvm-language-use.png"></p><h4 id="Spring-依然是-Java-框架中的王者"><a href="#Spring-依然是-Java-框架中的王者" class="headerlink" title="Spring 依然是 Java 框架中的王者"></a>Spring 依然是 Java 框架中的王者</h4><p>有十分之六的开发者依赖 <code>Spring</code> 框架来构建他们的程序，这对于众多的第三方开源框架来说，这是一个很高的占比，<code>Spring Framework</code> 依然是 <code>Java</code> 开发框架中的王者，<code>Spring</code> 框架已经发布了很长一段时间了，通过长时间的改进和创新，无疑 <code>Spring</code> 现在已经成为 <code>Java</code> 生态系统中的最重要的框架。在众多的使用者中有将近三分之二的用户使用 <code>Spring 5</code>，可见大家对 <code>Spring</code> 框架的新版使用率还是很高的。</p><p><img src="https://i.loli.net/2020/03/04/Xwg1GLW9jNl6YTv.png" alt="spring-version-use.png"></p><h4 id="Spring-Boot-是主流的服务器端-Web-框架"><a href="#Spring-Boot-是主流的服务器端-Web-框架" class="headerlink" title="Spring Boot 是主流的服务器端 Web 框架"></a>Spring Boot 是主流的服务器端 Web 框架</h4><p>服务器端依然是 <code>Spring</code> 的天下，其中有一半的人使用的是 <code>Spring Boot</code> 框架，还有将近的三分之一的人使用的是 <code>Spring MVC</code> 框架，前几年比较火的 <code>Struts</code> 框架已经开始没落了，这个占比和现在市场上比较流行微服务架构是分不开，因为 <code>Spring Boot</code> 框架天生就是为微服务而生的，它可以快速实现微服务。使用基于 <code>Spring Boot</code> 的 <code>Spring Cloud</code> 框架可以快速搭建一个分布式的服务或应用。</p><p><img src="https://i.loli.net/2020/03/04/UEJbGHIgz6YLsFa.png" alt="server-side-web-framework.png"></p><h4 id="IntelliJ-IDEA-是主流的开发工具"><a href="#IntelliJ-IDEA-是主流的开发工具" class="headerlink" title="IntelliJ IDEA 是主流的开发工具"></a>IntelliJ IDEA 是主流的开发工具</h4><p><code>IntelliJ IDEA</code> 是 <code>Java</code> 开发者们使用最广泛的开发工具，调查结果显示有 <code>62%</code> 的开发人员使用社区免费版和付费终极版。<code>Apache NetBeans</code> 以 <code>10%</code> 的市场份额保持在第三位，和去年的调查结果一致。可以发现被业界广泛称赞的 <code>VS Code</code> 神级编辑器在 <code>Java</code> 开发人员中并没有想象的那么受欢迎。</p><p><img src="https://i.loli.net/2020/03/04/nUVkcPDbW3zKoI1.png" alt="which-ide-use.png"></p><h4 id="Maven-是主流的项目构建管理工具"><a href="#Maven-是主流的项目构建管理工具" class="headerlink" title="Maven 是主流的项目构建管理工具"></a>Maven 是主流的项目构建管理工具</h4><p><code>Maven</code> 是一个软件项目管理和自动构建的工具，由 <code>Apache 基金会</code> 维护。它基于项目对象模型(POM)概念，<code>Maven</code> 利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。调查结果显示它在排名仍是第一，一直都是主流的项目构建工具，排名第二的 <code>Gradle</code> 一直保持着增长的趋势，在 2019 年占比达到四分之一，而在 2012 年占比高达 <code>40%</code> 的老牌的构建工具 <code>Ant</code> 将逐渐退出舞台，到 2019 年占比不到 <code>10%</code>。可以明确的是，构建工具之间的竞争从不会停止，能否及时更新发布一些可以解决使用者痛点的工具是大家选择的因素之一。</p><p><img src="https://i.loli.net/2020/03/04/Cst4LldU9Zz1G8B.png" alt="which-build-tool-use.png"></p><h4 id="Jenkins-仍然是持续集成工具中的王者"><a href="#Jenkins-仍然是持续集成工具中的王者" class="headerlink" title="Jenkins 仍然是持续集成工具中的王者"></a>Jenkins 仍然是持续集成工具中的王者</h4><p>和我们大多数 <code>Java</code> 开发人员的期望一致，<code>Jenkins</code> 以高达 <code>58%</code> 的占比排名稳居第一，排名第二的 <code>GitLab</code> 占比仅为 <code>6%</code>，有趣的是没有使用工具的也高达 <code>12%</code>，虽然不适用工具的人数占比比去年低了很多，但是这个占比还是让人有点儿惊讶。</p><p><img src="https://i.loli.net/2020/03/05/SRBTX6NVA4WJsyd.png" alt="which-CI-server-use.png"></p><hr><p>生态报告来源：<a href="https://snyk.io/blog/jvm-ecosystem-report-2020" target="_blank" rel="noopener">https://snyk.io/blog/jvm-ecosystem-report-2020</a></p><p>PS：关注公众号「mghio」，回复关键字 <code>JVM</code> 获取 2020 年 <code>JVM</code> 生态报告 <code>PDF</code> 版原文。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;做过 &lt;code&gt;Java&lt;/code&gt; 开发的同学都知道，&lt;code&gt;JVM（Java 虚拟机）&lt;/code&gt; 是 &lt;code&gt;Java&lt;/code&gt; 实现的基础，虽然在平时工作中真正运用到的时候可能并不多，但是一个程序员想要上升到高级层次，那就必须知道 &lt;code&gt;Java&lt;/code&gt; 到底是怎么运行的，这就有必要去学习了解 &lt;code&gt;JVM&lt;/code&gt; 的相关知识了。学习 &lt;code&gt;JVM&lt;/code&gt; 可以能更深入的理解 &lt;code&gt;Java&lt;/code&gt; 这门语言，可以清楚知道Java程序是如何执行的以及为未来排查线上问题打下坚实的基础。接下来我们看看 2020 年的 &lt;code&gt;JVM&lt;/code&gt; 生态报告和最新趋势，值得我们每个 &lt;code&gt;Java&lt;/code&gt; 开发者去关注了解。&lt;/p&gt;
&lt;h4 id=&quot;JDK-厂商占比&quot;&gt;&lt;a href=&quot;#JDK-厂商占比&quot; class=&quot;headerlink&quot; title=&quot;JDK 厂商占比&quot;&gt;&lt;/a&gt;JDK 厂商占比&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Oracle JDK&lt;/code&gt; 和 &lt;code&gt;Open JDK&lt;/code&gt; 加起来占比将近 &lt;code&gt;60%&lt;/code&gt;，其中 &lt;code&gt;Oracle JDK&lt;/code&gt; 占比略多一些，&lt;code&gt;Oracle JDK&lt;/code&gt; 和 &lt;code&gt;Open JDK&lt;/code&gt; 都是市场上的热门选择，我们看看二者之间的一些差异。&lt;code&gt;Oracle JDK&lt;/code&gt; 更多的关注稳定性，更适合企业级用户，而 &lt;code&gt;Open JDK&lt;/code&gt; 相对而言没有那么稳定，它会经常发布一些新特性。&lt;code&gt;Oracle JDK&lt;/code&gt; 支持长期发布的更改，而 &lt;code&gt;Open JDK&lt;/code&gt; 仅支持计划和完成下一个发行版，还有一个就是 &lt;code&gt;Oracle JDK&lt;/code&gt; 是根据 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Zlib%E6%8E%88%E6%9D%83%E6%9D%A1%E6%AC%BE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二进制代码许可协议&lt;/a&gt; 获得许可，而 &lt;code&gt;Open JDK&lt;/code&gt; 是根据 &lt;a href=&quot;https://zh.wikipedia.org/wiki/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GPL v2&lt;/a&gt; 许可获得许可。使用 &lt;code&gt;Oracle&lt;/code&gt; 平台时会产生一些许可影响。如 &lt;code&gt;Oracle&lt;/code&gt; 宣布的那样，在没有商业许可的情况下，在 2019 年 1 月之后发布的 &lt;code&gt;Oracle Java SE 8&lt;/code&gt; 的公开更新将无法用于商业，商业或生产用途。但是，&lt;code&gt;Open JDK&lt;/code&gt; 是完全开源的，可以自由使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="JVM" scheme="https://www.mghio.cn/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.mghio.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统之 — CAP 定理</title>
    <link href="https://www.mghio.cn/post/11cb7677.html"/>
    <id>https://www.mghio.cn/post/11cb7677.html</id>
    <published>2020-02-29T01:12:06.000Z</published>
    <updated>2020-04-10T13:23:19.242Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在互联网时代，我们的应用都是分布式系统，部署在 N 台机器上。说到分布式系统我们就不得不说分布式系统的祖先——集中式系统。它和分布式系统是两个完全相反的概念，集中式系统就是把所有的程序和功能都放到一台主机上，从而对外提供服务。集中式系统的优点就是容易理解、维护方便，它的的弊端也很明显，如果这个主机出故障了那么整个系统就崩溃了。著名投资家巴菲特有个关于投资的名言：</p><blockquote><p>不要把鸡蛋放在一个篮子里</p></blockquote><p>对于我们的系统而言也是如此，我们不可能保证主机永远不坏、也无法保证自己的程序永远不会出 <code>bug</code>，所以问题是无法避免的，我们只能把“鸡蛋”分散到不同的“篮子”里，降低系统出故障的风险，这就是我们为什么需要分布式系统的原因之一。使用分布式系统的另一个理由就是扩展性，毕竟单台主机都会有性能的极限，分布式系统可以通过增加主机数量来实现横向水平性能的扩展。接下来我们看看分布式系统中的一个基本定理——<code>CAP定理</code>。</p><a id="more"></a><h4 id="什么是-CAP-定理"><a href="#什么是-CAP-定理" class="headerlink" title="什么是 CAP 定理"></a>什么是 CAP 定理</h4><p><code>CAP 定理</code>指出对于一个分布式系统来说，不可能同时满足以下三点：</p><ul><li>一致性（Consistency）</li><li>可用性（Availability）</li><li>分区容错性（Partition tolerance）</li></ul><p>定理看起来很简单，但是<code>一致性</code>、<code>可用性</code>、<code>分区容错性</code>究竟是代表什么意思呢？理解定理的最简单的方式就是想象一个有两个节点分别处在不同的分区（PS：可以简单的把分区理解为不同的子网络）的分布式系统。</p><h4 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h4><p>我们假定一个很简单的分布式系统，系统由两个系统 <code>S1</code> 和 <code>S2</code> 组成。两个系统上面有两个相同的变量 <code>K</code>，该变量在两个系统对应的初始值为 <code>V0</code>。系统 <code>S1</code> 和 <code>S2</code> 可以进行通信同时也对外提供服务。我们假定的分布式系统如下所示：</p><p><img src="https://i.loli.net/2020/02/29/S7GyDcNF5zaxkhW.png" alt="cap-distributed-system.png"></p><p>客户端 <code>client</code> 可以向 <code>S1</code> 和 <code>S2</code> 任何一个系统发起读和写请求。当一个服务接收到发过来的请求后进行一些相关业务操作，然后返回给客户端 <code>client</code>，发起写请求的过程如下图所示：</p><p><img src="https://i.loli.net/2020/04/10/O8aCKB6FS9ncYoQ.png" alt="cap-client-send-write-request.png"></p><p>客户端发起读请求的过程如下所示：</p><p><img src="https://i.loli.net/2020/02/29/6Qa7LRwxWbsfpjA.png" alt="cap-client-send-read-request.png"></p><p>我们的分布式系统模型建立好了，接下来我们通过这个模型来分析<code>CAP 定理</code>中的一致性、可用性和分区容错性的具体含义。</p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p><code>一致性</code>要求在一个写操作完成之后的任何读操作都必须返回该值或者以后进行写操作的结果。在满足一致性的分布式系统中，客户端发起一个写请求到分布式系统的任何一个子系统中，然后再向该系统中任何一个子系统发起读请求查询该变量对应的值，都会返回上次更新的最新结果。客户端向一个<code>不满足一致性</code>的分布式系统发起写-读请求的过程如下所示：</p><p><img src="https://i.loli.net/2020/02/29/UWgRHxphk81sAuB.png" alt="cap-inconsistent-system.png"></p><p>当客户端向系统 <code>S1</code> 发送写请求(write V1)，得到成功返回响应后，再向系统 <code>S2</code> 发送读请求读取该变量的值，系统 <code>S2</code> 还是返回旧值 <code>V0</code>。另一方面，我们看看客户端向一个满足<code>一致性</code>的分布式系统发起写-读请求的过程：</p><p><img src="https://i.loli.net/2020/02/29/sdY5hNPoUHrpQMc.png" alt="cap-consistent-system.png"></p><p>在这个满足一致性的系统中，在上述过程中系统 <code>S1</code> 在返回客户端请求结果之前会先把最新值 <code>V1</code> 发送到系统 <code>S2</code>，然后才返回客户端的写请求结果。因此，当客户端再去请求系统 <code>S2</code> 的时候就会返回最新值 <code>V1</code>。</p><h4 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h4><p><code>可用性</code>要求在分布式系统中非故障节点收到的每一个请求都必须返回响应。在一个满足<code>可用性</code>的分布式系统中，如果客户端向系统中任意一个节点发送请求并且服务器没有崩溃的情况下，则该节点必须响应客户端，不管是哪个节点，只要收到请求，就必须告诉用户，到底是 <code>V0</code> 还是 <code>V1</code>，否则就不满足可用性，不允许服务器忽略客户端的请求。</p><h4 id="分区容错性（Partition-tolerance）"><a href="#分区容错性（Partition-tolerance）" class="headerlink" title="分区容错性（Partition tolerance）"></a>分区容错性（Partition tolerance）</h4><p>分区容错表明当消息从一个节点向另一个节点发送消息的过程中，消息可能会丢失。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在<code>一致性</code>和<code>可用性</code>之间做出选择。如果所有消息都无法发送的话，分布式系统的各个节点将无法同步消息。如下所示：</p><p><img src="https://i.loli.net/2020/02/29/QMkRvOA2aLWNPmr.png" alt="cap-partition-tolerance.png"></p><p>一般来说，分区容错无法避免，因此可以认为<code>CAP定理</code>的<code>分区容错性</code>总是成立。<code>CAP 定理</code>告诉我们，剩下的<code>一致性</code>和<code>可用性</code>无法同时做到。通常我们为了分区容错，我们的系统必须保证能够在任意网络分区下正常运行。</p><h4 id="为何不能同时满足一致性和可用性"><a href="#为何不能同时满足一致性和可用性" class="headerlink" title="为何不能同时满足一致性和可用性"></a>为何不能同时满足一致性和可用性</h4><p>我们现在知道了<code>一致性</code>、<code>可用性</code>、<code>分区容错性</code>所表示的具体含义，接下来看看为什么在一个分布式系统中不能同时满足<code>一致性</code>和<code>可用性</code>。我们假定存在一个同时满足这三个特性的系统。首先要做的就是对该系统进行分区，分区后系统如下所示：</p><p><img src="https://i.loli.net/2020/02/29/SU9NmiW7PqKwe25.png" alt="cap-partition.png"></p><p>下一步，客户端向分布式系统的节点 <code>S1</code> 发送一个写请求(write V1)，系统只要是可用的，该节点总是会返回响应。但是系统存在网络分区，因此节点 <code>S1</code> 无法将最新值 <code>V1</code> 通知节点 <code>S2</code> 去更新。如下所示：</p><p><img src="https://i.loli.net/2020/02/29/vDEw5VOk6fiHpzb.png" alt="cap-eight.png"></p><p>接下来，客户端向分布式系统的节点 <code>S2</code> 发送一个读请求（read K）查询变量 <code>K</code> 的值，同样的，系统只要是可用的，该节点总是会返回响应，但是系统存在网络分区，因此节点 <code>S2</code> 无法从节点 <code>S1</code> 获取到最新值 <code>V1</code> 进行更新。如下所示：</p><p><img src="https://i.loli.net/2020/02/29/RdfvYtVC16bMnZQ.png" alt="cap-nine.png"></p><p>客户端已经向节点 <code>S1</code> 发送写请求（write V1）成功后，再向节点 <code>S2</code> 发起读请求，得到的返回值是旧值 <code>V0</code>。这和我们假设的一致性冲突。如果要保证节点 <code>S1</code> 的一致性，那么节点 <code>S1</code> 必须在写操作时，锁定节点 <code>S2</code> 的读操作和写操作。只有当数据同步后，才能重新开放节点 <code>S2</code> 的读写操作。那么在锁定期间，<code>S2</code>不能读写，它就没有可用性了。再来看看，我们如果保证节点 <code>S2</code> 的可用性，那么就不能锁定节点 <code>S2</code> 的读写操作，所以一致性不成立。所以，节点 <code>S2</code> 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性，如果追求所有节点的可用性，那就没法做到一致性了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>CAP定理</code>指明了分布式系统的三大指标<code>一致性（Consistency）</code>、<code>可用性（Availability）</code>和<code>分区容错性（Partition tolerance）</code>不能同时满足，该定理是分布式系统的基本定理，也是理解分布式系统的起点。(PS: 像我们常用的注册中心 <code>Eureka</code>，因为节点之间的状态同步采用的异步方式，所以不能保证任意时刻各个节点间的状态一定是一致的，只能保证节点间最终状态是一致的。所以按照<code>CAP理论</code>，<code>Eureka</code> 的选择就是放弃了<code>一致性</code>，选择<code>可用性</code>和<code>分区容错性</code>。)</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在互联网时代，我们的应用都是分布式系统，部署在 N 台机器上。说到分布式系统我们就不得不说分布式系统的祖先——集中式系统。它和分布式系统是两个完全相反的概念，集中式系统就是把所有的程序和功能都放到一台主机上，从而对外提供服务。集中式系统的优点就是容易理解、维护方便，它的的弊端也很明显，如果这个主机出故障了那么整个系统就崩溃了。著名投资家巴菲特有个关于投资的名言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要把鸡蛋放在一个篮子里&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于我们的系统而言也是如此，我们不可能保证主机永远不坏、也无法保证自己的程序永远不会出 &lt;code&gt;bug&lt;/code&gt;，所以问题是无法避免的，我们只能把“鸡蛋”分散到不同的“篮子”里，降低系统出故障的风险，这就是我们为什么需要分布式系统的原因之一。使用分布式系统的另一个理由就是扩展性，毕竟单台主机都会有性能的极限，分布式系统可以通过增加主机数量来实现横向水平性能的扩展。接下来我们看看分布式系统中的一个基本定理——&lt;code&gt;CAP定理&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式系统" scheme="https://www.mghio.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="CAP定理" scheme="https://www.mghio.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/CAP%E5%AE%9A%E7%90%86/"/>
    
    
      <category term="分布式系统" scheme="https://www.mghio.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="CAP定理" scheme="https://www.mghio.cn/tags/CAP%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 最新版（2019.3）激活教程</title>
    <link href="https://www.mghio.cn/post/f440d00b.html"/>
    <id>https://www.mghio.cn/post/f440d00b.html</id>
    <published>2020-01-12T00:28:07.000Z</published>
    <updated>2020-01-12T10:45:50.230Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>相信做 <code>Java</code> 开发的朋友们绝大部分人应该都是用 <a href="https://www.jetbrains.com/idea" target="_blank" rel="noopener">IntelliJ IDEA</a> 作为开发工具，没用过的朋友们建议将你的开发工具换成这个，关于它的优点可以去 <code>Google</code> 一下，我之前都是用 <a href="https://www.eclipse.org" target="_blank" rel="noopener">Eclipse</a> 作为开发工具，自从用过一次 <code>IDEA</code> 之后就再也回不去了。。。今天早上<del>更新</del>（作死）了一下 <code>IDEA</code> 到最新版（<code>2019.3.1</code>），安装完毕之后进入就提示说之前的激活码失效了，经过一顿搜索之后终于成功激活了，在此记录一下激活过程。</p><p><img src="https://i.loli.net/2020/01/12/mFe5thxWnykXUY6.png" alt="start_welcome.png"></p><a id="more"></a><h4 id="Step-1-升级-IDEA-到-2019-3-版本"><a href="#Step-1-升级-IDEA-到-2019-3-版本" class="headerlink" title="Step 1 升级 IDEA 到 2019.3 版本"></a>Step 1 升级 IDEA 到 2019.3 版本</h4><p>如果之前电脑安装过 <code>IDEA</code>，依次选择菜单项 <code>IntelliJ IDEA -&gt; About IntelliJ IDEA</code> 查看 <code>IDEA</code> 的版本（<code>PS: windows 系统菜单项可能不同</code>），如果不是 <code>2019.3</code> 版本，则要到 <a href="https://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">官网</a> 下载 <code>2019.3.1</code> 版本，具体安装过程比较简单，安装过程有问题的朋友们请自行 <code>Google</code>。</p><p><img src="https://i.loli.net/2020/01/12/15uoLas2jgX9DYl.png" alt="about_idea.png"></p><h4 id="Step-2-下载补丁包"><a href="#Step-2-下载补丁包" class="headerlink" title="Step 2 下载补丁包"></a>Step 2 下载补丁包</h4><p>扫码关注微信公众号 <code>mghio</code> 后回复「<code>idea</code>」获取激活补丁包。</p><p><img src="https://i.loli.net/2020/01/12/tXKpok8JAqQZ7ER.jpg" alt="wechat_subscriber.jpg"></p><h4 id="Step-3-编辑-IDEA-的-idea-vmoptions-文件"><a href="#Step-3-编辑-IDEA-的-idea-vmoptions-文件" class="headerlink" title="Step 3 编辑 IDEA 的 idea.vmoptions 文件"></a>Step 3 编辑 <code>IDEA</code> 的 <code>idea.vmoptions</code> 文件</h4><p>经过 <code>Step 1</code> 安装完成之后，打开 <code>IDEA</code> 开发工具，然后它会提示要激活，这里我们先选择 <code>试用 30 天</code>。</p><p><img src="https://i.loli.net/2020/01/12/VmzJvbaqtU8PdlM.png" alt="use_evaluate_free.png"></p><p>然后将 <code>Step 2</code> 我们下载好的激活补丁包 <code>jetbrains-agent.jar</code> 拷贝到 <code>IDEA</code> 安装目录的 <code>bin</code> 目录下。</p><p><img src="https://i.loli.net/2020/01/12/GIcljvdAbg38SpT.png" alt="copy_to_bin.png"></p><p>编辑 <code>IDEA</code> 的 <code>idea.vmoptions</code>（<code>PS:推荐直接从</code>IDEA<code>中编辑</code>），依次选择菜单项 <code>Help -&gt; Edit Custom VM Optons...</code>。</p><p><img src="https://i.loli.net/2020/01/12/jWlQZ9xrho7Uebq.png" alt="config_vm_options.png"></p><p>点击打开编辑，在其内容最后追加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:你的 IDEA 的安装目录/bin/jetbrains-agent.jar</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/12/Xj42VQ7MuTRKFNc.png" alt="edit_idea_vmoptions.png"></p><h4 id="Step-4-重启后输入激活码激活"><a href="#Step-4-重启后输入激活码激活" class="headerlink" title="Step 4 重启后输入激活码激活"></a>Step 4 重启后输入激活码激活</h4><p>退出 <code>IDEA</code> 重新启动进入，依次选择菜单项 <code>Help -&gt; Register...</code>。</p><p><img src="https://i.loli.net/2020/01/12/4itcGQqxwFSgTWJ.png" alt="idea_register_enter.png"></p><p>进入后选择 <code>Activation code</code> 以输入激活码方式激活，在第二步 <code>Step 2 下载补丁包</code> 中下载的 <code>txt</code> 文件（<code>文件名：激活码.txt</code>）为激活码，这里也贴一下，激活码如下（<code>PS: 鼠标移至激活码区域，点击右侧 「复制」 按钮即可复制</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KNBB2QUUR1-eyJsaWNlbnNlSWQiOiJLTkJCMlFVVVIxIiwibGljZW5zZWVOYW1lIjoiZ2hib2tlIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IiIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiQUMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRFBOIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBTIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRNIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkNMIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJTMCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSTSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJXUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSU1UiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiMTI3OTY4NzcvMCIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-1iV7BA/baNqv0Q5yUnAphUmh66QhkDRX+qPL09ICuEicBqiPOBxmVLLCVUpkxhrNyfmOtat2LcHwcX/NHkYXdoW+6aS0S388xe1PV2oodiPBhFlEaOac42UQLgP4EidfGQSvKwC9tR1zL5b2CJPQKZ7iiHh/iKBQxP6OBMUP1T7j3Fe1rlxfYPc92HRZf6cO+C0+buJP5ERZkyIn5ZrVM4TEnWrRHbpL8SVNq4yqfc+NwoRzRSNC++81VDS3AXv9c91YeZJz6JXO7AokIk54wltr42FLNuKbozvB/HCxV9PA5vIiM+kZY1K0w5ytgxEYKqA87adA7R5xL/crpaMxHQ==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/12/btQoAjC5xzFvgWU.png" alt="activate_success.png"></p><p>部分朋友输入以上激活码后点击激活可能会出现如下报错提示：<code>Your activation code could not be validated（error 1653219）</code>，未出现此错误提示的朋友可以跳过以下步骤。</p><p><img src="https://i.loli.net/2020/01/12/5sxrd3kGpRTCLw6.png" alt="activate_error.png"></p><p>出现此错误是因为没有屏蔽 <code>account.jetbrains.com</code> 的 <code>443</code> 端口，因此修改本地 <code>hosts</code> 文件在其内容追加以下内容即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0 https://account.jetbrains.com:443</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/12/zrfTvG6gC9HWAZS.png" alt="modify_mac_hosts_file.png"></p><p>修改保存 <code>hosts</code> 文件后，再次激活即可激活。</p><p><img src="https://i.loli.net/2020/01/12/Os3JUgZVYlAXLMG.png" alt="enter_licenses_success.png"></p><h4 id="Step-5-验证是否激活"><a href="#Step-5-验证是否激活" class="headerlink" title="Step 5 验证是否激活"></a>Step 5 验证是否激活</h4><p>重启 <code>IDEA</code> 后，依次选择菜单项 <code>IntelliJ IDEA -&gt; About IntelliJ IDEA</code>，可以看到激活到期日期为：<code>2089-07-08</code>。</p><p><img src="https://i.loli.net/2020/01/12/FW17nLZvjorsUIm.png" alt="activated_display.png"></p><p>至此， <code>IntelliJ IDEA</code> 激活完成。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上激活步骤只针对 <code>IntelliJ IDEA</code> 的 <code>2019.3.1</code> 版本，不同的版本可能无法激活，在激活前请确认好你所使用的 <code>IDEA</code> 版本。激活码和激活补丁包要一起使用，单独使用无效，在激活过程中有问题请在文末留言区留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;相信做 &lt;code&gt;Java&lt;/code&gt; 开发的朋友们绝大部分人应该都是用 &lt;a href=&quot;https://www.jetbrains.com/idea&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IntelliJ IDEA&lt;/a&gt; 作为开发工具，没用过的朋友们建议将你的开发工具换成这个，关于它的优点可以去 &lt;code&gt;Google&lt;/code&gt; 一下，我之前都是用 &lt;a href=&quot;https://www.eclipse.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Eclipse&lt;/a&gt; 作为开发工具，自从用过一次 &lt;code&gt;IDEA&lt;/code&gt; 之后就再也回不去了。。。今天早上&lt;del&gt;更新&lt;/del&gt;（作死）了一下 &lt;code&gt;IDEA&lt;/code&gt; 到最新版（&lt;code&gt;2019.3.1&lt;/code&gt;），安装完毕之后进入就提示说之前的激活码失效了，经过一顿搜索之后终于成功激活了，在此记录一下激活过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/mFe5thxWnykXUY6.png&quot; alt=&quot;start_welcome.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="IDEA" scheme="https://www.mghio.cn/categories/Java/IDEA/"/>
    
      <category term="工具" scheme="https://www.mghio.cn/categories/Java/IDEA/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="IDEA" scheme="https://www.mghio.cn/tags/IDEA/"/>
    
      <category term="工具" scheme="https://www.mghio.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射机制（二）</title>
    <link href="https://www.mghio.cn/post/7528c810.html"/>
    <id>https://www.mghio.cn/post/7528c810.html</id>
    <published>2020-01-04T08:51:05.000Z</published>
    <updated>2020-01-05T14:51:30.490Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上篇 <a href="http://www.mghio.cn/post/102cd3d9.html">Java 反射机制（一）</a> 介绍了一些 <code>Java</code> 反射相关的常用 API ，在知道了如何去使用反射之后，作为一个合格的工程师，下一步肯定是要去了解它的如何实现的，我们今天就来看看在 <code>JDK</code> 源码中是如何去实现反射的(<code>PS:以下源码分析基于 JDK1.8</code>)。</p><h4 id="Field-类-set-方法的实现"><a href="#Field-类-set-方法的实现" class="headerlink" title="Field 类 set 方法的实现"></a>Field 类 set 方法的实现</h4><p><code>Field</code> 类的 <code>set</code> 方法是在运行时用来动态修改一个类的属性的值，进入到 <code>Field</code> 类的 <code>set</code> 方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getFieldAccessor(obj).set(obj, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据 <code>override</code> 判断是否需要检查字段的访问权限，然后通过 <code>getFieldAccessor</code> 方法获得一个 <code>FieldAccessor</code> 字段访问者对象，最后调用的是 <code>FieldAccessor</code> 类的 <code>set</code> 方法进行下一步操作的，<code>FieldAccessor</code> 是一个接口，定义了对字段的一些操作，该接口有如下一些实现类：</p><a id="more"></a><p><img src="https://i.loli.net/2020/01/04/Dj24fGFKh8Qdzgb.png" alt="fieldaccessor_implements.png"></p><p>要看 <code>set</code> 到底调用的是哪个实现类的方法，那么我们需要看看 <code>getFieldAccessor()</code> 返回的是哪个类的对象，下面是 <code>getFieldAccessor</code> 方法的源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// security check is done before calling this method</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> FieldAccessor <span class="title">getFieldAccessor</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ov = override;</span><br><span class="line">    FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;</span><br><span class="line">    <span class="keyword">return</span> (a != <span class="keyword">null</span>) ? a : acquireFieldAccessor(ov);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先通过 <code>override</code> 来获取不同的缓存的 <code>FieldAccessor</code>，其中 <code>overrideFieldAccessor</code> 代表本类覆盖父类的字段访问者对象缓存，<code>fieldAccessor</code> 是本类的字段访问器对象缓存。如果缓存存在的话就直接复用之前的对象，否则就调用 <code>Field</code> 类的 <code>acquireFieldAccessor</code> 方法获取。我们进入到 <code>acquireFieldAccessor</code> 方法中看看，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FieldAccessor <span class="title">acquireFieldAccessor</span><span class="params">(<span class="keyword">boolean</span> overrideFinalCheck)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    FieldAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getFieldAccessor(overrideFinalCheck);</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (overrideFinalCheck)</span><br><span class="line">            overrideFieldAccessor = tmp;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fieldAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newFieldAccessor(<span class="keyword">this</span>, overrideFinalCheck);</span><br><span class="line">        setFieldAccessor(tmp, overrideFinalCheck);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>acquireFieldAccessor</code> 的源码中我们可以看到，先判断是否已存在 <code>FieldAccessor</code> 对象，如果存在的话那么就会复用之前的 <code>FieldAccessor</code> 对象，否则就使用 <code>reflectionFactory</code> 工厂的 <code>newFieldAccessor</code> 方法生成一个新的 <code>FieldAccessor</code> 对象出来。所以我们就要进到 <code>newFieldAccessor</code> 方法里面看看是如何生成的，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field var1, <span class="keyword">boolean</span> var2)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    <span class="keyword">return</span> UnsafeFieldAccessorFactory.newFieldAccessor(var1, var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>newFieldAccessor</code> 方法代码可以得知，在方法里面是通过 <code>UnsafeFieldAccessorFactory</code> 类的 <code>static</code> 方法 <code>newFieldAccessor</code> 来生产 <code>FieldAccessor</code> 的，那么我们继续进入到 <code>UnsafeFieldAccessorFactory</code> 类的 <code>newFieldAccessor</code> 方法里面看看，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field var0, <span class="keyword">boolean</span> var1)</span> </span>&#123;</span><br><span class="line">    Class var2 = var0.getType();</span><br><span class="line">    <span class="keyword">boolean</span> var3 = Modifier.isStatic(var0.getModifiers());</span><br><span class="line">    <span class="keyword">boolean</span> var4 = Modifier.isFinal(var0.getModifiers());</span><br><span class="line">    <span class="keyword">boolean</span> var5 = Modifier.isVolatile(var0.getModifiers());</span><br><span class="line">    <span class="keyword">boolean</span> var6 = var4 || var5;</span><br><span class="line">    <span class="keyword">boolean</span> var7 = var4 &amp;&amp; (var3 || !var1);</span><br><span class="line">    <span class="keyword">if</span> (var3) &#123;</span><br><span class="line">      UnsafeFieldAccessorImpl.unsafe.ensureClassInitialized(var0.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (!var6) &#123;</span><br><span class="line">        <span class="keyword">if</span> (var2 == Boolean.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticBooleanFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Byte.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticByteFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Short.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticShortFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Character.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticCharacterFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Integer.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticIntegerFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Long.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticLongFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var2 == Float.TYPE) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticFloatFieldAccessorImpl(var0);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (FieldAccessor)(var2 == Double.TYPE ? <span class="keyword">new</span> UnsafeStaticDoubleFieldAccessorImpl(var0) : <span class="keyword">new</span> UnsafeStaticObjectFieldAccessorImpl(var0));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 剩下的部分省略...</span></span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上 <code>UnsafeFieldAccessorFactory</code> 类的 <code>newFieldAccessor</code> 方法代码可以看出，方法里面通过类的字段修饰符类型和字段的类类型共同决定返回的 <code>FieldAccessor</code> 实现类，这里要注意一下方法里面这几个变量的含义：</p><ul><li>var3（isStatic）：静态属性，也就是 <code>static</code> 关键字修饰的属性。</li><li>var4（isFinal）：<code>final</code> 关键字修饰的属性。</li><li>var5（isVolatile）：<code>valatile</code> 关键字修饰的属性。</li><li>var6（isQualified）：<code>valatile</code> 关键字或者 <code>final</code> 关键字修饰的属性。</li><li>var7 (isReadOnly)：是否只读属性，<code>final</code> 关键字修饰的属性或者 <code>static</code> 关键字修饰并且不能覆盖（<code>override = false</code>）的属性</li></ul><p>举一个例子，假设在一个类中的字段声明为 <code>public static String name</code>，那么返回的字段访问器为 <code>UnsafeStaticCharacterFieldAccessorImpl</code>，我们看看这个类的 <code>set</code> 方法是如何实现的，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object var1, Object var2)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFinal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.throwFinalFieldIllegalAccessException(var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.throwSetIllegalArgumentException(var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (var2 <span class="keyword">instanceof</span> Character) &#123;</span><br><span class="line">      unsafe.putChar(<span class="keyword">this</span>.base, <span class="keyword">this</span>.fieldOffset, (Character)var2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.throwSetIllegalArgumentException(var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面方法的代码得知，方法最终还是通过 <code>Unsafe</code> 类的 <code>native</code> 方法 <code>putChar(Object var1, long var2, char var4)</code> 来实现的，有关 <code>Unsafe</code> 类的介绍请看这篇文章（<a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html" target="_blank" rel="noopener">Java魔法类：Unsafe应用解析</a>）。</p><h4 id="Method-类-invoke-方法的实现"><a href="#Method-类-invoke-方法的实现" class="headerlink" title="Method 类 invoke 方法的实现"></a>Method 类 invoke 方法的实现</h4><p><code>Method</code> 类的 <code>invoke</code> 方法用来在运行时动态调用对象的方法，我们进入到 <code>Method</code> 类的 <code>invoke</code> 方法中看看在 <code>JDK</code> 中到底是怎么做的，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上方法代码我们可以看到，和上文说的的 <code>Field</code> 类一样，首先也是先根据 <code>override</code> 进行了一些权限检查，最后调用的是 <code>MethodAccessor</code> 的 <code>invoke</code> 方法进行处理，这个方法访问器 <code>MethodAccessor</code> 是一个接口，它只有一个操作方法调用的 <code>invoke</code> 方法，它有如下三个实现类：</p><p><img src="https://i.loli.net/2020/01/05/qNho7AfvJU4nGQW.png" alt="methodaccessor_implements.png"></p><p>要想知道 <code>ma.invoke</code> 具体调用的是哪个类的方法，我们需要看看方法 <code>acquireMethodAccessor</code> 返回的对象是哪个，该方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">    <span class="comment">// if so</span></span><br><span class="line">    MethodAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getMethodAccessor();</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        methodAccessor = tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">        tmp = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</span><br><span class="line">        setMethodAccessor(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上方法 <code>acquireMethodAccessor</code> 的源码可以看出，首先会先先判断是否已经存在了对应的 <code>MethodAccessor</code> 对象，如果有就会复用这个对象，否则就调用工厂 <code>reflectionFactory</code> 的 <code>newMethodAccessor</code> 方法生成一个 <code>MethodAccessor</code> 对象出来。那么我们就需要进入到方法 <code>newMethodAccessor</code> 中，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method var1)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      NativeMethodAccessorImpl var2 = <span class="keyword">new</span> NativeMethodAccessorImpl(var1);</span><br><span class="line">      DelegatingMethodAccessorImpl var3 = <span class="keyword">new</span> DelegatingMethodAccessorImpl(var2);</span><br><span class="line">      var2.setParent(var3);</span><br><span class="line">      <span class="keyword">return</span> var3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法 <code>newMethodAccessor</code> 的代码可以看到，方法首先是使用 <code>Method</code> 对象作为入参生成了 <code>NativeMethodAccessorImpl</code> 对象，然后再使用 <code>NativeMethodAccessorImpl</code> 对象作为入参生成了 <code>DelegatingMethodAccessorImpl</code> 对象。这个使用了<code>代理模式</code>，将 <code>NativeMethodAccessorImpl</code> 交给了 <code>DelegatingMethodAccessorImpl</code> 类进行了代理，进入到代理类 <code>DelegatingMethodAccessorImpl</code> 中可以看到：</p><p><img src="https://i.loli.net/2020/01/05/iOXY41amPClUj7F.png" alt="delegatingmethodaccessorimpl.png"></p><p>从上面的红色方框可以看到，在类 <code>DelegatingMethodAccessorImpl</code> 的构造方法中将参数赋值给类中的 <code>delegate</code> 属性，所有上所说的 <code>ma.invoke</code> 最终会进入到 <code>DelegatingMethodAccessorImpl</code> 代理类的 <code>invoke</code>，方法里调用的是 <code>delegate</code> 属性的 <code>invoke</code> 方法，该属性声明的类型为抽象类 <code>MethodAccessorImpl</code>，它有如下两个实现类： </p><p><img src="https://i.loli.net/2020/01/05/HVpQ48Pmv9MIKG3.png" alt="methodaccessorimpl_implements.png"></p><p>按照上文所说的，这里的 <code>delegate</code> 属性是 <code>NativeMethodAccessorImpl</code> 对象，那么就进入到 <code>NativeMethodAccessorImpl</code> 的 <code>invoke</code> 方法中，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">      MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">      <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 <code>NativeMethodAccessorImpl</code> 的 <code>invoke</code> 方法会先判断此次调用是否超过 <code>ReflectionFactory.inflationThreshold()</code> 方法返回的阈值（<code>PS：默认的阈值大小为 15</code>），如果超过了该阈值，则使用方法访问生成器重新生成一个 <code>MethodAccessorImpl</code>，并将 <code>DelegatingMethodAccessorImpl</code> 的 <code>delegate</code> 属性指向这个新生成的 <code>MethodAccessorImpl</code> 对象。从 <code>Reflectionfactory</code> 工厂类的一下注释：</p><p><img src="https://i.loli.net/2020/01/05/gxE8bmp9s5Ydt1P.png" alt="reflectionfactory_doc.png"></p><p>可以得知 <code>JVM</code> 初次加载字节码实现反射的时候，使用 <code>Method.invoke</code> 和 <code>Constructor.newInstance</code> 方式加载所花费的时间是使用原生代码加载所花费的时间的 3 - 4 倍。这也就是我们平常说为什么频繁使用反射的应用需要花费更多的时间。<code>JVM</code> 作者们为了避免这种花费较长的加载时间，我们在第一次加载的时候重用了 <code>JVM</code> 的入口，之后切换到字节码实现的实现。<br>正如注释所述，在 <code>MethodAccessor</code> 接口的实现中，有两个不同的版本，一个 <code>Java</code> 实现的，一个是 <code>Native</code> 实现的。<code>Java</code> 版本实现的版本在初始化的时需要比较多的时间，但长久来说性能会更好一些；而 <code>Native</code> 版本则正好相反，在初始化时相对较快，但是在运行一段时间之后性能就不如 <code>Java</code> 版本的了。为了权衡两种版本的特性，<code>sun</code> 公司的 <code>JDK</code> 使用了 <code>inflation</code> 机制，让 <code>Java</code> 方法在被反射调用时，开头的几次调用使用 <code>native</code> 版，等反射调用次数超过阈值时则生成一个专用的 <code>MethodAccessor</code> 实现类，生成其中的 <code>invoke</code> 方法的字节码，以后对该 <code>Java</code> 方法的反射调用就会使用 <code>Java</code> 版。 </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍反射调用 <code>set(Object obj, Object value)</code> 方法和 <code>invoke(Object obj, Object... args)</code> 方法的底层实现，由于水平有限本人暂时还没有能力分析 <code>JVM</code> 的实现，这里只分析到最终 <code>native</code> 方法的调用。底层会依赖到 <code>Unsafe</code> 类来执行一些低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 <code>Java</code> 运行效率、增强 <code>Java</code> 语言底层资源操作能力方面起到了很大的作用。对于属性反射的方法 <code>setXXX</code> 和 <code>getXXX</code> 的实现分别对应 <code>Unsafe</code> 类的 <code>putXXX</code> 和 <code>getXXX</code> 方法，也就是说完全依赖 <code>Unsafe</code> 类中的 <code>native</code> 方法来实现的；对于方法反射的方法 <code>invoke</code> 底层调用的是 <code>NativeMethodAccessorImpl</code> 类的 <code>invoke0</code> 的 <code>native</code> 方法来实现的。对于反射构造器调用的实现，读者可以自己进入其源码进行分析，大体上和反射方法调用的实现类似。</p><hr><p>参考文章</p><ul><li><a href="https://www.cnblogs.com/onlywujun/p/3519037.html" target="_blank" rel="noopener">JAVA深入研究——Method的Invoke方法。</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在上篇 &lt;a href=&quot;http://www.mghio.cn/post/102cd3d9.html&quot;&gt;Java 反射机制（一）&lt;/a&gt; 介绍了一些 &lt;code&gt;Java&lt;/code&gt; 反射相关的常用 API ，在知道了如何去使用反射之后，作为一个合格的工程师，下一步肯定是要去了解它的如何实现的，我们今天就来看看在 &lt;code&gt;JDK&lt;/code&gt; 源码中是如何去实现反射的(&lt;code&gt;PS:以下源码分析基于 JDK1.8&lt;/code&gt;)。&lt;/p&gt;
&lt;h4 id=&quot;Field-类-set-方法的实现&quot;&gt;&lt;a href=&quot;#Field-类-set-方法的实现&quot; class=&quot;headerlink&quot; title=&quot;Field 类 set 方法的实现&quot;&gt;&lt;/a&gt;Field 类 set 方法的实现&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Field&lt;/code&gt; 类的 &lt;code&gt;set&lt;/code&gt; 方法是在运行时用来动态修改一个类的属性的值，进入到 &lt;code&gt;Field&lt;/code&gt; 类的 &lt;code&gt;set&lt;/code&gt; 方法的源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj, Object value)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IllegalArgumentException, IllegalAccessException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!override) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            checkAccess(caller, clazz, obj, modifiers);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getFieldAccessor(obj).set(obj, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;首先根据 &lt;code&gt;override&lt;/code&gt; 判断是否需要检查字段的访问权限，然后通过 &lt;code&gt;getFieldAccessor&lt;/code&gt; 方法获得一个 &lt;code&gt;FieldAccessor&lt;/code&gt; 字段访问者对象，最后调用的是 &lt;code&gt;FieldAccessor&lt;/code&gt; 类的 &lt;code&gt;set&lt;/code&gt; 方法进行下一步操作的，&lt;code&gt;FieldAccessor&lt;/code&gt; 是一个接口，定义了对字段的一些操作，该接口有如下一些实现类：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="反射" scheme="https://www.mghio.cn/categories/Java/%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="反射" scheme="https://www.mghio.cn/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射机制（一）</title>
    <link href="https://www.mghio.cn/post/102cd3d9.html"/>
    <id>https://www.mghio.cn/post/102cd3d9.html</id>
    <published>2019-12-29T06:00:29.000Z</published>
    <updated>2019-12-31T04:30:05.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在 <code>Java</code> 中有两种方式可以让我们在运行时识别对象和类的信息。一种是 <code>RTTI</code>（运行时类型识别：Run-Time Type Identification），它假定了我们在编译时已经知道了所有的类型；另一种是我们本文要说的<code>反射机制</code>，它允许我们在运行时获取和使用类的信息。无论是 <code>RTTI</code> 还是<code>反射</code>，其本质都是一样的，都是去动态的获取类的信息。它们唯一不同的是，<code>RTTI</code> 在编译时期知道要解析的类型，而<code>反射</code>是在运行时才知道要解析的类型。</p><h4 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h4><p>反射就是把 <code>Java</code> 类中的各个部分（属性、方法、构造方法等）映射成一个个对象。<code>Class</code> 类与 <code>java.lang.reflect</code> 类库一起对反射的概念提供了支持，类库中包含了 <code>Field</code>、<code>Method</code> 及 <code>Constructor</code> 类，每个类都实现了 <code>Member</code> 接口。这些类型的对象都是由 <code>JVM</code> 运行时创建的，用来表示未知类里对应的成员。这样我们就可以使用 <code>Constructor</code> 创建新的对象，用 <code>get</code> 和 <code>set</code> 方法读取和修改类中与 <code>Field</code> 对象关联的字段，用 <code>invoke</code> 方法调用类中与 <code>Method</code> 对象关联的方法等。<br><code>Java</code> 反射机制是在运行状态中的，对于任意一个类我们可以通过反射获取这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。重要的是，要认识到反射机制并没有什么特别之处，当我们通过反射和一个未知类型的对象打交道时，<code>JVM</code> 只是简单的对这个对象做检查，看它属于哪个类，在用它做其它事情之前必须先加载那个类 <code>Class</code> 对象。所以那个类的字节码文件对象对于 <code>JVM</code> 来说必须是可获取的，要么在本地机器上，要么通过网络获取。</p><a id="more"></a><h4 id="反射-API-的使用"><a href="#反射-API-的使用" class="headerlink" title="反射 API 的使用"></a>反射 API 的使用</h4><p>想要通过反射获取一个类的信息之前，首先要先获取这个类的 <code>Class</code> 对象，在 <code>Java</code> 中所有类型都有与之关联的 <code>Class</code> 对象。</p><h5 id="获取类的-Class-对象"><a href="#获取类的-Class-对象" class="headerlink" title="获取类的 Class 对象"></a>获取类的 Class 对象</h5><p>在 <code>Java</code> 中获取一个类的 <code>Class</code> 对象有三种方式：<br><strong>第 ① 种</strong> 使用 <code>Class</code> 类的 <code>forName</code> 静态方法，当我们知道一个类的全路径时，可以通过 <code>Class.forName</code> 方法获取类的 <code>Class</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class stringClass = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">System.out.println(stringClass);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 使用 <code>.class</code> 获取，这种方式只适合在编译前就已经知道了要操作的 <code>Class</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class stringClass = String.class;</span><br><span class="line">System.out.println(stringClass);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br></pre></td></tr></table></figure><p><strong>第 ③ 种</strong> 使用 <code>getClass()</code> 方法获取 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class stringClass = <span class="string">"mghio"</span>.getClass();</span><br><span class="line">System.out.println(stringClass);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br></pre></td></tr></table></figure><h5 id="通过反射创建类对象"><a href="#通过反射创建类对象" class="headerlink" title="通过反射创建类对象"></a>通过反射创建类对象</h5><p>通过反射创建类对象有两种方式：</p><p><strong>第 ① 种</strong> 通过调用 <code>Class</code> 对象的 <code>newInstance()</code> 方法创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Person person = personClass.newInstance();</span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 通过调用 <code>Constructor</code> 对象的 <code>newInstance()</code> 方法创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Constructor personConstructor = personClass.getConstructor();</span><br><span class="line">Person person = (Person) personConstructor.newInstance();</span><br></pre></td></tr></table></figure><p>两者的区别是，通过 <code>Class</code> 的 <code>newInstance</code> 方法只能通过无参构造方法创建，这就要求这个类必须有一个无参的构造方法，而通过 <code>Constructor</code> 的 <code>newInstance</code> 可以指定参数来选择特定的构造方法来创建对象。以下代码就是指定参数然后通过特定的构造方法创建对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Constructor personConstructor = personClass.getConstructor();</span><br><span class="line">Person person = (Person) personConstructor.newInstance(<span class="string">"mghio"</span>, <span class="string">"中国上海"</span>);</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的属性"><a href="#通过反射获取类的属性" class="headerlink" title="通过反射获取类的属性"></a>通过反射获取类的属性</h5><p><code>Class</code> 类提供了两种方式获取一个类的属性。<br><strong>第 ① 种</strong> 是通过 <code>Class</code> 对象的 <code>getFields</code> 方法获取类的属性，该方法只能获取类的 <code>public</code> 属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Field[] fields = personClass.getFields();</span><br><span class="line">System.out.println(Arrays.toString(fields));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.id, </span><br><span class="line"><span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.name]</span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 是通过 <code>Class</code> 对象的 <code>getDeclaredFields</code> 方法获取类的属性，该方法可以获取类的所有属性（包括 <code>private</code> 修饰的属性）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Field[] fields = personClass.getDeclaredFields();</span><br><span class="line">System.out.println(Arrays.toString(fields));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.id, </span><br><span class="line"><span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.name, </span><br><span class="line"><span class="keyword">protected</span> java.lang.Integer cn.mghio.blogmghiocode.reflect.Person.age, </span><br><span class="line"><span class="keyword">private</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.address]</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的方法"><a href="#通过反射获取类的方法" class="headerlink" title="通过反射获取类的方法"></a>通过反射获取类的方法</h5><p><code>Class</code> 也提供了两种方式获取类的方法。<br><strong>第 ① 种</strong> 是通过 <code>Class</code> 对象的 <code>getMethods</code> 方法获取类的方法（包括继承而得的方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Method[] methods = personClass.getMethods();</span><br><span class="line">System.out.println(Arrays.toString(methods));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.toString(), </span><br><span class="line"><span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.getAddress(), </span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> java.lang.Class java.lang.Object.getClass(), </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> java.lang.Object.notify()]</span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 是通过 <code>Class</code> 对象的 <code>getDeclaredMethods</code> 方法获取类的方法（只包含类中定义的方法，不包含继承而来的方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Method[] methods = personClass.getDeclaredMethods();</span><br><span class="line">System.out.println(Arrays.toString(methods));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.toString(), </span><br><span class="line"><span class="keyword">public</span> java.lang.String cn.mghio.blogmghiocode.reflect.Person.getAddress(), </span><br><span class="line">... </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> cn.mghio.blogmghiocode.reflect.Person.protectedMethod(), </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> cn.mghio.blogmghiocode.reflect.Person.privateMethod()]</span><br></pre></td></tr></table></figure><p>从以上结果可以看出这个方法只获取当前类中定义的方法，包含 <code>private</code> 方法，不会获取从父类中继承而来的方法。</p><h5 id="通过反射获取类的构造方法"><a href="#通过反射获取类的构造方法" class="headerlink" title="通过反射获取类的构造方法"></a>通过反射获取类的构造方法</h5><p><code>Class</code> 也提供了两种方式获取类的构造方法。<br><strong>第 ① 种</strong> 是通过 <code>Class</code> 对象的 <code>getConstructors</code> 方法获取类的构造方法（只能获取当前类的 <code>public</code> 构造方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Constructor[] constructors = personClass.getConstructors();</span><br><span class="line">System.out.println(Arrays.toString(constructors));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> cn.mghio.blogmghiocode.reflect.Person(java.lang.String,java.lang.String,java.lang.Integer,java.lang.String)]</span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 是通过 <code>Class</code> 对象的 <code>getDeclaredConstructors</code> 方法获取类的构造方法（只包含类中定义的所有构造方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Constructor[] constructors = personClass.getDeclaredConstructors();</span><br><span class="line">System.out.println(Arrays.toString(constructors));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span> cn.mghio.blogmghiocode.reflect.Person(java.lang.String,java.lang.String,java.lang.Integer,java.lang.String), </span><br><span class="line"><span class="keyword">protected</span> cn.mghio.blogmghiocode.reflect.Person(java.lang.String,java.lang.String), </span><br><span class="line"><span class="keyword">private</span> cn.mghio.blogmghiocode.reflect.Person()]</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的类名"><a href="#通过反射获取类的类名" class="headerlink" title="通过反射获取类的类名"></a>通过反射获取类的类名</h5><p><code>Class</code> 类提供了两种方式获取类的类名。<br><strong>第 ① 种</strong> 是通过 <code>getName</code> 方法获取类的全限定名（包含包名）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">String fullPersonClassName = personClass.getName();</span><br><span class="line">System.out.println(fullPersonClassName);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cn.mghio.blogmghiocode.reflect.Person</span><br></pre></td></tr></table></figure><p><strong>第 ② 种</strong> 是通过 <code>Class</code> 对象的 <code>getSimpleName</code> 方法获取类的类名（不包含包名）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">String fullPersonClassName = personClass.getSimpleName();</span><br><span class="line">System.out.println(fullPersonClassName);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的修饰符"><a href="#通过反射获取类的修饰符" class="headerlink" title="通过反射获取类的修饰符"></a>通过反射获取类的修饰符</h5><p>可以通过 <code>Class</code> 类来获取一个类的修饰符，也就是我们熟知的 <code>public</code>、<code>protected</code>、<code>private</code> 等关键字，通过调用 <code>getModifiers</code> 方法来获取一个类的修饰符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line"><span class="keyword">int</span> modifyInt = personClass.getModifiers();</span><br><span class="line">System.out.println(modifyInt);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>返回 <code>1</code> 表示类 <code>Person</code> 的修饰符为 <code>public</code>，修饰符在 <code>Modifier</code> 类中都被包装成一个 <code>int</code> 类型的数字，部分修饰符定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The &#123;<span class="doctag">@code</span> int&#125; value representing the &#123;<span class="doctag">@code</span> public&#125;</span></span><br><span class="line"><span class="comment">  * modifier.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC           = <span class="number">0x00000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The &#123;<span class="doctag">@code</span> int&#125; value representing the &#123;<span class="doctag">@code</span> private&#125;</span></span><br><span class="line"><span class="comment">  * modifier.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIVATE          = <span class="number">0x00000002</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The &#123;<span class="doctag">@code</span> int&#125; value representing the &#123;<span class="doctag">@code</span> protected&#125;</span></span><br><span class="line"><span class="comment">  * modifier.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROTECTED        = <span class="number">0x00000004</span>;</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的包信息"><a href="#通过反射获取类的包信息" class="headerlink" title="通过反射获取类的包信息"></a>通过反射获取类的包信息</h5><p><code>Class</code> 对象通过 <code>getPackage</code> 方法获取类的包相关信息，可以使用 <code>Class</code> 对象通过如下的方式获取包信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Package packageClazz = personClass.getPackage();</span><br><span class="line">System.out.println(packageClazz.getName());</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cn.mghio.blogmghiocode.reflect</span><br></pre></td></tr></table></figure><h5 id="通过反射获取类的父类"><a href="#通过反射获取类的父类" class="headerlink" title="通过反射获取类的父类"></a>通过反射获取类的父类</h5><p>可以通过 <code>Class</code> 类来获取一个类的父类，通过调用 <code>getModifiers</code> 方法来获取一个类的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Class superclass = personClass.getSuperclass();</span><br><span class="line">System.out.println(superclass.getName());</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br></pre></td></tr></table></figure><p>以上运行结果表示 <code>Person</code> 类的父类是 <code>Object</code> 类，可以看到 <code>superclass</code> 对象其实就是一个 <code>Class</code> 类的实例，所以也可以继续在这个对象上进行反射操作。</p><h5 id="通过反射获取类的实现接口"><a href="#通过反射获取类的实现接口" class="headerlink" title="通过反射获取类的实现接口"></a>通过反射获取类的实现接口</h5><p>可以通过 <code>Class</code> 类来获取一个类的父类，通过调用 <code>getInterfaces</code> 方法来获取一个类实现的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">Class&lt;?&gt;[] interfaces = personClass.getInterfaces();</span><br><span class="line">System.out.println(Arrays.toString(interfaces));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[interface cn.mghio.blogmghiocode.reflect.IPerson]</span><br></pre></td></tr></table></figure><p>在 <code>Java</code> 中一个类可以实现多个接口，因此 <code>getInterfaces</code> 方法返回一个 <code>Class</code> 数组，在 <code>Java</code> 中接口也同样有对应的 <code>Class</code> 对象。这个方法需要注意的是，<code>getInterfaces</code> 方法仅仅只返回当前类所实现的接口。当前类的父类如果实现了接口，这些接口是不会在返回的 <code>Class</code> 集合中的，尽管实际上当前类其实已经实现了父类接口。</p><h5 id="通过反射获取泛型信息"><a href="#通过反射获取泛型信息" class="headerlink" title="通过反射获取泛型信息"></a>通过反射获取泛型信息</h5><p>当我们在声明一个类或者接口的时候可以指定它可以参数化，常用的 <code>List</code> 接口就是一个参数化接口的例子。比如想要检查 <code>List</code> 接口的参数化类型，我们是没有办法能知道它具体的参数化类型是什么。这个类型就可以是一个应用中所有的类型。但是，当你检查一个使用了被参数化的类型的变量或者方法，你可以获得这个被参数化类型的具体参数。<br><strong>第 ① 种 泛型方法返回类型</strong> 当你获得了 <code>Method</code> 对象，那么就可以获取到这个方法的泛型返回类型信息。如果方法是在一个被参数化类型之中（例如: T foo()），那么将无法获得它的具体类型，但是如果方法返回的是一个泛型类（例如：List<string> foo()），那么就可以获得这个泛型类的具体参数化类型。下面这个例子中的类定义了一个返回类型是泛型的方法。</string></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> List&lt;Integer&gt; stringList = Arrays.asList(<span class="number">2</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">90</span>, <span class="number">81</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getStringList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stringList;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以获取上面这个类 <code>ReflectGenericDemo</code> 的方法 <code>getStringList</code> 的泛型返回类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemoTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodReturnGenericType</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    Class&lt;ReflectGenericDemo&gt; reflectClass = ReflectGenericDemo.class;</span><br><span class="line">    Method method = reflectClass.getMethod(<span class="string">"getStringList"</span>, (Class&lt;?&gt;) <span class="keyword">null</span>);</span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      ParameterizedType type = (ParameterizedType) returnType;</span><br><span class="line">      Type[] typeArguments = type.getActualTypeArguments();</span><br><span class="line">      <span class="keyword">for</span> (Type typeArgument : typeArguments) &#123;</span><br><span class="line">        Class typeArgumentClass = (Class) typeArgument;</span><br><span class="line">        System.out.println(<span class="string">"typeArgumentClass = "</span> + typeArgumentClass);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeArgumentClass = <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span></span></span><br></pre></td></tr></table></figure><p><code>typeArguments</code> 数组只有一个值，这个数组中唯一的值是 <code>Integer</code> 的 <code>Class</code> 类的实例，同时 <code>Class</code> 类也实现了 <code>Type</code> 接口。</p><p><strong>第 ② 种 泛型方法返回类型</strong> 泛型方法参数类型，我们也可以通过反射来获取方法参数的泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> List&lt;Integer&gt; stringList = Arrays.asList(<span class="number">2</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">90</span>, <span class="number">81</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStringList</span><span class="params">(List&lt;Integer&gt; stringList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stringList = stringList;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过以下方式获取方法参数的泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemoTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethodParameterGenericType</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    Class&lt;ReflectGenericDemo&gt; reflectClass = ReflectGenericDemo.class;</span><br><span class="line">    Method method = reflectClass.getMethod(<span class="string">"setStringList"</span>, List.class);</span><br><span class="line">    Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">      <span class="keyword">if</span> (genericParameterType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        ParameterizedType parameterizedType = (ParameterizedType) genericParameterType;</span><br><span class="line">        Type[] parameterArgTypes = parameterizedType.getActualTypeArguments();</span><br><span class="line">        <span class="keyword">for</span> (Type parameterArgType : parameterArgTypes) &#123;</span><br><span class="line">          Class parameterArgClass = (Class) parameterArgType;</span><br><span class="line">          System.out.println(<span class="string">"parameterArgClass = "</span> + parameterArgClass);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameterArgClass = <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span></span></span><br></pre></td></tr></table></figure><p><strong>第 ③ 种 泛型变量类型</strong> 可以通过反射来访问类中定义变量的泛型类型，不管这个变量是一个类的静态成员变量或是实例成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt; stringList = Arrays.asList(<span class="number">2</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">90</span>, <span class="number">81</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过以下代码来获取类 <code>ReflectGenericDemo</code> 的私有变量 <code>stringList</code> 的泛型变量类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过反射获取泛型信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectGenericDemoTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFieldGenericType</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">    Class&lt;ReflectGenericDemo&gt; reflectClass = ReflectGenericDemo.class;</span><br><span class="line">    Field field = reflectClass.getDeclaredField(<span class="string">"stringList"</span>);</span><br><span class="line">    Type type = field.getGenericType();</span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      ParameterizedType fieldGenericType = (ParameterizedType) type;</span><br><span class="line">      Type[] fieldGenericTypes = fieldGenericType.getActualTypeArguments();</span><br><span class="line">      <span class="keyword">for</span> (Type genericType : fieldGenericTypes) &#123;</span><br><span class="line">        Class fieldGenericTypeClass = (Class) genericType;</span><br><span class="line">        System.out.println(fieldGenericTypeClass);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Integer</span></span></span><br></pre></td></tr></table></figure><p>数组 <code>fieldGenericTypes</code> 只有一个元素，它代表类 <code>Integer</code> 的 <code>Class</code> 类的实例。我们可以得出通过反射获取泛型信息的套路都是先获取 <code>Class</code> 类对象，然后通过该对象获取相应的类，如果是要获取变量的泛型信息就先获取到 <code>Field</code> 类，如果是要获取方法的泛型信息就先获取到 <code>Method</code> 类，最后再通过是否是 <code>ParameterizedType</code> 的实例来判断是否是泛型类型。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们介绍了 <code>Java</code> 泛型的基本使用，反射可能在我们日常的工作中不怎么接触到，但是，在很多框架中都有运用，比如，<code>Spring</code> 的 <code>IOC/DI</code> 也是反射；还有 <code>JDBC</code> 的 <code>classForName</code> 也是反射。所有深入了解 <code>Java</code> 反射机制很有必要。</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Constructor getConstructor(Class[] params)</td><td align="center">根据构造方法的参数，返回一个 <code>public</code> 类型的构造方法</td></tr><tr><td align="center">Constructor getConstructors()</td><td align="center">返回所有 <code>public</code> 类型的构造方法数组</td></tr><tr><td align="center">Constructor getDeclaredConstructor(Class[] params)</td><td align="center">根据构造方法的参数，返回一个具体的构造方法（所有的类型）</td></tr><tr><td align="center">Constructor getDeclaredConstructors()</td><td align="center">返回该类中所有的构造方法数组（所有的类型）</td></tr><tr><td align="center">Method getMethod(String name, Class[] params)</td><td align="center">根据方法名和参数，返回一个 <code>public</code> 类型的方法</td></tr><tr><td align="center">Method[] getMethods()</td><td align="center">返回所有 <code>public</code> 类型的方法数组</td></tr><tr><td align="center">Method getDeclaredMethod(String name, Class[] params)</td><td align="center">根据方法名和参数，返回一个具体的方法（所有的类型）</td></tr><tr><td align="center">Method[] getDeclaredMethods()</td><td align="center">返回该类中的所有的方法数组（所有的类型）</td></tr><tr><td align="center">Field getField(String name)</td><td align="center">根据变量名，返回一个 <code>public</code> 类型的成员变量</td></tr><tr><td align="center">Field[] getFields()</td><td align="center">返回 <code>public</code> 类型的成员变量的数组</td></tr><tr><td align="center">Field getDeclaredField(String name)</td><td align="center">根据变量名，返回一个成员变量（所有的类型）</td></tr><tr><td align="center">Field[] getDelcaredField()</td><td align="center">返回所有成员变量组成的数组（所有的类型）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;Java&lt;/code&gt; 中有两种方式可以让我们在运行时识别对象和类的信息。一种是 &lt;code&gt;RTTI&lt;/code&gt;（运行时类型识别：Run-Time Type Identification），它假定了我们在编译时已经知道了所有的类型；另一种是我们本文要说的&lt;code&gt;反射机制&lt;/code&gt;，它允许我们在运行时获取和使用类的信息。无论是 &lt;code&gt;RTTI&lt;/code&gt; 还是&lt;code&gt;反射&lt;/code&gt;，其本质都是一样的，都是去动态的获取类的信息。它们唯一不同的是，&lt;code&gt;RTTI&lt;/code&gt; 在编译时期知道要解析的类型，而&lt;code&gt;反射&lt;/code&gt;是在运行时才知道要解析的类型。&lt;/p&gt;
&lt;h4 id=&quot;反射概述&quot;&gt;&lt;a href=&quot;#反射概述&quot; class=&quot;headerlink&quot; title=&quot;反射概述&quot;&gt;&lt;/a&gt;反射概述&lt;/h4&gt;&lt;p&gt;反射就是把 &lt;code&gt;Java&lt;/code&gt; 类中的各个部分（属性、方法、构造方法等）映射成一个个对象。&lt;code&gt;Class&lt;/code&gt; 类与 &lt;code&gt;java.lang.reflect&lt;/code&gt; 类库一起对反射的概念提供了支持，类库中包含了 &lt;code&gt;Field&lt;/code&gt;、&lt;code&gt;Method&lt;/code&gt; 及 &lt;code&gt;Constructor&lt;/code&gt; 类，每个类都实现了 &lt;code&gt;Member&lt;/code&gt; 接口。这些类型的对象都是由 &lt;code&gt;JVM&lt;/code&gt; 运行时创建的，用来表示未知类里对应的成员。这样我们就可以使用 &lt;code&gt;Constructor&lt;/code&gt; 创建新的对象，用 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 方法读取和修改类中与 &lt;code&gt;Field&lt;/code&gt; 对象关联的字段，用 &lt;code&gt;invoke&lt;/code&gt; 方法调用类中与 &lt;code&gt;Method&lt;/code&gt; 对象关联的方法等。&lt;br&gt;&lt;code&gt;Java&lt;/code&gt; 反射机制是在运行状态中的，对于任意一个类我们可以通过反射获取这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。重要的是，要认识到反射机制并没有什么特别之处，当我们通过反射和一个未知类型的对象打交道时，&lt;code&gt;JVM&lt;/code&gt; 只是简单的对这个对象做检查，看它属于哪个类，在用它做其它事情之前必须先加载那个类 &lt;code&gt;Class&lt;/code&gt; 对象。所以那个类的字节码文件对象对于 &lt;code&gt;JVM&lt;/code&gt; 来说必须是可获取的，要么在本地机器上，要么通过网络获取。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="反射" scheme="https://www.mghio.cn/categories/Java/%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="反射" scheme="https://www.mghio.cn/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="https://www.mghio.cn/post/817c7d82.html"/>
    <id>https://www.mghio.cn/post/817c7d82.html</id>
    <published>2019-12-21T04:00:49.000Z</published>
    <updated>2019-12-21T15:52:44.260Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h4><p>作为 <code>Java</code> 后端开发的我们，开发的项目绝大部分都是部署在 <code>Linux</code> 系统上的，因此熟练使用一些常用的 <code>Linux</code> 命令不管是对于日常开发、服务部署或者查找问题都非常有用。以下整理了一些常用的 <code>Linux</code> 常用命令。</p><h4 id="1-2-文件管理"><a href="#1-2-文件管理" class="headerlink" title="1.2 文件管理"></a>1.2 文件管理</h4><h5 id="1-2-1-ls-命令"><a href="#1-2-1-ls-命令" class="headerlink" title="1.2.1 ls 命令"></a>1.2.1 ls 命令</h5><p><code>ls</code> 命令是 <code>Linux</code> 最常用的命令之一，其功能是列出指定目录下的内容及其相关属性信息。默认状态下，<code>ls</code> 命令会列出当前目录的内容，它也可以带上一些参数来实现更多的功能。<br><strong>语法格式</strong>：ls [选项] [文件]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">显示所有文件及目录（包括以 <code>.</code> 开头的隐藏文件）</td></tr><tr><td align="center">-l</td><td align="center">使用长格式列出文件及目录</td></tr><tr><td align="center">-r</td><td align="center">将文件以相反次序显示（默认按照英文字母次序）</td></tr><tr><td align="center">-t</td><td align="center">根据最后的修改时间排序</td></tr><tr><td align="center">-A</td><td align="center">同 <code>-a</code>，但是不列出 <code>.</code>（当前目录）以及 <code>..</code>（父级目录）</td></tr><tr><td align="center">-S</td><td align="center">根据文件大小排序</td></tr><tr><td align="center">-R</td><td align="center">递归列出所有子目录</td></tr></tbody></table><a id="more"></a><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -<span class="keyword">a</span>       # 列出所有文件（包括隐藏文件）</span><br><span class="line"><span class="keyword">ls</span> -<span class="keyword">l</span>       # 列出文件的详细信息</span><br><span class="line"><span class="keyword">ls</span> /        # 列出根目录（/）下的所有目录</span><br><span class="line"><span class="keyword">ls</span> -ltr s*  # 列出当前目录下所有名称是 s 开头的文件</span><br><span class="line"><span class="keyword">ls</span> -AS      # 列出当前目录下所有文件及目录并以文件大小进行排序</span><br></pre></td></tr></table></figure><h5 id="1-2-2-chown-命令"><a href="#1-2-2-chown-命令" class="headerlink" title="1.2.2 chown 命令"></a>1.2.2 chown 命令</h5><p><code>Linux</code> 是一种多用户多任务的操作系统，所有的文件都有一个拥有者。<code>chown</code> 命令就是用来将指定文件的拥有者改为指定的用户或者组（<code>PS：用户和组都可以是名称或者其 ID</code>），文件是以空格分开的要改变权限的文件列表，支持通配符。<br><strong>语法格式</strong>：chown [参数]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-R</td><td align="center">对当前目录下的所有文件与子目录进行相同的拥有者变更</td></tr><tr><td align="center">-c</td><td align="center">若该文件拥有者确实已经更改，才显示其更改动作</td></tr><tr><td align="center">-f</td><td align="center">若该文件拥有者无法更改也不显示错误信息</td></tr><tr><td align="center">-v</td><td align="center">显示拥有者变更的详细信息</td></tr><tr><td align="center">–version</td><td align="center">显示版本</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 将 change_usergroup_and_user_demo.txt 文件用户组与用户都改为 mghio</span><br><span class="line"></span><br><span class="line">[root@mghio ~]# <span class="keyword">ll</span> change_usergroup_and_user_demo.txt</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">56</span> Dec <span class="number">21</span> <span class="number">10</span>:<span class="number">17</span> change_usergroup_and_user_demo.txt</span><br><span class="line">[root@mghio ~]# chown mghio:mghio change_usergroup_and_user_demo.txt</span><br><span class="line">[root@mghio ~]# <span class="keyword">ll</span> change_usergroup_and_user_demo.txt</span><br><span class="line">-rw-r--r-- <span class="number">1</span> mghio mghio <span class="number">56</span> Dec <span class="number">21</span> <span class="number">10</span>:<span class="number">17</span> change_usergroup_and_user_demo.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 显示其更改动作</span><br><span class="line"></span><br><span class="line">[root@mghio ~]# <span class="keyword">ll</span> change_usergroup_and_user_demo.txt</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">45</span> Dec <span class="number">21</span> <span class="number">10</span>:<span class="number">30</span> change_usergroup_and_user_demo.txt</span><br><span class="line">[root@mghio ~]# chown -<span class="keyword">c</span> mghio:mghio change_usergroup_and_user_demo.txt</span><br><span class="line">changed ownership of <span class="string">'change_usergroup_and_user_demo.txt'</span> <span class="keyword">to</span> mghio:mghio</span><br></pre></td></tr></table></figure><h5 id="1-2-3-cp-命令"><a href="#1-2-3-cp-命令" class="headerlink" title="1.2.3 cp 命令"></a>1.2.3 cp 命令</h5><p><code>cp</code> 命令为英文单词 <code>copy</code> 的缩写，功能为复制文件或目录。<code>cp</code> 命令可以将多个文件复制到一个具体的文件名或者一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。<br><strong>语法格式</strong>：cp [参数] [文件]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-f</td><td align="center">若目标文件已经存在，则直接覆盖原文件</td></tr><tr><td align="center">-i</td><td align="center">若目标文件已经存在，则会询问是否覆盖</td></tr><tr><td align="center">-p</td><td align="center">保留原文件或者目录的属性</td></tr><tr><td align="center">-r</td><td align="center">递归复制文件和目录</td></tr><tr><td align="center">-d</td><td align="center">当复制符号链接时，把目标文件或者目录也建立符号链接，并指向和原文件或目录连接的原始文件或目录</td></tr><tr><td align="center">-l</td><td align="center">对原文件建立连接，而非复制文件</td></tr><tr><td align="center">-s</td><td align="center">对原文件建立符合连接，而非复制文件</td></tr><tr><td align="center">-b</td><td align="center">覆盖已经存在的文件目标前将目标文件备份</td></tr><tr><td align="center">-v</td><td align="center">详细显示 <code>cp</code> 命令的执行过程</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 复制目录</span><br><span class="line"><span class="keyword">cp</span> -R source_dir1 dest_dir2/</span><br><span class="line"></span><br><span class="line"># 将文件 demo1.txt 改名为 demo2.txt</span><br><span class="line"><span class="keyword">cp</span> -<span class="keyword">f</span> demo1.txt demo2.txt</span><br><span class="line"></span><br><span class="line"># 复制多个文件</span><br><span class="line"><span class="keyword">cp</span> -r file1 file2 file3 dest_dir</span><br></pre></td></tr></table></figure><h5 id="1-2-4-mkdir-命令"><a href="#1-2-4-mkdir-命令" class="headerlink" title="1.2.4 mkdir 命令"></a>1.2.4 mkdir 命令</h5><p><code>mkdir</code> 命令是 <code>make directories</code> 的缩写，其功能是用来创建目录。默认状态下，如果要创建的目录如果已经存在，则提示已存在，而不会继续创建目录。所有我们在创建目录时，应该要保证新建的目录与它所在的目录下的文件没有重名，同时该命令还可以一次性创建多个目录。<br><strong>语法格式</strong>：mkdir [参数] [目录]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-p</td><td align="center">递归创建多级目录</td></tr><tr><td align="center">-m</td><td align="center">建立目录的同时设置目录的权限</td></tr><tr><td align="center">-v</td><td align="center">显示目录的常见过程</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录下，创建一个名为 dir 的子目录</span><br><span class="line"><span class="built_in">mkdir</span> dir</span><br><span class="line"></span><br><span class="line"># 在目录 /usr/mghio 下建立子目录 dir，并且设置文件属主有读（<span class="number">4</span>）、写（<span class="number">2</span>）和执行（<span class="number">1</span>）权限，其它用户无法访问</span><br><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">m</span> <span class="number">700</span> /usr/mghio/dir</span><br><span class="line"></span><br><span class="line"># 一次性创建目录 dir1、dir2、dir3</span><br><span class="line"><span class="built_in">mkdir</span> dir1 dir2 dir3</span><br><span class="line"></span><br><span class="line"># 递归创建目录</span><br><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> /mghio/dir</span><br></pre></td></tr></table></figure><h5 id="1-2-5-mv-命令"><a href="#1-2-5-mv-命令" class="headerlink" title="1.2.5 mv 命令"></a>1.2.5 mv 命令</h5><p><code>mv</code> 命令为英文单词 <code>move</code> 的缩写，功能为移动文件或者对文件重新命名。<code>mv</code> 与 <code>cp</code> 命令的结果不同。<code>mv</code> 命令是将文件整个移走，文件名发生改变，但是个数没有增加。而 <code>cp</code> 命令是对文件进行复制操作，文件个数增加。<br><strong>语法格式</strong>：mv [参数]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">若存在同名文件，则会询问是否覆盖</td></tr><tr><td align="center">-f</td><td align="center">覆盖已经存在的文件时，不进行任何提示</td></tr><tr><td align="center">-b</td><td align="center">当文件存在时，覆盖前为其创建一个备份</td></tr><tr><td align="center">-u</td><td align="center">当原文件比目标文件新或者目标文件不存在时，才会执行</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 将文件 file1 重命名为 file2</span><br><span class="line">mv file1 file2</span><br><span class="line"></span><br><span class="line"># 将文件 <span class="keyword">file</span> 移动到目录 dest_dir</span><br><span class="line">mv <span class="keyword">file</span> /dest_dir</span><br><span class="line"></span><br><span class="line"># 将目录 dir 下的所有文件移到当前目录</span><br><span class="line">mv /dir/* .</span><br></pre></td></tr></table></figure><h4 id="1-3-文档编辑"><a href="#1-3-文档编辑" class="headerlink" title="1.3 文档编辑"></a>1.3 文档编辑</h4><h5 id="1-3-1-cat-命令"><a href="#1-3-1-cat-命令" class="headerlink" title="1.3.1 cat 命令"></a>1.3.1 cat 命令</h5><p>在 <code>Linux</code> 系统中有很多用于查看文件内容的命令，<code>cat</code> 命令就是用来查看<code>内容较少</code>的纯文本内容文件的。当文件内容较大时，文本内容会在屏幕上快速滚屏，我们通常都看不到所显示的内容。对于较长文件内容可以按 <code>Ctrl+S</code> 键来停止滚屏，以及 <code>Ctrl+Q</code> 键来恢复滚屏，按 <code>Ctrl+C（中断）</code>键则可以终止该命令的执行。对于大文件，推荐使用下文说的 <code>more</code> 命令。<br><strong>语法格式</strong>：cat [参数] [文件]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">显示行数（一个空行显示一个编号）</td></tr><tr><td align="center">-s</td><td align="center">显示行数（多个空行只算一个编号）</td></tr><tr><td align="center">-b</td><td align="center">显示行数（空行不编号）</td></tr><tr><td align="center">-E</td><td align="center">每行结束显示 <code>$</code> 符号</td></tr><tr><td align="center">-T</td><td align="center">将 <code>TAB</code> 字符显示为 <code>^|</code> 符号</td></tr><tr><td align="center">–version</td><td align="center">显示版本信息</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查看文件内容 </span><br><span class="line"><span class="keyword">cat</span> demo.txt</span><br><span class="line"></span><br><span class="line"># 查看文件内容，并显示行号</span><br><span class="line"><span class="keyword">cat</span> -n demo.txt</span><br><span class="line"></span><br><span class="line"># 产查看文件的内容，并添加行数编号后输出到另外一个文件中</span><br><span class="line"><span class="keyword">cat</span> -n mghio.<span class="built_in">log</span> &gt; mghio_with_line_number.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"># 清空文件内容</span><br><span class="line"><span class="keyword">cat</span> /dev/null &gt; /mghio/demo.txt</span><br><span class="line"></span><br><span class="line"># 持续写入文件内容，直到碰到 `EOF` 符号后结束并保存</span><br><span class="line"><span class="keyword">cat</span> &gt; demo.txt &lt;&lt; EOF</span><br><span class="line">&gt; Hello, World</span><br><span class="line">&gt; mghio</span><br><span class="line">&gt; EOF</span><br></pre></td></tr></table></figure><h5 id="1-3-2-more-命令"><a href="#1-3-2-more-命令" class="headerlink" title="1.3.2 more 命令"></a>1.3.2 more 命令</h5><p><code>more</code> 命令用于将内容较长的文本文件内容（无法在一屏显示完）进行分屏显示，并且支持显示时定位关键字。对于内容比较少的文本内容推荐使用 <code>cat</code> 命令查看。<br><strong>语法格式</strong>：more [参数] [文件]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-num</td><td align="center">指定每屏显示的内容行数</td></tr><tr><td align="center">-l</td><td align="center"><code>more</code> 在通常情况下把 <code>^L</code> 当遇到这个字符就会暂停，这个参数可以屏蔽这个特性</td></tr><tr><td align="center">-f</td><td align="center">计算实际的行数，而非自动换行的行数</td></tr><tr><td align="center">-p</td><td align="center">先清除屏幕在显示文本文件的剩余内容</td></tr><tr><td align="center">-c</td><td align="center">与 <code>-p</code> 相似，不滚屏，先显示内容在清除内容</td></tr><tr><td align="center">-s</td><td align="center">多个空行压缩成一行显示</td></tr><tr><td align="center">-u</td><td align="center">禁止下划线</td></tr><tr><td align="center">+/pattern</td><td align="center">在每个文档显示前搜寻该字（<code>pattern</code>），然后该字串之后开始显示</td></tr><tr><td align="center">+num</td><td align="center">从第 <code>num</code> 行开始显示</td></tr></tbody></table><p><strong>查看时的命令操作</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Space 键</td><td align="center">显示文本的下一屏内容</td></tr><tr><td align="center">Enter 键</td><td align="center">向下 <code>n</code> 行，需要定义，默认为 1 行</td></tr><tr><td align="center"><code>\</code> 键</td><td align="center">接着输入一个模式，可以在文本中寻找下一个相匹配的模式</td></tr><tr><td align="center">H 键</td><td align="center">显示帮助屏</td></tr><tr><td align="center">B 键</td><td align="center">显示上一屏内容</td></tr><tr><td align="center">Q 键</td><td align="center">退出 <code>more</code> 命令</td></tr><tr><td align="center">Ctrl + F、空格键</td><td align="center">向下滚动一屏</td></tr><tr><td align="center">Ctrl + B</td><td align="center">返回上一屏</td></tr><tr><td align="center">=</td><td align="center">输出当前的行号</td></tr><tr><td align="center">:f</td><td align="center">输出文件名和当前的行号</td></tr><tr><td align="center">V</td><td align="center">调用 <code>vi</code> 编辑器</td></tr><tr><td align="center">!</td><td align="center">调用 <code>Shell</code>， 并执行命令</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 显示文件 demo.txt 的内容和已显示的百分比，显示之前先清屏</span><br><span class="line">more -dc demo.txt</span><br><span class="line"></span><br><span class="line"># 显示文件 demo.txt 的内容，每 <span class="number">10</span> 行显示一次，而且在显示之前先清屏</span><br><span class="line">more -<span class="keyword">c</span> -<span class="number">10</span> demo.txt</span><br><span class="line"></span><br><span class="line"># 显示文件 demo.txt 的内容，每 <span class="number">5</span> 行显示一次，而且在显示之后再清屏</span><br><span class="line">more -<span class="keyword">p</span> -<span class="number">5</span> demo.txt</span><br><span class="line"></span><br><span class="line"># 从第 <span class="number">20</span> 行开始显示文件 demo.txt 的内容</span><br><span class="line">more +<span class="number">20</span> demo.txt</span><br></pre></td></tr></table></figure><h5 id="1-3-3-tail-命令"><a href="#1-3-3-tail-命令" class="headerlink" title="1.3.3 tail 命令"></a>1.3.3 tail 命令</h5><p><code>tial</code> 命令用于显示文件尾部的内容，默认在屏幕上显示指定文件的末尾 10 行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题，如果没有指定文件或者文件名为 <code>-</code>，则读取标准输入。<br><strong>语法格式</strong>：tail [参数]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">–retry</td><td align="center">即是在 <code>tail</code> 命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与 <code>—f</code> 一起使用</td></tr><tr><td align="center">-c <n></n></td><td align="center">输出文件尾部的 <code>N</code>（<code>N</code> 为整数） 个字节内容</td></tr><tr><td align="center">-f</td><td align="center">显示文件最新追加的内容</td></tr><tr><td align="center">-n <n></n></td><td align="center">输出文件的尾部 <code>N</code>（<code>N</code> 为整数） 行内容</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 显示文件 demo.txt 的最后 <span class="number">10</span> 行</span><br><span class="line">tail demo.txt</span><br><span class="line"></span><br><span class="line"># 显示文件 demo.txt 的内容，从第 <span class="number">20</span> 行至文件末尾</span><br><span class="line">tail +<span class="number">20</span> demo.txt</span><br><span class="line"></span><br><span class="line"># 显示文件 demo.txt 的最后 <span class="number">10</span> 个字符</span><br><span class="line">tail -<span class="keyword">c</span> <span class="number">10</span> demo.txt</span><br></pre></td></tr></table></figure><h5 id="1-3-4-grep-命令"><a href="#1-3-4-grep-命令" class="headerlink" title="1.3.4 grep 命令"></a>1.3.4 grep 命令</h5><p><code>grep</code> 是英文 <code>global search regular expression and print out the line</code> 的简称。是全面搜索正则表达式，并将其打印出来。这个命令可以结合正则表达式使用，使用非常广泛。<code>grep</code> 命令的选项用于对搜索过程的补充，而其命令的模式十分灵活，可以是变量、字符串、正则表达式，需要注意的是，当我们的模式中包含了空格的话，要使用双引号将其引起来。<br><strong>语法格式</strong>：grep [参数]<br><strong>参数列表</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">搜索时，忽略大小写</td></tr><tr><td align="center">-c</td><td align="center">只输出匹配行的数量</td></tr><tr><td align="center">-l</td><td align="center">只列出符合匹配的文件名，不列出具体匹配行</td></tr><tr><td align="center">-n</td><td align="center">列出所有匹配行，显示行号</td></tr><tr><td align="center">-h</td><td align="center">查询多文件时不显示文件名</td></tr><tr><td align="center">-s</td><td align="center">不显示不存在、没有匹配文本的错误信息</td></tr><tr><td align="center">-v</td><td align="center">显示不包含匹配文本的所有行</td></tr><tr><td align="center">-w</td><td align="center">匹配整词</td></tr><tr><td align="center">-x</td><td align="center">匹配整行</td></tr><tr><td align="center">-r</td><td align="center">递归搜索</td></tr><tr><td align="center">-q</td><td align="center">禁止输出任何结果，已退出状态表示搜索是否成功</td></tr><tr><td align="center">-b</td><td align="center">打印匹配行距文件头部的偏移量（以字节为单位）</td></tr><tr><td align="center">-o</td><td align="center">与 <code>-b</code> 结合使用，打印匹配的词距文件头部的偏移量（以字节为单位）</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 支持多文件查询并支持使用通配符</span><br><span class="line"></span><br><span class="line">[root@mghio ~]# <span class="keyword">grep</span> mghio file_* /usr/demo</span><br><span class="line">file_1:mghio</span><br><span class="line">file_1:mghioddkjflkdjfdlkfjlsdkj</span><br><span class="line">file_2:mghio</span><br><span class="line">file_4:dkfjlmghioejfkds</span><br><span class="line">file_4:mghio djftgf</span><br><span class="line">file_4:twetmghioedkfgj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 列出所有的匹配行，并显示行号</span><br><span class="line">[root@mghio ~]# <span class="keyword">grep</span> mghio file_* /usr/demo</span><br><span class="line">file_1:<span class="number">1</span>:mghio</span><br><span class="line">file_1:<span class="number">3</span>:mghioddkjflkdjfdlkfjlsdkj</span><br><span class="line">file_2:<span class="number">4</span>:mghio</span><br><span class="line">file_4:<span class="number">8</span>:dkfjlmghioejfkds</span><br><span class="line">file_4:<span class="number">11</span>:mghio djftgf</span><br><span class="line">file_4:<span class="number">20</span>:twetmghioedkfgj</span><br></pre></td></tr></table></figure><h5 id="1-3-5-echo-命令"><a href="#1-3-5-echo-命令" class="headerlink" title="1.3.5 echo 命令"></a>1.3.5 echo 命令</h5><p><code>echo</code> 命令用于在终端设备上输出字符串或者变量提取后的值，这是在 <code>Linux</code> 系统中最常用的几个命令之一，在 <code>Linux</code> 系统中，人们一般使用在变量前加上 <code>$</code> 符号的方式提取出变量的值，例如：<code>$PATH</code>，然后再用 <code>echo</code> 命令予以输出。或者直接使用 <code>echo</code> 命令输出一段字符串到屏幕上，起到给用户提示的作用。<br><strong>语法格式</strong>：echo [参数] [字符串]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-n</td><td align="center">不输出结尾的换行符</td></tr><tr><td align="center">-e”\a”</td><td align="center">发出警告音</td></tr><tr><td align="center">-e”\b”</td><td align="center">删除前面的一个字符</td></tr><tr><td align="center">-e”\c”</td><td align="center">结尾不加换行符</td></tr><tr><td align="center">-e”\f”</td><td align="center">换行，光标仍然停留在原来的坐标位置</td></tr><tr><td align="center">-e”\n”</td><td align="center">换行，光标移至行首</td></tr><tr><td align="center">-e”\r”</td><td align="center">光标移至首行，但是不换行</td></tr><tr><td align="center">-E</td><td align="center">禁止反斜杠转义，与 <code>-e</code> 参数功能相反</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 输出一段字符串</span><br><span class="line">[root@mghio ~]#  <span class="keyword">echo</span> <span class="string">"mghio.cn"</span> </span><br><span class="line">mghio.<span class="keyword">cn</span></span><br><span class="line"></span><br><span class="line"># 输出变量提取后的值</span><br><span class="line">[root@mghio ~]# <span class="keyword">echo</span> $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</span><br><span class="line"></span><br><span class="line"># 对内容进行转义，不让$符号的提取变量值功能生效</span><br><span class="line">[root@mghio ~]# <span class="keyword">echo</span> \$PATH</span><br><span class="line">$PATH</span><br><span class="line"></span><br><span class="line"># 使用反引号符执行命令，并输出其结果到终端</span><br><span class="line">[root@mghio ~]# <span class="keyword">echo</span> `date`</span><br><span class="line">Sat Dec <span class="number">21</span> <span class="number">15</span>:<span class="number">30</span>:<span class="number">24</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure><h4 id="1-4-网络通讯"><a href="#1-4-网络通讯" class="headerlink" title="1.4 网络通讯"></a>1.4 网络通讯</h4><h5 id="1-4-1-ssh-命令"><a href="#1-4-1-ssh-命令" class="headerlink" title="1.4.1 ssh 命令"></a>1.4.1 ssh 命令</h5><p><code>ssh</code> 命令是 <code>openssh</code> 套件中的客户端连接工具，可以给予 <code>ssh</code> 加密协议实现安全的远程登录服务器，实现对服务器的管理。<br><strong>语法格式</strong>：ssh [参数] [主机]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">强制使用 <code>ssh</code> 协议版本 1</td></tr><tr><td align="center">-2</td><td align="center">强制使用 <code>ssh</code> 协议版本 2</td></tr><tr><td align="center">-4</td><td align="center">强制使用 <code>IPv4</code> 地址</td></tr><tr><td align="center">-6</td><td align="center">强制使用 <code>IPv6</code> 地址</td></tr><tr><td align="center">-A</td><td align="center">开启认证代理连接转发功能</td></tr><tr><td align="center">-a</td><td align="center">关闭认证代理连接转发功能</td></tr><tr><td align="center">-b&lt;IP地址&gt;</td><td align="center">使用本机指定的地址作为对位连接的源 <code>IP</code> 地址</td></tr><tr><td align="center">-C</td><td align="center">请求压缩所有数据</td></tr><tr><td align="center">-F&lt;配置文件&gt;</td><td align="center">指定 <code>ssh</code> 指令的配置文件，默认的配置文件为 <code>/etc/ssh/ssh_config</code></td></tr><tr><td align="center">-f</td><td align="center">后台执行 <code>ssh</code>指令</td></tr><tr><td align="center">-g</td><td align="center">允许远程主机连接本机的转发端口</td></tr><tr><td align="center">-i&lt;身份文件&gt;</td><td align="center">指定身份文件（即私钥文件）</td></tr><tr><td align="center">-l&lt;登录名&gt;</td><td align="center">指定连接远程服务器的登录用户名</td></tr><tr><td align="center">-N</td><td align="center">不执行远程指令</td></tr><tr><td align="center">-o&lt;选项&gt;</td><td align="center">指定配置选项</td></tr><tr><td align="center">-p&lt;端口&gt;</td><td align="center">指定远程服务器上的端口</td></tr><tr><td align="center">-q</td><td align="center">静默模式，所有的警告和诊断信息被禁止输出</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 登录远程服务器</span><br><span class="line">[root@mghio ~]# ssh <span class="number">112.67</span>.<span class="number">239.127</span></span><br><span class="line"></span><br><span class="line"># 用 mghio 用户连接远程服务器</span><br><span class="line">[root@linuxcool ~]# ssh -<span class="keyword">l</span> mghio <span class="number">112.67</span>.<span class="number">239.127</span></span><br></pre></td></tr></table></figure><h5 id="1-4-2-sftp-命令"><a href="#1-4-2-sftp-命令" class="headerlink" title="1.4.2 sftp 命令"></a>1.4.2 sftp 命令</h5><p><code>sftp</code> 命令全称是 <code>Secure File Transfer Protocol</code>。是一个交互式的文件传输程序，<code>sftp</code> 命令的运行和使用与 <code>ftp</code> 相似，但是 <code>sftp</code> 命令对传输的所有信息使用 <code>ssh</code> 加密 ，它还支持公钥认证和压缩等功能。<br><strong>语法格式</strong>：sftp [参数] [IP或主机名]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-B</td><td align="center">指定传输文件缓冲区的大小</td></tr><tr><td align="center">-l</td><td align="center">使用 <code>ssh</code> 协议版本 1</td></tr><tr><td align="center">-b</td><td align="center">指定批处理文件</td></tr><tr><td align="center">-C</td><td align="center">使用压缩</td></tr><tr><td align="center">-o</td><td align="center">指定 <code>ssh</code> 选项</td></tr><tr><td align="center">-F</td><td align="center">指定 <code>ssh</code> 配置文件</td></tr><tr><td align="center">-R</td><td align="center">指定一次可以容忍多少请求数</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用 sftp 命令连接到服务器</span><br><span class="line">[root@mghio ~]# sftp <span class="number">112.67</span>.<span class="number">239.127</span></span><br><span class="line"></span><br><span class="line"># 指定传输文件是缓冲区大小</span><br><span class="line">[root@mghio ~]# sftp -B <span class="number">256</span> <span class="number">112.67</span>.<span class="number">239.127</span></span><br><span class="line"></span><br><span class="line"># 在传输过程中使用压缩</span><br><span class="line">[root@linuxcool ~]# sftp -C <span class="number">112.67</span>.<span class="number">239.127</span></span><br></pre></td></tr></table></figure><h5 id="1-4-3-telnet-命令"><a href="#1-4-3-telnet-命令" class="headerlink" title="1.4.3 telnet 命令"></a>1.4.3 telnet 命令</h5><p><code>telnet</code> 命令的功能是远端登入，执行 <code>telnet</code> 指令开启终端机阶段作业，并登入远端主机。<code>telnet</code> 命令可以帮助你从这台路由器远程登陆到远端开启了 <code>telnet</code> 服务的设备，包括路由器、交换机、<code>Linux</code> 服务器等，并且配置当前路由器的 <code>telnet</code> 服务。<br><strong>语法格式</strong>：telnet [参数]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-8</td><td align="center">允许使用 8 位字符资料，包括输入与输出</td></tr><tr><td align="center">-a</td><td align="center">尝试自动登入远端系统</td></tr><tr><td align="center">-b</td><td align="center">使用别名指定远端主机名称</td></tr><tr><td align="center">-c</td><td align="center">不读取用户专属目录里的 <code>.telnetrc</code> 文件</td></tr><tr><td align="center">-d</td><td align="center">启动排错模式</td></tr><tr><td align="center">-e</td><td align="center">设置脱离字符</td></tr><tr><td align="center">-E</td><td align="center">滤除脱离字符</td></tr><tr><td align="center">-f</td><td align="center">此参数的效果和指定 <code>-F</code> 参数相同</td></tr><tr><td align="center">-F</td><td align="center">使用 <code>Kerberos V5</code> 认证时，加上此参数可把本地主机的认证数据上传到远端主机</td></tr><tr><td align="center">-k</td><td align="center">使用 <code>Kerberos</code> 认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名</td></tr><tr><td align="center">-K</td><td align="center">不自动登入远端主机</td></tr><tr><td align="center">-l</td><td align="center">指定要登入远端主机的用户名称</td></tr><tr><td align="center">-L</td><td align="center">允许输出8位字符资料</td></tr><tr><td align="center">-n</td><td align="center">指定文件记录相关信息</td></tr><tr><td align="center">-r</td><td align="center">使用类似 <code>rlogin</code> 指令的用户界面</td></tr><tr><td align="center">-S</td><td align="center">设置 <code>telnet</code> 连线所需的 <code>IP TOS</code> 信息</td></tr><tr><td align="center">-x</td><td align="center">假设主机有支持数据加密的功能，就使用它</td></tr><tr><td align="center">-X</td><td align="center">关闭指定的认证形态</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 登录远程主机</span><br><span class="line">[root@mghio ~]# telnet <span class="number">112.67</span>.<span class="number">239.127</span></span><br><span class="line"></span><br><span class="line"># 连接本地主机，端口号为 <span class="number">23</span></span><br><span class="line">[root@mghio ~]# telnet localhost <span class="number">23</span></span><br></pre></td></tr></table></figure><h5 id="1-4-4-netstat-命令"><a href="#1-4-4-netstat-命令" class="headerlink" title="1.4.4 netstat 命令"></a>1.4.4 netstat 命令</h5><p><code>netstat</code> 命令用于显示各种网络相关信息，如网络连接、路由表、接口状态、多播成员等。从整体上看，<code>netstat</code> 的输出结果为两部分：一个是 <code>Active Internet connections</code> 称为 <code>有源 TCP 连接</code>，其中 <code>Recv-Q</code> 和 <code>Send-Q</code> 指 <code>%OA</code> 的是接收队列和发送队列。另一个是 <code>Active UNIX domain sockets</code>，称为<code>有源Unix域套接口</code>(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。<br><strong>语法格式</strong>：netstat [参数]<br><strong>常用参数</strong></p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">显示所有连线中的 <code>Socket</code></td></tr><tr><td align="center">-p</td><td align="center">显示正在使用 <code>Socket</code> 的程序识别码和程序名称</td></tr><tr><td align="center">-u</td><td align="center">显示 <code>UDP</code> 传输协议的连线状况</td></tr><tr><td align="center">-i</td><td align="center">显示网络界面信息表单</td></tr><tr><td align="center">-n</td><td align="center">直接使用 <code>IP</code> 地址，不通过域名服务器</td></tr></tbody></table><p><strong>Examples</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 显示详细的网络状况</span><br><span class="line">[root@mghio ~]# netstat -<span class="keyword">a</span></span><br><span class="line"></span><br><span class="line"># 显示当前 UDP 连接状况</span><br><span class="line">[root@mghio ~]# netstat -<span class="keyword">nu</span></span><br><span class="line"></span><br><span class="line"># 显示网卡列表</span><br><span class="line">[root@mghio ~]# netstat -i</span><br><span class="line">Kernel Interface table </span><br><span class="line">Iface MTU Met  RX-OK  RX-ERR  RX-DRP RX-OVR  TX-OK TX-ERR TX-DRP TX-OVR Flg </span><br><span class="line">eth0 <span class="number">1500</span>   <span class="number">0</span>  <span class="number">181864</span>   <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>     <span class="number">141278</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    BMRU </span><br><span class="line"><span class="keyword">lo</span>   <span class="number">16436</span>  <span class="number">0</span>   <span class="number">3362</span>    <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>     <span class="number">3362</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    LRU</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h4&gt;&lt;p&gt;作为 &lt;code&gt;Java&lt;/code&gt; 后端开发的我们，开发的项目绝大部分都是部署在 &lt;code&gt;Linux&lt;/code&gt; 系统上的，因此熟练使用一些常用的 &lt;code&gt;Linux&lt;/code&gt; 命令不管是对于日常开发、服务部署或者查找问题都非常有用。以下整理了一些常用的 &lt;code&gt;Linux&lt;/code&gt; 常用命令。&lt;/p&gt;
&lt;h4 id=&quot;1-2-文件管理&quot;&gt;&lt;a href=&quot;#1-2-文件管理&quot; class=&quot;headerlink&quot; title=&quot;1.2 文件管理&quot;&gt;&lt;/a&gt;1.2 文件管理&lt;/h4&gt;&lt;h5 id=&quot;1-2-1-ls-命令&quot;&gt;&lt;a href=&quot;#1-2-1-ls-命令&quot; class=&quot;headerlink&quot; title=&quot;1.2.1 ls 命令&quot;&gt;&lt;/a&gt;1.2.1 ls 命令&lt;/h5&gt;&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 命令是 &lt;code&gt;Linux&lt;/code&gt; 最常用的命令之一，其功能是列出指定目录下的内容及其相关属性信息。默认状态下，&lt;code&gt;ls&lt;/code&gt; 命令会列出当前目录的内容，它也可以带上一些参数来实现更多的功能。&lt;br&gt;&lt;strong&gt;语法格式&lt;/strong&gt;：ls [选项] [文件]&lt;br&gt;&lt;strong&gt;常用参数&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;参数&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-a&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;显示所有文件及目录（包括以 &lt;code&gt;.&lt;/code&gt; 开头的隐藏文件）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-l&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;使用长格式列出文件及目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-r&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;将文件以相反次序显示（默认按照英文字母次序）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-t&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;根据最后的修改时间排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-A&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;同 &lt;code&gt;-a&lt;/code&gt;，但是不列出 &lt;code&gt;.&lt;/code&gt;（当前目录）以及 &lt;code&gt;..&lt;/code&gt;（父级目录）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-S&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;根据文件大小排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-R&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;递归列出所有子目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="Linux笔记" scheme="https://www.mghio.cn/categories/Linux%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux笔记" scheme="https://www.mghio.cn/tags/Linux%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程基础（二）</title>
    <link href="https://www.mghio.cn/post/4ea48fa7.html"/>
    <id>https://www.mghio.cn/post/4ea48fa7.html</id>
    <published>2019-12-14T08:32:14.000Z</published>
    <updated>2019-12-16T12:22:59.495Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在上篇 <a href="https://www.mghio.cn/post/7eb2637f.html">Java 多线程基础（一）</a> 我们提到了一些线程的常用方法，这篇我们具体看看其中一些方法的使用以及方法的区别，让我们在工作中更好的使用。</p><h4 id="wait-方法与-notify-方法"><a href="#wait-方法与-notify-方法" class="headerlink" title="wait 方法与 notify 方法"></a>wait 方法与 notify 方法</h4><p>在 <code>Object</code> 类中定义了 <code>wait</code> 方法和 <code>notify</code> 方法，<code>wait</code> 方法的作用是让当前线程进入等待状态，将当前线程置入 <code>预执行队列</code>，会在 <code>wait</code> 方法所在代码处停止执行，直到被通知或者被中断，在调用 <code>wait</code> 方法之前，线程必须获取该对象的锁，因此只能在<code>同步方法</code>或者<code>同步代码块</code>中调用 <code>wait</code> 方法，并且该方法会释放当前线程锁持有的锁。<code>notify</code> 方法是唤醒在当前对象上等待的<code>单个线程</code>，如果有多个线程等待，那么线程调度器会挑出一个 <code>wait</code> 的线程，对其发出 <code>notify</code> ，并使它等待获取该对象的对象锁，这意味着，即使收到了通知，线程也不会立即获取到对象锁，必须等待 <code>notify</code> 方法的线程释放锁才可以。和 <code>wait</code> 方法一样，<code>notify</code> 方法也只能在<code>同步方法</code>或者<code>同步代码块</code>中调用。它还有个相似的方法 <code>notifyAll</code>，它的作用是唤醒在当前对象上等待的<code>所有线程</code>。</p><a id="more"></a><p>下面通过一个生产者消费者来说明 <code>wait</code> 方法和 <code>notify</code> 方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程 wait() 和 notify() 方法使用示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadWaitAndNotifyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">new</span> Consumer(<span class="string">"Consumer One"</span>, producer).start();</span><br><span class="line">    <span class="keyword">new</span> Consumer(<span class="string">"Consumer Two"</span>, producer).start();</span><br><span class="line">    <span class="keyword">new</span> Consumer(<span class="string">"Consumer Three"</span>, producer).start();</span><br><span class="line">    <span class="keyword">new</span> Consumer(<span class="string">"Consumer Four"</span>, producer).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; messageList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          <span class="keyword">synchronized</span> (messageList) &#123;</span><br><span class="line">            String message = String.format(<span class="string">"producer message [create time:%s]"</span>, LocalDateTime.now());</span><br><span class="line">            messageList.add(message);</span><br><span class="line">            System.out.println(<span class="string">"Producer "</span> + getName() + <span class="string">" producer a msg: "</span> + message);</span><br><span class="line">            messageList.notify();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (messageList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (messageList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            messageList.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> messageList.remove(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Producer producer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String name, Producer producer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">      <span class="keyword">this</span>.producer = producer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String message = producer.getMessage();</span><br><span class="line">        System.out.println(<span class="string">"Consumer "</span> + getName() + <span class="string">" get a msg: "</span> + message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Producer Thread-<span class="number">0</span> producer a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">42.319</span>]</span><br><span class="line">Consumer Consumer One get a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">42.319</span>]</span><br><span class="line">Producer Thread-<span class="number">0</span> producer a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">44.324</span>]</span><br><span class="line">Consumer Consumer Two get a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">44.324</span>]</span><br><span class="line">Producer Thread-<span class="number">0</span> producer a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">46.325</span>]</span><br><span class="line">Consumer Consumer Three get a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">46.325</span>]</span><br><span class="line">Producer Thread-<span class="number">0</span> producer a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">48.328</span>]</span><br><span class="line">Consumer Consumer Four get a msg: producer message [create time:<span class="number">2019</span>-<span class="number">12</span>-<span class="number">14</span>T22:<span class="number">45</span>:<span class="number">48.328</span>]</span><br></pre></td></tr></table></figure><p>消费者线程循环调用生产者的 <code>getMessage</code> 方法获取消息，如果消息列表 <code>messageList</code> 为空，则调用消息列表的 <code>wait</code> 方法让线程进入等待状态，生产者每隔 2 秒生成消息并放入消息列表 <code>messageList</code> 中，放入成功后调用 <code>notify</code> 方法唤醒一个处于 <code>wait</code> 状态的线程去消费消息，需要注意的是，在调用 <code>wait</code> 和 <code>notify</code> 方法时必须要先获得该对象的锁，上面的示例中是在 <code>synchronized</code> 代码块中调用的。</p><h4 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep 方法"></a>sleep 方法</h4><p>与 <code>wait</code>、<code>notify</code> 方法不同，<code>sleep</code> 方法定义在 <code>Thread</code> 类中，从方法名也可以知道，这个方法的作用就是让<code>当前线程休眠</code>，即调用该方法后当前线程会从<code>运行状态(Running）状态</code>进入到<code>阻塞（休眠）状态（Blocked）</code>，同时该方法必须指定休眠的时间，当前线程的休眠时间会大于或者等于这个指定的休眠时间。当线程重新被唤醒时，线程会由<code>阻塞状态（Blocked）</code>变成<code>就绪状态（Runnable）</code>，然后等待 CPU 的调度执行。<code>sleep</code> 方法的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程 sleep() 方法使用示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread myThreadOne = <span class="keyword">new</span> MyThread(<span class="string">"t1"</span>);</span><br><span class="line">    MyThread myThreadTwo = <span class="keyword">new</span> MyThread(<span class="string">"t2"</span>);</span><br><span class="line">    myThreadOne.start();</span><br><span class="line">    myThreadTwo.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s: %d"</span>, <span class="keyword">this</span>.getName(), i));</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">              Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1: <span class="number">0</span></span><br><span class="line">t1: <span class="number">1</span></span><br><span class="line">t1: <span class="number">2</span></span><br><span class="line">t1: <span class="number">3</span></span><br><span class="line">t1: <span class="number">4</span></span><br><span class="line">t2: <span class="number">0</span></span><br><span class="line">t2: <span class="number">1</span></span><br><span class="line">t2: <span class="number">2</span></span><br><span class="line">t2: <span class="number">3</span></span><br><span class="line">t2: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>我们启动了两个线程 <code>t1</code> 和 <code>t2</code>，两个线程的 <code>run</code> 方法引用了同一个对象 <code>object</code> 的同步锁（<code>synchronized (object)</code>），虽然在第一个线程 <code>t1</code> 中当 <code>i</code> 被 2 整除时会调用 <code>Thread.sleep(2000)</code> 让当前线程休眠 2 s，但是此时线程 <code>t2</code> 也不会得到 cpu 的执行权去执行，因为 <code>t1</code> 线程调用 <code>sleep</code> 方法并没有释放<code>object</code>所持有的同步锁。如果我们注释掉 <code>synchronized (object)</code> 后再次执行该程序，线程 <code>t1</code> 和 <code>t2</code> 是可以交替执行的，注释之后的输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t2: <span class="number">0</span></span><br><span class="line">t1: <span class="number">0</span></span><br><span class="line">t1: <span class="number">1</span></span><br><span class="line">t2: <span class="number">1</span></span><br><span class="line">t1: <span class="number">2</span></span><br><span class="line">t2: <span class="number">2</span></span><br><span class="line">t2: <span class="number">3</span></span><br><span class="line">t1: <span class="number">3</span></span><br><span class="line">t2: <span class="number">4</span></span><br><span class="line">t1: <span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield 方法"></a>yield 方法</h4><p><code>yield</code> 方法定义在 <code>Thread</code> 类中，是线程特有的方法。此方法的主要作用是<code>让步</code>，它会使当前线程从<code>运行状态（Running）</code>变为<code>就绪状态（Runnable）</code>，从而让其他具有同样优先级的处于<code>就绪状态</code>的线程获取到 CPU 执行权(<code>PS: CPU 会从众多的处于就绪状态的线程里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到</code>)，但是，也并不能保证在当前线程调用 <code>yield</code> 之后，其它哪些具有相同优先级的线程就一定能获得执行权，也有可能是当前线程又进入到<code>运行状态（Running）</code>继续运行。<code>yield</code> 方法的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程 yield() 方法使用示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread myThreadOne = <span class="keyword">new</span> MyThread(<span class="string">"t1"</span>);</span><br><span class="line">    MyThread myThreadTwo = <span class="keyword">new</span> MyThread(<span class="string">"t2"</span>);</span><br><span class="line">    myThreadOne.start();</span><br><span class="line">    myThreadTwo.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyThread(String name) &#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s [%d] ---&gt; %d"</span>, <span class="keyword">this</span>.getName(), <span class="keyword">this</span>.getPriority(), i));</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">          yield();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">0</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">0</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">1</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">2</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">3</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">4</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">5</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">6</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">7</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">8</span></span><br><span class="line">t1 [<span class="number">5</span>] ---&gt; <span class="number">9</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">1</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">2</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">3</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">4</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">5</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">6</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">7</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">8</span></span><br><span class="line">t2 [<span class="number">5</span>] ---&gt; <span class="number">9</span></span><br></pre></td></tr></table></figure><p>从以上输出结果可以看出，线程 <code>t1</code> 中的变量 <code>i</code> 在被 2 整除的时候，并没有切换到线程 <code>t2</code> 去执行，这也验证了我们上文说的，<code>yield</code> 方法虽然可以让线程由<code>运行状态</code>变成<code>就绪状态</code>，但是，它不一定会让其它线程获取 CPU 执行权从而进入到<code>运行状态</code>，即使这个其它线程和当前具有相同的优先级，<code>yield</code> 方法不会释放锁（证明方法只需将上面这个示例的 <code>run</code> 方法里面加上 <code>synchronized (obj)</code> 即可，此时 <code>t2</code> 线程会等到线程 <code>t1</code> 执行完毕后才会执行）。</p><h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h4><p>在有些场景中我们需要在子线程去执行一些耗时的任务，但是我们的主线程又必须等待子线程执行完毕之后才能结束，那么此时就可以使用 <code>join</code> 方法了，该方法定义在 <code>Thread</code> 类中，方法的作用是：<code>让主线程等待子线程执行结束之后才能继续执行</code>，下面我们通过一个例子来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 线程 join() 方法使用示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MyThread myThread = <span class="keyword">new</span> MyThread(<span class="string">"t1"</span>);</span><br><span class="line">      myThread.start();</span><br><span class="line">      myThread.join();</span><br><span class="line">      System.out.println(String.format(<span class="string">"%s ---&gt; %s finish"</span>, LocalDateTime.now(), Thread.currentThread().getName()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyThread(String name) &#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(String.format(<span class="string">"%s ---&gt; %s start"</span>, LocalDateTime.now(), <span class="keyword">this</span>.getName()));</span><br><span class="line">      <span class="comment">// 模拟耗时操作</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(String.format(<span class="string">"%s ---&gt; %s finish"</span>, LocalDateTime.now(), <span class="keyword">this</span>.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">15</span>T00:<span class="number">22</span>:<span class="number">55.971</span> ---&gt; t1 start</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">15</span>T00:<span class="number">22</span>:<span class="number">57.984</span> ---&gt; t1 finish</span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span>-<span class="number">15</span>T00:<span class="number">22</span>:<span class="number">57.985</span> ---&gt; main finish</span><br></pre></td></tr></table></figure><p>在主线程 <code>main</code> 中通过 <code>new MyThread(&quot;t1&quot;)</code> 新建线程 <code>t1</code>。 接着，通过 <code>t1.start()</code> 启动线程 <code>t1</code>，在执行 <code>t1.join()</code>之后， 主线程会进入<code>阻塞状态</code>等待 <code>t1</code> 运行结束。子线程 <code>t1</code> 结束之后，会唤醒主线程，主线程重新获取 CPU 执行权，主线程继续往下运行。在使用了 <code>join</code> 方法之后主线程会等待子线程结束之后才会结束。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上是线程一些常用的方法介绍和具体使用知识总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在上篇 &lt;a href=&quot;https://www.mghio.cn/post/7eb2637f.html&quot;&gt;Java 多线程基础（一）&lt;/a&gt; 我们提到了一些线程的常用方法，这篇我们具体看看其中一些方法的使用以及方法的区别，让我们在工作中更好的使用。&lt;/p&gt;
&lt;h4 id=&quot;wait-方法与-notify-方法&quot;&gt;&lt;a href=&quot;#wait-方法与-notify-方法&quot; class=&quot;headerlink&quot; title=&quot;wait 方法与 notify 方法&quot;&gt;&lt;/a&gt;wait 方法与 notify 方法&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;Object&lt;/code&gt; 类中定义了 &lt;code&gt;wait&lt;/code&gt; 方法和 &lt;code&gt;notify&lt;/code&gt; 方法，&lt;code&gt;wait&lt;/code&gt; 方法的作用是让当前线程进入等待状态，将当前线程置入 &lt;code&gt;预执行队列&lt;/code&gt;，会在 &lt;code&gt;wait&lt;/code&gt; 方法所在代码处停止执行，直到被通知或者被中断，在调用 &lt;code&gt;wait&lt;/code&gt; 方法之前，线程必须获取该对象的锁，因此只能在&lt;code&gt;同步方法&lt;/code&gt;或者&lt;code&gt;同步代码块&lt;/code&gt;中调用 &lt;code&gt;wait&lt;/code&gt; 方法，并且该方法会释放当前线程锁持有的锁。&lt;code&gt;notify&lt;/code&gt; 方法是唤醒在当前对象上等待的&lt;code&gt;单个线程&lt;/code&gt;，如果有多个线程等待，那么线程调度器会挑出一个 &lt;code&gt;wait&lt;/code&gt; 的线程，对其发出 &lt;code&gt;notify&lt;/code&gt; ，并使它等待获取该对象的对象锁，这意味着，即使收到了通知，线程也不会立即获取到对象锁，必须等待 &lt;code&gt;notify&lt;/code&gt; 方法的线程释放锁才可以。和 &lt;code&gt;wait&lt;/code&gt; 方法一样，&lt;code&gt;notify&lt;/code&gt; 方法也只能在&lt;code&gt;同步方法&lt;/code&gt;或者&lt;code&gt;同步代码块&lt;/code&gt;中调用。它还有个相似的方法 &lt;code&gt;notifyAll&lt;/code&gt;，它的作用是唤醒在当前对象上等待的&lt;code&gt;所有线程&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="多线程" scheme="https://www.mghio.cn/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="多线程" scheme="https://www.mghio.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程基础（一）</title>
    <link href="https://www.mghio.cn/post/7eb2637f.html"/>
    <id>https://www.mghio.cn/post/7eb2637f.html</id>
    <published>2019-12-07T13:56:55.000Z</published>
    <updated>2019-12-08T15:20:18.832Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在接触<code>多线程</code>之前，在我们程序中在任意时刻都只能执行一个步骤，称之为<code>单线程</code>。在单线程开发的程序中所有的程序路径都是顺序执行的，前面的必须先执行，后面的才会执行。单线程的优点也很明显，相对于多线程来说更加稳定、扩展性更强、程序开发相对比较容易。但是由于每次都要等上一个任务执行完成后才能开始新的任务，导致其效率比多线程低，甚至有时候应用程序会出现假死的现象。使用多线程有利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。多线程是 Java 学习的非常重要的方面，是每个 Java 程序员必须掌握的基本技能。本文是有关 Java 多线程的一些基础知识总结。</p><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程是<code>操作系统资源分配</code>的基本单位，它是操作系统的基础，是一个程序及其数据在处理机上顺序执行时所发生的活动。一个程序进入内存运行，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立功能。进程的实质就是程序在操作系统中的一次执行过程，它是动态产生的、动态销毁的，拥有自己的生命周期和各种不同的运行状态。同时，进程还具有并发性，它可以同其他进程一起并发执行，按各自独立的、不可预知的速度向前推进（<code>PS：并发性和并行性是不同的概念，并行指的是同一时刻，两个及两个以上的指令在多个处理器上同时执行。而并发指的是同一时刻只有一条指令执行，但是多个进程可以被 CPU 快速交换执行，给我们感觉好像是多个执行在同时执行一样</code>）。　</p><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程是<code>任务调度和执行</code>的基本单位，也被称为<code>轻量级进程</code>，线程由线程 ID，当前指令指针(PC），寄存器集合和堆栈组成。线程不拥有系统资源，它只会拥有一点儿在运行时必不可少的资源，但是它可以与同属于同一进程的线程共享该进程所拥有的所有资源。一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</p><a id="more"></a><h5 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h5><ol><li><strong>调度</strong> 线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li><li><strong>并发性</strong> 不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</li><li><strong>拥有资源</strong> 进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源</li><li><strong>系统开销</strong> 在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销</li></ol><h4 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h4><p>在 Java 中使用 Thread 类代表线程，所有的线程对象都必须是 Thread 类或者其子类的实例，Java 中创建线程主要有以下三种方式：</p><h5 id="方式一-继承-Thread-类"><a href="#方式一-继承-Thread-类" class="headerlink" title="方式一 继承 Thread 类"></a>方式一 继承 Thread 类</h5><p><strong>step 1</strong> 定义一个类继承自 <code>Thread</code> 类，然后重写该类的 <code>run</code> 方法，这个方法的内容表示线程要完成的任务<br><strong>step 2</strong> 创建线程对象，即创建 <code>Thread</code> 类子类的实例<br><strong>step 3</strong> 调用步骤二中创建出来的对象的 <code>start</code> 方法来启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过继承 Thread 类的方式创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByExtendsThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CreateThreadByExtendsThread threadOne = <span class="keyword">new</span> CreateThreadByExtendsThread();</span><br><span class="line">    CreateThreadByExtendsThread threadTwo = <span class="keyword">new</span> CreateThreadByExtendsThread();</span><br><span class="line">    CreateThreadByExtendsThread threadThree = <span class="keyword">new</span> CreateThreadByExtendsThread();</span><br><span class="line"></span><br><span class="line">    threadOne.start();</span><br><span class="line">    threadTwo.start();</span><br><span class="line">    threadThree.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二-实现-Runnable-接口"><a href="#方式二-实现-Runnable-接口" class="headerlink" title="方式二 实现 Runnable 接口"></a>方式二 实现 Runnable 接口</h5><p><strong>step 1</strong> 定义一个类实现 <code>Runnable</code> 接口，然后实现该接口的 <code>run</code> 方法，这个方法的内容同样也表示线程要完成的任务<br><strong>step 2</strong> 创建 <code>Runnable</code> 接口实现类的实例，并使用该实例作为 <code>Thraed</code> 构造方法的参数创建 <code>Thread</code> 类的对象，该对象才是真正的线程对象<br><strong>step 3</strong> 调用线程对象的 <code>start</code> 方法来启动该线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过实现 Runnable 接口的方式创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByImplementsRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10</span>).forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CreateThreadByImplementsRunnable target = <span class="keyword">new</span> CreateThreadByImplementsRunnable();</span><br><span class="line">    <span class="keyword">new</span> Thread(target, <span class="string">"thread-one"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(target, <span class="string">"thread-two"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(target, <span class="string">"thread-three"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式三-实现-Callable-接口"><a href="#方式三-实现-Callable-接口" class="headerlink" title="方式三 实现 Callable 接口"></a>方式三 实现 Callable 接口</h5><p><strong>step 1</strong> 定义一个类实现 <code>Callable</code> 接口，然后实现该接口的 <code>call</code> 方法，这个方法的内容同样也表示线程要完成的任务，并且有返回值<br><strong>step 2</strong> 创建 <code>Callable</code> 接口实现类的实例，使用 <code>FutureTask</code> 类来包装 <code>Callable</code> 对象，该 <code>FutureTask</code> 对象封装了 <code>Callable</code> 对象的 <code>call</code> 方法的返回值<br><strong>step 3</strong> 并使用 <code>FutureTask</code> 对象作为 <code>Thraed</code> 构造方法的参数创建 <code>Thread</code> 对象，并调用该对象的 <code>start</code> 方法启动线程<br><strong>step 4</strong> 调用 <code>FutureTask</code> 对象的 <code>get</code> 方法获取线程执行结束后的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019-12-07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 通过实现 Callable 接口的方式创建线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadByImplementsCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    IntStream.rangeClosed(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">      count.getAndIncrement();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CreateThreadByImplementsCallable target = <span class="keyword">new</span> CreateThreadByImplementsCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(target);</span><br><span class="line"></span><br><span class="line">    IntStream.rangeClosed(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">" 的循环变量 i 的值"</span> + i);</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask, <span class="string">"有返回值的线程"</span>).start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">"有返回值线程的返回值："</span> + futureTask.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上可以看出，其实通过实现 <code>Runnable</code> 接口和实现 <code>Callable</code> 接口这两种方式创建线程基本相同，采用实现 <code>Runnable</code> 和 <code>Callable</code> 接口的方式创建线程时，线程类只是实现接口，还可以继承其它类（<code>PS：Java 单继承决定</code>）。在这种方式下，多个线程可以共享同一个 <code>target</code>对象，所以非常适合多个相同线程来处理同一份资源的情况。还有一点就是，使用继承 <code>Thread</code> 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 <code>Thread.currentThread()</code> 方法，直接使用 <code>this</code> 即可获得当前线程。，在实际项目中如果使用这三种方式创建线程，如果创建关闭频繁会消耗系统资源影响性能，而使用线程池可以不用线程的时候放回线程池，用的时候再从线程池取，所以在我们项目开发中主要还是使用线程池，有关线程池的可以看看这两篇 <a href="https://www.mghio.cn/post/bc557e1a.html">Java 线程池（一）</a>、<a href="https://www.mghio.cn/post/ab706eb5.html">Java 线程池（二）</a>。</p><h4 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h4><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程，在 Java 中一个线程完整的生命周期一共包含以下五种状态：<br><strong>新建状态（New）</strong><br>当使用 <code>new</code> 关键字和 <code>Thread</code> 类或其子类创建一个线程对象后，那么线程就进入了<code>新建状态</code>，此时它和其它的 Java 对象一样，仅仅由 JVM 分配了内存，并初始化其成员变量值，它会一直保持这个状态直到调用该对象的 <code>start</code> 方法。</p><p><strong>就绪状态（Runnable）</strong><br>当线程对象调用了 <code>start</code> 方法之后，该线程就进入了就绪状态。就绪状态的线程会放在一个就绪队列中，等待 JVM 里的调度器进行调度。处于就绪状态的线程，随时可能被 CPU 调度执行。</p><p><strong>运行状态（Running）</strong><br>如果就绪状态的执行被 CPU 调度执行，就可以执行 <code>run</code> 方法，此时线程就处于线程状态。处于运行状态的线程最复杂，它可以变为<code>阻塞状态</code>、<code>就绪状态</code>和<code>死亡状态</code>。需要注意一点，线程变为<code>运行状态</code>之前的状态只能是<code>就绪状态</code>。</p><p><strong>阻塞状态（Blocked）</strong><br>线程变为阻塞状态是因为某种原因放弃 CPU 的使用权，暂时停止运行，如果执行了 <code>sleep</code>、<code>suspend</code> 等方法，释放了所占用的资源之后，线程就从<code>运行状态</code>进入<code>阻塞状态</code>。等待睡眠时间结束或者获得设备资源之可以重新进入<code>就绪状态</code>。阻塞可以分为以下三种：</p><ol><li><strong>等待阻塞</strong> 处于<code>运行状态</code>的线程调用<code>wait</code>方法，会使线程进入<code>等待阻塞状态</code></li><li><strong>同步阻塞</strong> 当线程获取 <code>synchronized</code> 同步锁因为同步锁被其他线程占用而失败后，会使线程进入<code>同步阻塞</code></li><li><strong>其它阻塞</strong> 通过调用线程的<code>sleep</code>或<code>join</code>发出了 I/O 请求时，线程就会进入到阻塞状态。当<code>sleep</code>状态超时，<code>join</code>等待线程终止或超时，或者 I/O 处理完毕，线程重新回到<code>就绪状态</code>。</li></ol><p><strong>死亡状态（Dead）</strong><br>一个处于<code>运行状态</code>的线程执行完了 <code>run</code> 方法或者因为其它终止条件发生时，线程就会进入到<code>死亡状态</code>，该线程结束生命周期。<br>以上线程各种状态的流转用一张图表示如下：</p><p><img src="https://i.loli.net/2019/12/07/ZtTHNLP8eoAYqcM.png" alt="thread-state-transfer.png"></p><h4 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h4><p>线程中常用的方法按照来源可以分为两类，一类是继承自 <code>Object</code> 类的方法，如下所示：</p><table><thead><tr><th align="left">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">public final native void notify()</td><td align="center">唤醒在此对象监视器上等待的单个线程，使其进入<code>就绪状态</code></td></tr><tr><td align="left">public final native void notifyAll()</td><td align="center">唤醒在此对象监视器上等待的所有线程，使其进入<code>就绪状态</code></td></tr><tr><td align="left">public final void wait()</td><td align="center">让当前线程处于·<code>等待阻塞状态</code>，直到其他线程调用此对象的<code>notify</code>方法或<code>notifyAll</code>方法，当前线程被唤醒，会释放它所持有的锁</td></tr><tr><td align="left">public final native void wait(long timeout)</td><td align="center">让当前线程处于·<code>等待阻塞状态</code>，直到其他线程调用此对象的<code>notify</code>方法或<code>notifyAll</code>方法，当前线程被唤醒</td></tr><tr><td align="left">public final void wait(long timeout, int nanos)</td><td align="center">让当前线程处于·<code>等待阻塞状态</code>，直到其他线程调用此对象的<code>notify</code>方法或<code>notifyAll</code>方法或者其他某个线程中断当前线程，或者已超过某个实际时间量，当前线程被唤醒</td></tr></tbody></table><p>另一类是 <code>Thread</code> 类定义的方法，如下所示：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public static native void yield()</td><td align="center">暂停当前正在执行的线程对象，并执行其他线程，<code>yield</code> 方法不会释放锁</td></tr><tr><td align="center">public static native void sleep(long millis)</td><td align="center">在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），<code>sleep</code> 方法不会释放锁</td></tr><tr><td align="center">public final void join()</td><td align="center">当某个程序执行流中调用其他线程的 <code>join</code> 方法时，调用线程将被阻塞，直到被 <code>join</code> 的线程执行完毕</td></tr><tr><td align="center">public void interrupt()</td><td align="center">用于中断本线程，这个方法被调用时，会立即将线程的中断标志设置为 <code>true</code></td></tr><tr><td align="center">public static boolean interrupted()</td><td align="center"><code>Thread</code> 类的一个静态方法，它返回一个布尔类型指明当前线程是否已经被中断，<code>interrupted</code> 方法除了返回中断标记之外，它还会清除中断标记(即将中断标记设为 <code>false</code>)</td></tr><tr><td align="center">public boolean isInterrupted()</td><td align="center"><code>Thread</code> 类的一个实例方法，它返回一个布尔类型指明当前线程是否已经被中断，<code>isInterrupted</code> 方法仅仅返回中断标记，不会清楚终端标记</td></tr></tbody></table><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 线程的优先级是一个整数，其取值范围是<code>1（Thread.MIN_PRIORITY ）~ 10（Thread.MAX_PRIORITY ）</code>。默认情况下，每一个线程都会分配一个优先级<code>NORM_PRIORITY（5）</code>。具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源，<code>Thread</code> 类提供了 <code>setPriority</code> 和 <code>getPriority</code> 方法来更改和获取线程优先级（<strong><font color="#ff0000">需要注意的是: 线程优先级不能保证线程执行的顺序，而且非常依赖于平台</font></strong>）。</p><hr><p>参考文章</p><ul><li><a href="https://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html" target="_blank" rel="noopener">进程和线程的区别</a></li><li><a href="https://www.cnblogs.com/skywang12345/p/3479224.html" target="_blank" rel="noopener">Java多线程系列–“基础篇”05之 线程等待与唤醒</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在接触&lt;code&gt;多线程&lt;/code&gt;之前，在我们程序中在任意时刻都只能执行一个步骤，称之为&lt;code&gt;单线程&lt;/code&gt;。在单线程开发的程序中所有的程序路径都是顺序执行的，前面的必须先执行，后面的才会执行。单线程的优点也很明显，相对于多线程来说更加稳定、扩展性更强、程序开发相对比较容易。但是由于每次都要等上一个任务执行完成后才能开始新的任务，导致其效率比多线程低，甚至有时候应用程序会出现假死的现象。使用多线程有利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。多线程是 Java 学习的非常重要的方面，是每个 Java 程序员必须掌握的基本技能。本文是有关 Java 多线程的一些基础知识总结。&lt;/p&gt;
&lt;h4 id=&quot;进程与线程的区别&quot;&gt;&lt;a href=&quot;#进程与线程的区别&quot; class=&quot;headerlink&quot; title=&quot;进程与线程的区别&quot;&gt;&lt;/a&gt;进程与线程的区别&lt;/h4&gt;&lt;h5 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h5&gt;&lt;p&gt;进程是&lt;code&gt;操作系统资源分配&lt;/code&gt;的基本单位，它是操作系统的基础，是一个程序及其数据在处理机上顺序执行时所发生的活动。一个程序进入内存运行，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立功能。进程的实质就是程序在操作系统中的一次执行过程，它是动态产生的、动态销毁的，拥有自己的生命周期和各种不同的运行状态。同时，进程还具有并发性，它可以同其他进程一起并发执行，按各自独立的、不可预知的速度向前推进（&lt;code&gt;PS：并发性和并行性是不同的概念，并行指的是同一时刻，两个及两个以上的指令在多个处理器上同时执行。而并发指的是同一时刻只有一条指令执行，但是多个进程可以被 CPU 快速交换执行，给我们感觉好像是多个执行在同时执行一样&lt;/code&gt;）。　&lt;/p&gt;
&lt;h5 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h5&gt;&lt;p&gt;线程是&lt;code&gt;任务调度和执行&lt;/code&gt;的基本单位，也被称为&lt;code&gt;轻量级进程&lt;/code&gt;，线程由线程 ID，当前指令指针(PC），寄存器集合和堆栈组成。线程不拥有系统资源，它只会拥有一点儿在运行时必不可少的资源，但是它可以与同属于同一进程的线程共享该进程所拥有的所有资源。一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="多线程" scheme="https://www.mghio.cn/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="多线程" scheme="https://www.mghio.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程池（二）</title>
    <link href="https://www.mghio.cn/post/ab706eb5.html"/>
    <id>https://www.mghio.cn/post/ab706eb5.html</id>
    <published>2019-11-30T08:07:14.000Z</published>
    <updated>2019-12-01T04:16:31.573Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在上篇 <a href="http://www.mghio.cn/post/bc557e1a.html">Java 线程池（一）</a> 我们介绍了线程池中一些的重要参数和具体含义，这篇我们看一看在 Java 中是如何去实现<code>线程池</code>的，要想用好线程池，只知其然是远远不够的，我们需要深入实现源码去了解线程池的具体实现细节，这样才能更好的使用到我们的工作中，当出现问题时能快速找到问题根源所在。</p><h4 id="线程池如何处理提交的任务"><a href="#线程池如何处理提交的任务" class="headerlink" title="线程池如何处理提交的任务"></a>线程池如何处理提交的任务</h4><p>我们向线程池提交任务有两种方式，分别是通过 <code>submit</code> 方法提交和通过 <code>execute</code> 方法提交，这两种方式的区别为 <code>execute</code> 只能提交 <code>Runnable</code> 类型的任务并且没有返回值，而 <code>submit</code> 既能提交 <code>Runnable</code> 类型的任务也能提交 <code>Callable</code>（JDK 1.5+）类型的任务并且会有一个类型 <code>Future</code> 的返回值，我们知道 <code>Runnable</code> 是没有返回值的，所以只有当提交 <code>Callable</code> 类型的任务时才会有返回值，而提交 <code>Runnable</code> 的返回值是 <code>null</code>。 <code>execute</code> 执行任务时，如果此时遇到异常会直接抛出，而 <code>submit</code> 不会直接抛出，只有在使用 <code>Future</code> 的 <code>get</code> 方法获取任务的返回结果时，才会抛出异常。<br>通过查看 <code>ThreadPoolExecutor</code> 的源码我们发现，其 <code>submit</code> 方法是继承自其抽象父类 <code>AbstractExecutorService</code> 而来的，有三个重载的方法，分别可以提交 <code>Runnable</code> 类型和 <code>Callable</code> 类型的任务。无论是哪个 <code>submit</code> 方法最终还是调用了 <code>execute</code> 方法来实现的。方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>首先对提交的任务进行判非空指针后，三个方法都是调用 <code>newTaskFor</code> 方法把任务统一封装成 <code>RunnableFuture</code> 对象，然后把封装好的对象作为 <code>execute</code> 方法的入参去执行，而此时 <code>execute</code> 方法还未实现，这个方法是在 <code>AbstractExecutorService</code> 的继承类 <code>ThreadPoolExecutor</code> 中实现。下面看看 <code>newTaskFor</code> 方法是如何封装我们提交的任务的，两个重载方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个 <code>FutureTask</code> 是个什么东东呢，进入其源码发现它实现了 <code>RunnableFuture</code> 接口，而 <code>RunnableFuture</code> 接口的作用正如其名，它是 <code>Runnable</code> 和 <code>Future</code> 的结合体，表示一个能<code>异步返回结果的线程</code>。我们知道 <code>Runnable</code> 是不能返回结果的，所以上面第一个 <code>newTaskFor(Runnable runnable, T value)</code> 方法的第二个参数 <code>value</code> 的作用就是指定返回结果。其实最后也是通过 <code>RunnableAdapter</code> 把  <code>Runnable</code> 和 <code>value</code> 封装成 <code>Callable</code> 的。下面我们看看 <code>execute</code> 方法是怎么处理的，方法源码如下：</p><p><img src="https://i.loli.net/2019/12/01/8gXOBWVe4hMmtPG.png" alt="thread-pool-3.png"></p><p><strong>第 ① 步</strong> 获取当前的 <code>ctl</code> 值，在上篇 <a href="http://www.mghio.cn/post/bc557e1a.html">Java 线程池（一）</a> 中说过，变量 <code>ctl</code> 存储了线程池的工作状态 <code>runState</code> 和线程池中正在运行的线程数 <code>workerCount</code>。<br><strong>第 ② 步</strong> 通过 <code>workerCountOf</code> 方法取出线程池中当前正在运行的线程数( <code>ctl</code> 低 29 位的值)，如果线程池当前工作线程数小于核心线程数 <code>corePoolSize</code>，则进行第 ③ 步。<br><strong>第 ③ 步</strong> 通过 <code>addWorker</code> 方法新建一个线程加到线程池中，<code>addWorker</code> 方法的第二个参数如果为 <code>true</code> 则限制添加线程的数量是根据 <code>corePoolSize</code> 来判断，反之则根据 <code>maximumPoolSize</code> 来判断，并把任务添加到该线程中。<br><strong>第 ④ 步</strong> 如果添加失败，则重新获取 <code>ctl</code> 的值。<br><strong>第 ⑤ 步</strong> 如果当前线程池的状态是运行状态（state &lt; SHUTDOWN）并且把任务成功添加到队列中。<br><strong>第 ⑥ 步</strong> 重新获取 <code>ctl</code> 的值，再次判断线程池的运行状态，如果不是运行状态，要从队列中移除任务，因为到这一步了，意味着之前已经把任务成功添加到队列中了，所以需要从队列移除。移除成功后调用拒绝策略对任务进行处理，整个 <code>execute</code> 方法结束（<code>PS：为什么不在入队列之前就先判断线程池的状态呢？因为判断一个线程池工作处于运行状态到执行入队列操作这段时间，线程池可能已经被其它线程关闭了，所以提前判断其实毫无意义</code>）。<br><strong>第 ⑦ 步</strong> 通过 <code>workerCountOf</code> 方法取出线程池中当前正在运行的线程数( <code>ctl</code> 低 29 位的值)，如果是 0 则执行 <code>addWorker(null, false)</code> 方法，第一个参数传 <code>null</code> 表示只是在线程池中创建一个线程出来，但是没有立即启动，因为我们创建线程池时可能要求核心线程数量为 0。第二个参数为 <code>false</code> 表示限制添加线程时根据 <code>maximumPoolSize</code> 来判断，如果当前线程池中正在运行线程数量大于 0 ，则直接返回，因为在上面第 ⑤ 步已经把任务成功添加到队列 <code>workQueue</code> 中，它会在将来的某个时刻执行到。<br><strong>第 ⑧ 步</strong> 如果执行到这个地方，只有两种情况，一种是线程池的状态已经不是运行状态了，另一种是线程池是运行状态，但是此时线程池的工作线程数大于等于核心线程数（workerCount &gt;= corePoolSize）并且队列 <code>workQueue</code> 已满。这时会再次调用 <code>addWorker</code> 方法，第二个参数传的 <code>false</code>，意味着限制添加线程的数量是根据 <code>maximumPoolSize</code> 来判断的，如果失败则调用拒绝策略对任务进行处理，整个 <code>execute</code> 方法结束。<br>上面的 <code>execute</code> 方法中多次调用 <code>addWorker</code>，该方法的主要作用就是创建一个线程来执行任务。<code>addWorker</code> 的方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addWorker(Runnable firstTask, <span class="keyword">boolean</span> core)</span><br></pre></td></tr></table></figure><p>第一个参数 <code>firstTask</code> 如果不为 <code>null</code>，则创建的线程首先执行 <code>firstTask</code> 任务，然后才会从队列中获取任务，否则会直接从队列中获取任务。第二个参数如果为 <code>true</code>，则表示限制添加线程时根据 <code>corePoolSize</code> 来判断，否则根据<code>maximumPoolSize</code> 来判断。我们看看 <code>addWorker</code> 方法的源码，方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法首先获取线程池 <code>ctl</code> 属性的值，该属性包含了线程池的<code>运行状态</code>和<code>工作线程数</code>，通过 <code>runStateOf</code> 获取线程池的运行状态，然后执行下面这个比较复杂的条件判断</p><p><img src="https://i.loli.net/2019/11/30/ZlVv9WBwQgmd1xc.png" alt="thread-pool-4.png"></p><p>第 ① 个条件表示此时线程池已经不再接受新任务了，接下来的 ②、③、④ 三个判断条件只要有一个不满足，那么方法就会返回 <code>false</code>，方法结束。第 ② 个条件表示线程池为关闭状态，处于关闭状态的线程池不会处理新提交的任务，但会处理完已处理的任务，第 ③ 个条件为 firstTask 为 <code>null</code>，第 ④ 个条件为队列不为空。我们看看如果线程池此时为关闭状态的情况，这种情况线程池不会接受新提交的任务，所以此时如果传入的 <code>firstTask</code> 不为 <code>null</code>，则会直接返回 <code>false</code>；然后如果 <code>firstTask</code> 为 <code>null</code>，并且队列 <code>workQueue</code> 为空，此时也会返回 <code>false</code>，因为此时队列里已经没有任务了，那么也不需要再添加线程了，然后接下来会进入一个循环。</p><p><img src="https://i.loli.net/2019/11/30/uCHvlNtQpzT1ach.png" alt="thread-pool-5.png"></p><p><strong>第 ① 步</strong> 调用 <code>workerCountOf</code> 方法获取当前线程池的工作线程数<br><strong>第 ② 步</strong> 如果当前线程池的工作数大于 <code>CAPACITY</code> 也就是 <code>ctl</code> 的低 29 位的最大值，则返回 <code>false</code>，如果不大于 <code>CAPACITY</code>，然后根据 <code>core</code> （该方法的第二个参数）来判断是和 <code>corePoolSize</code> 比较还是和 <code>maximumPoolSize</code> 比较，如果比这个值大则返回 <code>false</code>。<br><strong>第 ③ 步</strong> 使用 <code>ctl</code> 的 <code>compareAndSet</code> 原子方法尝试把工作线程数 <code>workerCount + 1</code>，如果增加成功，退出第一层循环。<br><strong>第 ④ 步</strong> 如果增加线程池工作线程数失败，则重新获取 <code>ctl</code> 的值。<br><strong>第 ⑤ 步</strong> 调用 <code>runStateOf</code> 获取线程池的状态，如果不等于方法前面获取的 <code>rs</code>，说明线程池的状态已经改变了，回到第一层循环继续执行。<br>接下来会启动线程执行任务，源码如下：</p><p><img src="https://i.loli.net/2019/11/30/ZnRj4395iqIAk2t.png" alt="thread-pool-6.png"></p><p><strong>第 ① 步</strong> 根据 <code>firstTask</code> 创建 <code>Worker</code> 对象，每一个 <code>Worker</code> 对象都会创建一个线程，然后会使用重入锁 <code>ReentrantLock</code> 进行加锁操作。<br><strong>第 ② 步</strong> 调用 <code>runStateOf</code> 获取线程池的状态，然后进行一个条件判断，第一个 <code>rs &lt; SHUTDOWN</code> 表示线程池是运行状态。如果线程池是运行状态或者线程池是关闭状态并且 <code>firstTask</code> 为 <code>null</code>，那么就往线程池中加入线程（因为当线程池是 <code>SHUTDOWN</code> 状态时不会再向线程池添加新的任务，但会执行队列 <code>workQueue</code> 中的任务）。这里的 <code>workers</code> 是一个 <code>HashSet</code>，所以其 <code>add</code> 方法不是线程安全的，所以需要加锁操作。然后修改线程池中出现过的最大线程数量 <code>largestPoolSize</code> 记录和把是否添加成功标记 <code>workerAdded</code> 为 <code>true</code>。如果 <code>workerAdded</code> 为 <code>true</code> 那么会启动线程并把线程是否启动标记 <code>workerStarted</code> 改为 <code>true</code>。<br><strong>第 ③ 步</strong> 根据线程是否启动 <code>workerStarted</code> 标记来判断是否需要进行失败的操作。包含从 <code>workers</code> 移除当前的 <code>worker</code>、线程池的工作线程数减 1、尝试终端线程池。</p><h4 id="线程池中线程是如何执行的"><a href="#线程池中线程是如何执行的" class="headerlink" title="线程池中线程是如何执行的"></a>线程池中线程是如何执行的</h4><p>线程池的线程执行是调用 <code>Worker</code> 的 <code>thread</code> 属性的 <code>start</code> 方法，而 <code>thread</code> 的 <code>run</code> 方法实际上调用了 <code>Worker</code> 类的 <code>runWorker</code> 方法，所以我们直接来看看 <code>runWorker</code> 方法的源码：</p><p><img src="https://i.loli.net/2019/11/30/YsESi5peaUX31fC.png" alt="thread-pool-7.png"></p><p><strong>第 ① 步</strong> 获取第一个任务，<code>while</code> 循环不断地通过 <code>getTask</code> 方法从队列中获取任务。<br><strong>第 ② 步</strong> 这个判断条件目的是要保证如果线程池正在停止，要保证当前线程是中断状态，如果是的话，要保证当前线程不是终端状态。<br><strong>第 ③ 步</strong> 方法 <code>beforeExecute</code> 方法在类 <code>ThreadPoolExecutor</code> 中没有做任何操作，是留给子类去自定义在线程执行之前添加操作的方法。<br><strong>第 ④ 步</strong> 执行 <code>task.run()</code> 执行任务（<code>PS：这里为什么是调用 run 方法而不是调用 start 方法呢？我们知道当调用了 start 方法后操作系统才会给我们创建一个独立的线程来运行，而调用 run 方法只是一个普通的方法调用，而线程池正好就是需要它是一个普通的方法才能进行任务的调度。我们可以想象一下，假如这里是调用的 Runnable 的 start 方法，那么会是什么结果呢。如果我们往一个核心线程数、最大线程数为 3 的线程池里丢了 500 个任务，那么它会额外的创建 500 个线程，同时每个任务都是异步执行的，结果一下子就执行完毕了，根本无法对任务进行调度。从而没法做到由这 3 个 Worker 线程来调度这 1000 个任务，而只有当做一个普通的 run 方法调用时才能满足线程池的这个要求</code>）。<br><strong>第 ⑤ 步</strong> 方法 <code>afterExecute</code> 方法在类 <code>ThreadPoolExecutor</code> 中没有做任何操作，是留给子类去自定义在线程执行之后添加操作的方法。<code>completedAbruptly</code> 变量是用来表示在执行任务过程中是否出现了异常，<code>processWorkerExit</code> 方法中会对该变量的值进行判断。<br>接下来我们看看 <code>getTask</code> 方法是如何从队列中获取任务的，方法源码如下：</p><p><img src="https://i.loli.net/2019/12/01/PhBqwfsUFx4va3T.png" alt="thread-pool-8.png"></p><p><strong>第 ① 步</strong> 如果线程池不是运行状态，则判断线程池是否正在停止或者当前队列为空，如果条件满足将线程池的工作线程数减一并返回 <code>null</code>。因为如果当前线程池状态的值是 <code>SHUTDOWN</code> 或以上时，就不允许再向队列中添加任务了。<br><strong>第 ② 步</strong> 这里的 <code>timed</code> 变量用来标记是否需要线程进行超时控制，<code>allowCoreThreadTimeOut</code> 默认是 <code>false</code>，也就是核心线程不允许进行超时。<code>wc &gt; corePoolSize</code> 表示当前线程池中的工作线程数量大于核心线程数量，对于超过核心线程数量的这些线程，需要进行超时控制。<br><strong>第 ③ 步</strong> 第一个判断 <code>wc &gt; maximumPoolSize</code> 如果成立是因为可能在此方法执行阶段同时执行了线程池的 <code>setMaximumPoolSize</code> 方法；第二个判断 <code>timed &amp;&amp; timedOut</code> 如果成立表示当前操作需要进行超时控制，并且上次从队列中获取任务发生了超时（<code>timeOut</code> 变量的值表示上次从阻塞队列中取任务时是否超时）；第三个判断 <code>wc &gt; 1 || workQueue.isEmpty()</code> 如果线程池中工作线程数量大于 1，或者队列是空的，那么尝试将 <code>workerCount</code> 减一，如果减一失败，则返回重试。如果 <code>wc == 1</code> 时，也就说明当前线程是线程池中唯一的一个线程了。<br><strong>第 ④ 步</strong> 根据 <code>timed</code> 来判断，如果为 <code>true</code>，则通过阻塞队列的 <code>poll</code> 方法进行超时控制，如果在 <code>keepAliveTime</code> 时间内没有获取到任务，则返回 <code>null</code>，否则通过 <code>take</code> 方法，如果这时队列为空，则 <code>take</code> 方法会阻塞直到队列不为空。如果 <code>r == null</code>，说明已经超时，<code>timedOut</code> 设置为 <code>true</code>。<br><strong>第 ⑤ 步</strong> 如果获取任务时当前线程发生了中断，则设置 <code>timedOut</code> 为 <code>false</code> 并重新循环重试。</p><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><p>线程池的关闭一般都是使用 <code>shutdown</code> 方法和 <code>shutdownNow</code> 方法，两者的区别是前面的 <code>shutdown</code> 方法不会执行新的任务，但是会执行完当前正在执行的任务，而后面的 <code>shutdownNow</code> 方法会立即停止当前线程池，不管当前是否有线程在执行。一般都是使用 <code>shutdown</code> 方法来停止线程池，其方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>advanceRunState(SHUTDOWN)</code> 方法的作用是通过 <code>CAS</code> 原子操作将线程池的状态更改为关闭状态。<code>interruptIdleWorkers</code> 方法是对空闲的线程进行中断，其实是调用重载带参数的函数 <code>interruptIdleWorkers(false)</code>。然后 <code>onShutdown</code> 方法和上文提到的 <code>beforeExecute</code>、<code>afterExecute</code> 方法一样，在类 <code>ThreadPoolExecutor</code> 是空实现，也是个钩子函数。我们看看 <code>interruptIdleWorkers</code> 的实现源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进行加锁操作，然后遍历 <code>workers</code> 容器，也就是遍历线程池中的线程，对每个线程进行 <code>tryLock</code> 操作，如果成功说明线程空闲，则设置其中断标志位。而线程是否响应中断则交给我们定义任务的人来决定。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文比较详细的分析了线程池任务的提交、线程的执行、线程池的关闭的工作流程。通过学习线程池相关的源码后，看到了在其内部用运用了很多多线程的解决方法，有如下几个方式：</p><ol><li>通过定义重入锁 <code>ReentrantLock</code> 变量 <code>mainLock</code> 来解决并发多线程的安全问题</li><li>利用等待机制来实现线程之间的通讯问题<br>除了内置的功能外，<code>ThreadPoolExecutor</code> 也向外提供了两个接口供我们自己扩展满足我们需求的线程池，这两个接口分别是：<code>beforeExecute</code> 任务执行前执行的方法，<code>afterExecute</code> 任务执行结束后执行的方法。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在上篇 &lt;a href=&quot;http://www.mghio.cn/post/bc557e1a.html&quot;&gt;Java 线程池（一）&lt;/a&gt; 我们介绍了线程池中一些的重要参数和具体含义，这篇我们看一看在 Java 中是如何去实现&lt;code&gt;线程池&lt;/code&gt;的，要想用好线程池，只知其然是远远不够的，我们需要深入实现源码去了解线程池的具体实现细节，这样才能更好的使用到我们的工作中，当出现问题时能快速找到问题根源所在。&lt;/p&gt;
&lt;h4 id=&quot;线程池如何处理提交的任务&quot;&gt;&lt;a href=&quot;#线程池如何处理提交的任务&quot; class=&quot;headerlink&quot; title=&quot;线程池如何处理提交的任务&quot;&gt;&lt;/a&gt;线程池如何处理提交的任务&lt;/h4&gt;&lt;p&gt;我们向线程池提交任务有两种方式，分别是通过 &lt;code&gt;submit&lt;/code&gt; 方法提交和通过 &lt;code&gt;execute&lt;/code&gt; 方法提交，这两种方式的区别为 &lt;code&gt;execute&lt;/code&gt; 只能提交 &lt;code&gt;Runnable&lt;/code&gt; 类型的任务并且没有返回值，而 &lt;code&gt;submit&lt;/code&gt; 既能提交 &lt;code&gt;Runnable&lt;/code&gt; 类型的任务也能提交 &lt;code&gt;Callable&lt;/code&gt;（JDK 1.5+）类型的任务并且会有一个类型 &lt;code&gt;Future&lt;/code&gt; 的返回值，我们知道 &lt;code&gt;Runnable&lt;/code&gt; 是没有返回值的，所以只有当提交 &lt;code&gt;Callable&lt;/code&gt; 类型的任务时才会有返回值，而提交 &lt;code&gt;Runnable&lt;/code&gt; 的返回值是 &lt;code&gt;null&lt;/code&gt;。 &lt;code&gt;execute&lt;/code&gt; 执行任务时，如果此时遇到异常会直接抛出，而 &lt;code&gt;submit&lt;/code&gt; 不会直接抛出，只有在使用 &lt;code&gt;Future&lt;/code&gt; 的 &lt;code&gt;get&lt;/code&gt; 方法获取任务的返回结果时，才会抛出异常。&lt;br&gt;通过查看 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 的源码我们发现，其 &lt;code&gt;submit&lt;/code&gt; 方法是继承自其抽象父类 &lt;code&gt;AbstractExecutorService&lt;/code&gt; 而来的，有三个重载的方法，分别可以提交 &lt;code&gt;Runnable&lt;/code&gt; 类型和 &lt;code&gt;Callable&lt;/code&gt; 类型的任务。无论是哪个 &lt;code&gt;submit&lt;/code&gt; 方法最终还是调用了 &lt;code&gt;execute&lt;/code&gt; 方法来实现的。方法源码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Future&amp;lt;?&amp;gt; submit(Runnable task) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (task == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    execute(ftask);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ftask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable task, T result)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (task == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    execute(ftask);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ftask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Future&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;submit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Callable&amp;lt;T&amp;gt; task)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (task == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    execute(ftask);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ftask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="线程池" scheme="https://www.mghio.cn/categories/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程池（一）</title>
    <link href="https://www.mghio.cn/post/bc557e1a.html"/>
    <id>https://www.mghio.cn/post/bc557e1a.html</id>
    <published>2019-11-23T10:35:30.000Z</published>
    <updated>2019-11-24T03:07:56.046Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h4><p>使用线程池可以很好的提高性能，线程池在运行之初就会创建一定数量的空闲线程，我们将一个任务提交给线程池，线程池就会使用一个空闲的线程来执行这个任务，该任务执行完后，该线程不会死亡，<code>而是再次变成空闲状态返回线程池，等待下一个任务的到来</code>。在使用线程池时，我们把要执行的任务提交给整个线程池，而不是提交给某个线程，线程池拿到提交的任务后，会在内部寻找是否还有空闲的线程，如果有，就将这个任务提交给某个空闲的线程，虽然一个线程同一时刻只能执行一个任务，但是我们可以向线程池提交多个任务。合理使用线程池有以下几个优点：<br>① <strong>降低资源消耗</strong> 多线程运行期间，系统不断的启动和关闭新线程，成本高，会过度消耗系统资源，通过<code>重用</code>存在的线程，减少对象创建、消亡的开销<br>② <strong>提高响应速度</strong> 当有任务到达时，任务可以不需要等待线程的创建，可以直接从线程池中取出空闲的线程来执行任务<br>③ <strong>方便线程管理</strong> 线程对计算机来说是很稀缺的资源，如果让他无限制创建，它不仅消耗系统的资源，还会降低系统的稳定性，我们使用线程池后可以统一进行分配和监控<br>谈到线程池就会想到<code>池化</code>技术，核心思想就是<code>把宝贵的资源放到一个池子中</code>，每次要使用都从池子里面取，用完之后又放回池子让别人用。那么线程池在 Java 中是如何实现的呢？</p><h4 id="Java-四种线程池"><a href="#Java-四种线程池" class="headerlink" title="Java 四种线程池"></a>Java 四种线程池</h4><p>在 Java 中 Executors 工具类给我们提供了四种不同使用场景的线程池的创建方法，分别为：</p><ol><li><code>newSingleThreadExecutor</code> 只有一个线程来执行任务，适用于有顺序的任务的应用场景。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，它可以保证任务按照指定顺序（FIFO，LIFO）执行，它还有可以指定线程工厂（<code>ThreadFactory</code>）的重载方法，可以自定义线程的创建行为</li><li><code>newFixedThreadPool</code> 固定线程数的线程池，只有核心线程，核心线程的即为最大的线程数量，没有非核心线程。每次提交一个任务就创建一个线程，直到达到线程池的最大大小。线程池一旦达到最大值就会保持不变，如果当中的某个线程因为异常而结束，那么线程池会新建一个线程加入到线程池中。它还可以控制线程的最大并发数，超出的线程会在阻塞队列（<code>LinkedBlockingQueue</code>）中等待，同样它也有可以指定线程工厂（<code>ThreadFactory</code>）的重载方法，可以自定义线程的创建行为。</li><li><code>newCachedThreadPool</code> 创建一个可缓存线程池，最大的线程个数为 <code>2^31 - 1（Integer.MAX_VALUE）</code>，可以认为是无限大，若无可回收，则新建线程，如果线程池的大小超出了处理任务所需要的线程，那么就会回收部分空闲（60s 不执行任务）的线程。</li><li><code>newScheduledThreadPool</code> 周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大（<code>Integer.MAX_VALUE：2^31 - 1</code>），适用于执行周期性的任务。</li></ol><a id="more"></a><h4 id="Java-线程池参数详解"><a href="#Java-线程池参数详解" class="headerlink" title="Java 线程池参数详解"></a>Java 线程池参数详解</h4><p>上文说到的 Executors 工具类提供的四种适用于不同场景的线程池，通过查看源码可以发现最终都是调用 <code>ThreadPoolExecutor</code> 类来实现的，我们接下来深入了解这个类一些成员变量的具体含义。首先是<code>ctl</code>，其声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这个成员变量 <code>ctl</code> 主要用于<code>存储线程池的工作状态以及线程池正在运行的线程数</code>。很显然，要在一个整型变量中存储两部分数据，只能将其一分为二。其中的高 3bit 用于存储线程的状态，低 29bit 用于存储线程池中正在执行的线程数。</p><h5 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h5><p>在 <code>ThreadPoolExecutor</code> 定义了线程池的五种状态（<code>注意，这里说的是线程池状态，不是池中的线程的状态</code>），当创建一个线程池时的状态为 <code>RUNNING</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">线程池状态</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">RUNNING</td><td align="center">允许提交并处理任务</td></tr><tr><td align="center">SHUTDOWN</td><td align="center">不会处理新提交的任务，但会处理完已处理的任务</td></tr><tr><td align="center">STOP</td><td align="center">不会处理新提交的任务，也不会处理阻塞队列中未执行的任务，并设置正在执行任务的中断标志位</td></tr><tr><td align="center">TIDYING</td><td align="center">所有任务执行完毕，线程池中工作的线程数为 0，等待执行 terminated() 钩子方法</td></tr><tr><td align="center">TERMINATED</td><td align="center">terminated() 钩子方法执行完毕</td></tr></tbody></table><p>调用线程池的 <code>shutdown</code> 方法，将线程池由 RUNNING 状态转为 SHUTDOWN 状态。调用 <code>shutdownNow</code> 方法，将线程池由 RUNNING 状态转为 STOP 状态。SHUTDOWN 状态和 STOP 状态都会先变为 TIDYING 状态，最终都会变为 TERMINATED 状态。用图表示为：</p><p><img src="https://i.loli.net/2019/11/23/RwvDlzJU23GfjdZ.png" alt="thread-pool-one.png"></p><p><code>ThreadPoolExecutor</code> 同时提供了以下三个方法来查看线程池的状态和池中正在执行的线程数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h5 id="ThreadPoolExecutor-的构造函数"><a href="#ThreadPoolExecutor-的构造函数" class="headerlink" title="ThreadPoolExecutor 的构造函数"></a>ThreadPoolExecutor 的构造函数</h5><p>该类参数最全的构造方法如下，这个方法决定了创建出来的线程池的各种属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>各个参数的含义：<br><code>corePoolSize</code> 线程池中核心线程数的最大值<br><code>maximumPoolSize</code> 线程池中最多能拥有的线程数<br><code>keepAliveTime</code> 空闲线程存活时间<br><code>unit</code> 空闲线程存活时间的单位<br><code>workQueue</code> 用于存放任务的阻塞队列<br><code>threadFactory</code> 创建线程工厂<br><code>handler</code> 当 <code>workQueue</code> 已满，并且池中的线程数达到 <code>maximumPoolSize</code> 时，线程池继续添加新任务时采取的策略</p><p>下面通过一张图来更形象的理解线程池的这几个参数：</p><p><img src="https://i.loli.net/2019/11/23/1rzqtsmXv3g5O24.png" alt="thread-pool-two.png"></p><p>corePoolSize、maximumPoolSize、workQueue 三者的关系，通过向线程池添加新的任务来说明着三者之间的关系：</p><ol><li>如果没有空闲的线程执行该任务，并且池中运行的线程数小于<code>corePoolSize</code>时，则创建新的线程执行该任务</li><li>如果没有空闲的线程执行该任务，并且当池中正在执行的线程数大于<code>corePoolSize</code>时，新添加的任务进入<code>workQueue</code>排队（如果<code>workQueue</code>长度允许），等待空闲线程来执行</li><li>如果没有空闲的线程执行该任务，并且阻塞队列已满同时池中的线程数小于<code>maximumPoolSize</code>，则创建新的线程执行该任务</li><li>如果没有空闲的线程执行该任务，并且阻塞队列已满同时池中的线程数等于<code>maximumPoolSize</code>，则根据构造函数中的<code>handler</code>指定的策略来拒绝新添加的任务</li></ol><p>在线程池中并没有标记出哪些线程是核心线程，哪些非核心线程，线程池它只关心<code>核心线程的数量</code>。下面这个是网上看到的一个形象的比喻：</p><blockquote><p>如果把线程池比作一个单位的话，<code>corePoolSize</code>就表示正式工，线程就可以表示一个员工。当我们向单位委派一项工作时，如果单位发现正式工还没招满，单位就会招个正式工来完成这项工作。随着我们向这个单位委派的工作增多，即使正式工全部满了，工作还是干不完，那么单位只能按照我们新委派的工作按先后顺序将它们找个地方搁置起来，这个地方就是<code>workQueue</code>，等正式工完成了手上的工作，就到这里来取新的任务。如果不巧，年末了，各个部门都向这个单位委派任务，导致<code>workQueue</code>已经没有空位置放新的任务，于是单位决定招点临时工吧（临时工：又是我！）。临时工也不是想招多少就找多少，上级部门通过这个单位的<code>maximumPoolSize</code>确定了你这个单位的人数的最大值，换句话说最多招<code>maximumPoolSize – corePoolSize</code>个临时工。当然，在线程池中，谁是正式工，谁是临时工是没有区别，完全同工同酬。</p></blockquote><h5 id="keepAliveTime-和-unit-单位"><a href="#keepAliveTime-和-unit-单位" class="headerlink" title="keepAliveTime 和 unit 单位"></a>keepAliveTime 和 unit 单位</h5><p>keepAliveTime 表示那些超出<code>corePoolSize</code>数量之外的线程的空闲时间大于<code>keepAliveTime</code>后就被清除了。</p><h5 id="workQueue-任务队列"><a href="#workQueue-任务队列" class="headerlink" title="workQueue 任务队列"></a>workQueue 任务队列</h5><p><code>workQueue</code>决定了缓存任务的排队策略，对于不同的任务场景我们可以采取不同的策略，这个队列需要一个实现了<code>BlockingQueue</code>接口的任务等待队列。从<code>ThreadPoolExecutor</code>的文档中得知，官方一共给我们推荐了三种队列，分别是：<code>SynchronousQueue</code>、<code>LinkedBlockingQueue</code>、<code>ArrayBlockingQueue</code>。其中<code>SynchronousQueue</code>和<code>ArrayBlockingQueue</code>属于<code>有限队列</code>，<code>LinkedBlockingQueue</code>属于<code>无限队列</code>，具体作用如下：</p><ol><li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等待另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于<code>LinkedBlockingQueue</code>，静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列。</li><li><code>ArrayBlockingQueue</code>：有界阻塞队列。一个由数组支持的有界阻塞队列。此队列按<code>FIFO</code>（先进先出）原则对元素进行排序。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞，试图从空队列中提取元素将导致类似阻塞。</li><li><code>LinkedBlockingQueue</code>：链表结构的阻塞队列，尾部插入元素，头部取出元素。<code>LinkedBlockingQueue</code>是我们在<code>ThreadPoolExecutor</code>线程池中常用的等待队列。它可以指定容量也可以不指定容量。由于它具有“无限容量”的特性，实际上任何无限容量的队列/栈都是有容量的，这个容量就是<code>Integer.MAX_VALUE</code>。<code>LinkedBlockingQueue</code>的实现是基于链表结构，而不是类似<code>ArrayBlockingQueue</code>那样的数组。但实际使用过程中，不需要关心它的内部实现，如果指定了<code>LinkedBlockingQueue</code>的容量大小，那么它反映出来的使用特性就和<code>ArrayBlockingQueue</code>类似了。</li></ol><h5 id="threadFactory-创建线程的工厂"><a href="#threadFactory-创建线程的工厂" class="headerlink" title="threadFactory 创建线程的工厂"></a>threadFactory 创建线程的工厂</h5><p>其实像<code>ThreadPoolExecutor</code>有的没有<code>threadFactory</code>参数的构造方法中使用的创建线程的工厂就是默认的工厂，比如下面这个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个构造方法中，创建线程的工厂的方法使用<code>Executors.defaultThreadFactory()</code>的工厂和<code>ThreadPoolExecutor</code>中的<code>defaultHandler</code>默认抛弃策略。使用 <code>Executors.defaultThreadFactory</code>创建的线程同属于相同的线程组，具有同为<code>Thread.NORM_PRIORITY</code>的优先级，以及名为<code>pool-poolNumber.getAndIncrement()-thread-</code>的线程名（poolNumber.getAndIncrement() 为线程池顺序序号），且创建的线程都是非守护进程。</p><h5 id="handler-拒绝策略"><a href="#handler-拒绝策略" class="headerlink" title="handler 拒绝策略"></a>handler 拒绝策略</h5><p>表示当<code>workQueue</code>已满，池中的线程数达到<code>maximumPoolSize</code>时，线程池拒绝添加新任务时采取的策略。从文档中得知，<code>handler</code>一般可以取以下四种值：</p><table><thead><tr><th align="center">拒绝策略</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">AbortPolicy</td><td align="center">抛出 RejectedExecutionException 异常</td></tr><tr><td align="center">CallerRunsPolicy</td><td align="center">由向线程池提交任务的线程来执行该任务</td></tr><tr><td align="center">DiscardPolicy</td><td align="center">直接丢弃当前的任务</td></tr><tr><td align="center">DiscardOldestPolicy</td><td align="center">抛弃最旧的任务（最先提交而没有得到执行的任务）</td></tr></tbody></table><p>个人觉得最优雅的方式还是<code>AbortPolicy</code>提供的处理方式：抛出异常，由开发人员进行处理。<code>ThreadPoolExecutor</code>默认的拒绝方式<code>defaultHandler</code>就是<code>ThreadPoolExecutor.AbortPolicy</code>。</p><h4 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h4><p>最后，我们要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p><h5 id="任务的性质"><a href="#任务的性质" class="headerlink" title="任务的性质"></a>任务的性质</h5><p>任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能少的线程数量，如配置<code>Ncpu+1</code>个线程的线程池。IO 密集型任务则由于需要等待 IO 操作，线程并不是一直在执行任务，则配置尽可能多的线程，如<code>2*Ncpu</code>。混合型的任务，如果可以拆分，则将其拆分成一个 CPU 密集型任务和一个 IO 密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过<code>Runtime.getRuntime().availableProcessors()</code>方法获得当前设备的 CPU 个数。</p><h5 id="任务的优先级"><a href="#任务的优先级" class="headerlink" title="任务的优先级"></a>任务的优先级</h5><p>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p><h5 id="任务的执行时间"><a href="#任务的执行时间" class="headerlink" title="任务的执行时间"></a>任务的执行时间</h5><p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p><h5 id="任务的依赖性"><a href="#任务的依赖性" class="headerlink" title="任务的依赖性"></a>任务的依赖性</h5><p>依赖数据库连接池的任务，因为线程提交 SQL 后需要等待数据库返回结果，如果等待的时间越长 CPU 空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用 CPU。建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行 SQL 变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。</p><hr><p>参考文章：<br><a href="https://www.infoq.cn/article/java-threadPool" target="_blank" rel="noopener">JAVA 线程池的分析和使用</a><br><a href="https://blog.csdn.net/xiaojin21cen/article/details/87363143" target="_blank" rel="noopener">ThreadPoolExecutor 的 workQueue 任务队列详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;线程池简介&quot;&gt;&lt;a href=&quot;#线程池简介&quot; class=&quot;headerlink&quot; title=&quot;线程池简介&quot;&gt;&lt;/a&gt;线程池简介&lt;/h4&gt;&lt;p&gt;使用线程池可以很好的提高性能，线程池在运行之初就会创建一定数量的空闲线程，我们将一个任务提交给线程池，线程池就会使用一个空闲的线程来执行这个任务，该任务执行完后，该线程不会死亡，&lt;code&gt;而是再次变成空闲状态返回线程池，等待下一个任务的到来&lt;/code&gt;。在使用线程池时，我们把要执行的任务提交给整个线程池，而不是提交给某个线程，线程池拿到提交的任务后，会在内部寻找是否还有空闲的线程，如果有，就将这个任务提交给某个空闲的线程，虽然一个线程同一时刻只能执行一个任务，但是我们可以向线程池提交多个任务。合理使用线程池有以下几个优点：&lt;br&gt;① &lt;strong&gt;降低资源消耗&lt;/strong&gt; 多线程运行期间，系统不断的启动和关闭新线程，成本高，会过度消耗系统资源，通过&lt;code&gt;重用&lt;/code&gt;存在的线程，减少对象创建、消亡的开销&lt;br&gt;② &lt;strong&gt;提高响应速度&lt;/strong&gt; 当有任务到达时，任务可以不需要等待线程的创建，可以直接从线程池中取出空闲的线程来执行任务&lt;br&gt;③ &lt;strong&gt;方便线程管理&lt;/strong&gt; 线程对计算机来说是很稀缺的资源，如果让他无限制创建，它不仅消耗系统的资源，还会降低系统的稳定性，我们使用线程池后可以统一进行分配和监控&lt;br&gt;谈到线程池就会想到&lt;code&gt;池化&lt;/code&gt;技术，核心思想就是&lt;code&gt;把宝贵的资源放到一个池子中&lt;/code&gt;，每次要使用都从池子里面取，用完之后又放回池子让别人用。那么线程池在 Java 中是如何实现的呢？&lt;/p&gt;
&lt;h4 id=&quot;Java-四种线程池&quot;&gt;&lt;a href=&quot;#Java-四种线程池&quot; class=&quot;headerlink&quot; title=&quot;Java 四种线程池&quot;&gt;&lt;/a&gt;Java 四种线程池&lt;/h4&gt;&lt;p&gt;在 Java 中 Executors 工具类给我们提供了四种不同使用场景的线程池的创建方法，分别为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt; 只有一个线程来执行任务，适用于有顺序的任务的应用场景。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，它可以保证任务按照指定顺序（FIFO，LIFO）执行，它还有可以指定线程工厂（&lt;code&gt;ThreadFactory&lt;/code&gt;）的重载方法，可以自定义线程的创建行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt; 固定线程数的线程池，只有核心线程，核心线程的即为最大的线程数量，没有非核心线程。每次提交一个任务就创建一个线程，直到达到线程池的最大大小。线程池一旦达到最大值就会保持不变，如果当中的某个线程因为异常而结束，那么线程池会新建一个线程加入到线程池中。它还可以控制线程的最大并发数，超出的线程会在阻塞队列（&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;）中等待，同样它也有可以指定线程工厂（&lt;code&gt;ThreadFactory&lt;/code&gt;）的重载方法，可以自定义线程的创建行为。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt; 创建一个可缓存线程池，最大的线程个数为 &lt;code&gt;2^31 - 1（Integer.MAX_VALUE）&lt;/code&gt;，可以认为是无限大，若无可回收，则新建线程，如果线程池的大小超出了处理任务所需要的线程，那么就会回收部分空闲（60s 不执行任务）的线程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt; 周期性执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大（&lt;code&gt;Integer.MAX_VALUE：2^31 - 1&lt;/code&gt;），适用于执行周期性的任务。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="线程池" scheme="https://www.mghio.cn/categories/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深挖 HashMap</title>
    <link href="https://www.mghio.cn/post/99ea2970.html"/>
    <id>https://www.mghio.cn/post/99ea2970.html</id>
    <published>2019-11-14T13:23:23.000Z</published>
    <updated>2019-11-16T09:06:26.019Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h4><p>做过 java 开发的朋友们相信都很熟悉 HashMap 这个类，它是一个基于 hashing 原理用于存储 Key-Value 键值对的集合，其中的每一个键也叫做 <code>Entry</code>，这些键分别存储在一个数组当中，系统会根据 <code>hash</code> 方法来计算出 Key-Value 的存储位置，可以通过 key 快速存取 value。<br>HashMap 基于 hashing 原理，当我们将一个键值对（Key-Value） 传入 <code>put</code> 方法时，它将调用这个 key 的  <code>hashcode</code> 方法计算出 key 的 hashcode 值，然后根据这个 hashcode 值来定位其存放数组的位置来存储对象（HashMap 使用链表来解决碰撞问题，当其发生碰撞了，对象将会存储在链表的下一个节点中，在链表的每个节点中存储 <code>Entry</code> 对象，在 JDK 1.8+ 中，当链表的节点个数超过一定值时会转为红黑树来进行存储），当通过 <code>get</code> 方法传入一个 key 来获取其对应的值时，也是先通过 key 的 <code>hashcode</code> 方法来定位其存储在数组的位置，然后通过键对象的 <code>eqauls</code> 方法找到对应的 value 值。接下来让我们看看其内部的一些实现细节。（<code>PS：以下代码分析都是基于 JDK 1.8</code>）</p><h4 id="1-2-为什么容量始终是-2-的整数次幂"><a href="#1-2-为什么容量始终是-2-的整数次幂" class="headerlink" title="1.2 为什么容量始终是 2 的整数次幂"></a>1.2 为什么容量始终是 2 的整数次幂</h4><p>因为获取 key 在数组中对应的下标是通过 key 的哈希值与数组的长度减一进行与运算来确定的（<code>tab[(n - 1) &amp; hash]</code>）。当数组的长度 n 为 2 的整数次幂，这样进行 n - 1 运算后，之前为 1 的位后面全是 1 ，这样就能保证 <code>(n - 1) &amp; hash</code> 后相应位的值既可能是 1 又可能是 0 ，这完全取决于 key 的哈希值，这样就能保证散列的均匀，同时与运算（位运算）效率高。如果数组的长度 n 不是 2 的整数次幂，会造成更多的 hash 冲突。HashMap 提供了如下四个重载的构造方法来满足不同的使用场景：</p><ol><li>无参构造：<code>HashMap()</code>，使用该方法表示全部使用 HashMap 的默认配置参数</li><li>指定容量初始值构造：<code>HashMap(int initialCapacity)</code>，在初始化 HashMap 时指定其容量大小</li><li>指定容量初始值和扩容因子构造：<code>HashMap(int initialCapacity, float loadFactor)</code>，使用自定义初始化容量和扩容因子</li><li>通过 <code>Map</code> 来构造 HashMap：<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>，使用默认的扩容因子，其容量大小有传入的 <code>Map</code> 大小来决定<a id="more"></a>前三个构造方法最终都是调用第三个即自定义容量初始值和扩容因子构造 <code>HashMap(int initialCapacity, float loadFactor)</code>，其源码实现如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从源码实现可以看出，如果我们传入的初始容量值大于 <code>MAXIMUM_CAPACITY</code> 时，就设置容量为 <code>MAXIMUM_CAPACITY</code>，其值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">  * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">  * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>也就是容量的最大值为 2 的 30 次方（<code>1 &lt;&lt; 30</code>）。我们知道，HashMap 的容量始终是 2 的整数次幂，不管我们传入的初始容量是什么，它都会使用最接近这个值并且是 2 的整数次幂作为 HashMap 的初始容量，这一步处理是通过 <code>tableSizeFor</code> 方法来实现的，我们看看它的源码：</p><p><img src="https://i.loli.net/2019/11/14/MArIFaUlDchbvVG.png" alt="hashmap-tableSizeFor.png"></p><p>通过方法的注释我们也可以知道（<code>英语对于从事技术开发的人太重要了~~~</code>），此方法的返回值始终是 2 的整数次幂，它是如何做到的呢？接下来我们通过一个例子一步一步来看，假设我们传入的初始容量大小 <code>cap</code> 的值 <code>cap</code> 为 15。</p><p><strong>第 ① 步</strong>：将 <code>cap - 1</code> 后，<code>n</code> 的值为 14（15 - 1）。 </p><p><strong>第 ② 步</strong>：将 <code>n</code> 的值先右移 1 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/mCWoVrOeBY4zsuE.png" alt="hashmap-tableSizeFor-2.png"></p><p><strong>第 ③ 步</strong>：将 <code>n</code> 的值先右移 2 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/LHIDGjecq5Ak8oQ.png" alt="hashmap-tableSizeFor-3.png"></p><p><strong>第 ④ 步</strong>：将 <code>n</code> 的值先右移 4 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/oOt6wEuycSBDUjx.png" alt="hashmap-tableSizeFor-4.png"></p><p><strong>第 ⑤ 步</strong>：将 <code>n</code> 的值先右移 8 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/BFRgw85KzCMNsqy.png" alt="hashmap-tableSizeFor-5.png"></p><p><strong>第 ⑥ 步</strong>：将 <code>n</code> 的值先右移 16 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/g7DqVIRf9sz1wK4.png" alt="hashmap-tableSizeFor-6.png"></p><p>最后如果 <code>n</code> 的值小于 <code>0</code>，则返回 1，如果大于最大值 <code>MAXIMUM_CAPACITY</code> 则返回 <code>MAXIMUM_CAPACITY</code>，否则返回 <code>n + 1</code>。 现在 n 为 15，所以返回 n + 1（16），而 16 正好是 2 的 4 次幂。有的朋友可能会问，刚刚上文假设的初始容量大小 <code>cap</code> 是 15，本来就不是 2 的整数次幂，如果我传入初始容量的就是 2 的整数次幂那会怎么样呢？现在假设传的初始容量大小为 32（2 的 5 次方）看看结果是什么。</p><p><strong>第 ① 步</strong>：将 <code>cap - 1</code> 后，<code>n</code> 的值为 31（32 - 1）。 </p><p><strong>第 ② 步</strong>：将 <code>n</code> 的值先右移 1 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/BK2QEp5dxLCfhkA.png" alt="hashmap-tableSizeFor-even-1.png"></p><p><strong>第 ③ 步</strong>：将 <code>n</code> 的值先右移 2 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/WX9BlOhDjfaZypn.png" alt="hashmap-tableSizeFor-even-2.png"></p><p><strong>第 ④ 步</strong>：将 <code>n</code> 的值先右移 4 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/m2MgTlSfuIowHF7.png" alt="hashmap-tableSizeFor-even-4.png"></p><p><strong>第 ⑤ 步</strong>：将 <code>n</code> 的值先右移 8 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/ZYl6Hnf7cSxsJdk.png" alt="hashmap-tableSizeFor-even-5.png"></p><p><strong>第 ⑥ 步</strong>：将 <code>n</code> 的值先右移 16 位后与 <code>n</code> 进行 <code>或运算</code>（两者都为 0 结果为 0，其它情况都为 1），下面是具体的计算过程：</p><p><img src="https://i.loli.net/2019/11/16/7hgSZaOXxyMbuj8.png" alt="hashmap-tableSizeFor-even-6.png"></p><p>经过以上 6 步计算后得出 n 的值为 31，大于 0 小于 <code>MAXIMUM_CAPACITY</code> 返回 <code>n + 1</code>，所以经过计算后的初始容量大小为 32。稍微总结一下，我们可以得出：如果我们传入的初始容量大小不是 2 的整数次幂，那么经过计算后的初始容量大小为大于我们传入初始容量值的最小值并且是 2 的整数次幂。细心的朋友会发现，为什么第一步要进行 <code>cap - 1</code> 的操作呢？那是因为，如果不进行 - 1 运算的话，当我们传入的初始容量大小为 2 的整数次幂的时候，通过以上步骤计算出来的结果值为传入值的 2 倍。假设我们传入的初始容量大小为 32，此时没有第 ① 步（<code>cap - 1</code>）的操作，那么依次通过以上 ②、③、④、⑤、⑥ 后为 <code>63</code>，最后再进行 <code>n + 1</code> 操作，结果为 <code>64</code> 是 传入值 32 的 2 倍，显然和预期结果（<code>32</code>）不符。这个计算初始容量的算法还是很巧妙的，先进行了 -1 的操作，保证传入初始容量值为 2 的整数次幂的时候，返回传入的原始值。 </p><h4 id="1-3-hash-方法是如何实现的"><a href="#1-3-hash-方法是如何实现的" class="headerlink" title="1.3 hash 方法是如何实现的"></a>1.3 hash 方法是如何实现的</h4><p>不管是通过 <code>get</code> 方法获取 key 对应的 Value 值或者通过 <code>put</code> 方法存储 Key-Value 键值对时，都会先根据 key 的哈希值定位到数组的位置，我们看看 HashMap 里的 <code>hash</code> 方法是如何实现的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 key 为 <code>null</code> 时，返回 0，否则进行 <code>h = key.hashCode()) ^ (h &gt;&gt;&gt; 16</code> 运算，先调用 key 的 <code>hashCode</code> 方法获取 key 的哈希值，然后与 key 的哈希值右移 16 位后的值进行异或运算（相同为 0，不同为 1，简称 <code>同假异真</code>），为什么获取 key 的哈希值还要再进行异或运算，直接返回 key 的哈希值好像也没什么问题，如果没有后面的异或运算，直接返回哈希值，我们假设数组的长度为 16，现在要往 HashMap 存入的三个键值对的 key 的哈希值分别为 32831、33554495、2097215，根据 hash 方法返回值定位到数组的位置（<code>(n - 1) &amp; hash</code>），以上三个值和 15（16 - 1）进行 <code>&amp; 运算（都为 1 才为 1，其它情况都为 0）</code> 如下：</p><p><img src="https://i.loli.net/2019/11/16/EQ2aWPbKxYryDn8.png" alt="hashmap-hashcode-2.png"></p><p>可以发现以上三个哈希值都定位的数组下标为 15 的位置上。所以 <code>hash</code> 如果方法没有后面与哈希值右移 16 位后的值进行异或运算的话，当数组长度比较小时很容易造成 <code>哈希碰撞</code>，即多个 key（不同的哈希值）都会定位到数组上的同一个位置，也就是说会放入到同一个链表或者红黑树中，因为此时 key 的哈希值只有低位的才会参与运算，显然和我们的预期不符合。可见 <code>hash</code> 方法将 key 的哈希值与其右移 16 位后进行异或运算能减少哈希碰撞的次数，把高位和低位都参与了运算，提高了分散性。</p><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><p>HashMap 其实还有很多值得我们深入研究的点，看懂了上面两个方法后，不得不佩服作者的代码设计能力，JDK 中有很多优秀源码都值得我们好好品味，看代码的时候一定要多看几遍多问几个为什么，特别是经典的源代码，然后将这些思想运用到我们的实际工作中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h4&gt;&lt;p&gt;做过 java 开发的朋友们相信都很熟悉 HashMap 这个类，它是一个基于 hashing 原理用于存储 Key-Value 键值对的集合，其中的每一个键也叫做 &lt;code&gt;Entry&lt;/code&gt;，这些键分别存储在一个数组当中，系统会根据 &lt;code&gt;hash&lt;/code&gt; 方法来计算出 Key-Value 的存储位置，可以通过 key 快速存取 value。&lt;br&gt;HashMap 基于 hashing 原理，当我们将一个键值对（Key-Value） 传入 &lt;code&gt;put&lt;/code&gt; 方法时，它将调用这个 key 的  &lt;code&gt;hashcode&lt;/code&gt; 方法计算出 key 的 hashcode 值，然后根据这个 hashcode 值来定位其存放数组的位置来存储对象（HashMap 使用链表来解决碰撞问题，当其发生碰撞了，对象将会存储在链表的下一个节点中，在链表的每个节点中存储 &lt;code&gt;Entry&lt;/code&gt; 对象，在 JDK 1.8+ 中，当链表的节点个数超过一定值时会转为红黑树来进行存储），当通过 &lt;code&gt;get&lt;/code&gt; 方法传入一个 key 来获取其对应的值时，也是先通过 key 的 &lt;code&gt;hashcode&lt;/code&gt; 方法来定位其存储在数组的位置，然后通过键对象的 &lt;code&gt;eqauls&lt;/code&gt; 方法找到对应的 value 值。接下来让我们看看其内部的一些实现细节。（&lt;code&gt;PS：以下代码分析都是基于 JDK 1.8&lt;/code&gt;）&lt;/p&gt;
&lt;h4 id=&quot;1-2-为什么容量始终是-2-的整数次幂&quot;&gt;&lt;a href=&quot;#1-2-为什么容量始终是-2-的整数次幂&quot; class=&quot;headerlink&quot; title=&quot;1.2 为什么容量始终是 2 的整数次幂&quot;&gt;&lt;/a&gt;1.2 为什么容量始终是 2 的整数次幂&lt;/h4&gt;&lt;p&gt;因为获取 key 在数组中对应的下标是通过 key 的哈希值与数组的长度减一进行与运算来确定的（&lt;code&gt;tab[(n - 1) &amp;amp; hash]&lt;/code&gt;）。当数组的长度 n 为 2 的整数次幂，这样进行 n - 1 运算后，之前为 1 的位后面全是 1 ，这样就能保证 &lt;code&gt;(n - 1) &amp;amp; hash&lt;/code&gt; 后相应位的值既可能是 1 又可能是 0 ，这完全取决于 key 的哈希值，这样就能保证散列的均匀，同时与运算（位运算）效率高。如果数组的长度 n 不是 2 的整数次幂，会造成更多的 hash 冲突。HashMap 提供了如下四个重载的构造方法来满足不同的使用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无参构造：&lt;code&gt;HashMap()&lt;/code&gt;，使用该方法表示全部使用 HashMap 的默认配置参数&lt;/li&gt;
&lt;li&gt;指定容量初始值构造：&lt;code&gt;HashMap(int initialCapacity)&lt;/code&gt;，在初始化 HashMap 时指定其容量大小&lt;/li&gt;
&lt;li&gt;指定容量初始值和扩容因子构造：&lt;code&gt;HashMap(int initialCapacity, float loadFactor)&lt;/code&gt;，使用自定义初始化容量和扩容因子&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;Map&lt;/code&gt; 来构造 HashMap：&lt;code&gt;HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m)&lt;/code&gt;，使用默认的扩容因子，其容量大小有传入的 &lt;code&gt;Map&lt;/code&gt; 大小来决定
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="原理" scheme="https://www.mghio.cn/categories/Java/%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java, 原理" scheme="https://www.mghio.cn/tags/Java-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
