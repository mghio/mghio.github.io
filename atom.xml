<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mghio</title>
  
  <subtitle>Java 搬运工 &amp; 终身学习者。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mghio.cn/"/>
  <updated>2022-11-05T08:31:14.785Z</updated>
  <id>https://www.mghio.cn/</id>
  
  <author>
    <name>mghio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring 中 @EnableXXX 注解的套路</title>
    <link href="https://www.mghio.cn/post/aa9d18bf.html"/>
    <id>https://www.mghio.cn/post/aa9d18bf.html</id>
    <published>2022-06-05T08:29:44.000Z</published>
    <updated>2022-11-05T08:31:14.785Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/05/22/NC7L6GlyJYM1kxt.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Spring 框架中有很多实用的功能，不需要写大量的配置代码，只需添加几个注解即可开启。 其中一个重要原因是那些 @EnableXXX 注解，它可以让你通过在配置类加上简单的注解来快速地开启诸如事务管理（@EnableTransactionManagement）、Spring MVC（@EnableWebMvc）或定时任务（@EnableScheduling）等功能。这些看起来简单的注解语句提供了很多功能，但它们的内部机制从表面上看却不太明显。 一方面，对于使用者来说用这么少的代码获得这么多实用的功能是很好的，但另一方面，如果你不了解某个东西的内部是如何工作的，就会使调试和解决问题更加困难。</p><a id="more"></a><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>Spring 框架中那些 @EnableXXX 注解的设计目标是允许用户用最少的代码来开启复杂使用的功能。 此外，用户必须能够使用简单的默认值，或者允许手动配置该代码。最后，代码的复杂性要向框架使用者隐藏掉。 简而言之，让使用者设置大量的 Bean，并选择性地配置它们，而不必知道这些 Bean 的细节（或真正被设置的内容）。下面来看看具体的几个例子：</p><h2 id="EnableScheduling-导入一个-Configuration-类"><a href="#EnableScheduling-导入一个-Configuration-类" class="headerlink" title="@EnableScheduling (导入一个 @Configuration 类)"></a>@EnableScheduling (导入一个 @Configuration 类)</h2><p>首先要知道的是，@EnableXXX 注解并不神奇。实际上在 BeanFactory 中并不知道这些注解的具体内容，而且在 BeanFactory 类中，核心功能和特定注解（如 @EnableWebMvc）或它们所存放的 jar 包（如 spring-web）之间没有任何依赖关系。 让我们看一下 @EnableScheduling，下面看看它是如何工作的。 定义一个 SchedulingConfig 配置类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">// some bean in here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的内容没有什么特别之处。只是一个用 @EnableScheduling 注释的标准 Java 配置。@EnableScheduling 让你以设定的频率执行某些方法。例如，你可以每 10 分钟运行 BankService.transferMoneyToMghio()。  @EnableScheduling 注解源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(SchedulingConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 EnableScheduling 注解，我们可以看到它只是一个标准的类级注解（@Target/@Retention），应该包含在 JavaDocs 中（@Documented），但是它有一个 Spring 特有的注解（@Import）。 @Import 是将一切联系起来的关键。 在这种情况下，由于我们的 SchedulingConfig 被注解为 @EnableScheduling，当 BeanFactory 解析文件时（内部是ConfigurationClassPostProcessor 在解析它），它也会发现 @Import(SchedulingConfiguration.class) 注解，它将导入该值中定义的类。 在这个注解中，就是 SchedulingConfiguration。 </p><p>这里<strong>导入</strong>是什么意思呢？在这种情况下，它只是被当作另一个 Spring Bean。 SchedulingConfiguration 实际上被注解为@Configuration，所以 BeanFactory 会把它看作是另一个配置类，所有在该类中定义的 Bean 都会被拉入你的应用上下文，就像你自己定义了另一个 @Configuration 类一样。 如果我们检查 SchedulingConfiguration，我们可以看到它只定义了一个Bean（一个Post Processor），它负责我们上面描述的调度工作，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ScheduledAnnotationBeanPostProcessor <span class="title">scheduledAnnotationProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledAnnotationBeanPostProcessor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你会问，如果想配置 SchedulingConfiguration 中定义的 bean 呢？ 这里也只是在处理普通的Bean。 所以你对其它 Bean 所使用的机制也适用于此。 在这种情况下，ScheduledAnnotationBeanPostProcessor 使用一个标准的 Spring Bean 生命周期（postProcessAfterInitialization）来发现应用程序上下文何时被刷新。 当符合条件时，它会检查是否有任何 Bean 实现了 SchedulingConfigurer，如果有，就使用这些 Bean 来配置自己。 其实这一点并不明细（在 IDE 中也不太容易找到），但它与 BeanFactory 是完全分离的，而且是一个相当常见的模式，一个 Bean 被用来配置另一个 Bean。 而现在我们可以把所有的点连接起来，它（在某种程度上）很容易找到（你可以 Google 一下文档或阅读一下 JavaDocs）。</p><h2 id="EnableTransactionManagement（导入一个-ImportSelector）"><a href="#EnableTransactionManagement（导入一个-ImportSelector）" class="headerlink" title="@EnableTransactionManagement（导入一个 ImportSelector）"></a>@EnableTransactionManagement（导入一个 ImportSelector）</h2><p>在上一个示例中，我们讨论了像 @EnableScheduling 这样的注解如何使用 @Import 来导入另一个 @Configuration 类并使其所有的 Bean 对你的应用程序可用（和可配置）。但是如果你想根据某些配置加载不同的 Bean 集，会发生什么呢？ @EnableTransactionManagement 就是一个很好的例子。TransactioConfig 定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>(mode = AdviceMode.ASPECTJ)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactioConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some bean in here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再一次，上面没有什么特别之处。只是一个用@EnableTransactionManagement注释的标准Java配置。唯一与之前的例子有些不同的是，用户为注释指定了一个参数（mode=AdviceMode.ASPECTJ）。 @EnableTransactionManagement注解本身看起来像这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(TransactionManagementConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面一样，一个相当标准的注解，尽管这次它有一些参数。 然而，正如前文提到，@Import 注解是将一切联系在一起的关键，这一点再次得到证实。 但区别在于，这次我们导入的是 TransactionManagementConfigurationSelector 这个类，通过源码可以发现，其实它不是一个被 @Configuration 注解的类。 TransactionManagementConfigurationSelector 是一个实现ImportSelector 的类。 ImportSelector 的目的是让你的代码选择在运行时加载哪些配置类。 它有一个方法，接收关于注解的一些元数据，并返回一个类名数组。 在这种情况下，TransactionManagementConfigurationSelector 会查看模式并根据模式返回一些类。其中的 selectImports 方法源码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> PROXY:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">                           ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">    <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些类中的大多数是 @Configuration（例如 ProxyTransactionManagementConfiguration），通过前文介绍我们知道它们会像前面一样工作。 对于 @Configuration 类，它们被加载和配置的方式与我们之前看到的完全一样。 所以简而言之，我们可以使用 @Import 和 @Configuration 类来加载一套标准的 Bean，或者使用 @Import 和 ImportSelector 来加载一套在运行时决定的 Bean。</p><h2 id="EnableAspectJAutoProxy-在-Bean-定义层导入"><a href="#EnableAspectJAutoProxy-在-Bean-定义层导入" class="headerlink" title="@EnableAspectJAutoProxy (在 Bean 定义层导入)"></a>@EnableAspectJAutoProxy (在 Bean 定义层导入)</h2><p>@Import 支持的最后一种情况，即当你想直接处理 BeanRegistry（工厂）时。如果你需要操作Bean Factory或者在Bean定义层处理Bean，那么这种情况就适合你，它与上面的情况非常相似。 你的 AspectJProxyConfig 可能看起来像。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJProxyConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">// some bean in here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再一次，上面定义没有什么特别的东西。只是一个用 @EnableAspectJAutoProxy 注释的标准 Java 配置。 下面是@EnableAspectJAutoProxy 的源代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面一样，@Import 是关键，但这次它指向 AspectJAutoProxyRegistrar，它既没有 @Configuration 注解，也没有实现 ImportSelector 接口。 这次使用的是实现了 ImportBeanDefinitionRegistrar。 这个接口提供了对 Bean 注册中心（Bean Registry）和注解元数据的访问，因此我们可以在运行时根据注解中的参数来操作 Bean 注册表。 如果你仔细看过前面的示例，你可以看到我们忽略的类也是 ImportBeanDefinitionRegistrar。 在 @Configuration 类不够用的时候，这些类会直接操作 BeanFactory。</p><p>所以现在我们已经涵盖了 @EnableXXX 注解使用 @Import 将各种 Bean 引入你的应用上下文的所有不同方式。 它们要么直接引入一组 @Configuration 类，这些类中的所有 Bean 都被导入到你的应用上下文中。 或者它们引入一个 ImportSelector 接口实现类，在运行时选择一组 @Configuration 类并将这些 Bean 导入到你的应用上下文中。 最后，他们引入一个ImportBeanDefinitionRegistrars，可以直接与 BeanFactory 在 BeanDefinition 级别上合作。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总的来说，个人认为这种将 Bean 导入应用上下文的方法很好，因为它使框架使用者的使用某个功能非常容易。不幸的是，它模糊了如何找到可用的选项以及如何配置它们。 此外，它没有直接利用 IDE 的优势，所以很难知道哪些 Bean 正在被创建（以及为什么）。 然而，现在我们知道了 @Import 注解，我们可以使用 IDE 来挖掘一下每个注解及其相关的配置类，并了解哪些 Bean 正在被创建，它们如何被添加到你的应用上下文中，以及如何配置它们。 希望对你有帮助~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/22/NC7L6GlyJYM1kxt.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Spring 框架中有很多实用的功能，不需要写大量的配置代码，只需添加几个注解即可开启。 其中一个重要原因是那些 @EnableXXX 注解，它可以让你通过在配置类加上简单的注解来快速地开启诸如事务管理（@EnableTransactionManagement）、Spring MVC（@EnableWebMvc）或定时任务（@EnableScheduling）等功能。这些看起来简单的注解语句提供了很多功能，但它们的内部机制从表面上看却不太明显。 一方面，对于使用者来说用这么少的代码获得这么多实用的功能是很好的，但另一方面，如果你不了解某个东西的内部是如何工作的，就会使调试和解决问题更加困难。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Spring/"/>
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Spring/Java/"/>
    
      <category term="实现原理" scheme="https://www.mghio.cn/categories/Spring/Java/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="实现原理" scheme="https://www.mghio.cn/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>聊聊二维码</title>
    <link href="https://www.mghio.cn/post/9072a99a.html"/>
    <id>https://www.mghio.cn/post/9072a99a.html</id>
    <published>2022-05-05T08:27:10.000Z</published>
    <updated>2022-11-05T08:28:41.532Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/01/09/3UcOhXMfKG4gBP6.jpg" alt="cover.jpg"></p><h2 id="一维码（条形码）"><a href="#一维码（条形码）" class="headerlink" title="一维码（条形码）"></a>一维码（条形码）</h2><p>在介绍二维码之前，先来看看它的“大哥”一维码，一维码也叫条形码（好像在日常生活中都是叫这个），它是由不同宽度的黑条和白条按照一定的顺序排列组成的平行线图案，它的宽度记录着数据信息，长度没有记录信息，条形码常用于标出物品的生产国、制造厂家、商品名称、生产日期、图书分类号、邮件起止地点、类别、日期等信息，比如大部分食品包装袋背后都会印有条形码。</p><a id="more"></a><h2 id="一维码的编码规则"><a href="#一维码的编码规则" class="headerlink" title="一维码的编码规则"></a>一维码的编码规则</h2><p>全球的条形码标准都是由一个叫<code>GS1</code>的非营利性组织管理和维护的，通常情况下条形码由 <code>95</code> 条红或黑色的平行竖线组成，前三条是由<code>黑-白-黑</code> 组成，中间的五条由<code>白-黑-白-黑-白</code>组成，最后的三条和前三条一样也是由<code>黑-白-黑</code>组成，这样就把一个条形码分为左、右两个部分。剩下的 84 (95-3-5-3=84) 条按每 7 条一组分为 12 组，每组对应着一个数字，不同的数字的具体表示因编码方式而有所不同，不过都遵循着一个规律：<code>右侧部分每一组的白色竖线条数都是奇数个。</code>这样不管你是正着扫描还是反着扫描都是可以识别的。</p><p>中国使用的条形码大部分都是 <code>EAN-13</code> 格式的，条形码数字编码的含义从左至右分别是前三位标识来源 <a href="https://en.wikipedia.org/wiki/List_of_GS1_country_codes" target="_blank" rel="noopener">国家编码</a> ，比如中国为：690–699，后面的 4 ~ 8 位数字代表的是厂商公司代码，但是位数不是固定的，紧接着后面 的 9~12 位是商品编码，第 13 位是校验码，这就意味着公司编码越短，剩余可用于商品编码的位数也越多，可表示的商品也就越多，当然公司代码出售价格也相应更昂贵，另外用在商品上的 <code>EAN-13</code> 条码是要到 <a href="http://www.ancc.org.cn/" target="_blank" rel="noopener">国家物品编码中心</a> 去申请的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec4bbe275e4c4c5c9bf1f639e39769e0~tplv-k3u1fbpfcp-zoom-1.image" alt="ean13-example.jpg"></p><h2 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h2><p><strong>二维码</strong> 是在一维码的基础之上扩展出来的，二维码有不同的种类，大体上可以分为这两种 ① 堆叠式/行排式二维条码 ② 矩阵式二维码，其中矩阵式二维码最为流行(下文的二维码指矩阵式二维码)，它与一维码所不同的是它的宽度和长度均有记录数据信息，存储的数据量更大，除此之外还增加了“定位点”和“容错机制”。通过“定位点”使读码机正确识别进行解读，所以二维码不管是从何种方向读取都是可以被识别的。</p><p>“容错机制”可以在没有识别到全部条码时也能正确推断和还原出原始的条码信息，维码的纠错级别，按照不同的纠错率（全部码字与可以纠错的码字的比率）分为 L (约 7%)、M (约 15%)、Q (约 25%)、H (约 30%) 四个不同的级别。比如下面的「<strong>mghio</strong>」公众号二维码尽管中间有公众号头像，但是依然可以正确识别出来就是这个“容错机制”的功能。不管是条形码（一维码）还是二维码其本质上都是对信息的编码，区别只是对信息的编码方式有所不同。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9333e46c16d24f28bf46fc2c5c25b739~tplv-k3u1fbpfcp-zoom-1.image" alt="mghio-official-account.jpg"></p><h2 id="二维码的结构"><a href="#二维码的结构" class="headerlink" title="二维码的结构"></a>二维码的结构</h2><p>二维码的版本从 1 ~ 40 共 40 个不同的版本，每个版本的基本结构都是相同的，所不同的是每个版本的码元（构成二维码的方形黑白点）数量不同，从版本 1 (21 × 21 码元) 至版本 40 (177 × 177 码元) 依次递增。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cd41116c0034958a454fd9b2e402ecd~tplv-k3u1fbpfcp-zoom-1.image" alt="qrcode-version.png"></p><p>二维码可以分为这几不同的功能区域，分别是<code>版本信息</code>、<code>格式信息</code>、<code>数据及容错</code>、<code>定位标志</code>、<code>校正标志</code>等主要区域，其中定位标识用来对二维码进行定位，版本信息表示二维码的版本，有 40 种不同版本的二维码，从版本 1 到版本 40 ，每一版本比前一个版本每边增加 4 个码元，数据及容错用于实际保存的二维码数据信息和用于修正二维码损坏带来的错误的纠错码字，二维码的编码规则比较复杂，感兴趣的朋友可以去看看它的编码规范。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b01fccc0f8c44129cde2ebaead2432d~tplv-k3u1fbpfcp-zoom-1.image" alt="qr-code-structure.png"></p><h2 id="普通二维码存在的问题"><a href="#普通二维码存在的问题" class="headerlink" title="普通二维码存在的问题"></a>普通二维码存在的问题</h2><p>以上介绍的这种普通二维码只是对文字、网址、电话等信息进行编码，不支持图片、音频、视频等内容，且生成二维码后内容无法改变，在信息内容较多时生成的二维码图案复杂，不容易识别和打印，正是由于存在这些特性故称之为<strong>静态二维码</strong>。静态二维码的好处就是无需联网也能识别，但是有些时候在线下场景经常需要打印二维码出来让用户去扫码，或者在一些运营场景下需要对用户的扫码情况进行数据统计和分析，再使用普通的二维码就无法提供这些功能了，这时候就要使用<strong>动态二维码</strong>了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71385c728ac2409d8669c9bda2436b76~tplv-k3u1fbpfcp-zoom-1.image" alt="static-qrcode-theory.png"></p><h2 id="动态二维码（活码）及其原理"><a href="#动态二维码（活码）及其原理" class="headerlink" title="动态二维码（活码）及其原理"></a>动态二维码（活码）及其原理</h2><p>动态二维码也称之为<strong>活码</strong>，关键就在于“活”，“活”就是内容可变，但是二维码不变。活码的优点其实就是静态二维码的缺点，支持随时修改二维码的内容且二维码图案不变，可跟踪扫描统计数据，支持存储大量文字、图片、文件、音视、视频等内容，同时生成的图案简单易扫。</p><p>实际上二维码是按照指定的规则编码后的一串字符串，通常大部分情况下是一个网址，在二维码出现之前，我们访问一个网址是打开浏览器输入网址后按下回车即可访问相应的网站，而有了二维码之后，我们使用软件扫描二维码，软件首先会做一次从二维码到文本的解析、转换，然后根据解析出来的文本结果判断是否是链接，是则跳转到这个链接，尽管对我们而言操作方式改变了，但其原理是相同的。</p><p>既然二维码背后是网址，要解决静态二维码生成后内容无法修改的问题，是不是只要把网址做成“活的”就行了，即可操控内容的链接，对外暴露的依然还是同一个网址，服务端只需要对这个网址做个二次跳转就行，实际上“活码”就是这么干的，这个对外暴露固定不变的网址也称为“活址”。此时脑海里浮现着计算机科学界一句著名的话：</p><blockquote><p>计算机科学的任何一个问题，都可以通过增加一个中间层来解决。</p></blockquote><p>上面的这个“活址”就是一个“中间层”的角色，屏蔽和隔离了二维码内容的变化，对外始终都只是暴露一个固定的网址。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d82cd87ce94bfbb47b0e0659b8e839~tplv-k3u1fbpfcp-zoom-1.image" alt="live-qrcode-theory.png"></p><h2 id="静态二维码和动态二维码（活码）的区别"><a href="#静态二维码和动态二维码（活码）的区别" class="headerlink" title="静态二维码和动态二维码（活码）的区别"></a>静态二维码和动态二维码（活码）的区别</h2><table><thead><tr><th>比较项</th><th>普通二维码</th><th>动态二维码(活码)</th></tr></thead><tbody><tr><td>内容修改</td><td>不支持</td><td>可以随时修改</td></tr><tr><td>内容类型</td><td>支持文字、网址、电话等</td><td>支持文字、图片、文件、音视、视频等内容</td></tr><tr><td>二维码图案</td><td>内容越多越复杂</td><td>活码图案简单</td></tr><tr><td>数据统计</td><td>不支持</td><td>支持</td></tr><tr><td>样式排版</td><td>不支持</td><td>支持</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要对<strong>条形码</strong>、<strong>静态二维码</strong>和<strong>动态二维码</strong>的一些基本概念做了简单的介绍，想要深入了解二维码的实现细节和原理的朋友可以看看耗子叔的这篇文章 <a href="https://coolshell.cn/articles/10590.html" target="_blank" rel="noopener">二维码的生成细节和原理</a> 或者到 <a href="https://www.qrcode.com/zh/index.html" target="_blank" rel="noopener">官网</a> 查看相关文档。虽然现在绝大部分人对于二维码都非常熟悉，几乎每天都会进行着扫码操作，不过在人们的大脑中依然有一个“根深蒂固”的认知，认为一个二维码扫描之后只会出现一种固定的结果，在接触 <strong>活码</strong> 这个概念之前俺也是。你知道的越多，不知道的也越多。</p><hr><p>参考资料</p><ul><li><p><a href="https://coolshell.cn/articles/10590.html" target="_blank" rel="noopener">二维码的生成细节和原理</a></p></li><li><p><a href="https://www.qrcode.com/zh/index.html" target="_blank" rel="noopener">QR code.com</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/09/3UcOhXMfKG4gBP6.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一维码（条形码）&quot;&gt;&lt;a href=&quot;#一维码（条形码）&quot; class=&quot;headerlink&quot; title=&quot;一维码（条形码）&quot;&gt;&lt;/a&gt;一维码（条形码）&lt;/h2&gt;&lt;p&gt;在介绍二维码之前，先来看看它的“大哥”一维码，一维码也叫条形码（好像在日常生活中都是叫这个），它是由不同宽度的黑条和白条按照一定的顺序排列组成的平行线图案，它的宽度记录着数据信息，长度没有记录信息，条形码常用于标出物品的生产国、制造厂家、商品名称、生产日期、图书分类号、邮件起止地点、类别、日期等信息，比如大部分食品包装袋背后都会印有条形码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="二维码" scheme="https://www.mghio.cn/categories/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="科技" scheme="https://www.mghio.cn/categories/%E4%BA%8C%E7%BB%B4%E7%A0%81/%E7%A7%91%E6%8A%80/"/>
    
    
      <category term="二维码" scheme="https://www.mghio.cn/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="科技" scheme="https://www.mghio.cn/tags/%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存模型</title>
    <link href="https://www.mghio.cn/post/2a3a86ee.html"/>
    <id>https://www.mghio.cn/post/2a3a86ee.html</id>
    <published>2022-04-15T08:24:50.000Z</published>
    <updated>2022-11-05T08:25:59.865Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/22/5ZlhXInxPCFUjYo.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在并发编程中，当多个线程同时访问同一个<strong>共享的可变变量</strong>时，会产生不确定的结果，所以要编写线程安全的代码，其本质上是对这些可变的共享变量的访问操作进行管理。导致这种不确定结果的原因就是<code>可见性</code>、<code>有序性</code>和<code>原子性</code>问题，<code>Java</code> 为解决可见性和有序性问题引入了 <a href="https://en.wikipedia.org/wiki/Java_memory_model" target="_blank" rel="noopener">Java 内存模型</a>，使用<code>互斥</code>方案（其核心实现技术是<code>锁</code>）来解决原子性问题。这篇先来看看解决可见性、有序性问题的 Java 内存模型（JMM）。</p><a id="more"></a><h2 id="什么是-Java-内存模型"><a href="#什么是-Java-内存模型" class="headerlink" title="什么是 Java 内存模型"></a>什么是 Java 内存模型</h2><p>Java 内存模型在<a href="https://en.wikipedia.org/wiki/Java_memory_model" target="_blank" rel="noopener">维基百科</a>上的定义如下：</p><blockquote><p>The Java memory model describes how threads in the Java programming language interact through memory. Together with the description of single-threaded execution of code, the memory model provides the semantics of the Java programming language.</p></blockquote><p>内存模型限制的是共享变量，也就是存储在堆内存中的变量，在 Java 语言中，所有的实例变量、静态变量和数组元素都存储在堆内存之中。而方法参数、异常处理参数这些局部变量存储在方法栈帧之中，因此不会在线程之间共享，不会受到内存模型影响，也不存在内存可见性问题。</p><p>通常，在线程之间的通讯方式有共享内存和消息传递两种，很明显，Java 采用的是第一种即<strong>共享的内存模型</strong>，在共享的内存模型里，多线程之间共享程序的公共状态，通过读-写内存的方式来进行隐式通讯。</p><p>从抽象的角度来看，JMM 其实是<code>定义了线程和主内存之间的关系</code>，首先，多个线程之间的共享变量存储在主内存之中，同时每个线程都有一个自己私有的本地内存，本地内存中存储着该线程读或写共享变量的副本（注意：本地内存是 JMM 定义的抽象概念，实际上并不存在）。抽象模型如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2769fe633304c1c8aeb0412df007b11~tplv-k3u1fbpfcp-zoom-1.image" alt="1.png"></p><p>在这个抽象的内存模型中，在两个线程之间的通信（共享变量状态变更）时，会进行如下两个步骤：</p><ol><li>线程 A 把在本地内存更新后的共享变量副本的值，刷新到主内存中。</li><li>线程 B 在使用到该共享变量时，到主内存中去读取线程 A 更新后的共享变量的值，并更新线程 B 本地内存的值。</li></ol><p>JMM 本质上是在硬件（处理器）内存模型之上又做了一层抽象，使得应用开发人员只需要了解 JMM 就可以编写出正确的并发代码，而无需过多了解硬件层面的内存模型。</p><h2 id="为什么需要-Java-内存模型"><a href="#为什么需要-Java-内存模型" class="headerlink" title="为什么需要 Java 内存模型"></a>为什么需要 Java 内存模型</h2><p>在日常的程序开发中，为一些共享变量赋值的场景会经常碰到，假设一个线程为整型共享变量 <code>count</code> 做赋值操作（<code>count = 9527;</code>），此时就会有一个问题，其它读取该共享变量的线程在什么情况下获取到的变量值为 <code>9527</code> 呢？如果缺少同步的话，会有很多因素导致其它读取该变量的线程无法立即甚至是永远都无法看到该变量的最新值。</p><p>比如缓存就可能会改变写入共享变量副本提交到主内存的次序，保存在本地缓存的值，对于其它线程是不可见的；编译器为了优化性能，有时候会改变程序中语句执行的先后顺序，这些因素都有可能会导致其它线程无法看到共享变量的最新值。</p><p>在文章开头，提到了 <code>JMM</code> 主要是为了解决<code>可见性</code>和<code>有序性</code>问题，那么首先就要先搞清楚，导致<code>可见性</code>和<code>有序性</code>问题发生的本质原因是什么？现在的服务绝大部分都是运行在多核 CPU 的服务器上，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据就会有一致性问题了，当一个线程对共享变量的修改，另外一个线程无法立刻看到。导致可见性问题的本质原因是<strong>缓存</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06c9cbb595a447fd8b662ee0b18cb1d1~tplv-k3u1fbpfcp-zoom-1.image" alt="2.png"></p><p>有序性是指代码实际的执行顺序和代码定义的顺序一致，编译器为了优化性能，虽然会遵守 <code>as-if-serial</code> 语义（不管怎么重排序，在单线程下的执行结果不能改变），不过有时候编译器及解释器的优化也可能引发一些问题。比如：双重检查来创建单实例对象。下面是使用双重检查来实现延迟创建单例对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> DoubleCheckedInstance instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (DoubleCheckedInstance.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> DoubleCheckedInstance();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>instance = new DoubleCheckedInstance();</code>，看起来 <code>Java</code> 代码只有一行，应该是无法就行重排序的，实际上其编译后的实际指令是如下三步：</p><ol><li>分配对象的内存空间</li><li>初始化对象</li><li>设置 instance 指向刚刚已经分配的内存地址</li></ol><p>上面的第 2 步和第 3 步如果改变执行顺序也不会改变单线程的执行结果，也就是说可能会发生重排序，下图是一种多线程并发执行的场景：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8389814c8ce475eaea2e24afd7ce25b~tplv-k3u1fbpfcp-zoom-1.image" alt="3.png"></p><p>此时线程 B 获取到的 <code>instance</code> 是没有初始化过的，如果此来访问 <code>instance</code> 的成员变量就可能触发空指针异常。导致<code>有序性</code>问题的本质原因是编译器优化。那你可能会想既然缓存和编译器优化是导致可见性问题和有序性问题的原因，那直接禁用掉不就可以彻底解决这些问题了吗，但是如果这么做了的话，程序的性能可能就会受到比较大的影响了。</p><p>其实可以换一种思路，能不能把这些禁用缓存和编译器优化的权利交给编码的工程师来处理，他们肯定最清楚什么时候需要禁用，这样就只需要提供按需禁用缓存和编译优化的方法即可，使用比较灵活。因此<code>Java 内存模型</code>就诞生了，它规范了 JVM 如何提供按需禁用缓存和编译优化的方法，规定了 JVM 必须遵守一组最小的保证，这个最小保证规定了线程对共享变量的写入操作何时对其它线程可见。</p><h2 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h2><p>顺序一致性模型是一个理想化后的理论参考模型，处理器和编程语言的内存模型的设计都是参考的顺序一致性模型理论。其有如下两大特性：</p><ol><li>一个线程中的所有操作必须按照程序的顺序来执行</li><li>所有的线程都只能看到一个单一的执行操作顺序，不管程序是否同步</li></ol><p>在工程师视角下的顺序一致性模型如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b4ba04c342430dbcfd34f48f72d2df~tplv-k3u1fbpfcp-zoom-1.image" alt="4.png"></p><p>顺序一致性模型有一个单一的全局内存，这个全局内存可以通过左右摇摆的开关可以连接到任意一个线程，每个线程都必须按照程序的顺序来执行内存的读和写操作。该理想模型下，任务时刻都只能有一个线程可以连接到内存，当多个线程并发执行时，就可以通过开关就可以把多个线程的读和写操作<strong>串行化</strong>。</p><p>顺序一致性模型中，所有操操作完全按照顺序串行执行，但是在 JMM 中就没有这个保证了，<code>未同步的程序</code>在 JMM 中不仅程序的执行顺序是无序的，而且由于本地内存的存在，所有线程看到的操作顺序也可能会不一致，比如一个线程把写共享变量保存在本地内存中，在还没有刷新到主内存前，其它线程是不可见的，只有更新到主内存后，其它线程才有可能看到。</p><p>JMM 对在<code>正确同步的程序</code>做了顺序一致性的保证，也就是程序的执行结果和该程序在顺序一致性内存模型中的执行结果相同。</p><h2 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h2><p><code>Happens-Before</code> 规则是 JMM 中的核心概念，<code>Happens-Before</code> 概念最开始在 <a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf" target="_blank" rel="noopener">这篇论文</a> 提出，其在论文中使用 <code>Happens-Before</code> 来定义分布式系统之间的偏序关系。在 <a href="https://download.oracle.com/otndocs/jcp/memory_model-1.0-pfd-spec-oth-JSpec" target="_blank" rel="noopener">JSR-133</a> 中使用 <code>Happens-Before</code> 来指定两个操作之间的执行顺序。</p><p>JMM 正是通过这个规则来保证跨线程的内存可见性，<code>Happens-Before</code> 的含义是<code>前面一个对共享变量的操作结果对该变量的后续操作是可见的</code>，约束了编译器的优化行为，虽然允许编译器优化，但是优化后的代码必须要满足 <code>Happens-Before</code> 规则，这个规则给工程师做了这个保证：同步的多线程程序是按照 <code>Happens-Before</code> 指定的顺序来执行的。目的就是<code>为了在不改变程序（单线程或者正确同步的多线程程序）执行结果的前提下，尽最大可能的提高程序执行的效率</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f49183b6d2e44de8351b22bd8f93f29~tplv-k3u1fbpfcp-zoom-1.image" alt="5.png"></p><p><code>JSR-133</code> 规范中定了如下 6 项 <code>Happens-Before</code> 规则：</p><ol><li><strong>程序顺序规则：</strong>一个线程中的每个操作，<code>Happens-Before</code> 该线程中的任意后续操作</li><li><strong>监视器锁规则：</strong>对一个锁的解锁操作，<code>Happens-Before</code> 于后面对这个锁的加锁操作</li><li><strong>volatile 规则</strong>对一个 <code>volatile</code> 类型的变量的写操作，<code>Happens-Before</code> 与任意后面对这个 <code>volatile</code> 变量的读操作</li><li><strong>传递性规则：</strong>如果操作 A <code>Happens-Before</code> 于操作 B，并且操作 B <code>Happens-Before</code> 于操作 C，则操作 A <code>Happens-Before</code> 于操作 C</li><li><strong>start() 规则：</strong>如果一个线程 A 执行操作 <code>threadB.start()</code> 启动线程 B，那么线程 A 的 <code>start()</code> 操作 <code>Happens-Before</code> 于线程 B 的任意操作</li><li><strong>join() 规则：</strong>如果线程 A 执行操作 <code>threadB.join()</code> 并成功返回，那么线程 B 中的任意操作 <code>Happens-Before</code> 于线程 A 从 <code>threadB.join()</code> 操作成功返回</li></ol><p>JMM 的一个基本原则是：只要不改变单线程和正确同步的多线程的执行结果，编译器和处理器随便怎么优化都可以，实际上对于应用开发人员对于两个操作是否真的被重排序并不关心，真正关心的是执行结果不能被修改。因此 <code>Happens-Before</code> 本质上和 <code>sa-if-serial</code> 的语义是一致的，只是 <code>sa-if-serial</code> 只是保证在单线程下的执行结果不被改变。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了内存模型的相关基础知识和相关概念，JMM 屏蔽了不同处理器内存模型之间的差异，在不同的处理器平台上给应用开发人员抽象出了统一的 <code>Java 内存模型（JMM）</code>。常见的处理器内存模型比 JMM 的要弱，因此 JVM 会在生成字节码指令时在适当的位置插入内存屏障（内存屏障的类型会因处理器平台而有所不同）来限制部分重排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/22/5ZlhXInxPCFUjYo.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在并发编程中，当多个线程同时访问同一个&lt;strong&gt;共享的可变变量&lt;/strong&gt;时，会产生不确定的结果，所以要编写线程安全的代码，其本质上是对这些可变的共享变量的访问操作进行管理。导致这种不确定结果的原因就是&lt;code&gt;可见性&lt;/code&gt;、&lt;code&gt;有序性&lt;/code&gt;和&lt;code&gt;原子性&lt;/code&gt;问题，&lt;code&gt;Java&lt;/code&gt; 为解决可见性和有序性问题引入了 &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_memory_model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 内存模型&lt;/a&gt;，使用&lt;code&gt;互斥&lt;/code&gt;方案（其核心实现技术是&lt;code&gt;锁&lt;/code&gt;）来解决原子性问题。这篇先来看看解决可见性、有序性问题的 Java 内存模型（JMM）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Memory" scheme="https://www.mghio.cn/categories/Java/Memory/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Memory" scheme="https://www.mghio.cn/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>对象转换工具 MapStruct 介绍</title>
    <link href="https://www.mghio.cn/post/42aa4c23.html"/>
    <id>https://www.mghio.cn/post/42aa4c23.html</id>
    <published>2022-03-05T08:23:01.000Z</published>
    <updated>2022-11-05T08:24:06.433Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/09/hy2JYfX8vmdwVDC.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们日常开发的分层结构的应用程序中，为了各层之间互相解耦，一般都会定义不同的对象用来在不同层之间传递数据，因此，就有了各种 <code>XXXDTO</code>、<code>XXXVO</code>、<code>XXXBO</code> 等基于数据库对象派生出来的对象，当在不同层之间传输数据时，不可避免地经常需要将这些对象进行相互转换。</p><p>此时一般处理两种处理方式：① 直接使用 <code>Setter</code> 和 <code>Getter</code> 方法转换、② 使用一些工具类进行转换（e.g. <code>BeanUtil.copyProperties</code>）。第一种方式如果对象属性比较多时，需要写很多的 <code>Getter/Setter</code> 代码。第二种方式看起来虽然比第一种方式要简单很多，但是因为其使用了反射，性能不太好，而且在使用中也有很多陷阱。而今天要介绍的主角 <a href="https://mapstruct.org" target="_blank" rel="noopener">MapStruct</a> 在不影响性能的情况下，同时解决了这两种方式存在的缺点。</p><a id="more"></a><h2 id="MapStruct-是什么"><a href="#MapStruct-是什么" class="headerlink" title="MapStruct 是什么"></a>MapStruct 是什么</h2><p><code>MapStruct</code> 是一个代码生成器，它基于<strong>约定优于配置</strong>方法极大地简化了 <code>Java bean</code> 类型之间映射的实现。自动生成的映射转换代码只使用简单的方法调用，因此速度快、类型安全而且易于理解阅读，源码仓库 <code>Github</code> 地址 <a href="https://github.com/mapstruct/mapstruct" target="_blank" rel="noopener">MapStruct</a>。总的来说，有如下三个特点：</p><ol><li>基于注解</li><li>在编译期自动生成映射转换代码</li><li>类型安全、高性能、无依赖性</li></ol><h2 id="MapStruct-使用步骤"><a href="#MapStruct-使用步骤" class="headerlink" title="MapStruct 使用步骤"></a>MapStruct 使用步骤</h2><p><code>MapStruct</code> 的使用比较简单，只需如下三步即可。</p><h3 id="①-引入依赖（这里以-Gradle-方式为例）"><a href="#①-引入依赖（这里以-Gradle-方式为例）" class="headerlink" title="① 引入依赖（这里以 Gradle 方式为例）"></a>① 引入依赖（这里以 <code>Gradle</code> 方式为例）</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'org.mapstruct:mapstruct:1.4.2.Final'</span></span><br><span class="line">    annotationProcessor <span class="string">'org.mapstruct:mapstruct-processor:1.4.2.Final'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-创建相关转换对象"><a href="#②-创建相关转换对象" class="headerlink" title="② 创建相关转换对象"></a>② 创建相关转换对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoctorDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③-创建转换器类（Mapper）"><a href="#③-创建转换器类（Mapper）" class="headerlink" title="③ 创建转换器类（Mapper）"></a>③ 创建转换器类（Mapper）</h3><p>需要注意的是，转换器不一定都要使用 <code>Mapper</code> 作为结尾，只是官方示例推荐以 <code>XXXMapper</code> 格式命名转换器名称，这里举例的是最简单的映射情况（字段名称和类型都完全匹配），只需要在转换器类上添加 <code>@Mapper</code> 注解即可，转换器代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DoctorMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="function">DoctorDTO <span class="title">toDTO</span><span class="params">(Doctor doctor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过下面这个简单的测试来校验转换结果是否正确，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoctorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToDTO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer doctorId = <span class="number">9527</span>;</span><br><span class="line">    String doctorName = <span class="string">"mghio"</span>;</span><br><span class="line"></span><br><span class="line">    Doctor doctor = <span class="keyword">new</span> Doctor();</span><br><span class="line">    doctor.setId(doctorId);</span><br><span class="line">    doctor.setName(doctorName);</span><br><span class="line"></span><br><span class="line">    DoctorDTO doctorDTO = DoctorMapper.INSTANCE.toDTO(doctor);</span><br><span class="line"></span><br><span class="line">    assertEquals(doctorId, doctorDTO.getId());</span><br><span class="line">    assertEquals(doctorName, doctorDTO.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果正常通过，说明使用 <code>DoctorMapper</code> 转换器达到我们的预期结果。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/841e311677cb451b8362408e4708afb3~tplv-k3u1fbpfcp-zoom-1.image" alt="1.png"></p><h2 id="MapStruct-实现浅析"><a href="#MapStruct-实现浅析" class="headerlink" title="MapStruct 实现浅析"></a>MapStruct 实现浅析</h2><p>在以上示例中，使用 <code>MapStruct</code> 通过简单的三步就实现了 <code>Doctor</code> 到 <code>DoctorDTO</code> 的转换，那么，<code>MapStruct</code> 是如何做到的呢？其实通过我们定义的转换器可以发现，转换器是接口类型的，而我们知道在 <code>Java</code> 中，接口是无法提供功能的，只是定义规范，具体干活的还是它的实现类。</p><p>因此我们可以大胆猜想，<code>MapStruct</code> 肯定给我们定义的转换器接口（<code>DoctorMapper</code>）生成了实现类，而通过 <code>Mappers.getMapper(DoctorMapper.class)</code> 获取到的转换器实际上是获取到了转化器接口的实现类。下面通过在测试类中 <code>debug</code> 来验证一下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/209532bf5cb74f5c83fe2f0776f2b1be~tplv-k3u1fbpfcp-zoom-1.image" alt="2.png"></p><p>通过 <code>debug</code> 可以看出，<code>DoctorMapper.INSTANCE</code> 获取到的是接口的实现类 <code>DoctorMapperImpl</code>。这个转换器接口实现类是在<strong>编译期</strong>自动生成的，<code>Gradle</code> 项目是在 <code>build/generated/sources/anotationProcessor/Java</code> 下（<code>Maven</code> 项目在 <code>target/generated-sources/annotations</code> 目录下），生成以上示例转换器接口的实现类源码如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd55c1172e5d41679efb7b6bcd3da429~tplv-k3u1fbpfcp-zoom-1.image" alt="4.png"></p><p>可以发现，自动生成的代码和我们平时手写的差不多，简单易懂，代码完全在编译期间生成，没有运行时依赖。和使用反射的实现方式相比还有一个有点就是，出错时很容易去 <code>debug</code> 实现源码来定位，而反射相对来说定位问题就要困难得多了。</p><h2 id="常见使用场景介绍"><a href="#常见使用场景介绍" class="headerlink" title="常见使用场景介绍"></a>常见使用场景介绍</h2><h3 id="①-对象属性名称和类型完全相同"><a href="#①-对象属性名称和类型完全相同" class="headerlink" title="① 对象属性名称和类型完全相同"></a>① 对象属性名称和类型完全相同</h3><p>从上文的示例可以看出，当属性名称和类型完全一致时，我们只需要定义一个转换器接口并添加 <code>@Mapper</code> 注解即可，然后 <code>MapStruct</code> 会自动生成实现类完成转换。示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  SourceMapper INSTANCE = Mappers.getMapper(SourceMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="function">Target <span class="title">toTarget</span><span class="params">(Source source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-对象属性类型相同但是名称不同"><a href="#②-对象属性类型相同但是名称不同" class="headerlink" title="② 对象属性类型相同但是名称不同"></a>② 对象属性类型相同但是名称不同</h3><p>当对象属性类型相同但是属性名称不一样时，通过 <code>@Mapping</code> 注解来手动指定转换。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String sourceName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String targetName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  SourceMapper INSTANCE = Mappers.getMapper(SourceMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mapping</span>(source = <span class="string">"sourceName"</span>, target = <span class="string">"targetName"</span>)</span><br><span class="line">  <span class="function">Target <span class="title">toTarget</span><span class="params">(Source source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③-在-Mapper-中使用自定义转换方法"><a href="#③-在-Mapper-中使用自定义转换方法" class="headerlink" title="③ 在 Mapper 中使用自定义转换方法"></a>③ 在 Mapper 中使用自定义转换方法</h3><p>有时候，对于某些类型（比如：一个类的属性是自定义的类），无法以自动生成代码的形式进行处理。此时我们需要自定义类型转换的方法，在 <code>JDK 7</code> 之前的版本，就需要使用抽象类来定义转换 <code>Mapper</code> 了，在 <code>JDK 8</code> 以上的版本可以使用接口的<strong>默认方法</strong>来自定义类型转换的方法。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String sourceName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> InnerSource innerSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer deleted;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String targetName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> InnerTarget innerTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Boolean isDeleted;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  SourceMapper INSTANCE = Mappers.getMapper(SourceMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mapping</span>(source = <span class="string">"sourceName"</span>, target = <span class="string">"targetName"</span>)</span><br><span class="line">  <span class="function">Target <span class="title">toTarget</span><span class="params">(Source source)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> InnerTarget <span class="title">innerTarget2InnerSource</span><span class="params">(InnerSource innerSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (innerSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InnerTarget innerTarget = <span class="keyword">new</span> InnerTarget();</span><br><span class="line">    innerTarget.setIsDeleted(innerSource.getDeleted() == <span class="number">1</span>);</span><br><span class="line">    innerTarget.setName(innerSource.getName());</span><br><span class="line">    <span class="keyword">return</span> innerTarget;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="④-多个对象转换成一个对象返回"><a href="#④-多个对象转换成一个对象返回" class="headerlink" title="④ 多个对象转换成一个对象返回"></a>④ 多个对象转换成一个对象返回</h3><p>在一些实际业务编码的过程中，不可避免地需要将多个对象转化为一个对象的场景，<code>MapStruct</code> 也能很好的支持，对于这种最终返回信息来源于多个类，我们可以通过配置来实现多对一的转换。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String street;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer zipCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddressMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  AddressMapper INSTANCE = Mappers.getMapper(AddressMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mapping</span>(source = <span class="string">"doctor.id"</span>, target = <span class="string">"personId"</span>)</span><br><span class="line">  <span class="meta">@Mapping</span>(source = <span class="string">"address.street"</span>, target = <span class="string">"streetDesc"</span>)</span><br><span class="line">  <span class="function">DeliveryAddressDTO <span class="title">doctorAndAddress2DeliveryAddressDTO</span><span class="params">(Doctor doctor, Address address)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个示例中的转换器（<code>AddressMapper</code>）可以看出，当属性名称和类型完全匹配时同样可以自动转换，但是当来源对象有多个属性名称及类型完全和目标对象相同时，还是需要手动配置指定的，因为此时 <code>MapStruct</code> 也无法准确判断应该使用哪个属性转换。</p><h2 id="获取转换器（Mapper）的几种方式"><a href="#获取转换器（Mapper）的几种方式" class="headerlink" title="获取转换器（Mapper）的几种方式"></a>获取转换器（Mapper）的几种方式</h2><p>获取转换器的方式根据 <code>@Mapper</code> 注解的 <code>componentModel</code> 属性不同而不同，支持以下四种不同的取值：</p><ol><li><strong>default</strong> 默认方式，默认方式，使用工厂方式（<code>Mappers.getMapper(Class)</code>）来获取</li><li><strong>cdi</strong> 此时生成的映射器是一个应用程序范围的 <code>CDI bean</code>，使用 <code>@Inject</code> 注解来获取</li><li><strong>spring</strong> <code>Spring</code> 的方式，可以通过 <code>@Autowired</code> 注解来获取，在 <code>Spring</code> 框架中推荐使用此方式</li><li><strong>jsr330</strong> 生成的映射器用 <code>@javax.inject.Named</code> 和 <code>@Singleton</code> 注解，通过 <code>@Inject</code> 来获取</li></ol><h3 id="①-通过工厂方式获取"><a href="#①-通过工厂方式获取" class="headerlink" title="① 通过工厂方式获取"></a>① 通过工厂方式获取</h3><p>上文的示例中都是通过工厂方式获取的，也就是使用 <code>MapStruct</code> 提供的 <code>Mappers.getMapper(Class&lt;T&gt; clazz)</code> 方法来获取指定类型的 <code>Mapper</code>。然后在调用的时候就不需要反复创建对象了，方法的最终实现是通过我们定义接口的类加载器加载 <code>MapStruct</code> 生成的实现类（类名称规则为：接口名称 + <code>Impl</code>），然后调用该类的无参构造器创建对象。核心源码如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c45fa84f0384c57abdff835677e67fa~tplv-k3u1fbpfcp-zoom-1.image" alt="5.png"></p><h3 id="②-使用依赖注入方式获取"><a href="#②-使用依赖注入方式获取" class="headerlink" title="② 使用依赖注入方式获取"></a>② 使用依赖注入方式获取</h3><p>对于依赖注入（<code>dependency injection</code>），使用 <code>Spring</code> 框架开发的朋友们应该很熟悉了，工作中经常使用。<code>MapStruct</code> 也支持依赖注入的使用方式，并且官方也推荐使用依赖注入的方式获取。使用 <code>Spring</code> 依赖注入的方式只需要指定 <code>@Mapper</code> 注解的 <code>componentModel = &quot;spring&quot;</code> 即可，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  SourceMapper INSTANCE = Mappers.getMapper(SourceMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mapping</span>(source = <span class="string">"sourceName"</span>, target = <span class="string">"targetName"</span>)</span><br><span class="line">  <span class="function">Target <span class="title">toTarget</span><span class="params">(Source source)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>@Autowired</code> 获取的原因是 <code>SourceMapper</code> 接口的实现类已经被注册为容器中一个 <code>Bean</code> 了，通过如下生成的接口实现类的代码也可以看到，在类上自动加上了 <code>@Component</code> 注解。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c2830645fc645b290446988a26a72ca~tplv-k3u1fbpfcp-zoom-1.image" alt="6.png"></p><p>最后还有两个注意事项：① 当两个转换对象的属性不一致时（比如 <code>DoctorDTO</code> 中不存在 <code>Doctor</code> 对象中的某个字段），编译时会出现警告提示。可以在<code>@Mapping</code> 注解中配置 <code>ignore = true</code>，或者当不一致字段比较多时，可以直接设置 <code>@Mapper</code> 注解的 <code>unmappedTargetPolicy</code> 属性或<code>unmappedSourcePolicy</code> 属性设置为 <code>ReportingPolicy.IGNORE</code>。② 如果你项目中也使用了 <a href="https://projectlombok.org" target="_blank" rel="noopener">Lombok</a>，需要注意一下 <code>Lombok</code> 的版本至少是 <code>1.18.10</code> 或者以上才行，否则会出现编译失败的情况。刚开始用的时候我也踩到这个坑了。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了对象转换工具 <code>Mapstruct</code> 库，以安全优雅的方式来减少我们的转换代码。从文中的示例中可以看出，<code>Mapstruct</code> 提供了大量的功能和配置，使我们能够以简单快捷的方式创建从简单到复杂的映射器。文中所介绍到的只是 <code>Mapstruct</code> 库的冰山一角，还有很多强大的功能文中没有提到，感兴趣的朋友可以自行查看 <a href="https://mapstruct.org/documentation/stable/reference/html" target="_blank" rel="noopener">官方使用指南</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/09/hy2JYfX8vmdwVDC.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在我们日常开发的分层结构的应用程序中，为了各层之间互相解耦，一般都会定义不同的对象用来在不同层之间传递数据，因此，就有了各种 &lt;code&gt;XXXDTO&lt;/code&gt;、&lt;code&gt;XXXVO&lt;/code&gt;、&lt;code&gt;XXXBO&lt;/code&gt; 等基于数据库对象派生出来的对象，当在不同层之间传输数据时，不可避免地经常需要将这些对象进行相互转换。&lt;/p&gt;
&lt;p&gt;此时一般处理两种处理方式：① 直接使用 &lt;code&gt;Setter&lt;/code&gt; 和 &lt;code&gt;Getter&lt;/code&gt; 方法转换、② 使用一些工具类进行转换（e.g. &lt;code&gt;BeanUtil.copyProperties&lt;/code&gt;）。第一种方式如果对象属性比较多时，需要写很多的 &lt;code&gt;Getter/Setter&lt;/code&gt; 代码。第二种方式看起来虽然比第一种方式要简单很多，但是因为其使用了反射，性能不太好，而且在使用中也有很多陷阱。而今天要介绍的主角 &lt;a href=&quot;https://mapstruct.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MapStruct&lt;/a&gt; 在不影响性能的情况下，同时解决了这两种方式存在的缺点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="MapStruct" scheme="https://www.mghio.cn/categories/Java/MapStruct/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="MapStruct" scheme="https://www.mghio.cn/tags/MapStruct/"/>
    
  </entry>
  
  <entry>
    <title>Java 异步编程的几种方式</title>
    <link href="https://www.mghio.cn/post/e3d37c7a.html"/>
    <id>https://www.mghio.cn/post/e3d37c7a.html</id>
    <published>2022-02-15T08:21:03.000Z</published>
    <updated>2022-11-05T08:22:06.335Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/01/5ZYw2EDlNizOSjQ.png" alt="cover.jpg"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>异步编程是让程序并发运行的一种手段。它允许多个事情<code>同时发生</code>，当程序调用需要长时间运行的方法时，它不会阻塞当前的执行流程，程序可以继续运行，当方法执行完成时通知给主线程根据需要获取其执行结果或者失败异常的原因。使用异步编程可以大大提高我们程序的吞吐量，可以更好的面对更高的并发场景并更好的利用现有的系统资源，同时也会一定程度上减少用户的等待时间等。本文我们一起来看看在 <code>Java</code> 语言中使用异步编程有哪些方式。</p><a id="more"></a><h4 id="Thread-方式"><a href="#Thread-方式" class="headerlink" title="Thread 方式"></a>Thread 方式</h4><p>在 <code>Java</code> 语言中最简单使用异步编程的方式就是创建一个 <code>Thread</code> 来实现，如果你使用的 <code>JDK</code> 版本是 8 以上的话，可以使用 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda 表达式</a> 会更加简洁。为了能更好的体现出异步的高效性，下面提供同步版本和异步版本的示例作为对照：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncWithAsyncDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doOneThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"doOneThing ----&gt;&gt;&gt; success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"doOtherThing ----&gt;&gt;&gt; success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch(<span class="string">"SyncWithAsyncDemo"</span>);</span><br><span class="line">    stopWatch.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步调用版本</span></span><br><span class="line">    <span class="comment">// testSynchronize();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步调用版本</span></span><br><span class="line">    testAsynchronize();</span><br><span class="line"></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    System.out.println(stopWatch);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAsynchronize</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-------------------- testAsynchronize --------------------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程执行 doOneThing</span></span><br><span class="line">    Thread doOneThingThread = <span class="keyword">new</span> Thread(SyncWithAsyncDemo::doOneThing, <span class="string">"doOneThing-Thread"</span>);</span><br><span class="line">    doOneThingThread.start();</span><br><span class="line"></span><br><span class="line">    doOtherThing();</span><br><span class="line">    <span class="comment">// 等待 doOneThing 线程执行完成</span></span><br><span class="line">    doOneThingThread.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSynchronize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-------------------- testSynchronize --------------------"</span>);</span><br><span class="line"></span><br><span class="line">    doOneThing();</span><br><span class="line">    doOtherThing();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步执行的运行如下：</p><p><img src="https://i.loli.net/2021/08/01/CuhrJQ87kSjyYvO.png" alt="1.png"></p><p>注释掉同步调用版本的代码，得到异步执行的结果如下：</p><p><img src="https://i.loli.net/2021/08/01/AKOnGP1jTh8S3Vw.png" alt="2.png"></p><p>从两次的运行结果可以看出，同步版本耗时 <code>4002 ms</code>，异步版本执行耗时 <code>2064 ms</code>，异步执行耗时减少将近一半，可以看出使用异步编程后可以大大缩短程序运行时间。</p><p>上面的示例的异步线程代码在 <code>main</code> 方法内开启了一个线程 <code>doOneThing-Thread</code> 用来异步执行 <code>doOneThing</code> 任务，在这时该线程与 <code>main</code> 主线程并发运行，也就是任务 <code>doOneThing</code> 与任务 <code>doOtherThing</code> 并发运行，则等主线程运行完 <code>doOtherThing</code> 任务后同步等待线程 <code>doOneThing</code> 运行完毕，整体还是比较简单的。</p><p>但是这个示例只能作为示例使用，如果用到了生产环境发生事故后果自负，使用上面这种 <code>Thread</code> 方式异步编程存在两个明显的问题。</p><ol><li>创建线程没有复用。我们知道频繁的线程创建与销毁是需要一部分开销的，而且示例里也没有限制线程的个数，如果使用不当可能会把系统线程用尽，从而引发事故，这个问题使用线程池可以解决。</li><li>异步任务无法获取最终的执行结果。示例中的这种方式是满足不了的，这时候就需要使用下面介绍的第二种 <code>FutureTask</code> 的方式了。</li></ol><h4 id="FutureTask-方式"><a href="#FutureTask-方式" class="headerlink" title="FutureTask 方式"></a>FutureTask 方式</h4><p>自 <code>JDK 1.5</code> 开始，引入了 <code>Future</code> 接口和实现 <code>Future</code> 接口的 <code>FutureTask</code> 类来表示异步计算结果。这个 <code>FutureTask</code> 类不仅实现了 <code>Future</code> 接口还实现了 <code>Runnable</code> 接口，表示一种可生成结果的 <code>Runnable</code>。其可以处于这三种状态：</p><ul><li><strong>未启动</strong> 当创建一个 <code>FutureTask</code> 没有执行 <code>FutureTask.run()</code> 方法之前</li><li><strong>已启动</strong> 在 <code>FutureTask.run()</code> 方法执行的过程中</li><li><strong>已完成</strong> 在 <code>FutureTask.run()</code> 方法正常执行结果或者调用了 <code>FutureTask.cancel(boolean mayInterruptIfRunning)</code> 方法以及在调用 <code>FutureTask.run()</code> 方法的过程中发生异常结束后</li></ul><p><code>FutureTask</code> 类实现了 <code>Future</code> 接口的开启和取消任务、查询任务是否完成、获取计算结果方法。要获取 <code>FutureTask</code> 任务的结果，我们只能通过调用 <code>getXXX()</code> 系列方法才能获取，当结果还没出来时候这些方法会被阻塞，同时这了任务可以是 <code>Callable</code> 类型（有返回结果），也可以是 <code>Runnable</code> 类型（无返回结果）。我们修改上面的示例把两个任务方法修改为返回 <code>String</code> 类型，使用 <code>FutureTask</code> 的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-------------------- testFutureTask --------------------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 FutureTask（doOneThing 任务）</span></span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(FutureTaskDemo::doOneThing);</span><br><span class="line">    <span class="comment">// 使用线程池执行 doOneThing 任务</span></span><br><span class="line">    ForkJoinPool.commonPool().execute(futureTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 doOtherThing 任务</span></span><br><span class="line">    String doOtherThingResult = doOtherThing();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步等待线程执行 doOneThing 任务结束</span></span><br><span class="line">    String doOneThingResult = futureTask.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行结果输出</span></span><br><span class="line">    System.out.println(<span class="string">"doOneThingResult ----&gt;&gt;&gt; "</span> + doOneThingResult);</span><br><span class="line">    System.out.println(<span class="string">"doOtherThingResult ----&gt;&gt;&gt; "</span> + doOtherThingResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>FutureTask</code> 异步编程方式的耗时和上面的 <code>Thread</code> 方式是差不多的，其本质都是另起一个线程去做 <code>doOneThing</code> 任务然后等待返回，运行结果如下：</p><p><img src="https://i.loli.net/2021/08/01/geL3PaO7tIAdz4r.png" alt="3.png"></p><p>这个示例中，<code>doOneThing</code> 和 <code>doOtherThing</code> 都是有返回值的任务（都返回 <code>String</code> 类型结果），我们在主线程 <code>main</code> 中创建一个异步任务 <code>FutureTask</code> 来执行 <code>doOneThing</code>，然后使用 <code>ForkJoinPool.commonPool()</code> 创建线程池（有关 <code>ForkJoinPool</code> 的介绍见 <a href="https://www.mghio.cn/post/30ff968d.html">这里</a>），然后调用了线程池的 <code>execute</code> 方法把 <code>futureTask</code> 提交到线程池来执行。</p><p>通过示例可以看到，虽然 <code>FutureTask</code> 提供了一些方法让我们获取任务的执行结果、任务是否完成等，但是使用还是比较复杂，在一些较为复杂的场景（比如多个 <code>FutureTask</code> 之间的关系表示）的编码还是比较繁琐，还是当我们调用 <code>getXXX()</code> 系列方法时还是会在任务执行完毕前阻塞调用线程，达不到异步编程的效果，基于这些问题，在 <code>JDK 8</code> 中引入了 <code>CompletableFuture</code> 类，下面来看看如何使用 <code>CompletableFuture</code> 来实现异步编程。</p><h4 id="CompletableFuture-方式"><a href="#CompletableFuture-方式" class="headerlink" title="CompletableFuture 方式"></a>CompletableFuture 方式</h4><p><code>JDK 8</code> 中引入了 <code>CompletableFuture</code> 类，实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口，为异步编程提供了一些列方法，如 <code>supplyAsync</code>、<code>runAsync</code> 和 <code>thenApplyAsync</code> 等，除此之外 <code>CompletableFuture</code> 还有一个重要的功能就是可以让两个或者多个 <code>CompletableFuture</code> 进行运算来产生结果。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;String&gt; <span class="title">doOneThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"doOneThing"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;String&gt; <span class="title">doOtherThing</span><span class="params">(String parameter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> parameter + <span class="string">" "</span> + <span class="string">"doOtherThing"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch(<span class="string">"CompletableFutureDemo"</span>);</span><br><span class="line">    stopWatch.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步执行版本</span></span><br><span class="line">    testCompletableFuture();</span><br><span class="line"></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    System.out.println(stopWatch);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCompletableFuture</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">// 先执行 doOneThing 任务，后执行 doOtherThing 任务</span></span><br><span class="line">    CompletableFuture&lt;String&gt; resultFuture = doOneThing().thenCompose(CompletableFutureDemo::doOtherThing);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务结果</span></span><br><span class="line">    String doOneThingResult = resultFuture.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取执行结果</span></span><br><span class="line">    System.out.println(<span class="string">"DoOneThing and DoOtherThing execute finished. result = "</span> + doOneThingResult);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://i.loli.net/2021/08/01/VNZndkpSHGIKWtR.png" alt="4.png"></p><p> 在主线程 <code>main</code> 中首先调用了方法 <code>doOneThing()</code> 方法开启了一个异步任务，并返回了对应的 <code>CompletableFuture</code> 对象，我们取名为 <code>doOneThingFuture</code>，然后在 <code>doOneThingFuture</code> 的基础上使用 <code>CompletableFuture</code> 的 <code>thenCompose()</code> 方法，让 <code>doOneThingFuture</code> 方法执行完成后，使用其执行结果作为 <code>doOtherThing(String parameter)</code> 方法的参数创建的异步任务返回。</p><p> 我们不需要显式使用 <code>ExecutorService</code>，在 <code>CompletableFuture</code> 内部使用的是 <code>Fork/Join</code> 框架异步处理任务，因此，它使我们编写的异步代码更加简洁。此外，<code>CompletableFuture</code> 类功能很强大其提供了和很多方便的方法，更多关于 <code>CompletableFuture</code> 的使用请见 <a href="https://www.mghio.cn/post/7b9ead86.html">这篇</a>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文介绍了在 <code>Java</code> 中的 <code>JDK</code> 使用异步编程的三种方式，这些是我们最基础的实现异步编程的工具，在其之上的还有 <code>Guava</code> 库提供的 <a href="https://guava.dev/releases/28.2-jre/api/docs/index.html?com/google/common/util/concurrent/ListenableFuture.html" target="_blank" rel="noopener">ListenableFuture</a> 和 <a href="https://guava.dev/releases/28.2-jre/api/docs/com/google/common/util/concurrent/Futures.html" target="_blank" rel="noopener">Futures</a> 类以及 <code>Spring</code> 框架提供的异步执行能力，使用 <code>@Async</code> 等注解实现异步处理，感兴趣的话可以自行学习了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/01/5ZYw2EDlNizOSjQ.png&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;异步编程是让程序并发运行的一种手段。它允许多个事情&lt;code&gt;同时发生&lt;/code&gt;，当程序调用需要长时间运行的方法时，它不会阻塞当前的执行流程，程序可以继续运行，当方法执行完成时通知给主线程根据需要获取其执行结果或者失败异常的原因。使用异步编程可以大大提高我们程序的吞吐量，可以更好的面对更高的并发场景并更好的利用现有的系统资源，同时也会一定程度上减少用户的等待时间等。本文我们一起来看看在 &lt;code&gt;Java&lt;/code&gt; 语言中使用异步编程有哪些方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="异步" scheme="https://www.mghio.cn/categories/Java/%E5%BC%82%E6%AD%A5/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="异步" scheme="https://www.mghio.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 Fork/Join 框架</title>
    <link href="https://www.mghio.cn/post/30ff968d.html"/>
    <id>https://www.mghio.cn/post/30ff968d.html</id>
    <published>2022-01-05T08:19:10.000Z</published>
    <updated>2022-11-05T08:20:10.908Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/25/ZjDdPW3NGlkSb7V.jpg" alt="cover.jpg"></p><h4 id="什么是-Fork-Join-框架"><a href="#什么是-Fork-Join-框架" class="headerlink" title="什么是 Fork/Join 框架"></a>什么是 Fork/Join 框架</h4><p><code>Fork/Join</code> 框架是一种在 <code>JDK 7</code> 引入的线程池，用于并行执行<code>把一个大任务拆成多个小任务并行执行，最终汇总每个小任务结果得到大任务结果</code>的特殊任务。通过其命名也很容易看出框架主要分为 <code>Fork</code> 和 <code>Join</code> 两个阶段，第一阶段 <code>Fork</code> 是把一个大任务拆分为多个子任务并行的执行，第二阶段 <code>Join</code> 是合并这些子任务的所有执行结果，最后得到大任务的结果。</p><p>这里不难发现其执行主要流程：首先判断一个任务是否足够小，如果任务足够小，则直接计算，否则，就拆分成几个更小的小任务分别计算，这个过程可以反复的拆分成一系列小任务。<code>Fork/Join</code> 框架是一种基于 <a href="https://en.wikipedia.org/wiki/Divide_and_conquer" target="_blank" rel="noopener">分治</a> 的算法，通过拆分大任务成多个独立的小任务，然后并行执行这些小任务，最后合并小任务的结果得到大任务的最终结果，通过并行计算以提高效率。</p><a id="more"></a><h4 id="Fork-Join-框架使用示例"><a href="#Fork-Join-框架使用示例" class="headerlink" title="Fork/Join 框架使用示例"></a>Fork/Join 框架使用示例</h4><p>下面通过一个<code>计算列表中所有元素的总和</code>的示例来看看 <code>Fork/Join</code> 框架是如何使用的，总的思路是：将这个列表分成许多子列表，然后对每个子列表的元素进行求和，然后，我们再计算所有这些值的总和就得到原始列表的和了。<code>Fork/Join</code> 框架中定义了 <code>ForkJoinTask</code> 来表示一个 <code>Fork/Join</code> 任务，其提供了 <code>fork()</code>、<code>join()</code> 等操作，通常情况下，我们并不需要直接继承这个 <code>ForkJoinTask</code> 类，而是使用框架提供的两个 <code>ForkJoinTask</code> 的子类：</p><ul><li><strong>RecursiveAction</strong> 用于表示<code>没有返回结果</code>的 <code>Fork/Join</code> 任务。</li><li><strong>RecursiveTask</strong> 用于表示<code>有返回结果</code>的 <code>Fork/Join</code> 任务。</li></ul><p>很显然，在这个示例中是需要返回结果的，可以定义 <code>SumAction</code> 类继承自 <code>RecursiveTask</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEQUENTIAL_THRESHOLD = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Long&gt; data;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(List&lt;Long&gt; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.size() &lt;= SEQUENTIAL_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">long</span> sum = computeSumDirectly();</span><br><span class="line">      System.out.format(<span class="string">"Sum of %s: %d\n"</span>, data.toString(), sum);</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = data.size() / <span class="number">2</span>;</span><br><span class="line">      SumTask firstSubtask = <span class="keyword">new</span> SumTask(data.subList(<span class="number">0</span>, mid));</span><br><span class="line">      SumTask secondSubtask = <span class="keyword">new</span> SumTask(data.subList(mid, data.size()));</span><br><span class="line">      <span class="comment">// 执行子任务</span></span><br><span class="line">      firstSubtask.fork();</span><br><span class="line">      secondSubtask.fork();</span><br><span class="line">      <span class="comment">// 等待子任务执行完成，并获取结果</span></span><br><span class="line">      <span class="keyword">long</span> firstSubTaskResult = firstSubtask.join();</span><br><span class="line">      <span class="keyword">long</span> secondSubTaskResult = secondSubtask.join();</span><br><span class="line">      <span class="keyword">return</span> firstSubTaskResult + secondSubTaskResult;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeSumDirectly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Long l : data) &#123;</span><br><span class="line">      sum += l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    List&lt;Long&gt; data = random</span><br><span class="line">        .longs(<span class="number">1_000</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">        .boxed()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    SumTask task = <span class="keyword">new</span> SumTask(data);</span><br><span class="line">    pool.invoke(task);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Sum: "</span> + pool.invoke(task));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里当列表大小小于 <code>SEQUENTIAL_THRESHOLD</code> 变量的值（阈值）时视为小任务，直接计算求和列表元素结果，否则再次拆分为小任务，运行结果如下：</p><p><img src="https://i.loli.net/2021/07/25/jkq3ZeJwfGhrOst.png" alt="1.png"></p><p>通过这个示例代码可以发现，<code>Fork/Join</code> 框架 中 <code>ForkJoinTask</code> 任务与平常的一般任务的主要不同点在于：<code>ForkJoinTask</code> 需要实现抽象方法 <code>compute()</code> 来定义计算逻辑，在这个方法里一般通用的实现模板是，首先先判断当前任务是否是小任务，如果是，就执行执行任务，如果不是小任务，则再次拆分为两个子任务，然后当每个子任务调用 <code>fork()</code> 方法时，会再次进入到 <code>compute()</code> 方法中，检查当前任务是否需要再拆分为子任务，如果已经是小任务，则执行当前任务并返回结果，否则继续分割，最后调用 <code>join()</code> 方法等待所有子任务执行完成并获得执行结果。伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (problem is small) &#123;</span><br><span class="line">  directly solve problem.</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  Step <span class="number">1</span>. split problem into independent parts.</span><br><span class="line">  Step <span class="number">2</span>. fork <span class="keyword">new</span> subtasks to solve each part.</span><br><span class="line">  Step <span class="number">3</span>. join all subtasks.</span><br><span class="line">  Step <span class="number">4</span>. compose result from subresults.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Fork-Join-框架设计"><a href="#Fork-Join-框架设计" class="headerlink" title="Fork/Join 框架设计"></a>Fork/Join 框架设计</h4><p><code>Fork/Join</code> 框架核心思想是把一个大任务拆分成若干个小任务，然后汇总每个小任务的结果最终得到大任务的结果，如果让你设计一个这样的框架，你会如何实现呢？（建议思考一下），<code>Fork/Join</code> 框架的整个流程正如其名所示，分为两个步骤：</p><ol><li><strong>大任务分割</strong> 需要有这么一个的类，用来将大任务拆分为子任务，可能一次拆分后的子任务还是比较大，需要多次拆分，直到拆分出来的子任务符合我们定义的小任务才结束。</li><li><strong>执行任务并合并任务结果</strong> 第一步拆分出来的子任务分别存放在一个个 <a href="https://en.wikipedia.org/wiki/Double-ended_queue" target="_blank" rel="noopener">双端队列</a> 里面（P.S. 这里为什么要使用双端队列请看下文），然后每个队列启动一个线程从队列中获取任务执行。这些子任务的执行结果都会放到一个统一的队列中，然后再启动一个线程从这个队列中拿数据，最后合并这些数据返回。</li></ol><p><code>Fork/Join</code> 框架使用了如下两个类来完成以上两个步骤：</p><ul><li><strong>ForkJoinTask 类</strong> 在上文的实例中也有提到，表示 <code>ForkJoin</code> 任务，在使用框架时首先必须先定义任务，通常只需要继承自 <code>ForkJoinTask</code> 类的子类 <code>RecursiveAction</code>(无返回结果) 或者 <code>RecursiveTask</code>(有返回结果)即可。</li><li><strong>ForkJoinPool</strong> 从名字也可以猜到一二了，就是用来执行 <code>ForkJoinTask</code> 的线程池。大任务拆分出的子任务会添加到当前线程的<code>双端队列</code>的头部。</li></ul><p>喜欢思考的你，心中想必会想到这么一种场景，当我们需要完成一个大任务时，会先把这个大任务拆分为多个独立的子任务，这些子任务会放到独立的队列中，并为每个队列都创建一个单独的线程去执行队列里的任务，即这里线程和队列时一对一的关系，那么当有的线程可能会先把自己队列的任务执行完成了，而有的线程则没有执行完成，这就导致一些先执行完任务的线程干等了，这是个好问题。</p><p>既然是做并发的，肯定要最大程度压榨计算机的性能，对于这种场景并发大师 <a href="http://gee.cs.oswego.edu" target="_blank" rel="noopener">Doug Lea</a> 使用了<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="noopener">工作窃取算法</a>处理，使用<code>工作窃取算法</code>后，先完成自己队列中任务的线程会去其它线程的队列中”窃取“一个任务来执行，哈哈，一方有难，八方支援。但是此时这个线程和队列的持有线程会同时访问同一个队列，所以为了<code>减少窃取任务的线程和被窃取任务的线程之间的竞争</code>，<code>ForkJoin</code> 选择了<code>双端队列</code>这种数据结构，这样就可以按照这种规则执行任务了：被窃取任务的线程始终从队列头部获取任务并执行，窃取任务的线程使用从队列尾部获取任务执行。这个算法在绝大部分情况下都可以充分利用多线程进行并行计算，但是在双端队列里只有一个任务等极端情况下还是会存在一定程度的竞争。</p><p><img src="https://i.loli.net/2021/07/25/Z2RIdHN8iWvKtlk.png" alt="2.png"></p><h4 id="Fork-Join-框架实现原理"><a href="#Fork-Join-框架实现原理" class="headerlink" title="Fork/Join 框架实现原理"></a>Fork/Join 框架实现原理</h4><p><code>Fork/Join</code> 框架的实现核心是 <code>ForkJoinPool</code> 类，该类的重要组成部分为 <code>ForkJoinTask</code> 数组和 <code>ForkJoinWorkerThread</code> 数组，其中 <code>ForkJoinTask</code> 数组用来存放框架使用者给提交给 <code>ForkJoinPool</code> 的任务，<code>ForkJoinWorkerThread</code> 数组则负责执行这些任务。任务有如下四种状态：</p><ul><li><strong>NORMAL</strong> 已完成</li><li><strong>CANCELLED</strong> 被取消</li><li><strong>SIGNAL</strong> 信号</li><li><strong>EXCEPTIONAL</strong> 发生异常</li></ul><p>下面来看看这两个类的核心方法实现原理，首先来看 <code>ForkJoinTask</code> 的 <code>fork()</code> 方法，源码如下：</p><p><img src="https://i.loli.net/2021/07/25/REUWxv9VfukS1la.png" alt="6.png"></p><p>方法对于 <code>ForkJoinWorkerThread</code> 类型的线程，首先会调用 <code>ForkJoinWorkerThread</code> 的 <code>workQueue</code> 的 <code>push()</code> 方法<code>异步的去执行这个任务</code>，然后马上返回结果。继续跟进 <code>ForkJoinPool</code> 的 <code>push()</code> 方法，源码如下：</p><p><img src="https://i.loli.net/2021/07/25/GRIbPCZodErX5UK.png" alt="8.png"></p><p>方法将当前任务添加到 <code>ForkJoinTask</code> 任务队列数组中，然后再调用 <code>ForkJoinPool</code> 的 <code>signalWork</code> 方法创建或者唤醒一个工作线程来执行该任务。然后再来看看 <code>ForkJoinTask</code> 的 <code>join()</code> 方法，方法源码如下：</p><p><img src="https://i.loli.net/2021/07/25/NAqC5XL6Iektm8f.png" alt="3.png"></p><p><img src="https://i.loli.net/2021/07/25/dRCjtwSYpDlrEJq.png" alt="4.png"></p><p>方法首先调用了 <code>doJoin()</code> 方法，该方法返回当前任务的状态，根据返回的任务状态做不同的处理：</p><ol><li>已完成状态则直接返回结果</li><li>被取消状态则直接抛出异常（<code>CancellationException</code>）</li><li>发生异常状态则直接抛出对应的异常</li></ol><p>继续跟进 <code>doJoin()</code> 方法，方法源码如下：</p><p><img src="https://i.loli.net/2021/07/25/KcYRWj2iPbUgCAo.png" alt="5.png"></p><p>方法首先判断当前任务状态是否已经执行完成，如果执行完成则直接返回任务状态。如果没有执行完成，则从任务数组中（<code>workQueue</code>）取出任务并执行，任务执行完成则设置任务状态为 <code>NORMAL</code>，如果出现异常则记录异常并设置任务状态为 <code>EXCEPTIONAL</code>（在 <code>doExec()</code> 方法中）。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍了 <code>Java</code> 并发框架中的 <code>Fork/Join</code> 框架的基本原理和其使用的<code>工作窃取算法</code>(<code>work-stealing</code>)、设计方式和部分实现源码。<code>Fork/Join</code> 框架在 <code>JDK</code> 的官方标准库中也有应用。比如 <code>JDK 1.8+</code> 标准库提供的 <code>Arrays.parallelSort(array)</code> 可以进行并行排序，它的原理就是内部通过 <code>Fork/Join</code> 框架对大数组分拆进行并行排序，可以提高排序的速度，还有集合中的 <code>Collection.parallelStream()</code> 方法底层也是基于 <code>Fork/Join</code> 框架实现的，最后就是定义小任务的阈值往往是需要通过测试验证才能合理给出，并且保证程序可以达到最好的性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/25/ZjDdPW3NGlkSb7V.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是-Fork-Join-框架&quot;&gt;&lt;a href=&quot;#什么是-Fork-Join-框架&quot; class=&quot;headerlink&quot; title=&quot;什么是 Fork/Join 框架&quot;&gt;&lt;/a&gt;什么是 Fork/Join 框架&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Fork/Join&lt;/code&gt; 框架是一种在 &lt;code&gt;JDK 7&lt;/code&gt; 引入的线程池，用于并行执行&lt;code&gt;把一个大任务拆成多个小任务并行执行，最终汇总每个小任务结果得到大任务结果&lt;/code&gt;的特殊任务。通过其命名也很容易看出框架主要分为 &lt;code&gt;Fork&lt;/code&gt; 和 &lt;code&gt;Join&lt;/code&gt; 两个阶段，第一阶段 &lt;code&gt;Fork&lt;/code&gt; 是把一个大任务拆分为多个子任务并行的执行，第二阶段 &lt;code&gt;Join&lt;/code&gt; 是合并这些子任务的所有执行结果，最后得到大任务的结果。&lt;/p&gt;
&lt;p&gt;这里不难发现其执行主要流程：首先判断一个任务是否足够小，如果任务足够小，则直接计算，否则，就拆分成几个更小的小任务分别计算，这个过程可以反复的拆分成一系列小任务。&lt;code&gt;Fork/Join&lt;/code&gt; 框架是一种基于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Divide_and_conquer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分治&lt;/a&gt; 的算法，通过拆分大任务成多个独立的小任务，然后并行执行这些小任务，最后合并小任务的结果得到大任务的最终结果，通过并行计算以提高效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Fork-Join" scheme="https://www.mghio.cn/categories/Java/%E5%B9%B6%E5%8F%91/Fork-Join/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Fork-Join" scheme="https://www.mghio.cn/tags/Fork-Join/"/>
    
  </entry>
  
  <entry>
    <title>Spring 的循环依赖问题</title>
    <link href="https://www.mghio.cn/post/f7a05eb0.html"/>
    <id>https://www.mghio.cn/post/f7a05eb0.html</id>
    <published>2021-12-05T08:16:39.000Z</published>
    <updated>2022-11-05T08:18:04.195Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/17/lw3qMrmSkIRfOGp.jpg" alt="cover.jpg"></p><h4 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h4><p>什么是<code>循环依赖</code>呢？可以把它拆分成<code>循环</code>和<code>依赖</code>两个部分来看，<strong>循环</strong>是指计算机领域中的循环，执行流程形成闭合回路；<strong>依赖</strong>就是完成这个动作的前提准备条件，和我们平常说的依赖大体上含义一致。放到 <code>Spring</code> 中来看就一个或多个 <code>Bean</code> 实例之间存在直接或间接的依赖关系，构成循环调用，循环依赖可以分为<code>直接循环依赖</code>和<code>间接循环依赖</code>，直接循环依赖的简单依赖场景：<code>Bean A</code> 依赖于 <code>Bean B</code>，然后 <code>Bean B</code> 又反过来依赖于 <code>Bean A</code>（<code>Bean A -&gt; Bean B -&gt; Bean A</code>），间接循环依赖的一个依赖场景：<code>Bean A</code> 依赖于 <code>Bean B</code>，<code>Bean B</code> 依赖于 <code>Bean C</code>，<code>Bean C</code> 依赖于 <code>Bean A</code>，中间多了一层，但是最终还是形成循环（<code>Bean A -&gt; Bean B -&gt; Bean C -&gt; Bean A</code>）。</p><a id="more"></a><h4 id="循环依赖的类型"><a href="#循环依赖的类型" class="headerlink" title="循环依赖的类型"></a>循环依赖的类型</h4><p>第一种是<strong>自依赖</strong>，自己依赖自己从而形成循环依赖，一般情况下不会发生这种循环依赖，因为它很容易被我们发现。</p><p><img src="https://i.loli.net/2021/07/17/LGgVfXmPKU3EwcS.png" alt="1.png"></p><p>第二种是<strong>直接依赖</strong>，发生在两个对象之间，比如：<code>Bean A</code> 依赖于 <code>Bean B</code>，然后 <code>Bean B</code> 又反过来依赖于 <code>Bean A</code>，如果比较细心的话肉眼也不难发现。</p><p><img src="https://i.loli.net/2021/07/17/yNlpDUtmQT2RXnu.png" alt="2.png"></p><p>第三种是<strong>间接依赖</strong>，这种依赖类型发生在 3 个或者以上的对象依赖的场景，间接依赖最简单的场景：<code>Bean A</code> 依赖于 <code>Bean B</code>，<code>Bean B</code> 依赖于 <code>Bean C</code>，<code>Bean C</code> 依赖于 <code>Bean A</code>，可以想象当中间依赖的对象很多时，是很难发现这种循环依赖的，一般都是借助一些工具排查。</p><p><img src="https://i.loli.net/2021/07/17/OH3JobWDSPqrYZE.png" alt="3.png"></p><h4 id="Spring-对几种循环依赖场景支持情况"><a href="#Spring-对几种循环依赖场景支持情况" class="headerlink" title="Spring 对几种循环依赖场景支持情况"></a>Spring 对几种循环依赖场景支持情况</h4><p>在介绍 Spring 对几种循环依赖场景的处理方式之前，先来看看在 Spring 中循环依赖会有哪些场景，大部分常见的场景总结如下图所示：</p><p><img src="https://i.loli.net/2021/07/17/qu4Y6s8nBi1NvRa.png" alt="4.png"></p><p>有句话说得好，<code>源码之下无秘密</code>，下面就通过源码探究这些场景 <code>Spring</code> 是否支持，以及支持的原因或者不支持的原因，话不多说，下面进入正题。</p><h5 id="第-①-种场景——单例-Bean-的-setter-注入"><a href="#第-①-种场景——单例-Bean-的-setter-注入" class="headerlink" title="第 ① 种场景——单例 Bean 的 setter 注入"></a>第 ① 种场景——单例 Bean 的 setter 注入</h5><p>这种使用方式也是最常用的方式之一，假设有两个 <code>Service</code> 分别为 <code>OrderService</code>（订单相关业务逻辑）和 <code>TradeService</code>（交易相关业务逻辑），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TradeService tradeService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateTrade</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种循环依赖场景，程序是可以正常运行的，从代码上看确实是有循环依赖了，也就是说 <code>Spring</code> 是支持这种循环依赖场景的，这里我们察觉不到循环依赖的原因是 <code>Spring</code> 已经默默地解决了。</p><p>假设没有做任何处理，按照正常的创建逻辑来执行的话，流程是这样的：容器先创建 <code>OrderService</code>，发现依赖于 <code>TradeService</code>，再创建 <code>OrderService</code>，又发现依赖于 <code>TradeService</code> … ，发生无限死循环，最后发生栈溢出错误，程序停止。为了支持这种常见的循环依赖场景，<code>Spring</code> 将创建对象分为如下几个步骤：</p><ol><li>实例化一个新对象（在堆中），但此时尚未给对象属性赋值</li><li>给对象赋值</li><li>调用 <code>BeanPostProcessor</code> 的一些实现类的方法，在这个阶段，<code>Bean</code> 已经创建并赋值属性完成。这时候容器中所有实现 <code>BeanPostProcessor</code> 接口的类都会被调用（e.g. <code>AOP</code>）</li><li>初始化（如果实现了 <code>InitializingBean</code>，就会调用这个类的方法来完成类的初始化）</li><li>返回创建出来的实例</li></ol><p>为此，<code>Spring</code> 引入了三级缓存来处理这个问题（三级缓存定义在 <code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</code> 中），第一级缓存 <code>singletonObjects</code> 用于存放完全初始化好的 <code>Bean</code>，从该缓存中取出的 <code>Bean</code> 可以直接使用，第二级缓存 <code>earlySingletonObjects</code> 用于存放提前暴露的单例对象的缓存，存放原始的 <code>Bean</code> 对象（属性尚未赋值），用于解决循环依赖，第三级缓存 <code>singletonFactories</code> 用于存放单例对象工厂的缓存，存放 <code>Bean</code> 工厂对象，用于解决循环依赖。上述实例使用三级缓存的处理流程如下所示：</p><p><img src="https://i.loli.net/2021/07/17/jPUQ6Sfs8mpBtLg.png" alt="5.png"></p><p>如果你看过三级缓存的定义源码的话，可能也有这样的疑问：为什么第三级的缓存的要定义成 <code>Map&lt;String, ObjectFactory&lt;?&gt;&gt;</code>，不能直接缓存对象吗？这里不能直接保存对象实例，因为这样就无法对其做增强处理了。详情可见类 <code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</code> 方法部分源码如下：</p><p><img src="https://i.loli.net/2021/07/17/ribwoNKSgs7L3Jn.png" alt="6.png"></p><hr><h5 id="第-②-种场景——多例-Bean-的-setter-注入"><a href="#第-②-种场景——多例-Bean-的-setter-注入" class="headerlink" title="第 ② 种场景——多例 Bean 的 setter 注入"></a>第 ② 种场景——多例 Bean 的 setter 注入</h5><p>这种方式平常使用得相对较少，还是使用前文的两个 <code>Service</code> 作为示例，唯一不同的地方是现在都声明为<code>多例</code>了，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TradeService tradeService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateTrade</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你在 <code>Spring</code> 中运行以上代码，是可以正常启动成功的，原因是在类 <code>org.springframework.beans.factory.support.DefaultListableBeanFactory</code> 的 <code>preInstantiateSingletons()</code> 方法预实例化处理时，过滤掉了多例类型的 <code>Bean</code>，方法部分代码如下：</p><p><img src="https://i.loli.net/2021/07/17/jO3nk4vrZ9yhXSi.png" alt="7.png"></p><p>但是如果此时有其它单例类型的 <code>Bean</code> 依赖到这些多例类型的 <code>Bean</code> 的时候，就会报如下所示的循环依赖错误了。</p><p><img src="https://i.loli.net/2021/07/17/MDVst5Er2UXCRzm.png" alt="8.png"></p><hr><h5 id="第-③-种场景——代理对象的-setter-注入"><a href="#第-③-种场景——代理对象的-setter-注入" class="headerlink" title="第 ③ 种场景——代理对象的 setter 注入"></a>第 ③ 种场景——代理对象的 setter 注入</h5><p>这种场景也会经常碰到，有时候为了实现异步调用会在 <code>XXXXService</code> 类的方法上添加 <code>@Async</code> 注解，让方法对外部变成异步调用（前提要是要在启用类上添加启用注解哦 <code>@EnableAsync</code>），示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlogMghioCodeApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(BlogMghioCodeApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TradeService tradeService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Async</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateTrade</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在标有 <code>@Async</code> 注解的场景下，在添加启用异步注解（<code>@EnableAsync</code>）后，代理对象会通过 <code>AOP</code> 自动生成。以上代码运行会抛出 <code>BeanCurrentlyInCreationException</code> 异常。运行的大致流程如下图所示：</p><p><img src="https://i.loli.net/2021/07/17/UMEi1GCOo3FDmKB.png" alt="9.png"></p><p>源码在 <code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</code> 类的方法 <code>doCreateBean</code> 中，会判断第二级缓存 <code>earlySingletonObjects</code> 中的对象是否等于原始对象，方法判断部分的源码如下：</p><p><img src="https://i.loli.net/2021/07/17/685tnVsEjD7aqWh.png" alt="10.png"></p><p>二级缓存存放的对象是 <code>AOP</code> 生成出来的代理对象，和原始对象不相等，所以抛出了循环依赖错误。如果细看源码的话，会发现如果二级缓存是空的话会直接返回（因为比较的对象都没有，根本无法校验了），就不会报循环依赖的错误了，默认情况下，<code>Spring</code> 是按照文件全路径递归搜索，按<code>路径</code> + <code>文件名</code> 排序，排序靠前先加载，所以我们只要调整这两个类名称，让方法标有 <code>@Async</code> 注解的类排序在后面即可。</p><hr><h5 id="第-④-种场景——构造器注入"><a href="#第-④-种场景——构造器注入" class="headerlink" title="第 ④ 种场景——构造器注入"></a>第 ④ 种场景——构造器注入</h5><p>构造器注入的场景很少，到目前为止我所接触过的公司项目和开源项目中还没遇到使用构造器注入的，虽然用得不多，但是需要知道 <code>Spring</code> 为什么不支持这种场景的循环依赖，构造器注入的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TradeService tradeService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(TradeService tradeService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tradeService = tradeService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TradeService</span><span class="params">(OrderService orderService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateTrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器注入无法加入到第三级缓存当中，<code>Spring</code> 框架中的三级缓存在此场景下无用武之地，所以只能抛出异常，整体流程如下（虚线表示无法执行，为了直观也把下一步画出来了）:</p><p><img src="https://i.loli.net/2021/07/17/k3f7VgNIyQjnUwG.png" alt="11.png"></p><hr><h5 id="第-⑤-种场景——DependsOn-循环依赖"><a href="#第-⑤-种场景——DependsOn-循环依赖" class="headerlink" title="第 ⑤ 种场景——DependsOn 循环依赖"></a>第 ⑤ 种场景——DependsOn 循环依赖</h5><p>这种 <code>DependsOn</code> 循环依赖场景很少，一般情况下不怎么使用，了解一下会导致循环依赖的问题即可，<code>@DependsOn</code> 注解主要是用来指定实例化顺序的，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@DependsOn</span>(<span class="string">"tradeService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TradeService tradeService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@DependsOn</span>(<span class="string">"orderService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateTrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上文，我们知道，如果这里的类没有标注 <code>@DependsOn</code> 注解的话是可以正常运行的，因为 <code>Spring</code> 支持单例 <code>setter</code> 注入，但是加了示例代码的 <code>@DependsOn</code> 注解后会报循环依赖错误，原因是在类 <code>org.springframework.beans.factory.support.AbstractBeanFactory</code> 的方法 <code>doGetBean()</code> 中检查了 <code>dependsOn</code> 的实例是否有循环依赖，如果有循环依赖则抛出循环依赖异常，方法判断部分代码如下：</p><p><img src="https://i.loli.net/2021/07/17/DdnyNJAe15rpkjZ.png" alt="12.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍了什么是循环依赖以及 <code>Spring</code> 对各种循环依赖场景的处理，文中只列出了部分涉及到的源码，都标了所在源码中的位置，感兴趣的朋友可以去看看完整源码，最后 <code>Spring</code> 对各种循环依赖场景的支持情况如下图所示（P.S. <code>Spring</code> 版本：5.1.9.RELEASE）：<br><img src="https://i.loli.net/2021/07/17/KTIwXJSUYdNMOuW.png" alt="13.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/17/lw3qMrmSkIRfOGp.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是循环依赖&quot;&gt;&lt;a href=&quot;#什么是循环依赖&quot; class=&quot;headerlink&quot; title=&quot;什么是循环依赖&quot;&gt;&lt;/a&gt;什么是循环依赖&lt;/h4&gt;&lt;p&gt;什么是&lt;code&gt;循环依赖&lt;/code&gt;呢？可以把它拆分成&lt;code&gt;循环&lt;/code&gt;和&lt;code&gt;依赖&lt;/code&gt;两个部分来看，&lt;strong&gt;循环&lt;/strong&gt;是指计算机领域中的循环，执行流程形成闭合回路；&lt;strong&gt;依赖&lt;/strong&gt;就是完成这个动作的前提准备条件，和我们平常说的依赖大体上含义一致。放到 &lt;code&gt;Spring&lt;/code&gt; 中来看就一个或多个 &lt;code&gt;Bean&lt;/code&gt; 实例之间存在直接或间接的依赖关系，构成循环调用，循环依赖可以分为&lt;code&gt;直接循环依赖&lt;/code&gt;和&lt;code&gt;间接循环依赖&lt;/code&gt;，直接循环依赖的简单依赖场景：&lt;code&gt;Bean A&lt;/code&gt; 依赖于 &lt;code&gt;Bean B&lt;/code&gt;，然后 &lt;code&gt;Bean B&lt;/code&gt; 又反过来依赖于 &lt;code&gt;Bean A&lt;/code&gt;（&lt;code&gt;Bean A -&amp;gt; Bean B -&amp;gt; Bean A&lt;/code&gt;），间接循环依赖的一个依赖场景：&lt;code&gt;Bean A&lt;/code&gt; 依赖于 &lt;code&gt;Bean B&lt;/code&gt;，&lt;code&gt;Bean B&lt;/code&gt; 依赖于 &lt;code&gt;Bean C&lt;/code&gt;，&lt;code&gt;Bean C&lt;/code&gt; 依赖于 &lt;code&gt;Bean A&lt;/code&gt;，中间多了一层，但是最终还是形成循环（&lt;code&gt;Bean A -&amp;gt; Bean B -&amp;gt; Bean C -&amp;gt; Bean A&lt;/code&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
      <category term="循环依赖" scheme="https://www.mghio.cn/categories/Java/Spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
      <category term="循环依赖" scheme="https://www.mghio.cn/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring 整合 Feign 的原理</title>
    <link href="https://www.mghio.cn/post/1d4949a7.html"/>
    <id>https://www.mghio.cn/post/1d4949a7.html</id>
    <published>2021-11-05T08:13:23.000Z</published>
    <updated>2022-11-05T08:15:04.495Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/04/Rh1fuymO8Dbewc2.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://www.mghio.cn/post/7d1b964a.html">上篇</a> 介绍了 Feign 的核心实现原理，在文末也提到了会再介绍其和 Spring Cloud 的整合原理，Spring 具有很强的扩展性，会把一些常用的解决方案通过 starter 的方式开放给开发者使用，在引入官方提供的 starter 后通常只需要添加一些注解即可使用相关功能（通常是 @EnableXXX）。下面就一起来看看 Spring Cloud 到底是如何整合 Feign 的。</p><a id="more"></a><h2 id="整合原理浅析"><a href="#整合原理浅析" class="headerlink" title="整合原理浅析"></a>整合原理浅析</h2><p>在 Spring 中一切都是围绕 Bean 来展开的工作，而所有的 Bean 都是基于 BeanDefinition 来生成的，可以说 BeanDefinition 是整个 Spring 帝国的基石，这个整合的关键也就是要如何生成 Feign 对应的 BeanDefinition。</p><p>要分析其整合原理，我们首先要从哪里入手呢？如果你看过 <a href="https://www.mghio.cn/post/6e436292.html">上篇</a> 的话，在介绍结合 Spring Cloud 使用方式的例子时，第二步就是要在项目的 XXXApplication 上加添加 @EnableFeignClients 注解，我们可以从这里作为切入点，一步步深入分析其实现原理（通常相当一部分的 starter 一般都是在启动类中添加了开启相关功能的注解）。</p><p><img src="https://i.loli.net/2021/07/04/pEegIXqVMovGbCd.png" alt="feign-1.png"></p><p>进入 @EnableFeignClients 注解中，其源码如下：</p><p><img src="https://i.loli.net/2021/07/04/OswIXcqPyjlBVME.png" alt="feign-2.png"></p><p>从注解的源码可以发现，该注解除了定义几个参数（basePackages、defaultConfiguration、clients 等）外，还通过 @Import 引入了 FeignClientsRegistrar 类，一般 @Import 注解有如下功能（具体功能可见 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html" target="_blank" rel="noopener">官方 Java Doc</a>）：</p><ul><li>声明一个 Bean</li><li>导入 @Configuration 注解的配置类</li><li>导入 ImportSelector 的实现类</li><li>导入 ImportBeanDefinitionRegistrar 的实现类（<strong>这里使用这个功能</strong>）</li></ul><p>到这里不难看出，整合实现的主要流程就在 FeignClientsRegistrar 类中了，让我们继续深入到类 FeignClientsRegistrar 的源码，</p><p><img src="https://i.loli.net/2021/07/04/1bJ5PI2U3ANuDvq.png" alt="feign-3.png"></p><p>通过源码可知 FeignClientsRegistrar 实现 ImportBeanDefinitionRegistrar 接口，该接口从名字也不难看出其主要功能就是将所需要初始化的 BeanDefinition 注入到容器中，接口定义两个方法功能都是用来注入给定的 BeanDefinition 的，一个可自定义 beanName（通过实现 BeanNameGenerator 接口自定义生成 beanName 的逻辑），另一个使用默认的规则生成 beanName（类名首字母小写格式）。接口源码如下所示：</p><p><img src="https://i.loli.net/2021/07/04/aY3C9T67qnAbLx5.png" alt="feign-4.png"></p><p>对 Spring 有一些了解的朋友们都知道，Spring 会在容器启动的过程中根据 BeanDefinition 的属性信息完成对类的初始化，并注入到容器中。所以这里 FeignClientsRegistrar 的终极目标就是<strong>将生成的代理类注入到 Spring 容器中。</strong><br>虽然 FeignClientsRegistrar 这个类的源码看起来比较多，但是从其终结目标来看，我们主要是看如何生成 BeanDefinition 的，通过源码可以发现其实现了 ImportBeanDefinitionRegistrar 接口，并且重写了 registerBeanDefinitions(AnnotationMetadata, BeanDefinitionRegistry) 方法，在这个方法里完成了一些 BeanDefinition 的生成和注册工作。源码如下：</p><p><img src="https://i.loli.net/2021/07/04/o9dhOBS4PQEs83C.png" alt="feign-5.png"></p><p>整个过程主要分为如下两个步骤：</p><ol><li>给 @EnableFeignClients 的全局默认配置（注解的 defaultConfiguration 属性）创建 BeanDefinition 对象并注入到容器中（对应上图中的第 ① 步）</li><li>给标有了 @FeignClient 的类创建 BeanDefinition 对象并注入到容器中（对应上图中的第 ② 步）</li></ol><p>下面分别深入方法源码实现来看其具体实现原理，首先来看看第一步的方法 registerDefaultConfiguration(AnnotationMetadata, BeanDefinitionRegistry)，源码如下：</p><p><img src="https://i.loli.net/2021/07/04/eoHI9PgkFOzR1Wq.png" alt="feign-6.png"></p><p>可以看到这里只是获取一下注解 @EnableFeignClients 的默认配置属性 defaultConfiguration 的值，最终的功能实现交给了 registerClientConfiguration(BeanDefinitionRegistry, Object, Object) 方法来完成，继续跟进深入该方法，其源码如下：</p><p><img src="https://i.loli.net/2021/07/04/YDkedFGaugh5OyP.png" alt="feign-7.png"></p><p>可以看到，全局默认配置的 BeanClazz 都是 FeignClientSpecification，然后这里将全局默认配置 configuration 设置为 BeanDefinition 构造器的输入参数，然后当调用构造器实例化时将这个参数传进去。到这里就已经把 @EnableFeignClients 的全局默认配置（注解的 defaultConfiguration 属性）创建出 BeanDefinition 对象并注入到容器中了，第一步到此完成，整体还是比较简单的。</p><p>下面再来看看第二步 <strong>给标有了 @FeignClient 的类创建 BeanDefinition 对象并注入到容器中</strong> 是如何实现的。深入第二步的方法 registerFeignClients(AnnotationMetadata, BeanDefinitionRegistry) 实现中，由于方法实现代码较多，使用截图会比较分散，所以用贴出源代码并在相关位置添加必要注释的方式进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终获取到有 @FeignClient 注解类的集合</span></span><br><span class="line">    LinkedHashSet&lt;BeanDefinition&gt; candidateComponents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取 @EnableFeignClients 注解的属性 map</span></span><br><span class="line">    Map&lt;String, Object&gt; attrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">    <span class="comment">// 获取 @EnableFeignClients 注解的 clients 属性</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span> : (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line">    <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// 如果 @EnableFeignClients 注解未指定 clients 属性则扫描添加（扫描过滤条件为：标注有 @FeignClient 的类）</span></span><br><span class="line">        ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">        scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(FeignClient.class));</span><br><span class="line">        Set&lt;String&gt; basePackages = getBasePackages(metadata);</span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            candidateComponents.addAll(scanner.findCandidateComponents(basePackage));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 @EnableFeignClients 注解已指定 clients 属性，则直接添加，不再扫描（从这里可以看出，为了加快容器启动速度，建议都指定 clients 属性）</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">            candidateComponents.add(<span class="keyword">new</span> AnnotatedGenericBeanDefinition(clazz));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历最终获取到的 @FeignClient 注解类的集合</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">            <span class="comment">// 验证带注释的类必须是接口，不是接口则直接抛出异常（大家可以想一想为什么只能是接口？）</span></span><br><span class="line">            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(), <span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line">            <span class="comment">// 获取 @FeignClient 注解的属性值</span></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                    .getAnnotationAttributes(FeignClient.class.getCanonicalName());</span><br><span class="line">            <span class="comment">// 获取 clientName 的值，也就是在构造器的参数值（具体获取逻辑可以参见 getClientName(Map&lt;String, Object&gt;) 方法      </span></span><br><span class="line">            String name = getClientName(attributes);</span><br><span class="line">            <span class="comment">// 同上文第一步最后调用的方法，注入 @FeignClient 注解的配置对象到容器中</span></span><br><span class="line">            registerClientConfiguration(registry, name, attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line">            <span class="comment">// 注入 @FeignClient 对象，该对象可以在其它类中通过 @Autowired 直接引入（e.g. XXXService）</span></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看到最后是通过方法 registerFeignClient(BeanDefinitionRegistry, AnnotationMetadata, Map&lt;String, Object&gt;) 注入的 @FeignClient 对象，继续深入该方法，源码如下：</p><p><img src="https://i.loli.net/2021/07/04/93NYJuOwdRBiTXF.png" alt="feign-8.png"></p><p>方法实现比较长，最终目标是构造出 BeanDefinition 对象，然后通过 BeanDefinitionReaderUtils.registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry) 注入到容器中。</p><p>其中关键的一步是从 @FeignClient 注解中获取信息并设置到 BeanDefinitionBuilder 中，BeanDefinitionBuilder 中注册的类是 FeignClientFactoryBean，这个类的功能正如它的名字一样是用来创建出 FeignClient 的 Bean 的，然后 Spring 会根据 FeignClientFactoryBean 生成对象并注入到容器中。</p><p>需要明确的一点是，实际上这里最终注入到容器当中的是 FeignClientFactoryBean 这个类，Spring 会在类初始化的时候会根据这个类来生成实例对象，就是调用 FeignClientFactoryBean.getObject() 方法，这个生成的对象就是我们实际使用的代理对象。下面再进入到类 FeignClientFactoryBean 的 getObject() 这个⽅法，源码如下：</p><p><img src="https://i.loli.net/2021/07/04/evjCWpEgx2s4YA5.png" alt="feign-9.png"></p><p>可以看到这个方法是直接调用的类中的另一个方法 getTarget() 的，在继续跟进该方法，由于该方法实现代码较多，使用截图会比较分散，所以用贴出源代码并在相关位置添加必要注释的方式进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> &lt;T&gt; the target type of the Feign client</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Feign&#125; client created with the specified data and the context</span></span><br><span class="line"><span class="comment">  * information</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 Spring 容器中获取 FeignContext Bean</span></span><br><span class="line">    FeignContext context = beanFactory != <span class="keyword">null</span> ? beanFactory.getBean(FeignContext.class)</span><br><span class="line">            : applicationContext.getBean(FeignContext.class);</span><br><span class="line">    <span class="comment">// 根据获取到的 FeignContext 构建出 Feign.Builder         </span></span><br><span class="line">    Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解 @FeignClient 未指定 url 属性 </span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(url)) &#123;</span><br><span class="line">        <span class="comment">// url 属性是固定访问某一个实例地址，如果未指定协议则拼接 http 请求协议</span></span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">            url = <span class="string">"http://"</span> + name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            url = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 格式化 url</span></span><br><span class="line">        url += cleanPath();</span><br><span class="line">        <span class="comment">// 生成代理和我们之前的代理一样，注解 @FeignClient 未指定 url 属性则返回一个带有负载均衡功能的客户端对象</span></span><br><span class="line">        <span class="keyword">return</span> (T) loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(type, name, url));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注解 @FeignClient 已指定 url 属性 </span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(url) &amp;&amp; !url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">        url = <span class="string">"http://"</span> + url;</span><br><span class="line">    &#125;</span><br><span class="line">    String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">    <span class="comment">// 获取一个 client</span></span><br><span class="line">    Client client = getOptional(context, Client.class);</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> FeignBlockingLoadBalancerClient) &#123;</span><br><span class="line">            <span class="comment">// not load balancing because we have a url,</span></span><br><span class="line">            <span class="comment">// but Spring Cloud LoadBalancer is on the classpath, so unwrap</span></span><br><span class="line">            <span class="comment">// 这里没有负载是因为我们有指定了 url </span></span><br><span class="line">            client = ((FeignBlockingLoadBalancerClient) client).getDelegate();</span><br><span class="line">        &#125;</span><br><span class="line">        builder.client(client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成代理和我们之前的代理一样，最后被注入到 Spring 容器中</span></span><br><span class="line">    Targeter targeter = get(context, Targeter.class);</span><br><span class="line">    <span class="keyword">return</span> (T) targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(type, name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码得知 FeignClientFactoryBean 继承了 FactoryBean，其方法 FactoryBean.getObject 返回的就是 Feign 的代理对象，最后这个代理对象被注入到 Spring 容器中，我们就通过 @Autowired 可以直接注入使用了。同时还可以发现上面的代码分支最终都会走到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Targeter targeter = get(context, Targeter.class);</span><br><span class="line"><span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br></pre></td></tr></table></figure><p>点进去深入 targeter.target 的源码，可以看到实际上这里创建的就是一个代理对象，也就是说在容器启动的时候，会为每个 @FeignClient 创建了一个代理对象。至此，Spring Cloud 和 Feign 整合原理的核心实现介绍完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 Spring Cloud 整合 Feign 的原理。通过上文介绍，你已经知道 Srpring 会我们的标注的 @FeignClient 的接口创建了一个代理对象，那么有了这个代理对象我们就可以做<strong>增强</strong>处理（e.g. 前置增强、后置增强），那么你知道是如何实现的吗？感兴趣的朋友可以再翻翻源码寻找答案（温馨提示：增强逻辑在 InvocationHandler 中）。还有 Feign 与 Ribbon 和 Hystrix 等组件的协作，感兴趣的朋友可以自行下载源码学习了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/04/Rh1fuymO8Dbewc2.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.mghio.cn/post/7d1b964a.html&quot;&gt;上篇&lt;/a&gt; 介绍了 Feign 的核心实现原理，在文末也提到了会再介绍其和 Spring Cloud 的整合原理，Spring 具有很强的扩展性，会把一些常用的解决方案通过 starter 的方式开放给开发者使用，在引入官方提供的 starter 后通常只需要添加一些注解即可使用相关功能（通常是 @EnableXXX）。下面就一起来看看 Spring Cloud 到底是如何整合 Feign 的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实现原理" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="Feign" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Feign/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Feign/Spring/"/>
    
    
      <category term="实现原理" scheme="https://www.mghio.cn/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="Feign" scheme="https://www.mghio.cn/tags/Feign/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Feign 实现原理</title>
    <link href="https://www.mghio.cn/post/7d1b964a.html"/>
    <id>https://www.mghio.cn/post/7d1b964a.html</id>
    <published>2021-10-06T08:10:30.000Z</published>
    <updated>2022-11-05T08:15:48.287Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/27/cfwIm4da7jBX6tL.jpg" alt="cover.jpg"></p><h2 id="What-is-Feign"><a href="#What-is-Feign" class="headerlink" title="What is Feign?"></a>What is Feign?</h2><p>Feign 是⼀个 HTTP 请求的轻量级客户端框架。通过 接口 + 注解的方式发起 HTTP 请求调用，面向接口编程，而不是像 Java 中通过封装 HTTP 请求报文的方式直接调用。服务消费方拿到服务提供方的接⼝，然后像调⽤本地接⼝⽅法⼀样去调⽤，实际发出的是远程的请求。让我们更加便捷和优雅的去调⽤基于 HTTP 的 API，被⼴泛应⽤在 Spring Cloud 的解决⽅案中。开源项目地址：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">Feign</a>，官方描述如下：</p><blockquote><p>Feign is a Java to HTTP client binder inspired by Retrofit, JAXRS-2.0, and WebSocket. Feign’s first goal was reducing the complexity of binding Denominator uniformly to HTTP APIs regardless of ReSTfulness.</p></blockquote><a id="more"></a><h2 id="Why-Feign"><a href="#Why-Feign" class="headerlink" title="Why Feign?"></a>Why Feign?</h2><p>Feign 的首要目标就是减少 HTTP 调用的复杂性。在微服务调用的场景中，我们调用很多时候都是基于 HTTP 协议的服务，如果服务调用只使用提供 HTTP 调用服务的 HTTP Client 框架（e.g. Apache HttpComponnets、HttpURLConnection OkHttp 等），我们需要关注哪些问题呢？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44ddd61c8f2248479dd3b9edaaf6b907~tplv-k3u1fbpfcp-watermark.image" alt="feign-1.png"></p><p>相比这些 HTTP 请求框架，Feign 封装了 HTTP 请求调用的流程，而且会强制使用者去养成面向接口编程的习惯（因为 Feign 本身就是要面向接口）。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h4 id="原生使用方式"><a href="#原生使用方式" class="headerlink" title="原生使用方式"></a>原生使用方式</h4><p>以获取 Feign 的 GitHub 开源项目的 Contributors 为例，原生方式使用 Feign 步骤有如下三步（这里以使用 Gradle 进行依赖管理的项目为例）：<br><strong>第一步：</strong> 引入相关依赖：implementation ‘io.github.openfeign:feign-core:11.0’<br>在项目的 build.gradle 文件的依赖声明处 dependencies 添加该依赖声明即可。</p><p><strong>第二步：</strong> 声明 HTTP 请求接口<br>使用 Java 的接口和 Feign 的原生注解 @RequestLine 声明 HTTP 请求接口，从这里就可以看到 Feign 给使用者封装了 HTTP 的调用细节，极大的减少了 HTTP 调用的复杂性，只要定义接口即可。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/645054130d41409c95aa320791932bd3~tplv-k3u1fbpfcp-zoom-1.image" alt="declare-interface.png"></p><p><strong>第三步：</strong> 配置初始化 Feign 客户端<br>最后一步配置初始化客户端，这一步主要是设置请求地址、编码（Encoder）、解码（Decoder）等。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a1bc5cd80174914877a25bc5cf3e147~tplv-k3u1fbpfcp-zoom-1.image" alt="config-feign-client.png"></p><p>通过定义接口，使用注解的方式描述接口的信息，就可以发起接口调用。最后请求结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21fa8de05c6479788cb59dae78567df~tplv-k3u1fbpfcp-zoom-1.image" alt="native-use-feign-result.png"></p><h4 id="结合-Spring-Cloud-使用方式"><a href="#结合-Spring-Cloud-使用方式" class="headerlink" title="结合 Spring Cloud 使用方式"></a>结合 Spring Cloud 使用方式</h4><p>同样还是以获取 Feign 的 GitHub 开源项目的 Contributors 为例，结合 Spring Cloud 的使用方式有如下三步：<br><strong>第一步：</strong> 引入相关 starter 依赖：org.springframework.cloud:spring-cloud-starter-openfeign<br>在项目的 build.gradle 文件的依赖声明处 dependencies 添加该依赖声明即可。</p><p><strong>第二步：</strong> 在项目的启动类 XXXApplication 上添加 @EnableFeignClients 注解启用 Feign 客户端功能。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adcceea29c1b4d8382d7a7551d1996f7~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-6.png"></p><p><strong>第三步：</strong> 创建 HTTP 调用接口，并添加声明 @FeignClient 注解。<br>最后一步配置初始化客户端，这一步主要是设置请求地址（url）、编码（Encoder）、解码（Decoder）等，与原生使用方式不同的是，现在我们是通过 @FeignClient 注解配置的 Feign 客户端属性，同时请求的 URL 也是使用的 Spring MVC 提供的注解。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6cecd86c4ba4aa68853e24506517fc7~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-7.png"></p><p>测试类如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b30cdcb90019472daf396449f410d351~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-8.png"></p><p>运行结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc966ac99d63455d9f77104e0598265e~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-9.png"></p><p>可以看到这里是通过 @Autowired 注入刚刚定义的接口的，然后就可以直接使用其来发起 HTTP 请求了，使用是不是很方便、简洁。</p><h2 id="Dive-into-Feign"><a href="#Dive-into-Feign" class="headerlink" title="Dive into Feign"></a>Dive into Feign</h2><p>从上面第一个原生使用的例子可以看到，只是定了接口并没有具体的实现类，但是却可以在测试类中直接调用接口的方法来完成接口的调用，我们知道在 Java 里面接口是无法直接进行使用的，因此可以大胆猜测是 Feign 在背后默默生成了接口的代理实现类，也可以验证一下，只需在刚刚的测试类 debug 一下看看接口实际使用的是什么实现类：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c430676371448deb19c0a7dd6c5cd7b~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-11.png"></p><p>从 debug 结果可知，框架生成了接口的代理实现类 HardCodedTarget 的对象 $Proxy14 来完成接口请求调用，和刚刚的猜测一致。Feign 主要是封装了 HTTP 请求调用，其整体架构如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17e2cdc545a84f8b90fab286e1cdbeb3~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-10.png"></p><p>测试类代码里面只在 GitHub github = Feign.builder().target(GitHub.class, “<a href="https://api.github.com&quot;" target="_blank" rel="noopener">https://api.github.com&quot;</a>); 用到了 Feign 框架的功能，所以我们选择从这里来深入源码，点击进入发现是 Feign 抽象类提供的方法，同样我们知道抽象类也是无法进行初始化的，所以肯定是有子类的，如果你刚刚有仔细观察上面的 debug 代码的话，可以发现有一个 ReflectiveFeign 类，这个类就是抽象类 Feign 的子类了。抽象类 feign.Feign 的部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Feign</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  ...  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;RequestInterceptor&gt; requestInterceptors = <span class="keyword">new</span> ArrayList&lt;RequestInterceptor&gt;();</span><br><span class="line">    <span class="keyword">private</span> Logger.Level logLevel = Logger.Level.NONE;</span><br><span class="line">    <span class="keyword">private</span> Contract contract = <span class="keyword">new</span> Contract.Default();</span><br><span class="line">    <span class="keyword">private</span> Client client = <span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">private</span> Retryer retryer = <span class="keyword">new</span> Retryer.Default();</span><br><span class="line">    <span class="keyword">private</span> Logger logger = <span class="keyword">new</span> NoOpLogger();</span><br><span class="line">    <span class="keyword">private</span> Encoder encoder = <span class="keyword">new</span> Encoder.Default();</span><br><span class="line">    <span class="keyword">private</span> Decoder decoder = <span class="keyword">new</span> Decoder.Default();</span><br><span class="line">    <span class="keyword">private</span> QueryMapEncoder queryMapEncoder = <span class="keyword">new</span> FieldQueryMapEncoder();</span><br><span class="line">    <span class="keyword">private</span> ErrorDecoder errorDecoder = <span class="keyword">new</span> ErrorDecoder.Default();</span><br><span class="line">    <span class="keyword">private</span> Options options = <span class="keyword">new</span> Options();</span><br><span class="line">    <span class="keyword">private</span> InvocationHandlerFactory invocationHandlerFactory =</span><br><span class="line">        <span class="keyword">new</span> InvocationHandlerFactory.Default();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> decode404;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> closeAfterDecode = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> ExceptionPropagationPolicy propagationPolicy = NONE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> forceDecoding = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Capability&gt; capabilities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输入打印日志级别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">logLevel</span><span class="params">(Logger.Level logLevel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.logLevel = logLevel;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置接口方法注解处理器（契约） </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">contract</span><span class="params">(Contract contract)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.contract = contract;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置使用的 Client（默认使用 JDK 的 HttpURLConnection）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">client</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.client = client;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置重试器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">retryer</span><span class="params">(Retryer retryer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.retryer = retryer;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求编码器 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">encoder</span><span class="params">(Encoder encoder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.encoder = encoder;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">decoder</span><span class="params">(Decoder decoder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.decoder = decoder;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 404 返回结果解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">decode404</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.decode404 = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置错误解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">errorDecoder</span><span class="params">(ErrorDecoder errorDecoder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.errorDecoder = errorDecoder;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">requestInterceptors</span><span class="params">(Iterable&lt;RequestInterceptor&gt; requestInterceptors)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.requestInterceptors.clear();</span><br><span class="line">      <span class="keyword">for</span> (RequestInterceptor requestInterceptor : requestInterceptors) &#123;</span><br><span class="line">        <span class="keyword">this</span>.requestInterceptors.add(requestInterceptor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Class&lt;T&gt; apiType, String url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> target(<span class="keyword">new</span> HardCodedTarget&lt;T&gt;(apiType, url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在方法 public <t> T target(Class<t> apiType, String url) 中直接创建了 HardCodedTarget 对象出来，这个对象也是上面 debug 看到的对象。再继续深入，就来到了 feign.Feign 的 newInstance(Target<t> target) 的方法了，是个抽象方法，其实现在子类 ReflectiveFeign 中，这个方法就是接口代理实现生成的地方，下面通过源码来看看实现逻辑是怎样的：</t></t></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveFeign</span> <span class="keyword">extends</span> <span class="title">Feign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ParseHandlersByName targetToHandlersByName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InvocationHandlerFactory factory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> QueryMapEncoder queryMapEncoder;</span><br><span class="line"></span><br><span class="line">  ReflectiveFeign(ParseHandlersByName targetToHandlersByName, InvocationHandlerFactory factory,</span><br><span class="line">      QueryMapEncoder queryMapEncoder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.targetToHandlersByName = targetToHandlersByName;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.queryMapEncoder = queryMapEncoder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;类名#方法签名, MethodHandler&gt;，key 是通过 feign.Feign.configKey(Class targetType, Method method) 生成的</span></span><br><span class="line">    Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">    <span class="comment">// 将 Map&lt;String, MethodHandler&gt; 转换为  Map&lt;Method, MethodHandler&gt; 方便调用</span></span><br><span class="line">    Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">    <span class="comment">// 默认方法处理器</span></span><br><span class="line">    List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">      <span class="comment">// 跳过 Object 类定于的方法  </span></span><br><span class="line">      <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isDefault(method)) &#123;</span><br><span class="line">        <span class="comment">// 默认方法（接口声明的默认方法）使用默认的方法处理器  </span></span><br><span class="line">        DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">        defaultMethodHandlers.add(handler);</span><br><span class="line">        methodToHandler.put(method, handler);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 接口正常声明的方法（e.g. GitHub.listContributors(String, String)）  </span></span><br><span class="line">        methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 Feign 封装的 InvocationHandler</span></span><br><span class="line">    InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">    <span class="comment">// 基于 JDK 动态代理生成接口的代理类（e.g. Github 接口）</span></span><br><span class="line">    T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">      defaultMethodHandler.bindTo(proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体流程就是在方法 <t> T newInstance(Target<t> target) 生成一个含有 FeignInvocationHandler 的代理对象，FeignInvocationHandler 对象会持有 Map&lt;Method, MethodHandler&gt; map，代理对象调用的时候进入 FeignInvocationHandler#invoke 方法，根据调用的方法来获取对应 MethodHandler，然后再 MethodHandler 完成对方法的处理（处理 HTTP 请求等）。</t></t></p><p>下面再深入 MethodHandler，看看是如何完成对方法 HTTP 请求处理的，MethodHandler 是一个接口定义在 feign.InvocationHandlerFactory 接口中（P.S. 基础知识点，接口是可以在内部定义内部接口的哦），有两个实现类分别为 DefaultMethodHandler 和 SynchronousMethodHandler，第一个 DefaultMethodHandler 用来处理接口的默认方法，第二个是用来处理正常的接口方法的，一般情况下都是由该类来处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousMethodHandler</span> <span class="keyword">implements</span> <span class="title">MethodHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 RequestTemplate 将请求参数封装成请求模板  </span></span><br><span class="line">    RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">    Options options = findOptions(argv);</span><br><span class="line">    <span class="comment">// 请求重试器</span></span><br><span class="line">    Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行请求并解码后返回  </span></span><br><span class="line">        <span class="keyword">return</span> executeAndDecode(template, options);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 发生重试异常则进行重试处理  </span></span><br><span class="line">          retryer.continueOrPropagate(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RetryableException th) &#123;</span><br><span class="line">          Throwable cause = th.getCause();</span><br><span class="line">          <span class="keyword">if</span> (propagationPolicy == UNWRAP &amp;&amp; cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> cause;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> th;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">          logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template, Options options)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 从请求模板 RequestTemplate 构造请求参数对象 Request  </span></span><br><span class="line">    Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 通过 client（Apache HttpComponnets、HttpURLConnection OkHttp 等）执行 HTTP 请求调用，默认是 HttpURLConnection </span></span><br><span class="line">      response = client.execute(request, options);</span><br><span class="line">      <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 12</span></span><br><span class="line">      response = response.toBuilder()</span><br><span class="line">          .request(request)</span><br><span class="line">          .requestTemplate(template)</span><br><span class="line">          .build();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decoder != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">// 对返回结果进行解码操作</span></span><br><span class="line">      <span class="keyword">return</span> decoder.decode(response, metadata.returnType());</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Object&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    asyncResponseHandler.handleResponse(resultFuture, metadata.configKey(), response,</span><br><span class="line">        metadata.returnType(),</span><br><span class="line">        elapsedTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!resultFuture.isDone())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Response handling not done"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> resultFuture.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CompletionException e) &#123;</span><br><span class="line">      Throwable cause = e.getCause();</span><br><span class="line">      <span class="keyword">if</span> (cause != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> cause;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Feign 的核心实现流程介绍完毕，从代码上看 feign.SynchronousMethodHandler 的操作相对比较简单，主要是通过 client 完成请求，对响应进行解码以及异常处理操作，整体流程如下：</p><p><img src="https://i.loli.net/2021/06/27/VMAbsPCRy3jD7ch.png" alt="feign-12.png"></p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Feign 通过给我们定义的目标接口（比如例子中的 GitHub）生成一个 HardCodedTarget 类型的代理对象，由 JDK 动态代理实现，生成代理的时候会根据注解来生成一个对应的 Map&lt;Method, MethodHandler&gt;，这个 Map 被 InvocationHandler 持有，接口方法调用的时候，进入 InvocationHandler 的 invoke 方法（为什么会进入这里？JDK 动态代理的基础知识）。</p><p>然后根据调用的方法从 Map&lt;Method, MethodHandler&gt; 获取对应的 MethodHandler，然后通过 MethodHandler 根据指定的 client 来完成对应处理， MethodHandler 中的实现类 DefaultMethodHandler 处理默认方法（接口的默认方法）的请求处理的，SynchronousMethodHandler 实现类是完成其它方法的 HTTP 请求的实现，这就是 Feign 的主要核心流程，源码已上传 <a href="https://github.com/mghio/feign-demo.git" target="_blank" rel="noopener">Github</a>。以上是 Feign 框架实现的核心流程介绍，Spring Cloud 是如何整合 Feign 的呢？请看下篇博文，敬请期待。s</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/27/cfwIm4da7jBX6tL.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;What-is-Feign&quot;&gt;&lt;a href=&quot;#What-is-Feign&quot; class=&quot;headerlink&quot; title=&quot;What is Feign?&quot;&gt;&lt;/a&gt;What is Feign?&lt;/h2&gt;&lt;p&gt;Feign 是⼀个 HTTP 请求的轻量级客户端框架。通过 接口 + 注解的方式发起 HTTP 请求调用，面向接口编程，而不是像 Java 中通过封装 HTTP 请求报文的方式直接调用。服务消费方拿到服务提供方的接⼝，然后像调⽤本地接⼝⽅法⼀样去调⽤，实际发出的是远程的请求。让我们更加便捷和优雅的去调⽤基于 HTTP 的 API，被⼴泛应⽤在 Spring Cloud 的解决⽅案中。开源项目地址：&lt;a href=&quot;https://github.com/OpenFeign/feign&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Feign&lt;/a&gt;，官方描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Feign is a Java to HTTP client binder inspired by Retrofit, JAXRS-2.0, and WebSocket. Feign’s first goal was reducing the complexity of binding Denominator uniformly to HTTP APIs regardless of ReSTfulness.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="实现原理" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="Feign" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Feign/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Feign/Spring/"/>
    
    
      <category term="实现原理" scheme="https://www.mghio.cn/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="Feign" scheme="https://www.mghio.cn/tags/Feign/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>信息爆炸时代，该如何获取优质信息？</title>
    <link href="https://www.mghio.cn/post/7f4af1a1.html"/>
    <id>https://www.mghio.cn/post/7f4af1a1.html</id>
    <published>2021-09-05T08:07:58.000Z</published>
    <updated>2022-11-05T08:09:15.874Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/20/jrvkdhabSB7wOCD.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们现在所处的信息爆炸时代，如何强调快速获取信息都不为过，信息多种多样，有些能找到源头，有些则不能，有些能找到规律，有些则不一定能找到，信息的源头和获取渠道很重要。然而事实上，能够真正有效获取到<strong>优质信息</strong>并加以消化利用的人并不多。</p><p>在信息的获取的过程中，应该要具备筛选信息的能力，什么是官方信息，你要核实，什么是虚假信息，你要甄别。看到网上有些陷入杀猪盘的，负载累累。仔细思考一下，其实甄别筛选信息的能力真的是最大的问题。</p><p>当然一个人将信息并内化利用是一个很复杂的过程，每个人都有自己独到的方法。今天来聊聊应该如何去获取「优质信息」以及如何去过滤无用信息。下面分享几个获取信息的原则：</p><a id="more"></a><h2 id="尽自己最大努力去获取“一手信息”"><a href="#尽自己最大努力去获取“一手信息”" class="headerlink" title="尽自己最大努力去获取“一手信息”"></a>尽自己最大努力去获取“一手信息”</h2><p>这个原则的关键是，这里的“一手信息”是如何定义呢? 对于那些权威机构或者国家机构，或者专家大咖，或者作者本人所发布的信息绝大部分情况下都可以看作为一手信息，第一手信息，不是被别人理解过、消化过的二手信息。</p><p>尤其对于知识性的东西来说，更应该是这样。应该是原汁原味的，不应该是被添油加醋的。对于一手信息的价值为什么大于二手信息甚至多手信息呢？很简单，这个效应在股票或者投资市场会被放大的很明显，能够在第一时间获取到第一手信息，是能否准确快速判断出市场行情走向的关键因素之一。</p><h2 id="收费的信息优于免费的信息"><a href="#收费的信息优于免费的信息" class="headerlink" title="收费的信息优于免费的信息"></a>收费的信息优于免费的信息</h2><p>对于这个原则，可能不是绝对，但至少在绝大部分情况下是正确的，对于现在很多“白嫖党”来说，可能确实要改一改自己的陋习了，要知道，其实免费反而最贵，因为它给你带来的负面作用或者时间成本，甚至可能会“毒害”你对于信息和知识的热情，当然也会有少部分人会把好的东西给开源或者免费掉。</p><h2 id="国外大部分情况优于国内"><a href="#国外大部分情况优于国内" class="headerlink" title="国外大部分情况优于国内"></a>国外大部分情况优于国内</h2><p>和上面的第二点一样，需要你带着审视和批判思维来看待了，国内整体的创作环境个人角色还是相关比较浮躁和恶劣的，尽管这些年有所改观，但当前的自媒体，包括一些所谓的大 V，也会有很多滥竽充数的文章，视频等内容，包括当前都说信息过载，其实准确来说，是垃圾信息过载，那些优质的内容与知识，毕竟少数。</p><p>有选择的相信专家，并关注他们的日常分享，但不要迷恋迷信专家，很多人会无脑喷当前所谓的砖家伪公知 ，但在大部分情况，专家是在某些领域沉淀研究了很多年，你可以看看别人的一些思路，观点，与框架性东西，在某些情况下，可能真会对自己有所启发。</p><h2 id="通过信息的冗余和比对"><a href="#通过信息的冗余和比对" class="headerlink" title="通过信息的冗余和比对"></a>通过信息的冗余和比对</h2><p>举一个简单的例子，如果今天巴菲特发表了一番言论，当然媒体会对此有记录和报道。但是，各种媒体可能记录有误差，而且可能还有意无意加入自己的看法，把不是巴菲特发表的言论加到他头上，这样就主观或客观地引入了错误信息。</p><p>此时如果你只从一个信息源了解信息，其实是很难判断所获得的是准确信息还是夹杂着一定的错误信息的。但是如果你能从多个信息源了解信息，虽然它们各自都有部分个人主观因素，但是由于各自角度的不同，很多噪音彼此可以抵消掉，获得的则是相对比较准确的信息。</p><p>要时刻警惕回音室响应，避免把自己关进一个封闭的信息圈子，这样慢慢的外部的信息就没法进来了，总之在获取信息的时候一定要尝试从不同维度，不同角度去摄取。</p><h2 id="将信息分解到不同的维度过滤"><a href="#将信息分解到不同的维度过滤" class="headerlink" title="将信息分解到不同的维度过滤"></a>将信息分解到不同的维度过滤</h2><p>在中国，人们常常都会很纠结一个问题，「就是老婆和妈妈掉到水里后先救谁？」，如果仔细思考一下，这个两难问题的重要原因在于，我们要考虑的因素太多，以至于大家越想越糊涂。其实只要你细想就会发现，这个问题的关键是分清楚什么是我们该考虑的信息，什么是不用考虑的信息。</p><p>比如，如果你觉得孝是第一位的，或者觉得以后谁和我生活更长时间是第一位的，作出选择就没有什么难的。这时，你其实是将这个有很多干扰信息的问题，分解到了某些你能够区分的维度，比如孝的维度，或者和一起生活的时间的维度。</p><h2 id="要主动去-pull-信息，不要总是等-push-信息"><a href="#要主动去-pull-信息，不要总是等-push-信息" class="headerlink" title="要主动去 pull 信息，不要总是等 push 信息"></a>要主动去 pull 信息，不要总是等 push 信息</h2><p>这是最后一点，也是最重要的一点，这里的 pull 和 push 可能说得有点偏技术化，解释一下就是 pull 是说要目的地在网络上主动查询一些信息，而不是等各种 APP 给你推送信息，虽然主动查询信息可能会让你感到比较难受，但这是获取优质信息的第一步。</p><p>我个人是目前做技术相关的工作，对这点比较有感触，一个人的学习能力强不强，其实就像生存能力一样，一个重要判断点就是看这个人是能自己找食吃，还是要等别人“喂着吃”。</p><p>别人投喂给你的信息未必都是错的，都是坏的，比如某些自媒体的信息，但如果要获取到更为准确的信息，我建议你还是要去主动搜索核对一下，而不是单凭别人的一面之词。也就是说，别人是不会为你的后果负责的，而你要为自己的后果负责。</p><hr><p>当然，以上是个人在选择信息源的一些原则和思考，希望可以对需要进行信息获取和筛选的朋友有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/20/jrvkdhabSB7wOCD.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们现在所处的信息爆炸时代，如何强调快速获取信息都不为过，信息多种多样，有些能找到源头，有些则不能，有些能找到规律，有些则不一定能找到，信息的源头和获取渠道很重要。然而事实上，能够真正有效获取到&lt;strong&gt;优质信息&lt;/strong&gt;并加以消化利用的人并不多。&lt;/p&gt;
&lt;p&gt;在信息的获取的过程中，应该要具备筛选信息的能力，什么是官方信息，你要核实，什么是虚假信息，你要甄别。看到网上有些陷入杀猪盘的，负载累累。仔细思考一下，其实甄别筛选信息的能力真的是最大的问题。&lt;/p&gt;
&lt;p&gt;当然一个人将信息并内化利用是一个很复杂的过程，每个人都有自己独到的方法。今天来聊聊应该如何去获取「优质信息」以及如何去过滤无用信息。下面分享几个获取信息的原则：&lt;/p&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://www.mghio.cn/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="信息获取" scheme="https://www.mghio.cn/categories/%E6%80%9D%E8%80%83/%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/"/>
    
    
      <category term="思考" scheme="https://www.mghio.cn/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="信息获取" scheme="https://www.mghio.cn/tags/%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>分享几个好用的 Google 搜索技巧</title>
    <link href="https://www.mghio.cn/post/4219480f.html"/>
    <id>https://www.mghio.cn/post/4219480f.html</id>
    <published>2021-08-15T08:03:47.000Z</published>
    <updated>2022-11-05T08:07:09.725Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/12/pzf8mEDUoWbxF6J.jpg" alt="cover.jpg"></p><p>搜索能力是被绝大多数人低估一项基本素质，绝大部分做编程技术相关的朋友应该都知道如何使用 <code>Google</code>，但是并不知道如何利用它的潜力。其实不管是 <code>Google</code> 还是 <code>百度</code>，会搜索的人一样都可以查找到需要的东西，不会搜索的人用什么都不好使。下面介绍一些 <code>Google</code> 常用的搜索技巧以及搜索快捷方式，可以帮助你更快，更准确地找到结果。<code>Google</code> 是世界上功能最强大的搜索引擎，它已经改变了我们查找信息的方式。</p><a id="more"></a><h2 id="0-使用准确的词组"><a href="#0-使用准确的词组" class="headerlink" title="0. 使用准确的词组"></a>0. 使用准确的词组</h2><p>将您要搜索的关键字用引号引起来，<code>Google</code> 会进行精确的词组搜索。</p><blockquote><p>语法：”[searchkey 1] [searchkey 2]” [searchkey 3]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be7884a6df0c4a7ea0737237b79af0f2~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-1.jpg"></p><h2 id="1-多个互斥的搜索条件使用-OR"><a href="#1-多个互斥的搜索条件使用-OR" class="headerlink" title="1. 多个互斥的搜索条件使用 OR"></a>1. 多个互斥的搜索条件使用 OR</h2><p>默认情况下，除非指定，否则 <code>Google</code> 会包含你搜索条件中的所有搜索关键字。通过在您的关键词之字输入<code>OR</code>，<code>Google</code> 会知道它可以查找一组或另一组。大写 <code>OR</code>，否则 <code>Google</code> 会认为它只是你的关键字的一部分。</p><blockquote><p>语法：[searchkey 1] <em>OR</em> [searchkey 2]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45309eefc510442aa754940a0b55b42a~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-2.jpg"></p><h2 id="2-排除指定关键词"><a href="#2-排除指定关键词" class="headerlink" title="2. 排除指定关键词"></a>2. 排除指定关键词</h2><p>通过在单词的前面添加减号，将单词从 <code>Google</code> 搜索中排除。</p><blockquote><p>语法：-[searchkey to exclude] [searchkey to include]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b5d349fcbc7430a898eac862f1f56a3~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-3.jpg"></p><h2 id="3-查找文本块中的所有单词"><a href="#3-查找文本块中的所有单词" class="headerlink" title="3. 查找文本块中的所有单词"></a>3. 查找文本块中的所有单词</h2><p>使用 <code>Google</code> 的 <code>allintext：</code> 语法仅搜索网站的正文，而忽略链接，<code>URL</code> 和标题。</p><blockquote><p> 语法：<em>allintext:</em>[searchkeys]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8858990204646c0bf1bbe53d308cb12~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-4.jpg"></p><h2 id="4-在文本-标题-URL-等查找单词"><a href="#4-在文本-标题-URL-等查找单词" class="headerlink" title="4. 在文本 + 标题 +  URL 等查找单词"></a>4. 在文本 + 标题 +  URL 等查找单词</h2><p>查找搜索词在不同位置的网页。即-在页面正文中，页面标题，<code>URL</code> 等中。为此，在您的关键字之前使用 <code>intext:</code>。</p><blockquote><p>语法：<em>intext:</em>[searchkeys]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892bc2b709ce4b83b3f2d6166374f1dd~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-5.jpg"></p><h2 id="5-标题搜索（单个关键字）"><a href="#5-标题搜索（单个关键字）" class="headerlink" title="5. 标题搜索（单个关键字）"></a>5. 标题搜索（单个关键字）</h2><p>在网页标题内搜索一个单词，然后在网页上的其他位置搜索另一个单词。为此，您需要将 <code>intitle：</code> 混合到您的搜索查询中。</p><blockquote><p>语法：[searchkeys 1] <em>intitle:</em>[searchkeys 2]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3abec6aa60844643be9e0d3b99afd01f~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-6.jpg"></p><h2 id="6-标题搜索（多个关键字）"><a href="#6-标题搜索（多个关键字）" class="headerlink" title="6. 标题搜索（多个关键字）"></a>6. 标题搜索（多个关键字）</h2><p>在网页标题中搜索查询中的所有关键字，在我们的搜索词之前使用 <code>allintitle：</code>。</p><blockquote><p>语法：<em>allintitle:</em>[searchkey1 searchkey2]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef452f1b907044c1b676788682c988a1~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-7.jpg"></p><h2 id="7-在-URL-中搜索"><a href="#7-在-URL-中搜索" class="headerlink" title="7. 在 URL 中搜索"></a>7. 在 URL 中搜索</h2><p>使用 <code>allinURL</code> 可以很容易地在 <code>URL</code> 中搜索关键字 。</p><blockquote><p>语法：<em>allinURL:</em>[searchkeys]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86005ebf9a694f448151c4d868774ff4~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-8.jpg"></p><h2 id="8-在指定网站内搜索"><a href="#8-在指定网站内搜索" class="headerlink" title="8. 在指定网站内搜索"></a>8. 在指定网站内搜索</h2><p>在网站内搜索单词-使用网站 <code>URL</code> 前面的 <code>site：</code> 语法，后跟您的搜索词。这会将搜索结果仅限制在该网站上。</p><blockquote><p>语法：<em>site:</em>[website URL] [searchkeys]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3392f9e2af43a8b6713b1ada33e59f~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-9.jpg"></p><h2 id="9-Google-搜索定义"><a href="#9-Google-搜索定义" class="headerlink" title="9. Google 搜索定义"></a>9. Google 搜索定义</h2><p>通过在单词之前使用 <code>define：</code> 轻松地找到单词的定义，而无需访问词典网站。<code>Google</code> 将提供定义，并提供一个音频播放器来提供该单词的语音发音。</p><blockquote><p>语法：<em>define:</em>[searchkey]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb4f2a9f5ab64008ad64b3c084fcbe52~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-10.jpg"></p><h2 id="10-Google-搜索通配符（遗漏或未知词）"><a href="#10-Google-搜索通配符（遗漏或未知词）" class="headerlink" title="10. Google 搜索通配符（遗漏或未知词）"></a>10. Google 搜索通配符（遗漏或未知词）</h2><p>没想到所有的话吗？加上 <code>*</code> 告诉 <code>Google</code> 为您填写空白，这对于歌曲歌词或书名搜索非常有效。</p><blockquote><p>语法：[searchkeys 1] * [searchkeys 2]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e11426ec76aa4862befaa12c90307d9b~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-11.jpg"></p><h2 id="11-Google-搜索文件类型"><a href="#11-Google-搜索文件类型" class="headerlink" title="11. Google 搜索文件类型"></a>11. Google 搜索文件类型</h2><p>搜索文件类型（例如 <code>PowerPoint</code>，<code>PDF</code> 等）时，请在搜索词中使用 <code>filetype：</code> 命令。</p><blockquote><p>语法：[searchkeyword] <em>filetype:</em>[file type extension]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1a69555faaa4b71a32c73f27119f0e9~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-12.jpg"></p><h2 id="12-转换计算"><a href="#12-转换计算" class="headerlink" title="12. 转换计算"></a>12. 转换计算</h2><p>使用 <code>Google</code> 可以进行任何度量转换。</p><blockquote><p>语法：<em>convert</em> [data value + unit of measure] <em>to</em> [like unit of measure]</p></blockquote><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30f3b8850e2f4c8dbdff7f5b0c318eaa~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-13.jpg"></p><h2 id="13-Google-搜索计算器"><a href="#13-Google-搜索计算器" class="headerlink" title="13. Google 搜索计算器"></a>13. Google 搜索计算器</h2><p>在搜索栏中输入您的计算结果，将 <code>Google</code> 用作计算器。<strong>数值运算符</strong>: <code>*</code> 表示乘，<code>+</code> 表示加，<code>-</code> 表示减，<code>/</code> 表示除。</p><blockquote><p>语法：[number] <em>[operator]</em> [number]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d25fecfe46c457bb98ae2e894ede6fe~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-14.jpg"></p><h2 id="14-Google-图片搜索"><a href="#14-Google-图片搜索" class="headerlink" title="14. Google 图片搜索"></a>14. Google 图片搜索</h2><p>查找图像的名称，描述和类型。</p><blockquote><p>语法：[searchkeyw] <em>image type</em></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/820f6862b73f42d48fa0d391f5cd41ea~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-15.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/12/pzf8mEDUoWbxF6J.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;搜索能力是被绝大多数人低估一项基本素质，绝大部分做编程技术相关的朋友应该都知道如何使用 &lt;code&gt;Google&lt;/code&gt;，但是并不知道如何利用它的潜力。其实不管是 &lt;code&gt;Google&lt;/code&gt; 还是 &lt;code&gt;百度&lt;/code&gt;，会搜索的人一样都可以查找到需要的东西，不会搜索的人用什么都不好使。下面介绍一些 &lt;code&gt;Google&lt;/code&gt; 常用的搜索技巧以及搜索快捷方式，可以帮助你更快，更准确地找到结果。&lt;code&gt;Google&lt;/code&gt; 是世界上功能最强大的搜索引擎，它已经改变了我们查找信息的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Google" scheme="https://www.mghio.cn/categories/Google/"/>
    
      <category term="Search" scheme="https://www.mghio.cn/categories/Google/Search/"/>
    
      <category term="Tips" scheme="https://www.mghio.cn/categories/Google/Search/Tips/"/>
    
    
      <category term="Google" scheme="https://www.mghio.cn/tags/Google/"/>
    
      <category term="Search" scheme="https://www.mghio.cn/tags/Search/"/>
    
      <category term="Tips" scheme="https://www.mghio.cn/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>论基础理论知识的重要性</title>
    <link href="https://www.mghio.cn/post/a328bfd.html"/>
    <id>https://www.mghio.cn/post/a328bfd.html</id>
    <published>2021-07-05T08:00:25.000Z</published>
    <updated>2022-11-05T08:01:43.363Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/12/9gD8NzcjWSMO2a3.jpg" alt="cover.jpg"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在计算机行业工作的人们，最大的感触就是这个行业里总是会出现很多的新东西，各种技术、框架等等，变化无处不在，有很大一部分人都比较焦虑。在一些论坛或者社区里面总是有人在问如何学习一门新技术？怎样才能跟上技术的潮流？我想说是，我们应该<strong>打牢基础，应对变化，以不变应万变</strong>。</p><a id="more"></a><h4 id="从变化中寻找不变的东西"><a href="#从变化中寻找不变的东西" class="headerlink" title="从变化中寻找不变的东西"></a>从变化中寻找不变的东西</h4><p>变化都是我们看到表面现象，本质的变化其实并没有多大。计算机发展的这几十年来，理论的层面变得不多，很多理论都是在几十年前就已经发现了的，只是在表现形式上变化比较大，夸张一点的甚至是一年一个样的都有。</p><p>所以想要应对这种变化就要抓住其本质不变的地方，也就是其背后的理论基础，打牢理论基础，提升自己的编程内功修养，一些与语言无关比较通用的东西要重点掌握，比如编程里面的一些设计模式、代码重用、解耦以及抽象能力等等。想要代码重用就必须得解耦，想要解耦就进行抽象，抽取出公共不变的东西，这些都是和语言无关的通用的技能。</p><h4 id="基础知识决定你能飞多高"><a href="#基础知识决定你能飞多高" class="headerlink" title="基础知识决定你能飞多高"></a>基础知识决定你能飞多高</h4><p>当你有牢固的基础知识以后，其实也会更加容易的突破自己的技术和成长瓶颈。我认为在技术领域里面其实是不存在量变可以达到质变这么一说的。量变达到质变也是说只要我努力多写代码就能成为架构师，技术有一个质的突破，其实并不是这样的。</p><p>尽管你代码写得再多，如果不懂得背后的技术原理，不懂得科学的学习方法，不进行归纳总结输出，是永远达到质变的。所以必须学习和打牢基础理论知识，如果总是只学习一些浮于表面上的东西，当技术形式发生一些变化后，你会发现之前学习的知识已经用不到了，又得重新学习，而在技术世界里变化又是非常快的，所以很多都迷失在不停的学习技术形式之中，这也是造成一部分人感到焦虑的原因之一。</p><p>上层的技术实现都是有背后的理论基础作为支撑的，因为这些理论基础都是抽象和归纳，比如不管是 <code>Java</code> 还是其它的一些开发语言，只要只用 TCP/IP 协议，用的都是一样的原理，不同的只是技术实现形式上的差异，你只要打牢基础理论知识，抓住本质原理，不管它技术实现形式上如何变化，都能很快掌握它。</p><h4 id="计算机基础理论分类"><a href="#计算机基础理论分类" class="headerlink" title="计算机基础理论分类"></a>计算机基础理论分类</h4><p>这些知识绝大部分都是一个科班学生本科的专业课讲到的原理知识，但是大部分人在学校可能都没有静下心来认真学习钻研，有句话说得好：“出来混，迟早要还的~”，一个好的学习方法就是一定要看一些经典的书和世界顶级学校的课程，最后自己归纳总结输出。这些知识总的来说可以分为以下几类，</p><ol><li>系统知识类：计算机系统、网络协议、数据库等</li><li>算法和数据结构类：算法和数据结构、分布式系统等</li><li>中间件类：消息队列、任务调度、网关代理等</li><li>程序语言类：类库实现、设计模式、编程技术（多线程、异步等）、语言原理等</li></ol><p>计算机发展的这几十年来，核心的基础知识就是上面列举的这些，虽然我们的直观感受技术是在不断更替的，实际上本质的东西并没有改变，其理论基础还是这些内容，变化的只是技术形式，我想说的一点是对这些基础理论知识的掌握程能直接决定的成长天花板。万丈高楼平地起，勿在浮沙筑高台。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/12/9gD8NzcjWSMO2a3.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在计算机行业工作的人们，最大的感触就是这个行业里总是会出现很多的新东西，各种技术、框架等等，变化无处不在，有很大一部分人都比较焦虑。在一些论坛或者社区里面总是有人在问如何学习一门新技术？怎样才能跟上技术的潮流？我想说是，我们应该&lt;strong&gt;打牢基础，应对变化，以不变应万变&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础知识" scheme="https://www.mghio.cn/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="思考" scheme="https://www.mghio.cn/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="https://www.mghio.cn/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="基础知识" scheme="https://www.mghio.cn/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title> 如何实现一个简易版的 Spring - 如何实现 AOP（终结篇）</title>
    <link href="https://www.mghio.cn/post/bd7ad750.html"/>
    <id>https://www.mghio.cn/post/bd7ad750.html</id>
    <published>2021-06-13T07:57:09.000Z</published>
    <updated>2022-11-05T07:58:44.870Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/13/42YRj7pdfJkK3wN.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://www.mghio.cn/post/2a28641b.html">上篇</a> 实现了 判断一个类的方式是符合配置的 pointcut 表达式、根据一个 Bean 的名称和方法名，获取 Method 对象、实现了 BeforeAdvice、AfterReturningAdvice 以及 AfterThrowingAdvice并按照指定次序调用 等功能，这篇再来看看剩下的 <strong>代理对象如何生成</strong>、<strong>根据 XML 配置文件生成 BeanDefintion</strong>以及<strong>如何将生成的代理对象放入到容器中</strong> 等功能，话不多说，下面进入主题。</p><a id="more"></a><h2 id="代理对象生成"><a href="#代理对象生成" class="headerlink" title="代理对象生成"></a>代理对象生成</h2><p>代理对象的生成策略和 Spring 框架一致，当被代理类实现了接口时采用 JDK 动态代理的方式生成代理对象，被代理对象未实现接口时使用 CGLIB 来生成代理对象，为了简单起见这里不支持手动指定生成代理对象的策略，JDK 动态代理的实现这里不在介绍，感兴趣可以自己实现一下，这里主要讨论 CGLIB 的生成方式。</p><p><img src="https://img-blog.csdnimg.cn/2021061320514299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lbGRveV9tZ2g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>基于面向接口编程的思想，这里的生成代理对象需要定义一个统一的接口，不管是 CGLIB 生成方式还是JDK 动态代理生成方式都要实现该接口。生成代理对象是根据一些配置去生成的，同样，这里生成代理的配置也可以抽取一个统一的接口，在实现类中定义拦截器（也就是 Advice）以及实现的接口等，<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a> 的基本使用可以到官网自行查找。代理对象生成的整体的类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20210613205250678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lbGRveV9tZ2g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>其中代理创建的工厂接口 AopProxyFactory 如下，提供了不指定 ClassLoader（使用默认的 ClassLoader）和指定 ClassLoader 两种方式创建代理对象，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 CGLIB 创建代理的工厂接口实现类如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Constants for CGLIB callback array indices</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AOP_PROXY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Advised advised;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyFactory</span><span class="params">(Advised config)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(config, <span class="string">"AdvisedSupport must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (config.getAdvices().size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"No advisors and no TargetSource specified"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advised = config;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getProxy(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Creating CGLIB proxy: target class is "</span> + <span class="keyword">this</span>.advised.getTargetClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">      Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">      <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        enhancer.setClassLoader(classLoader);</span><br><span class="line">      &#125;</span><br><span class="line">      enhancer.setSuperclass(rootClass);</span><br><span class="line">      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);  <span class="comment">// BySpringCGLIB</span></span><br><span class="line">      enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">      Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">        types[i] = callbacks[i].getClass();</span><br><span class="line">      &#125;</span><br><span class="line">      enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(<span class="keyword">this</span>.advised));</span><br><span class="line">      enhancer.setCallbackTypes(types);</span><br><span class="line">      enhancer.setCallbacks(callbacks);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">      <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> +</span><br><span class="line">          <span class="keyword">this</span>.advised.getTargetClass() + <span class="string">"]: "</span> +</span><br><span class="line">          <span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">          ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体来看还是比较简单的，主要是 CGLIB 第三方字节码生成库的基本用法，当然，前提是你已经了解了 CGLIB 的基本使用。AOP 的相关配置接口 Advised 相对来说就比较简单了，主要是一些相关属性的增、删、改等操作，主要部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; getTargetClass();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isInterfaceProxied</span><span class="params">(Class&lt;?&gt; intf)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Advice&gt; <span class="title">getAdvices</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(Advice advice)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Advice&gt; <span class="title">getAdvices</span><span class="params">(Method method)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addInterface</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类也比较简单，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">implements</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> proxyTargetClass = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> Object targetObject = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Advice&gt; advices = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AdvisedSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetObject.getClass();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterfaceProxied</span><span class="params">(Class&lt;?&gt; intf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> interfaces.contains(intf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Advice&gt; <span class="title">getAdvices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.advices;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.advices.add(advice);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Advice&gt; <span class="title">getAdvices</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    List&lt;Advice&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Advice advice : <span class="keyword">this</span>.getAdvices()) &#123;</span><br><span class="line">      Pointcut pc = advice.getPointcut();</span><br><span class="line">      <span class="keyword">if</span> (pc.getMethodMatcher().matches(method)) &#123;</span><br><span class="line">        result.add(advice);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterface</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.interfaces.add(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，代理对象使用 CGLIB 生成的方式就已经实现了，核心代码其实比较简单，主要是需要多考虑考虑代码后期的扩展性。</p><h2 id="创建-BeanDefinition"><a href="#创建-BeanDefinition" class="headerlink" title="创建 BeanDefinition"></a>创建 BeanDefinition</h2><p>我们先来看看一般 AOP 在 XML 配置文件中是如何定义的，一个包含 BeforeAdvice、AfterReturningAdvice以及AfterThrowingAdvice 的 XML 配置文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.e3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:scann-package</span> <span class="attr">base-package</span>=<span class="string">"cn.mghio.service.version5,cn.mghio.dao.version5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tx"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.tx.TransactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"tx"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"placeOrder"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.mghio.service.version5.*.placeOrder(..))"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"start"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"commit"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"rollback"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了之前解析 XML 的 Bean 定义的经验后，很显然这里我们需要一个数据结构去表示这个 AOP 配置，如果你阅读过 <a href="https://www.mghio.cn/post/2a28641b.html">上篇</a> 的话，类 AspectJExpressionPointcut 表示的是 &lt;aop:pointcut id=”placeOrder” expression=”execution(* cn.mghio.service.version5.*.placeOrder(..))”/&gt;，另外几个 Advice 配置分别对应 AspectJBeforeAdvice、AspectJAfterReturningAdvice以及 AspectJAfterThrowingAdvice 等几个类。<br>这里只要解析 XML 配置文件，然后使用对应的 Advice 的构造器创建对应的对象即可，解析 XML 使用的是 dom4j，主要部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigBeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASPECT = <span class="string">"aspect"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXPRESSION = <span class="string">"expression"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID = <span class="string">"id"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REF = <span class="string">"ref"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE = <span class="string">"before"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER = <span class="string">"after"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_RETURNING_ELEMENT = <span class="string">"after-returning"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_THROWING_ELEMENT = <span class="string">"after-throwing"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AROUND = <span class="string">"around"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT = <span class="string">"pointcut"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_REF = <span class="string">"pointcut-ref"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASPECT_NAME_PROPERTY = <span class="string">"aspectName"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Element element, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    List&lt;Element&gt; childElements = element.elements();</span><br><span class="line">    <span class="keyword">for</span> (Element el : childElements) &#123;</span><br><span class="line">      String localName = el.getName();</span><br><span class="line">      <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">        parseAspect(el, registry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAspect</span><span class="params">(Element aspectElement, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    String aspectName = aspectElement.attributeValue(REF);</span><br><span class="line"></span><br><span class="line">    List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;RuntimeBeanReference&gt; beanReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse advice</span></span><br><span class="line">    List&lt;Element&gt; elements = aspectElement.elements();</span><br><span class="line">    <span class="keyword">boolean</span> adviceFoundAlready = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isAdviceNode(element)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adviceFoundAlready) &#123;</span><br><span class="line">          adviceFoundAlready = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (!StringUtils.hasText(aspectName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          beanReferences.add(<span class="keyword">new</span> RuntimeBeanReference(aspectName));</span><br><span class="line">        &#125;</span><br><span class="line">        GenericBeanDefinition advisorDefinition = parseAdvice(aspectName, element, registry,</span><br><span class="line">            beanDefinitions, beanReferences);</span><br><span class="line">        beanDefinitions.add(advisorDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse pointcut</span></span><br><span class="line">    List&lt;Element&gt; pointcuts = aspectElement.elements(POINTCUT);</span><br><span class="line">    <span class="keyword">for</span> (Element pointcut : pointcuts) &#123;</span><br><span class="line">      parsePointcut(pointcut, registry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parsePointcut</span><span class="params">(Element pointcutElement, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    String id = pointcutElement.attributeValue(ID);</span><br><span class="line">    String expression = pointcutElement.attributeValue(EXPRESSION);</span><br><span class="line"></span><br><span class="line">    GenericBeanDefinition pointcutDefinition = createPointcutDefinition(expression);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(id)) &#123;</span><br><span class="line">      registry.registerBeanDefinition(id, pointcutDefinition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      BeanDefinitionReaderUtils.registerWithGeneratedName(pointcutDefinition, registry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> GenericBeanDefinition <span class="title">parseAdvice</span><span class="params">(String aspectName, Element adviceElement,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry, List&lt;BeanDefinition&gt; beanDefinitions,</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;RuntimeBeanReference&gt; beanReferences)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GenericBeanDefinition methodDefinition = <span class="keyword">new</span> GenericBeanDefinition(MethodLocatingFactory.class);</span><br><span class="line">    methodDefinition.getPropertyValues().add(<span class="keyword">new</span> PropertyValue(<span class="string">"targetBeanName"</span>, aspectName));</span><br><span class="line">    methodDefinition.getPropertyValues().add(<span class="keyword">new</span> PropertyValue(<span class="string">"methodName"</span>,</span><br><span class="line">        adviceElement.attributeValue(<span class="string">"method"</span>)));</span><br><span class="line">    methodDefinition.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create instance definition factory</span></span><br><span class="line">    GenericBeanDefinition aspectFactoryDef = <span class="keyword">new</span> GenericBeanDefinition(AopInstanceFactory.class);</span><br><span class="line">    aspectFactoryDef.getPropertyValues().add(<span class="keyword">new</span> PropertyValue(<span class="string">"aspectBeanName"</span>, aspectName));</span><br><span class="line">    aspectFactoryDef.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register the pointcut</span></span><br><span class="line">    GenericBeanDefinition adviceDef = createAdviceDefinition(adviceElement, aspectName,</span><br><span class="line">        methodDefinition, aspectFactoryDef, beanDefinitions, beanReferences);</span><br><span class="line">    adviceDef.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register the final advisor</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerWithGeneratedName(adviceDef, registry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adviceDef;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 BeanDefinition 已经完成了，现在可根据 XML 配置文件解析出对应的 BeanDefintion 了，下面只需要在合适的时机将这些 BeanDefinition 放到容器中就完成了全部流程了。 </p><h2 id="如何放到容器中"><a href="#如何放到容器中" class="headerlink" title="如何放到容器中"></a>如何放到容器中</h2><p>该如何把解析出来的 BeanDefintion 放到容器当中去呢？我们知道在 Spring 框架当中提供了很多的“钩子函数”，可以从这里入手，Bean 的生命周期如下：</p><p><img src="https://img-blog.csdnimg.cn/2021061320530617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lbGRveV9tZ2g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>选择在 Bean 实例化完成之后 BeanPostProcessor 的 postProcessAfterInitialization() 方法创建代理对象，AOP 使用的是 AspectJ，将创建代理对象的类命名为 AspectJAutoProxyCreator，实现 BeanPostProcessor 接口，处理代理对象的创建，AspectJAutoProxyCreator 类的核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyCreator</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ConfigurableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">beforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">afterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果这个 bean 本身就是 Advice 及其子类，则不生成动态代理</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Advice&gt; advices = getCandidateAdvices(bean);</span><br><span class="line">    <span class="keyword">if</span> (advices.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createProxy(advices, bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(List&lt;Advice&gt; advices, Object bean)</span> </span>&#123;</span><br><span class="line">    Advised config = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">    <span class="keyword">for</span> (Advice advice : advices) &#123;</span><br><span class="line">      config.addAdvice(advice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&gt; targetInterfaces = ClassUtils.getAllInterfacesForClassAsSet(bean.getClass());</span><br><span class="line">    <span class="keyword">for</span> (Class targetInterface : targetInterfaces) &#123;</span><br><span class="line">      config.addInterface(targetInterface);</span><br><span class="line">    &#125;</span><br><span class="line">    config.setTargetObject(bean);</span><br><span class="line"></span><br><span class="line">    AopProxyFactory proxyFactory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (config.getProxiedInterfaces().length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// CGLIB 代理</span></span><br><span class="line">      proxyFactory = <span class="keyword">new</span> CglibProxyFactory(config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// TODO(mghio): JDK dynamic proxy ...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(ConfigurableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;Advice&gt; <span class="title">getCandidateAdvices</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    List&lt;Object&gt; advices = <span class="keyword">this</span>.beanFactory.getBeansByType(Advice.class);</span><br><span class="line">    List&lt;Advice&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Object advice : advices) &#123;</span><br><span class="line">      Pointcut pointcut = ((Advice) advice).getPointcut();</span><br><span class="line">      <span class="keyword">if</span> (canApply(pointcut, bean.getClass())) &#123;</span><br><span class="line">        result.add((Advice) advice);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pointcut, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    MethodMatcher methodMatcher = pointcut.getMethodMatcher();</span><br><span class="line">    Set&lt;Class&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">    classes.add(targetClass);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">      Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">      <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (methodMatcher.matches(m)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Advice.class.isAssignableFrom(beanClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后别忘了，这里的 BeanPostProcessor 接口是我们新加的，需要到之前定义的 DefaultFactoryBean 中加上对 BeanPostProcessor 的处理逻辑，主要修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition bd)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. instantiate bean</span></span><br><span class="line">        Object bean = instantiateBean(bd);</span><br><span class="line">        <span class="comment">// 2. populate bean</span></span><br><span class="line">        populateBean(bd, bean);</span><br><span class="line">        <span class="comment">// 3. initialize bean</span></span><br><span class="line">        bean = initializeBean(bd, bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(BeanDefinition bd, Object bean)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非合成类型则创建代理</span></span><br><span class="line">        <span class="keyword">if</span> (!bd.isSynthetic()) &#123;</span><br><span class="line">            <span class="keyword">return</span> applyBeanPostProcessorAfterInitialization(bean, bd.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">applyBeanPostProcessorAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span> </span>&#123;</span><br><span class="line">        Object result = existingBean;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor postProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">            result = postProcessor.afterInitialization(result, beanName);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// omit other field and methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行事先测试用例，正常通过符合预期。</p><p><img src="https://img-blog.csdnimg.cn/20210613205223527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lbGRveV9tZ2g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 AOP 代理对象生成、解析 XML 配置文件并创建对应的 BeanDefinition 以及最后注入到容器中，只是介绍了大体实现思路，具体代码实现已上传 <a href="https://github.com/mghio/mghio-spring" target="_blank" rel="noopener">mghio-spring</a>，感兴趣的朋友可以参考，到这里，AOP 实现部分已经全部介绍完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/13/42YRj7pdfJkK3wN.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.mghio.cn/post/2a28641b.html&quot;&gt;上篇&lt;/a&gt; 实现了 判断一个类的方式是符合配置的 pointcut 表达式、根据一个 Bean 的名称和方法名，获取 Method 对象、实现了 BeforeAdvice、AfterReturningAdvice 以及 AfterThrowingAdvice并按照指定次序调用 等功能，这篇再来看看剩下的 &lt;strong&gt;代理对象如何生成&lt;/strong&gt;、&lt;strong&gt;根据 XML 配置文件生成 BeanDefintion&lt;/strong&gt;以及&lt;strong&gt;如何将生成的代理对象放入到容器中&lt;/strong&gt; 等功能，话不多说，下面进入主题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/categories/Java/Spring/AOP/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简易版的 Spring - 如何实现 AOP（下）</title>
    <link href="https://www.mghio.cn/post/2a28641b.html"/>
    <id>https://www.mghio.cn/post/2a28641b.html</id>
    <published>2021-06-06T07:54:32.000Z</published>
    <updated>2022-11-05T07:56:22.075Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/10/lOLEuXIUreJkNgM.jpg" alt="cover.jpg"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前面两篇 <a href="https://www.mghio.cn/post/9294037e.html">如何实现 AOP（上）</a>、<a href="https://www.mghio.cn/post/af7194f9.html">如何实现 AOP（中）</a> 做了一些 <code>AOP</code> 的核心基础知识简要介绍，本文进入到了实战环节了，去实现一个基于 <code>XML</code> 配置的简易版 <code>AOP</code>，虽然是简易版的但是<code>麻雀虽小五脏俱全</code>，一些核心的功能都会实现，通过实现这个简易版的 <code>AOP</code>，相信你会对 <code>AOP</code> 有深入的理解，不止知其然，还能知其所以然。<code>AOP</code> 的顶层接口规范和底层依赖基础组件都是由一个叫 <a href="http://aopalliance.sourceforge.net" target="_blank" rel="noopener">AOP Alliance</a> 的组织制定的，我们经常听到的 <code>AspectJ</code>、<code>ASM</code>、<code>CGLIB</code> 就是其中被管理的一些项目，需要明确的一点是，在 <code>Spring</code> 中只是使用了 <code>AspectJ</code> 的核心概念和核心类，并不是像 <code>AspectJ</code> 那样在编译期实现的 <code>AOP</code>，而是在<strong>运行期</strong>。话不多说，下面开始进入主题。</p><a id="more"></a><h4 id="解析-XML-中的-pointcut-定义及方法解析"><a href="#解析-XML-中的-pointcut-定义及方法解析" class="headerlink" title="解析 XML 中的 pointcut 定义及方法解析"></a>解析 XML 中的 pointcut 定义及方法解析</h4><p>假设有一个 <code>OrderService</code> 类(P.S. 这里的 <code>@Component</code> 是我自定义的注解，详见 <a href="https://www.mghio.cn/post/6775e26e.html">这篇</a>)，其中有一个下单的方法 <code>placeOrder()</code>，我们想实现的效果是想给这个 <code>placeOrder()</code> 方法加上 <a href="https://en.wikipedia.org/wiki/Database_transaction" target="_blank" rel="noopener">数据库事务</a>，即执行方法之前开启事务，执行过程中发生异常回滚事务，正常执行完成提交事务。<code>OrderService</code> 类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(value = <span class="string">"orderService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"place order"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这里的 <code>pointcut</code> 就是 <code>placeOrder()</code> 方法，在 <code>XML</code> 配置文件中的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"placeOrder"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.mghio.service.version5.*.placeOrder(..))"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>我们需要一个类去表达这个概念，<code>pointcut</code> 要实现的功能是给定一个类的方法，判断是否匹配配置文件中给定的表达式。总的来看 <code>pointcut</code> 由<code>方法匹配器</code>和<code>匹配表达式</code>两部分组成，方法匹配器可以有各种不同的实现，所以是一个接口，<code>pointcut</code> 同样也可以基于多种不同技术实现，故也是一个接口，默认是基于 <code>AspectJ</code> 实现的，类图结构如下：</p><p><img src="https://i.loli.net/2021/06/06/JZHDROnPEletVwU.png" alt="pointcut-implemented.png"></p><p>实现类 <code>AspectJExpressionPointcut</code> 是基于 <code>AspectJ</code> 实现的，方法的匹配过程是委托给 <code>AspectJ</code> 中的 <code>PointcutExpression</code> 来判断给定的方法是否匹配表达式，该类的核心实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJExpressionPointcut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span>, <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;PointcutPrimitive&gt; SUPPORTED_PRIMITIVES = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    SUPPORTED_PRIMITIVES.add(PointcutPrimitive.EXECUTION);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String expression;</span><br><span class="line">  <span class="keyword">private</span> ClassLoader pointcutClassLoader;</span><br><span class="line">  <span class="keyword">private</span> PointcutExpression pointcutExpression;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    checkReadyToMatch();</span><br><span class="line"></span><br><span class="line">    ShadowMatch shadowMatch = getShadowMatch(method);</span><br><span class="line">    <span class="keyword">return</span> shadowMatch.alwaysMatches();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkReadyToMatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(getExpression())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must set property 'expression' before attempting to match"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(<span class="keyword">this</span>.pointcutExpression)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.pointcutClassLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line">      <span class="keyword">this</span>.pointcutExpression = buildPointcutExpression(<span class="keyword">this</span>.pointcutClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> PointcutExpression <span class="title">buildPointcutExpression</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    PointcutParser pointcutParser = PointcutParser</span><br><span class="line">        .getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(SUPPORTED_PRIMITIVES, classLoader);</span><br><span class="line">    <span class="keyword">return</span> pointcutParser.parsePointcutExpression(replaceBooleanOperators(getExpression()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">replaceBooleanOperators</span><span class="params">(String pcExpr)</span> </span>&#123;</span><br><span class="line">    String result = StringUtils.replace(pcExpr, <span class="string">" and "</span>, <span class="string">" &amp;&amp; "</span>);</span><br><span class="line">    result = StringUtils.replace(result, <span class="string">" or "</span>, <span class="string">" || "</span>);</span><br><span class="line">    result = StringUtils.replace(result, <span class="string">" not "</span>, <span class="string">" ! "</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ShadowMatch <span class="title">getShadowMatch</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    ShadowMatch shadowMatch;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      shadowMatch = <span class="keyword">this</span>.pointcutExpression.matchesMethodExecution(method);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"not implemented yet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shadowMatch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other setter、getter ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就完成了给定一个类的方法，判断是否匹配配置文件中给定的表达式的功能。再来看如下的一个完整的 <code>AOP</code> 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.e3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:scann-package</span> <span class="attr">base-package</span>=<span class="string">"cn.mghio.service.version5,cn.mghio.dao.version5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tx"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.tx.TransactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"tx"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"placeOrder"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.mghio.service.version5.*.placeOrder(..))"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"start"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"commit"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"rollback"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实现各种 <code>XXXAdvice</code> 之前需要定位到这个 <code>Method</code>，比如以上配置文件中的 <code>start</code>、<code>commit</code>、<code>rollback</code> 等方法，为了达到这个目标我们还需要实现的功能就是根据一个 <code>Bean</code> 名称（比如这里的 <code>tx</code>）定位到指定的 <code>Method</code>，然后通过反射调用这个定位到的方法。实际上也比较简单，这个类命名为 <code>MethodLocatingFactory</code>，根据其功能可以定义出目标 <code>Bean</code> 的名称 <code>targetBeanName</code>、需要定位的方法名称 <code>methodName</code> 以及定位完成后得到的方法 <code>method</code> 这三个属性，整体类图结构如下所示：</p><p><img src="https://i.loli.net/2021/06/06/rQyJt8KuSDEO6gZ.png" alt="method-locating.png"></p><p>根据名称和类型定位到方法主要是在 <code>setBeanFactory()</code> 方法中完成的，前提是对应的目标 <code>Bean</code> 名称和方法名称要设置完成，方法定位的类 <code>MethodLocatingFactory</code> 类的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodLocatingFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Method</span>&gt;, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String targetBeanName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Method method;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetBeanName</span><span class="params">(String targetBeanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.targetBeanName = targetBeanName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.targetBeanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'targetBeanName' is required"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.methodName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'methodName' is required"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; beanClass = beanFactory.getType(<span class="keyword">this</span>.targetBeanName);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(beanClass)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can't determine type of bean with name '"</span> + <span class="keyword">this</span>.targetBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.method = BeanUtils.resolveSignature(<span class="keyword">this</span>.methodName, beanClass);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(<span class="keyword">this</span>.method)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to locate method ["</span> + <span class="keyword">this</span>.methodName + <span class="string">"] on bean ["</span></span><br><span class="line">          + <span class="keyword">this</span>.targetBeanName + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Method <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.method;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">    <span class="keyword">return</span> Method.class;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现各种不同类型的-Advice"><a href="#实现各种不同类型的-Advice" class="headerlink" title="实现各种不同类型的 Advice"></a>实现各种不同类型的 Advice</h4><p>各种不同类型的 <code>Advice</code>（<code>BeforeAdvice</code>、<code>AfterAdvice</code> 等）目标都是需要在指定对象的指定方法执行前后按指定次序执行一些操作（称之为 <code>拦截器</code>），比如以上示例中的一种执行次序为：<code>BeforeAdvice</code> -&gt; <code>placeOrder</code> -&gt; <code>AfterAdvice</code>。这里的一个关键问题就是<strong>如何去实现按照指定次序的链式调用？</strong>，这里先卖个关子，这个问题先放一放等下再介绍具体实现，先来看看要如何定义各种不同类型的 <code>Advice</code>，我们的 <code>Advice</code> 定义都是扩展自 <code>AOP Alliance</code> 定义的 <code>MethodInterceptor</code> 接口，<code>Advice</code> 部分的核心类图如下：</p><p><img src="https://i.loli.net/2021/06/06/gvOmqs4ci8jp1Nx.png" alt="advice-implemented.png"></p><p>其实到这里如果有了前面两篇文章（<a href="https://www.mghio.cn/post/9294037e.html">如何实现 AOP（上）</a>、<a href="https://www.mghio.cn/post/af7194f9.html">如何实现 AOP（中）</a>）的基础了，实现起来就相对比较简单了，就是在方法执行之前、之后以及发生异常时调用一些特定的方法即可，<code>AbstractAspectJAdvice</code> 类定义了一下公共的属性和方法，核心实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvice</span> <span class="keyword">implements</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Method adviceMethod;</span><br><span class="line">  <span class="keyword">protected</span> AspectJExpressionPointcut pc;</span><br><span class="line">  <span class="keyword">protected</span> AopInstanceFactory adviceObjectFactory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractAspectJAdvice</span><span class="params">(Method adviceMethod, AspectJExpressionPointcut pc, AopInstanceFactory adviceObjectFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.adviceMethod = adviceMethod;</span><br><span class="line">    <span class="keyword">this</span>.pc = pc;</span><br><span class="line">    <span class="keyword">this</span>.adviceObjectFactory = adviceObjectFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeAdviceMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    adviceMethod.invoke(adviceObjectFactory.getAspectInstance());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getAdviceInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adviceObjectFactory.getAspectInstance();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit getter ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个公共抽象父类之后其它几个 <code>Advice</code> 的实现就很简单了，<code>AspectJBeforeAdvice</code> 就是在执行拦截方法之前调用，核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit constructor ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.invokeAdviceMethod();</span><br><span class="line">    <span class="keyword">return</span> mi.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，<code>AspectJAfterReturningAdvice</code> 就是在方法正常执行结束后调用，核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit constructor ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object result = mi.proceed();</span><br><span class="line">    <span class="keyword">this</span>.invokeAdviceMethod();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的 <code>AspectJAfterThrowingAdvice</code> 想必你已经猜到了，没错，就是在方法执行过程中发生异常时调用，对应 <code>Java</code> 的异常机制也就是在 <code>try{...}catch{...}</code> 的 <code>catch</code> 中调用，核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAfterThrowingAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit constructor ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">this</span>.invokeAdviceMethod();</span><br><span class="line">      <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们支持的三种不同的 <code>Advice</code> 已经定义好了，接下来就是如何组装调用的问题了，同时也处理了<strong>如何去实现按照指定次序的链式调用？</strong>的问题，这里的方法调用我们也是扩展 <code>AOP Alliance</code> 定义的规范，即方法调用 <code>MethodInvocation</code> 接口。</p><p>由于这里的方法调用是基于反射完成的，将该类命名为 <code>ReflectiveMethodInvocation</code>，要使用反射来调用方法，很显然需要知道目标对象 <code>targetObject</code>、<code>targetMethod</code> 以及方法参数列表 <code>arguments</code> 等参数，当然还有我们的拦截器列表（也就是上文定义的 <code>Advice</code>）<code>interceptors</code>，因为这个是一个类似<strong>自调用的过程</strong>，为了判断是否已经执行完成所有拦截器，还需要记录当前调用拦截器的下标位置 <code>currentInterceptorIndex</code>，当 <code>currentInterceptorIndex</code> 等于 <code>interceptors.size() - 1</code> 时表示所有拦截器都已调用完成，再调用我们的实际方法即可。核心的类图如下：</p><p><img src="https://i.loli.net/2021/06/06/Df4bx7AkdLavjrX.png" alt="ReflectiveMethodInvocation-implemented.png"></p><p>其中类 <code>ReflectiveMethodInvocation</code> 的核心源码实现如下，强烈建议大家将 <code>proceed()</code> 方法结合上问定义的几个 <code>Advice</code> 类一起看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-04-05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Object targetObject;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Method targetMethod;</span><br><span class="line">  <span class="keyword">protected</span> Object[] arguments;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;MethodInterceptor&gt; interceptors;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> currentInterceptorIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReflectiveMethodInvocation</span><span class="params">(Object targetObject, Method targetMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object[] arguments, List&lt;MethodInterceptor&gt; interceptors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line">    <span class="keyword">this</span>.targetMethod = targetMethod;</span><br><span class="line">    <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">    <span class="keyword">this</span>.interceptors = interceptors;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// all interceptors have been called.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == interceptors.size() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.currentInterceptorIndex++;</span><br><span class="line">    MethodInterceptor methodInterceptor = <span class="keyword">this</span>.interceptors.get(<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetMethod.invoke(<span class="keyword">this</span>.targetObject, <span class="keyword">this</span>.arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other method ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，各种不同类型的 <code>Advice</code> 的核心实现已经介绍完毕，本来打算在这边介绍完 <code>AOP</code> 剩下部分的实现的，但是鉴于文章长度太长，还是放到下一次再开一篇来介绍吧。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍了 <code>AOP</code> 在 <code>XML</code> 配置的 <code>pointcut</code> 解析实现、方法匹配定位以及各种不同类型的 <code>Advice</code> 的实现，特别是 <code>Advice</code> 的实现部分，建议自己动手实现一版，这样印象会更加深刻，另源码已上传至 <a href="https://github.com/mghio/mghio-spring" target="_blank" rel="noopener">GitHub</a>，可自行下载参考，有任何问题请留言交流讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/10/lOLEuXIUreJkNgM.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;前面两篇 &lt;a href=&quot;https://www.mghio.cn/post/9294037e.html&quot;&gt;如何实现 AOP（上）&lt;/a&gt;、&lt;a href=&quot;https://www.mghio.cn/post/af7194f9.html&quot;&gt;如何实现 AOP（中）&lt;/a&gt; 做了一些 &lt;code&gt;AOP&lt;/code&gt; 的核心基础知识简要介绍，本文进入到了实战环节了，去实现一个基于 &lt;code&gt;XML&lt;/code&gt; 配置的简易版 &lt;code&gt;AOP&lt;/code&gt;，虽然是简易版的但是&lt;code&gt;麻雀虽小五脏俱全&lt;/code&gt;，一些核心的功能都会实现，通过实现这个简易版的 &lt;code&gt;AOP&lt;/code&gt;，相信你会对 &lt;code&gt;AOP&lt;/code&gt; 有深入的理解，不止知其然，还能知其所以然。&lt;code&gt;AOP&lt;/code&gt; 的顶层接口规范和底层依赖基础组件都是由一个叫 &lt;a href=&quot;http://aopalliance.sourceforge.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AOP Alliance&lt;/a&gt; 的组织制定的，我们经常听到的 &lt;code&gt;AspectJ&lt;/code&gt;、&lt;code&gt;ASM&lt;/code&gt;、&lt;code&gt;CGLIB&lt;/code&gt; 就是其中被管理的一些项目，需要明确的一点是，在 &lt;code&gt;Spring&lt;/code&gt; 中只是使用了 &lt;code&gt;AspectJ&lt;/code&gt; 的核心概念和核心类，并不是像 &lt;code&gt;AspectJ&lt;/code&gt; 那样在编译期实现的 &lt;code&gt;AOP&lt;/code&gt;，而是在&lt;strong&gt;运行期&lt;/strong&gt;。话不多说，下面开始进入主题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/categories/Java/Spring/AOP/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简易版的 Spring - 如何实现 AOP（中）</title>
    <link href="https://www.mghio.cn/post/af7194f9.html"/>
    <id>https://www.mghio.cn/post/af7194f9.html</id>
    <published>2021-05-30T07:51:39.000Z</published>
    <updated>2022-11-05T07:53:24.234Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/10/zDpSiZX6ThBjLyC.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上篇 <a href="https://www.mghio.cn/post/9294037e.html">如何实现 AOP（上）</a> 介绍了 <code>AOP</code> 技术出现的原因和一些重要的概念，在我们自己实现之前有必要先了解一下 <code>AOP</code> 底层到底是如何运作的，所以这篇再来看看 <code>AOP</code> 实现所依赖的一些核心基础技术。<code>AOP</code> 是使用<code>动态代理</code>和<code>字节码生成技术</code>来实现的，在<strong>运行期</strong>（注意：不是编译期！）为目标对象生成代理对象，然后将横切逻辑织入到生成的代理对象中，最后系统使用的是带有横切逻辑的代理对象，而不是被代理对象，由代理对象转发到被代理对象。</p><a id="more"></a><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>动态代理的根源是设计模式中的<a href="https://en.wikipedia.org/wiki/Proxy_pattern" target="_blank" rel="noopener">代理模式</a>，代理模式在 <a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener">GoF</a> 中的描述如下：</p><blockquote><p>Provide a surrogate or placeholder for another object to control access to it.</p></blockquote><p>从其定义可以看出，代理模式主要是为了控制对象的访问，通常也会拥有被代理者的所有功能。通过代理模式我们可以在不改变被代理类的情况下，通过引入代理类来给被代理类添加一些功能，此时脑海里飘过计算机科学界中一句著名的话(P.S. 基础知识很重要啊，可以参见 <a href="https://www.mghio.cn/post/a328bfd.html">这篇</a>)：</p><blockquote><p>计算机科学的任何一个问题，都可以通过增加一个中间层来解决。</p></blockquote><p>代理模式其实在现实生活中也经常会接触到，比如在一线城市租房时大部分都是找的租房中介去看的房子、谈价格以及签合同，是因为房子的房东已经把房子全权托管给了中介处理了，这里的租房中介其实就是充当了代理模式中的代理对象的解决，而真正的被代理对象(目标对象)其实是房子的房东，而和我们打交道都是租房中介(代理对象)。代理模式类图结构如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d5a1b3701804184ad818837aa52677f~tplv-k3u1fbpfcp-zoom-1.image" alt="proxy-pattern.png"></p><p>图中各个部分的含义如下：</p><ul><li><strong>ISubject</strong> 是被代理对象所能提供能力的抽象。</li><li><strong>SubjectImpl</strong> 是被代理的具体实现类。</li><li><strong>SubjectProxy</strong> 是代理的实现类，通常该类持有 <code>ISubject</code> 接口的实例。</li><li><strong>Client</strong> 是访问者的抽象角色，要访问 <code>ISubject</code> 类型的资源。</li></ul><p>可以看到 <code>SubjectImpl</code> 和 <code>SubjectProxy</code> 都实现了相同的接口 <code>ISubject</code>，在代理对象 <code>SubjectProxy</code> 内持有 <code>ISubject</code> 的引用，当 <code>Client</code> 访问 <code>doOperation()</code> 时，代理对象将请求转发给被代理对象，单单从这个过程来看，代理对象如果只是为了转发请求，是不是有点多此一举了？再结合代理模式的定义思考一下，在转发之前（后者之后）不就可以添加一些访问控制了吗。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb1ba1e1462e4b72821fa63735caba38~tplv-k3u1fbpfcp-zoom-1.image" alt="static-proxy.png"></p><p>在代理对象(<code>SubjectProxy</code>)将请求转发给被代理对象(<code>SubejctImpl</code>)之前或者之后都是根据需要添加一些处理逻辑，而不需要修改被代理对象的具体实现逻辑，假设 <code>SubjectImpl</code> 是我们系统中 <code>Joinpoint</code> 所在的对象，此时 <code>SubjectImpl</code> 就是我们的目标对象了，只需要为这个目标对象创建一个代理对象，然后将横切逻辑添加到代理对象中，对外暴露出创建出来的代理对象就可以将将横切逻辑和原来的逻辑融合在一起了。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>到目前为止，一切都是那么美好，当只为同一个目标对象类型添加横切逻辑时，只需要创建一个代理对象即可，但是在 <code>Joinpoint</code> 相同而目标对象类型不同时，需要为每个不同的目标对象类型都单独创建一个代理对象，而这些代理对象的横切逻辑其实都是一样的，根据 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">DRY原则</a>，需要寻找另一种技术来解决这个问题。<br>在 <code>JDK 1.3</code> 引入的 <code>动态代理机制</code> 可以为指定的接口在<code>运行期</code>动态的去生成代理对象，使用这个<code>动态代理机制</code>可以解决上述问题，这样我们就可以不事先为每个原始类创建代理类，而是在运行时<code>动态生成</code>代理类。在 <code>Java</code> 中，使用动态代理是比较简单的，它本身就已经使用反射实现了动态代理的语法，主要是由一个类 <code>Proxy</code> 和一个接口 <code>InvocationHandler</code> 组成，使用动态代理机制实现前文示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-05-29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doOperation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"SubjectImpl doOperation..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Subject target;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JDKInvocationHandler</span><span class="params">(Subject target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// add pre process logic if necessary</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"Proxy before JDKInvocationHandler doOperation..."</span>);</span><br><span class="line">    Object result = method.invoke(target, args);</span><br><span class="line">    System.out.println(<span class="string">"Proxy after JDKInvocationHandler doOperation..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add post process logic if necessary</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将生成的代理类保存在根目录下（com/sun/proxy/XXX.class）</span></span><br><span class="line">    System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">    Subject target = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line">    Subject proxy = (Subject) Proxy.newProxyInstance(SubjectImpl.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;Subject.class&#125;, <span class="keyword">new</span> JDKInvocationHandler(target));</span><br><span class="line">    proxy.doOperation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上代码可知，使用 <code>JDK</code> 的动态代理只要 3 步：</p><ol><li>定义公共接口 <code>Subject</code>，创建被代理对象 <code>SubjectImpl</code></li><li>创建被代理对象的处理对象 <code>JDKInvocationHandler</code>，持有目标对象 <code>Subject</code> 的引用</li><li>使用 <code>JDK</code> 的 <code>Proxy</code> 类的静态方法 <code>newProxyInstance</code> 创建代理对象</li></ol><p>通过设置 <code>sun.misc.ProxyGenerator.saveGeneratedFiles</code> 属性，可以将动态生成的代理类保存在项目根目录下，运行上面的示例代码生成的代理类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">      m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">      m3 = Class.forName(<span class="string">"cn.mghio.designpattern.proxy.dynamicproxy.Subject"</span>).getMethod(<span class="string">"doOperation"</span>);</span><br><span class="line">      m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">    <span class="keyword">super</span>(var1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doOperation</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">      <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit toString、equals、hashCode method...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从动态生成的代理类的代码可以看出，<code>JDK</code> 动态代理生成的代理类是继承 <code>JDK</code> 中提供的 <code>Proxy</code> 和实现被代理类所实现的接口。进一步可以从这个实现方式得出两点：1. 使用 <code>JDK</code> 动态代理时为什么只能使用<code>接口引用指向代理</code>，而不能使用被代理的具体类引用指向代理；2. 被代理类必须实现接口，因为 <code>JDK</code> 动态代理生成的代理类必须继承自 <code>Proxy</code>，而 <code>Java</code> 不支持多重继承，所以只能通过实现接口的方式。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/239c96b9db1240a1b39a0a23877bff48~tplv-k3u1fbpfcp-zoom-1.image" alt="jdk-dynamic-proxy.png"></p><p>在默认情况下，<code>Spring AOP</code> 发现了目标对象实现了接口，会使用 <code>JDK</code> 动态代理机制为其动态生成代理对象，虽然提倡<code>面向接口编程</code>，但是也有目标对象没有实现接口的场景，当被代理的目标对象没有实现接口时就无法使用 <code>JDK</code> 动态代理了，那么这种情况下就需要使用第三方工具来帮忙了。</p><h2 id="字节码生成技术"><a href="#字节码生成技术" class="headerlink" title="字节码生成技术"></a>字节码生成技术</h2><p>当目标对象没有实现接口时，可以通过动态字节码生成来继承目标对象来动态生成相应的子类，在生成的子类中<code>重写</code>父类目标对象的行为，然后将横切逻辑放在子类，在系统中使用目标对象的子类，最终的效果是代理模式是一样的，<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a> 动态字节码生成类库（它本身其实也是一个抽象层，更底层是 <a href="https://asm.ow2.io" target="_blank" rel="noopener">ASM</a>）可以动态生成和修改一个类的字节码。当以上示例代码目标对象未实现接口时修改为 <code>CGLIB</code> 动态生成字节码方式实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-05-29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"RealSubject doOperation..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// add pre process logic if necessary</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Cglib before RealSubject doOperation..."</span>);</span><br><span class="line">    Object result = methodProxy.invokeSuper(o, args);</span><br><span class="line">    System.out.println(<span class="string">"Cglib after RealSubject doOperation..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add post process logic if necessary</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将生成的动态代理类保存到文件中</span></span><br><span class="line">    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY,</span><br><span class="line">        <span class="string">"/Users/mghio/IdeaProjects/designpattern/cglib/proxy/"</span>);</span><br><span class="line">    <span class="comment">// 1. 创建 Enhancer 对象</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="comment">// 2. 设置被代理类</span></span><br><span class="line">    enhancer.setSuperclass(RealSubject.class);</span><br><span class="line">    <span class="comment">// 3. 设置回调对象(实现 MethodInterceptor 接口)</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">new</span> CglibMethodInterceptor());</span><br><span class="line">    <span class="comment">// 4. 创建代理对象</span></span><br><span class="line">    RealSubject proxy = (RealSubject) enhancer.create();</span><br><span class="line">    proxy.doOperation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>CGLIB</code> 生成代理对象需要 4 步：</p><ol><li>创建 <code>Enhancer</code> 对象，动态生成字节码的绝大部分逻辑都是在这个类中完成的。</li><li>设置被代理类(目标对象)，生成的代理类会继承自这个接口，也就意味着这个类不能是 <code>final</code> 类型的。</li><li>设置回调对象(实现 <code>MethodInterceptor</code> 接口)，在这里根据需要添加横切逻辑。</li><li>调用 <code>Enhaner</code> 的 <code>create()</code> 方法创建代理对象。</li></ol><p>在设置 <code>DebuggingClassWriter.DEBUG_LOCATION_PROPERTY</code> 属性后，反编译已保存的动态生成代理类如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6028afa727c243cbbc335af7b60ef4ea~tplv-k3u1fbpfcp-zoom-1.image" alt="cglib-generate.png"></p><p>从反编译后的代码可以看出 <code>CGLIB</code> 生成的代理类是通过继承被代理类 <code>RealSubject</code> 实现 <code>Factory</code> 接口实现的，要能被继承也就要求被代理类不能是 <code>final</code> 类型的。看到这里你可能会问：既然 <code>JDK</code> 动态代理要求被代理类实现接口，而 <code>CGLIB</code> 动态字节码生成要求不能是 <code>final</code> 类，那对于那些没有实现接口同时还是 <code>final</code> 类，要怎么动态代理呢？好问题，这个就留给你自己去思考了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简要介绍了 <code>Spring AOP</code> 实现所依赖的核心基础技术，从动态代理的根源代理模式到动态代理和动态字节码生成技术，为下篇动手实现简易版的 <code>AOP</code> 打下基础，在了解了所依赖的基础技术后，在具体实现时就会更加丝滑，<code>动态代理</code>和<code>动态字节码生成</code>对比如下：</p><table><thead><tr><th align="center">对比项</th><th align="center">JDK 动态代理</th><th align="center">CGLIB</th></tr></thead><tbody><tr><td align="center">生成代理类的方式</td><td align="center">继承 <code>JDK</code> 中 <code>Proxy</code>，实现被代理类的所有接口</td><td align="center">继承被代理类，实现 <code>CGLIB</code> 的 <code>Factory</code> 接口</td></tr><tr><td align="center">被代理对象的要求</td><td align="center">必须实现接口，可以是 <code>final</code> 类</td><td align="center">非 <code>final</code> 类，方法也要是非 <code>final</code> 类型的</td></tr><tr><td align="center">集成方式</td><td align="center"><code>JDK</code> 内置</td><td align="center">第三方动态字节码生成类库</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/10/zDpSiZX6ThBjLyC.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上篇 &lt;a href=&quot;https://www.mghio.cn/post/9294037e.html&quot;&gt;如何实现 AOP（上）&lt;/a&gt; 介绍了 &lt;code&gt;AOP&lt;/code&gt; 技术出现的原因和一些重要的概念，在我们自己实现之前有必要先了解一下 &lt;code&gt;AOP&lt;/code&gt; 底层到底是如何运作的，所以这篇再来看看 &lt;code&gt;AOP&lt;/code&gt; 实现所依赖的一些核心基础技术。&lt;code&gt;AOP&lt;/code&gt; 是使用&lt;code&gt;动态代理&lt;/code&gt;和&lt;code&gt;字节码生成技术&lt;/code&gt;来实现的，在&lt;strong&gt;运行期&lt;/strong&gt;（注意：不是编译期！）为目标对象生成代理对象，然后将横切逻辑织入到生成的代理对象中，最后系统使用的是带有横切逻辑的代理对象，而不是被代理对象，由代理对象转发到被代理对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/categories/Java/Spring/AOP/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简易版的 Spring - 如何实现 AOP（上）</title>
    <link href="https://www.mghio.cn/post/9294037e.html"/>
    <id>https://www.mghio.cn/post/9294037e.html</id>
    <published>2021-05-22T07:47:46.000Z</published>
    <updated>2022-11-05T07:50:37.227Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/10/Pw2T431Dy6hJSUg.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是「如何实现一个简易版的 Spring 系列」的第五篇，在之前介绍了 Spring 中的核心技术之一 IoC，从这篇开始我们再来看看 Spring 的另一个重要的技术——<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="noopener">AOP</a>。用过 Spring 框架进行开发的朋友们相信或多或少应该接触过 AOP，用中文描述就是面向<strong>切面</strong>编程。学习一个新技术了解其产生的背景是至关重要的，在刚开始接触 AOP 时不知道你有没有想过这个问题，既然在面向对象的语言中已经有了 <a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">OOP</a> 了，为什么还需要 AOP 呢？换个问法也就是说在 OOP 中有哪些场景其实处理得并不优雅，需要重新寻找一种新的技术去解决处理？（P.S. 这里建议暂停十秒钟，自己先想一想…）</p><a id="more"></a><h2 id="为什么需要-AOP"><a href="#为什么需要-AOP" class="headerlink" title="为什么需要 AOP"></a>为什么需要 AOP</h2><p>我们做软件开发的最终目的是为了解决公司的各种<strong>需求</strong>，为业务赋能，注意，这里的需求包含了业务需求和系统需求，对于绝大部分的业务需求的普通关注点，都可以通过面向对象（OOP）的方式对其进行很好的抽象、封装以及模块化，但是对于系统需求使用面向对象的方式虽然很好的对其进行分解并对其模块化，但是却不能很好的避免这些<strong>类似的系统需求在系统的各个模块中到处散落</strong>的问题。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39cdb4b190b74579b335a0211d32d65b~tplv-k3u1fbpfcp-zoom-1.image" alt="why-need-aop.png"></p><p>因此，需要去重新寻找一种更好的办法，可以在基于 OOP 的基础上提供一套全新的方法来处理上面的问题，或者说是对 OOP 面向对象的开发模式做一个补充，使其可以更优雅的处理上面的问题，迄今为止 Spring 提供一个的解决方案就是面向切面编程——AOP。有了 AOP 后，我们可以将这些事务管理、系统日志以及安全检查等系统需求（横切关注点：cross-cutting concern）进行模块化的组织，使得整个系统更加的模块化方便后续的管理和维护。细心的你应该发现在 AOP 里面引入了一个关键的抽象就是切面（Aspect），用于对于系统中的一些横切关注点进行封装，要明确的一点是 AOP 和 OOP 不是非此即彼的对立关系，AOP 是对 OOP 的一种补充和完善，可以相互协作来完成需求，Aspect 对于 AOP 的重要程度就像 Class 对 OOP 一样。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99b5de1457d045f28f85f3953ad11869~tplv-k3u1fbpfcp-zoom-1.image" alt="use-aop-arc.png"></p><h2 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h2><p>我们最终的目的是要模仿 Spring 框架自己去实现一个简易版的 AOP 出来，虽然是简易版但是会涉及到 Spring AOP 中的核心思想和主要实现步骤，不过在此之前先来看看 AOP 中的重要概念，同时也是为以后的实现打下理论基础，这里需要说明一点是我不会使用中文翻译去描述这些 AOP 定义的术语（另外，业界 AOP 术语本来就不太统一），你需要重点理解的是术语在 AOP 中代表的含义，就像我们不会把 Spring 给翻译成春天一样，在软件开发交流你知道它表示一个 <figure class="highlight plain"><figcaption><span>开发框架就可以了。下面对其关键术语进行逐个介绍：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">### Joinpoint</span><br><span class="line">&gt; A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution. -- Spring Docs</span><br><span class="line"></span><br><span class="line">通过之前的介绍可知，在我们的系统运行之前，需要将 AOP 定义的一些横切关注点（功能模块）**织入**（可以简单理解为嵌入）到系统的一些业务模块当中去，想要完成织入的前提是我们需要知道可以在哪些**执行点**上进行操作，这些执行点就是 Joinpoint。下面看个简单示例：</span><br><span class="line">```Java</span><br><span class="line">/**</span><br><span class="line"> * @author mghio</span><br><span class="line"> * @since 2021-05-22</span><br><span class="line"> */</span><br><span class="line">public class Developer &#123;</span><br><span class="line"></span><br><span class="line">  private String name;</span><br><span class="line"></span><br><span class="line">  private Integer age;</span><br><span class="line"></span><br><span class="line">  private String siteUrl;</span><br><span class="line"></span><br><span class="line">  private String position;</span><br><span class="line"></span><br><span class="line">  public Developer(String name, String siteUrl) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.siteUrl = siteUrl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setSiteUrl(String siteUrl) &#123;</span><br><span class="line">    this.siteUrl = siteUrl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setAge(Integer age) &#123;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setName(String name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void setPosition(String position) &#123;</span><br><span class="line">    this.position = position;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void showMainIntro() &#123;</span><br><span class="line">    System.out.printf(&quot;name:[%s], siteUrl:[%s]\n&quot;, this.name, this.siteUrl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void showAllIntro() &#123;</span><br><span class="line">    System.out.printf(&quot;name:[%s], age:[%s], siteUrl:[%s], position:[%s]\n&quot;,</span><br><span class="line">        this.name, this.age, this.siteUrl, this.position);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-05-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeveloperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Developer developer = <span class="keyword">new</span> Developer(<span class="string">"mghio"</span>, <span class="string">"https://www.mghio.cn"</span>);</span><br><span class="line">    developer.showMainIntro();</span><br><span class="line">    developer.setAge(<span class="number">18</span>);</span><br><span class="line">    developer.setPosition(<span class="string">"中国·上海"</span>);</span><br><span class="line">    developer.showAllIntro();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上，在上面示例的这个 test() 方法调用中，我们可以选择在 Developer 的构造方法执行时进行织入，也可以在 showMainIntro() 方法的执行点上进行织入（被调用的地方或者在方法内部执行的地方），或者在 setAge() 方法设置 sge 字段时织入，实际上，只要你想可以在 test() 方法的任何一个执行点上执行织入，这些可以织入的执行点就是 Joinpoint。<br>这么说可能比较抽象，下面通过 test() 方法调用的时序图来直观的看看：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d40190763b64f10a34cdc914c9c3eb0~tplv-k3u1fbpfcp-zoom-1.image" alt="aop-weaving.png"></p><p>从方法执行的时序来看不难发现，会有如下的一些常见的 Joinpoint 类型：</p><ul><li><strong>构造方法调用（Constructor Call）</strong>。对某个对象调用其构造方法进行初始化的执行点，比如以上代码中的 Developer developer = new Developer(“mghio”, “<a href="https://www.mghio.cn&quot;);。">https://www.mghio.cn&quot;);。</a></li><li><strong>方法调用（Method call）</strong>。调用某个对象的方法时所在的执行点，实际上构造方法调用也是方法调用的一种特殊情况，只是这里的方法是构造方法而已，比如示例中的 developer.showMainIntro(); 和 developer.showAllIntro(); 都是这种类型。</li><li><strong>方法执行（Method execution）</strong>。当某个方法被调用时方法内部所处的程序的执行点，这是被调用方法内部的执行点，与方法调用不同，方法执行入以上方法时序图中标注所示。</li><li><strong>字段设置（Field set）</strong>。调用对象 setter 方法设置对象字段的代码执行点，触发点是对象的属性被设置，和设置的方式无关。以上示例中的 developer.setAge(18); 和 developer.setPosition(“中国.上海”); 都是这种类型。</li><li><strong>类初始化（Class initialization）</strong>。类中的一些静态字段或者静态代码块的初始化执行点，在以上示例中没有体现。</li><li><strong>异常执行（Exception execution）</strong>。类的某些方法抛出异常后对应的异常处理逻辑的执行点，在以上示例中没有这种类型。</li></ul><p>虽然理论上，在程序执行中的任何执行点都可以作为 Joinpoint，但是在某些类型的执行点上进行织入操作，付出的代价比较大，所以在 Spring 中的 Joinpoint 只支持方法执行（Method execution）这一种类型（这一点从 Spring 的官方文档上也有说明），实际上这种类型就可以满足绝大部分的场景了。</p><h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h3><blockquote><p>A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.– by Spring Docs</p></blockquote><p>Pointcut 表示的是一类 Jointpoint 的表述方式，在进行织入时需要根据 Pointcut 的配置，然后往那些匹配的 Joinpoint 织入横切的逻辑。这里面临的第一个问题：用人类的自然语言可以很快速的表述哪些我们需要织入的 Joinpoint，但是在代码里要如何去表述这些 Joinpoint 呢？<br>目前有如下的一些表述 Joinpoint 定义的方式：</p><ul><li><strong>直接指定织入的方法名</strong>。显而易见，这种表述方式虽然简单，但是所支持的功能比较单一，只适用于方法类型的 Joinpoint，而且当我们系统中需要织入的方法比较多时，一个一个的去定义织入的 Pointjoint 时过于麻烦。</li><li><strong>正则表达式方式</strong>。正则表达式相信大家都有一些了解，功能很强大，可以匹配表示多个不同方法类型的 Jointpoint，Spring 框架的 AOP 也支持这种表述方式。</li><li><strong>Pointcut 特定语言方式</strong>。这个因为是一种特定领域语言（DSL），所以其提供的功能也是最为灵活和丰富的，这也导致了不管其使用和实现复杂度都比较高，像 AspectJ 就是使用的这种表述方式，当然 Spring 也支持。</li></ul><p>另外 Pointcut 也支持进行一些简单的逻辑运算，这时我们就可以将多个简单的 Pointcut 通过逻辑运算组合为一个比较复杂的 Pointcut 了，比如在 Spring 配置中的 and 和 or 等逻辑运算标识符以及 AspectJ 中的 &amp;&amp; 和 || 等逻辑运算符。</p><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><blockquote><p>Action taken by an aspect at a particular join point. Different types of advice include “around”, “before” and “after” advice. (Advice types are discussed later.) Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point.– by Spring Docs</p></blockquote><p>Advice 表示的是一个注入到 Joinpoint 的横切逻辑，是一个横切关注点逻辑的抽象载体。按照 Advice 的执行点的位置和功能的不同，分为如下几种主要的类型：</p><ul><li><strong>Before Advice</strong>。Before Advice 表示是在匹配的 Joinpoint 位置之前执行的类型。如果被成功织入到方法类型的 Joinpoint 中，那么 Beofre Advice 就会在这个方法执行之前执行，还有一点需要注意的是，如果需要在 Before Advice 中结束方法的执行，我们可以通过在 Advice 中抛出异常的方式来结束方法的执行。</li><li><strong>After Advice</strong>。显而易见，After Advice 表示在配置的 Joinpoint 位置之后执行的类型。可以在细分为 After returning Advice、After throwing Advice 和 After finally Advice 三种类型。其中 After returning Advice 表示的是匹配的 Joinpoint 方法正常执行完成（没有抛出异常）后执行；After throwing Advice 表示匹配的 Joinpoint 方法执行过程中抛出异常没有正常返回后执行；After finally Advice 表示方法类型的 Joinpoint 的不管是正常执行还是抛出异常都会执行。<br>这几种 Advice 类型在方法类型的 Joinpoint 中执行顺序如下图所示：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/490b66015e4f489e967f2299297dca19~tplv-k3u1fbpfcp-zoom-1.image" alt="advice-example-location.png"></li><li><strong>Around Advice</strong>。这种类型是功能最为强大的 Advice，可以匹配的 Joinpoint 之前、之后甚至终端原来 Joinpoint 的执行流程，正常情况下，会先执行 Joinpoint 之前的执行逻辑，然后是 Joinpoint 自己的执行流程，最后是执行 Joinpoint 之后的执行逻辑。细心的你应该发现了，这不就是上面介绍的 Before Advice 和 After Advice 类型的组合吗，是的，它可以完成这两个类型的功能，不过还是要根据具体的场景选择合适的 Advice 类型。</li></ul><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h3><blockquote><p>A modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented by using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style). – Spring Docs</p></blockquote><p>Aspect 是对我们系统里的横切关注点（crosscutting concern）包装后的一个抽象概念，可以包含多个 Joinpoint 以及多个 Advice 的定义。Spring 集成了 AspectJ 后，也可以使用 @AspectJ 风格的声明式指定一个 Aspect，只要添加 @Aspect 注解即可。</p><h3 id="Target-object"><a href="#Target-object" class="headerlink" title="Target object"></a>Target object</h3><blockquote><p>An object being advised by one or more aspects. Also referred to as the “advised object”. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object. – by Spring Docs</p></blockquote><p>目标对象一般是指那些可以匹配上 Pointcut 声明条件，被织入横切逻辑的对象，正常情况下是由 Pointcut 来确定的，会根据 Pointcut 设置条件的不同而不同。<br>有了 AOP 这些概念后就可以把上文的例子再次进行整理，各个概念所在的位置如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0abeed9cebc492db22c1c94c07eb461~tplv-k3u1fbpfcp-zoom-1.image" alt="aop-concept.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文首先对 AOP 技术的诞生背景做了简要介绍，后面介绍了 AOP 的几个重要概念为后面我们自己实现简易版 AOP 打下基础，AOP 是对 OOP 的一种补充和完善，文中列出的几个概念只是 AOP 中涉及的概念中的冰山一角，想要深入了解更多的相关概念的朋友们可以看 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-introduction-defn" target="_blank" rel="noopener">官方文档</a> 学习，下篇是介绍 AOP 实现依赖的一些基础技术，敬请期待。转发、分享都是对我的支持，我将更有动力坚持原创分享！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/10/Pw2T431Dy6hJSUg.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是「如何实现一个简易版的 Spring 系列」的第五篇，在之前介绍了 Spring 中的核心技术之一 IoC，从这篇开始我们再来看看 Spring 的另一个重要的技术——&lt;a href=&quot;https://en.wikipedia.org/wiki/Aspect-oriented_programming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AOP&lt;/a&gt;。用过 Spring 框架进行开发的朋友们相信或多或少应该接触过 AOP，用中文描述就是面向&lt;strong&gt;切面&lt;/strong&gt;编程。学习一个新技术了解其产生的背景是至关重要的，在刚开始接触 AOP 时不知道你有没有想过这个问题，既然在面向对象的语言中已经有了 &lt;a href=&quot;https://en.wikipedia.org/wiki/Object-oriented_programming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OOP&lt;/a&gt; 了，为什么还需要 AOP 呢？换个问法也就是说在 OOP 中有哪些场景其实处理得并不优雅，需要重新寻找一种新的技术去解决处理？（P.S. 这里建议暂停十秒钟，自己先想一想…）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/categories/Java/Spring/AOP/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简易版的 Spring - 如何实现 @Autowired 注解</title>
    <link href="https://www.mghio.cn/post/80982e71.html"/>
    <id>https://www.mghio.cn/post/80982e71.html</id>
    <published>2021-03-07T07:44:29.000Z</published>
    <updated>2022-11-05T07:46:40.621Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/12/xwcrdv6a7CHq5T8.jpg" alt="cover.jpg"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文是 <code>如何实现一个简易版的 Spring</code> 系列第四篇，在 <a href="https://www.mghio.cn/post/6775e26e.html">上篇</a> 介绍了 <code>@Component</code> 注解的实现，这篇再来看看在使用 <code>Spring</code> 框架开发中常用的 <code>@Autowired</code> 注入要如何实现，大家用过 <code>Spring</code> 都知道，该注解可以用在<code>字段</code>、<code>构造函数</code>以及<code>setter 方法</code>上，限于篇幅原因我们主要讨论用在字段的方式实现，其它的使用方式大体思路是相同的，不同的只是解析和注入方式有所区别，话不多说，下面进入我们今天的正题—<code>如何实现一个简易版的 Spring - 如何实现 @Autowired 注解</code>。</p><a id="more"></a><h4 id="实现步骤拆分"><a href="#实现步骤拆分" class="headerlink" title="实现步骤拆分"></a>实现步骤拆分</h4><p>实现步骤总的来说分为三大步：</p><ol><li>分析总结要做的事情，抽象出数据结构</li><li>利用这些数据结构来做一些事情</li><li>在某个时机注入到 <code>Spring</code> 容器中</li></ol><p>细心的朋友可以发现，其实前面几篇文章的实现也是套路，其中最为关键也是比较困难的点就是如何抽象出数据结构。这里我们要做的是当某个 <code>Bean</code> 上的字段有 <code>@Autowired</code> 注解时，从容器中获取该类型的 <code>Bean</code> 然后调用该字段对应的 <code>setter</code> 方法设置到对象的属性中。下面就跟着这个思路去实现 <code>@Autowired</code> 注解。</p><h4 id="数据结构抽象"><a href="#数据结构抽象" class="headerlink" title="数据结构抽象"></a>数据结构抽象</h4><p>要想根据字段的类型注入在容器中对应的实例，首先需要提供这个从一个类型获取对应 <code>Bean</code> 实例的能力，这需要 <code>BeanFactory</code> 接口提供一个这样的能力，等等，像这样容器内部使用的接口直接定义在 <code>BeanFactory</code> 好吗？像这种内部的操作应该尽量做到对使用者透明，所以这里新加一个接口 <code>AutowireCapableBeanFactory</code> 继承自 <code>BeanFactory</code>，这样在内部就可以直接使用新接口接口。需要注意的是新接口的方法参数并不能直接使用 <code>Class</code> 类型去容器中查找对应的 <code>Bean</code>，为了后期的灵活扩展（比如：是否必须依赖等），需要使用一个类来描述这种依赖，命名为 <code>DependencyDescriptor</code>，其部分源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyDescriptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Field field;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> required;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DependencyDescriptor</span><span class="params">(Field field, <span class="keyword">boolean</span> required)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(field, <span class="string">"Field must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.field = field;</span><br><span class="line">    <span class="keyword">this</span>.required = required;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getDependencyType() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.field != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> field.getType();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"only support field dependency"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.required;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口 <code>AutowireCapableBeanFactory</code> 声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">resolveDependency</span><span class="params">(DependencyDescriptor descriptor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找解析依赖的功能我们抽象完成了，下面来看看核心步骤如何抽象封装注入的过程，抽象总结后不难发现，注入可以分为两大部分：<code>注入的目标对象</code> 和 <code>需要被注入的元素列表</code>，这些对于注入来说是一些<code>元数据</code>，命名为 <code>InjectionMetadata</code>，其包含两个字段，一个是注入的目标对象，另一个是被注入的元素列表，还有一个重要的方法将元素列表注入到方法参数传入的目标对象中去。</p><p>每个注入元素都要提供一个注入到指定目标对象的能力，所以抽取出公共抽象父类 <code>InjectionElement</code>，使用上文的 <code>AutowireCapableBeanFactory</code> 接口解析出当前字段类型对应 <code>Bean</code>，然后注入到指定的目标对象中。抽象父类 <code>InjectinElement</code> 的主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectionElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Member member;</span><br><span class="line">  <span class="keyword">protected</span> AutowireCapableBeanFactory factory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InjectionElement</span><span class="params">(Member member, AutowireCapableBeanFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.member = member;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入元数据类 <code>InjectionMetadata</code> 的主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectionMetadata</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetClass;</span><br><span class="line">  <span class="keyword">private</span> List&lt;InjectionElement&gt; injectionElements;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InjectionMetadata</span><span class="params">(Class&lt;?&gt; targetClass, List&lt;InjectedElement&gt; injectionElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.targetClass = targetClass;</span><br><span class="line">    <span class="keyword">this</span>.injectionElements = injectionElements;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (injectionElements == <span class="keyword">null</span> || injectionElements.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (InjectionElement element : injectionElements) &#123;</span><br><span class="line">      element.inject(target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把一个 <code>Class</code> 转换为 <code>InjectionMetadata</code> 的部分实现我们留到下文实现部分介绍，抽象后总的流程就是把一个 <code>Class</code> 转换为 <code>InjectionMedata</code> ，然后调用 <code>InjectionMedata</code> 提供的  <code>inject(Object)</code> 方法来完成注入（依赖 <code>AutowireCapableBeanFactory</code> 接口提供的 <code>resolveDependency(DependencyDescriptor)</code> 能力），下面是抽象后的字段注入部分的相关类图关系如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5060977e0a674d668be6c1cb9fbbd764~tplv-k3u1fbpfcp-zoom-1.image" alt="autowried-arc.png"></p><h4 id="解析构造出定义的数据结构"><a href="#解析构造出定义的数据结构" class="headerlink" title="解析构造出定义的数据结构"></a>解析构造出定义的数据结构</h4><p>在上文我们还没实现将一个类转换为 <code>InjectionMetadata</code> 的操作，也就是需要实现这样的一个方法 <code>InjectionMetadata buildAutowiringMetadata(Class&lt;?&gt; clz)</code>，实现过程也比较简单，扫描类中声明的属性找到有 <code>@Autowried</code> 注解解析构造出 <code>InjectinMetadata</code> 实例，核心实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredAnnotationProcessor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String requiredParameterName = <span class="string">"required"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> requiredParameterValue = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; autowiredAnnotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AutowiredAnnotationProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(Class&lt;?&gt; clz)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;InjectionElement&gt; elements = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clz;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      LinkedList&lt;InjectionElement&gt; currElements = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (Field field : targetClass.getDeclaredFields()) &#123;</span><br><span class="line">        Annotation ann = findAutowiredAnnotation(field);</span><br><span class="line">        <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">          elements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required, beanFactory));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">      targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125; <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clz, elements);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">determineRequiredStatus</span><span class="params">(Annotation ann)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Method method = ReflectionUtils.findMethod(ann.annotationType(), <span class="keyword">this</span>.requiredParameterName);</span><br><span class="line">      <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">this</span>.requiredParameterValue == (Boolean) ReflectionUtils.invokeMethod(method, ann));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Annotation <span class="title">findAutowiredAnnotation</span><span class="params">(AccessibleObject ao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotationType : <span class="keyword">this</span>.autowiredAnnotationTypes) &#123;</span><br><span class="line">      Annotation ann = AnnotationUtils.getAnnotation(ao, annotationType);</span><br><span class="line">      <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ann;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面在做数据结构抽象时定义好了注入元素的抽象父类 <code>InjectionElement</code>，这里需要定义一个子类表示字段注入类型，命名为 <code>AutowiredFieldElement</code>，依赖 <code>AutowireCapableBeanFactory</code> 接口的能力解析出字段所属类型的 <code>Bean</code>，然后调用属性的 <code>setter</code> 方法完成注入，在基于我们上面定义好的数据结构后实现比较简单，主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredFieldElement</span> <span class="keyword">extends</span> <span class="title">InjectionElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> required;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AutowiredFieldElement</span><span class="params">(Field field, <span class="keyword">boolean</span> required, AutowireCapableBeanFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(field, factory);</span><br><span class="line">    <span class="keyword">this</span>.required = required;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Field) <span class="keyword">this</span>.member;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    Field field = <span class="keyword">this</span>.getField();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      DependencyDescriptor descriptor = <span class="keyword">new</span> DependencyDescriptor(field, <span class="keyword">this</span>.required);</span><br><span class="line">      Object value = factory.resolveDependency(descriptor);</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ReflectionUtils.makeAccessible(field);</span><br><span class="line">        field.set(target, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(<span class="string">"Could not autowire field:"</span> + field, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注入到-Spring-中"><a href="#注入到-Spring-中" class="headerlink" title="注入到 Spring 中"></a>注入到 Spring 中</h4><p>接下来面临的问题是：要在什么时候调用上面这些类和方法呢？在这里我们回顾一下 <code>Spring</code> 中 <code>Bean</code> 的生命周期，其中几个钩子入口如下图所示：</p><p><img src="https://i.loli.net/2021/03/07/xHE2FLZUG1DsTvA.png" alt="bean-lifecycle.png"></p><p>通过生命周期开放的钩子方法可以看出我们需要在 <code>InstantiationAwareBeanPostProcessor</code> 接口的 <code>postProcessPropertyValues</code> 方法中实现 <code>Autowired</code> 注入，将前面的 <code>AutowiredAnnotationProcessor</code> 类实现该接口然后在 <code>postProcessPropertyValues</code> 方法处理注入即可。这部分的整体类图如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7b63931313d4fbdada93362cfcdcc1c~tplv-k3u1fbpfcp-zoom-1.image" alt="AutowriedAnnotationProcessor.png"></p><p> <code>AutowiredAnnotationProcessor</code> 处理器实现的 <code>postProcessPropertyValues()</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredAnnotationProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanProcessor</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessPropertyValues</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = <span class="keyword">this</span>.buildAutowiringMetadata(bean.getClass());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      metadata.inject(bean);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of autowired dependencies failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后只需要在抽象父类 <code>AbstractApplicationContext</code> 构造函数注册那些我们定义的 <code>processor</code>，然后在 <code>Bean</code> 注入的时候(<code>DefaultBeanFactory.populateBean()</code>)调用 <code>processor</code> 的 <code>postProcessPropertyValues</code> 方法完成属性注入，抽象类 <code>AbstractApplicationContext</code> 改动部分的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(String configFilePath)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    registerBeanPostProcessor(beanFactory);</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessor</span><span class="params">(ConfigurableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    AutowiredAnnotationProcessor postProcessor = <span class="keyword">new</span> AutowiredAnnotationProcessor();</span><br><span class="line">    postProcessor.setBeanFactory(beanFactory);</span><br><span class="line">    beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BeanFactory</code> 接口的默认实现类 <code>DefaultBeanFactory</code> 注入 <code>Bean</code> 属性的方法 <code>populateBean(BeanDefinition, Object)</code> 改动如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...      </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BeanPostProcessor&gt; beanPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(BeanDefinition bd, Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor postProcessor : <span class="keyword">this</span>.getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> InstantiationAwareBeanProcessor) &#123;</span><br><span class="line">                ((InstantiationAwareBeanProcessor) postProcessor).postProcessPropertyValues(bean, bd.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">    &#125;      </span><br><span class="line">          </span><br><span class="line">    ...      </span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说整个使用 <code>processor</code> 的过程分为两步，首先在 <code>AbstractApplicationContext</code> 构造方法中注册我们自定义的 <code>processor</code>，然后再 <code>DefaultBeanFactory</code> 中调用其 <code>postProcessPropertyValues</code> 方法进行注入，至此使用在类字段上的 <code>@Autowired</code> 注解实现完成。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简要介绍了实现 <code>Spring</code> 的 <code>@Autowired</code> 注解（使用在类字段上的方式），其中比较麻烦的步骤是数据结构抽象部分，需要考虑到后期的扩展性和内部操作对使用者尽量透明，限于篇幅，只列出了部分核心实现代码，完整代码已上传至 <a href="https://github.com/mghio/mghio-spring" target="_blank" rel="noopener">GitHub</a> ，感兴趣的朋友可以查看完整代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/12/xwcrdv6a7CHq5T8.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;本文是 &lt;code&gt;如何实现一个简易版的 Spring&lt;/code&gt; 系列第四篇，在 &lt;a href=&quot;https://www.mghio.cn/post/6775e26e.html&quot;&gt;上篇&lt;/a&gt; 介绍了 &lt;code&gt;@Component&lt;/code&gt; 注解的实现，这篇再来看看在使用 &lt;code&gt;Spring&lt;/code&gt; 框架开发中常用的 &lt;code&gt;@Autowired&lt;/code&gt; 注入要如何实现，大家用过 &lt;code&gt;Spring&lt;/code&gt; 都知道，该注解可以用在&lt;code&gt;字段&lt;/code&gt;、&lt;code&gt;构造函数&lt;/code&gt;以及&lt;code&gt;setter 方法&lt;/code&gt;上，限于篇幅原因我们主要讨论用在字段的方式实现，其它的使用方式大体思路是相同的，不同的只是解析和注入方式有所区别，话不多说，下面进入我们今天的正题—&lt;code&gt;如何实现一个简易版的 Spring - 如何实现 @Autowired 注解&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简易版的 Spring - 如何实现 @Component 注解</title>
    <link href="https://www.mghio.cn/post/6775e26e.html"/>
    <id>https://www.mghio.cn/post/6775e26e.html</id>
    <published>2021-02-14T07:39:19.000Z</published>
    <updated>2022-11-05T07:43:07.083Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/12/ZaBY1LuEdOXKV3k.jpg" alt="cover.jpg"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前面两篇文章（<a href="https://www.mghio.cn/post/5731122e.html">如何实现一个简易版的 Spring - 如何实现 Setter 注入</a>、<a href="https://www.mghio.cn/post/315ff4dc.html">如何实现一个简易版的 Spring - 如何实现 Constructor 注入</a>）介绍的都是基于 <code>XML</code> 配置文件方式的实现，从 <code>JDK 5</code> 版本开始 <code>Java</code> 引入了注解支持，带来了极大的便利，<code>Sprinng</code> 也从 <code>2.5</code> 版本开始支持注解方式，使用注解方式我们只需加上相应的注解即可，不再需要去编写繁琐的 <code>XML</code> 配置文件，深受广大 <code>Java</code> 编程人员的喜爱。接下来一起看看如何实现 <code>Spring</code> 框架中最常用的两个注解（<code>@Component</code>、<code>@Autowired</code>），由于涉及到的内容比较多，会分为两篇文章进行介绍，本文先来介绍上半部分 — <strong>如何实现 <code>@Component</code> 注解</strong>。</p><a id="more"></a><h4 id="实现步骤拆分"><a href="#实现步骤拆分" class="headerlink" title="实现步骤拆分"></a>实现步骤拆分</h4><p>本文实现的注解虽然说不用再配置 <code>XML</code> 文件，但是有点需要明确的是指定扫描 <code>Bean</code> 的包还使用 <code>XML</code> 文件的方式配置的，只是指定 <code>Bean</code> 不再使用配置文件的方式。有前面两篇文章的基础后实现 <code>@Component</code> 注解主要分成以下几个步骤：</p><ol><li>读取 <code>XML</code> 配置文件，解析出需要扫描的包路径</li><li>对解析后的包路径进行扫描然后读取标有 <code>@Component</code> 注解的类，创建出对应的 <code>BeanDefinition</code></li><li>根据创建出来的 <code>BeanDefinition</code> 创建对应的 <code>Bean</code> 实例</li></ol><p>下面我们一步步来实现这几个步骤，最后去实现 <code>@Component</code> 注解：</p><h4 id="读取-XML-配置文件，解析出需要扫描的包路径"><a href="#读取-XML-配置文件，解析出需要扫描的包路径" class="headerlink" title="读取 XML 配置文件，解析出需要扫描的包路径"></a>读取 <code>XML</code> 配置文件，解析出需要扫描的包路径</h4><p>假设有如下的 <code>XML</code> 配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.e3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:scann-package</span> <span class="attr">base-package</span>=<span class="string">"cn.mghio.service.version4,cn.mghio.dao.version4"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们期望的结果是解析出来的扫描包路径为： <code>cn.mghio.service.version4</code>、<code>cn.mghio.dao.version4</code> 。如果有仔细有了前面的文章后，这个其实就比较简单了，只需要修改读取 <code>XML</code> 配置文件的类 <code>XmlBeanDefinitionReader</code> 中的 <code>loadBeanDefinition(Resource resource)</code> 方法，判断当前的 <code>namespace</code> 是否为 <code>context</code> 即可，修改该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinition</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> (InputStream is = resource.getInputStream()) &#123;</span><br><span class="line">    SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    Document document = saxReader.read(is);</span><br><span class="line">    Element root = document.getRootElement();  <span class="comment">// &lt;beans&gt;</span></span><br><span class="line">    Iterator&lt;Element&gt; iterator = root.elementIterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      Element element = iterator.next();</span><br><span class="line">      String namespaceUri = element.getNamespaceURI();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isDefaultNamespace(namespaceUri)) &#123;  <span class="comment">// beans</span></span><br><span class="line">        parseDefaultElement(element);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.isContextNamespace(namespaceUri)) &#123;  <span class="comment">// context</span></span><br><span class="line">        parseComponentElement(element);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (DocumentException | IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionException(<span class="string">"IOException parsing XML document:"</span> + resource, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseComponentElement</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 从 XML 配置文件中获取需要的扫描的包路径</span></span><br><span class="line">  String basePackages = element.attributeValue(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">  <span class="comment">// TODO 2. 对包路径进行扫描然后读取标有 `@Component` 注解的类，创建出对应的 `BeanDefinition`</span></span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContextNamespace</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// CONTEXT_NAMESPACE_URI = http://www.springframework.org/schema/context</span></span><br><span class="line">  <span class="keyword">return</span> (StringUtils.hasLength(namespaceUri) &amp;&amp; CONTEXT_NAMESPACE_URI.equals(namespaceUri));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// BEAN_NAMESPACE_URI = http://www.springframework.org/schema/beans</span></span><br><span class="line">  <span class="keyword">return</span> (StringUtils.hasLength(namespaceUri) &amp;&amp; BEAN_NAMESPACE_URI.equals(namespaceUri));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个步骤就已经完成了，其实相对来说还是比较简单的，接下来看看第二步要如何实现。</p><h4 id="对解析后的包路径进行扫描然后读取标有-Component-注解的类，创建出对应的-BeanDefinition"><a href="#对解析后的包路径进行扫描然后读取标有-Component-注解的类，创建出对应的-BeanDefinition" class="headerlink" title="对解析后的包路径进行扫描然后读取标有 @Component 注解的类，创建出对应的 BeanDefinition"></a>对解析后的包路径进行扫描然后读取标有 <code>@Component</code> 注解的类，创建出对应的 <code>BeanDefinition</code></h4><p>第二步是整个实现步骤中最为复杂和比较麻烦的一步，当面对一个任务比较复杂而且比较大时，可以对其进行适当的拆分为几个小步骤分别去实现，这里可以其再次拆分为如下几个小步骤：</p><ol><li>扫描包路径下的字节码（<code>.class</code> ）文件并转换为一个个 <code>Resource</code> 对象（其对于 <code>Spring</code> 框架来说是一种资源，在 <code>Spring</code> 中资源统一抽象为 <code>Resource</code> ，这里的字节码文件具体为 <code>FileSystemResource</code>）</li><li>读取转换好的 <code>Resource</code> 中的 <code>@Component</code> 注解</li><li>根据读取到的 <code>@Component</code> 注解信息创建出对应的 <code>BeanDefintion</code></li></ol><h5 id="①-扫描包路径下的字节码（-class-）文件并转换为一个个-Resource-对象（其对于-Spring-框架来说是一种资源，在-Spring-中资源统一抽象为-Resource-，这里的字节码文件具体为-FileSystemResource）"><a href="#①-扫描包路径下的字节码（-class-）文件并转换为一个个-Resource-对象（其对于-Spring-框架来说是一种资源，在-Spring-中资源统一抽象为-Resource-，这里的字节码文件具体为-FileSystemResource）" class="headerlink" title="① 扫描包路径下的字节码（.class ）文件并转换为一个个 Resource 对象（其对于 Spring 框架来说是一种资源，在 Spring 中资源统一抽象为 Resource ，这里的字节码文件具体为 FileSystemResource）"></a>① 扫描包路径下的字节码（<code>.class</code> ）文件并转换为一个个 <code>Resource</code> 对象（其对于 <code>Spring</code> 框架来说是一种资源，在 <code>Spring</code> 中资源统一抽象为 <code>Resource</code> ，这里的字节码文件具体为 <code>FileSystemResource</code>）</h5><p>第一小步主要是实现从一个指定的包路径下获取该包路径下对应的字节码文件并将其转化为 <code>Resource</code> 对象，将该类命名为 <code>PackageResourceLoader</code>，其提供一个主要方法是 <code>Resource[] getResources(String basePackage)</code> 用来将一个给定的包路径下的字节码文件转换为 <code>Resource</code> 数组，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageResourceLoader</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> Resource[] getResources(String basePackage) &#123;</span><br><span class="line">        Assert.notNull(basePackage, <span class="string">"basePackage must not be null"</span>);</span><br><span class="line">        String location = ClassUtils.convertClassNameToResourcePath(basePackage);</span><br><span class="line">        ClassLoader classLoader = getClassLoader();</span><br><span class="line">        URL url = classLoader.getResource(location);</span><br><span class="line">        Assert.notNull(url, <span class="string">"URL must not be null"</span>);</span><br><span class="line">        File rootDir = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line"></span><br><span class="line">        Set&lt;File&gt; matchingFile = retrieveMatchingFiles(rootDir);</span><br><span class="line">        Resource[] result = <span class="keyword">new</span> Resource[matchingFile.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (File file : matchingFile) &#123;</span><br><span class="line">            result[i++] = <span class="keyword">new</span> FileSystemResource(file);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;File&gt; <span class="title">retrieveMatchingFiles</span><span class="params">(File rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rootDir.exists() || !rootDir.isDirectory() || !rootDir.canRead()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;File&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">        doRetrieveMatchingFiles(rootDir, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRetrieveMatchingFiles</span><span class="params">(File dir, Set&lt;File&gt; result)</span> </span>&#123;</span><br><span class="line">        File[] dirContents = dir.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (dirContents == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (File content : dirContents) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!content.isDirectory()) &#123;</span><br><span class="line">                result.add(content);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (content.canRead()) &#123;</span><br><span class="line">                doRetrieveMatchingFiles(content, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的第一小步至此已经完成了，下面继续看第二小步。</p><h5 id="②-读取转换好的-Resource-中的-Component-注解"><a href="#②-读取转换好的-Resource-中的-Component-注解" class="headerlink" title="② 读取转换好的 Resource 中的 @Component 注解"></a>② 读取转换好的 <code>Resource</code> 中的 <code>@Component</code> 注解</h5><p>要实现第二小步（读取转换好的 <code>Resource</code> 中的 <code>@Component</code> 注解），首先面临的第一个问题是：<code>如何读取字节码？</code>，熟悉字节结构的朋友可以字节解析读取，但是难度相对比较大，而且也比较容易出错，这里读取字节码的操作我们使用著名的字节码操作框架 <a href="https://asm.ow2.io" target="_blank" rel="noopener">ASM</a> 来完成底层的操作，官网对其的描述入下：</p><blockquote><p><strong>ASM</strong> is an all purpose Java bytecode manipulation and analysis framework. </p></blockquote><p>其描述就是：<code>ASM</code> 是一个通用的 <code>Java</code> 字节码操作和分析框架。其实不管是在工作或者日常学习中，我们对于一些比较基础的库和框架，如果有成熟的开源框架使用其实没有从零开发（当然，本身就是想要研究其源码的除外），这样可以减少不必要的开发成本和精力。<code>ASM</code> 基于 <code>Visitor</code> 模式可以方便的读取和修改字节码，目前我们只需要使用其读取字节码的功能。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a47a511bba614227939e529ceecf6d1e~tplv-k3u1fbpfcp-zoom-1.image" alt="asm-sequence-diagram.png"></p><p><code>ASM</code> 框架中分别提供了 <code>ClassVisitor</code> 和 <code>AnnotationVisitor</code> 两个抽象类来访问类和注解的字节码，我们可以使用这两个类来获取类和注解的相关信息。很明显我们需要继承这两个类然后覆盖其中的方法增加自己的逻辑去完成信息的获取，要如何去描述一个类呢？其实比较简单无非就是 <code>类名</code>、<code>是否是接口</code>、<code>是否是抽象类</code>、<code>父类的类名</code>、<code>实现的接口列表</code> 等这几项。</p><p>但是一个注解要如何去描述它呢？注解其实我们主要关注注解的类型和其所包含的属性，类型就是一个 <code>包名 + 注解名</code> 的字符串表达式，而属性本质上是一种 <code>K-V</code> 的映射，值类型可能为 <code>数字</code>、<code>布尔</code>、<code>字符串</code> 以及 <code>数组</code> 等，为了方便使用可以继承自 <code>LinkedHashMap&lt;String, Object&gt;</code> 封装一些方便的获取属性值的方法，读取注解部分的相关类图设计如下：</p><p><img src="https://i.loli.net/2021/02/14/AWDROochqdkHxEv.png" alt="spring-annotation-reading.png"></p><p>其中绿色背景的 <code>ClassVisitor</code> 和 <code>AnnotationVisitor</code> 是 <code>ASM</code> 框架提供的类，<code>ClassMetadata</code> 是类相关的元数据接口，<code>AnnotationMetadata</code> 是注解相关的元数据接口继承自 <code>ClassMetadata</code>，<code>AnnotationAttributes</code> 是对注解属性的描述，继承自 <code>LinkedHashMap</code> 主要是封装了获取指定类型 <code>value</code> 的方法，还有三个自定义的 <code>Visitor</code> 类是本次实现的关键，第一个类 <code>ClassMetadataReadingVisitor</code> 实现了 <code>ClassVisitor</code> 抽象类，用来获取字节码文件中类相关属性的提取，其代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassMetadataReadingVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> <span class="keyword">implements</span> <span class="title">ClassMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean isInterface;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean isAbstract;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassMetadataReadingVisitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM7);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = ClassUtils.convertResourcePathToClassName(name);</span><br><span class="line">        <span class="keyword">this</span>.isInterface = ((access &amp; Opcodes.ACC_INTERFACE) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.isAbstract = ((access &amp; Opcodes.ACC_ABSTRACT) != <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isAbstract;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个类 <code>AnnotationMetadataReadingVisitor</code> 用来获取注解的类型，然后通过构造方法传给 <code>AnnotataionAttributesVisitor</code>，为获取注解属性做准备，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationMetadataReadingVisitor</span> <span class="keyword">extends</span> <span class="title">ClassMetadataReadingVisitor</span> <span class="keyword">implements</span> <span class="title">AnnotationMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; annotationSet = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, AnnotationAttributes&gt; attributesMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String descriptor, <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">        String className = Type.getType(descriptor).getClassName();</span><br><span class="line">        <span class="keyword">this</span>.annotationSet.add(className);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationAttributesReadingVisitor(className, <span class="keyword">this</span>.attributesMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.hasText(getSuperClassName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.annotationSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAnnotation</span><span class="params">(String annotationType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.annotationSet.contains(annotationType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationAttributes <span class="title">getAnnotationAttributes</span><span class="params">(String annotationType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attributesMap.get(annotationType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三个类 <code>AnnotationAttributesReadingVisitor</code> 根据类 <code>AnnotationMetadataReadingVisitor</code> 传入的注解类型和属性集合，获取并填充注解对应的属性，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAttributesReadingVisitor</span> <span class="keyword">extends</span> <span class="title">AnnotationVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String annotationType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, AnnotationAttributes&gt; attributesMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnnotationAttributes attributes = <span class="keyword">new</span> AnnotationAttributes();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationAttributesReadingVisitor</span><span class="params">(String annotationType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Map&lt;String, AnnotationAttributes&gt; attributesMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Opcodes.ASM7);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.annotationType = annotationType;</span><br><span class="line">        <span class="keyword">this</span>.attributesMap = attributesMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(String attributeName, Object attributeValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attributes.put(attributeName, attributeValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attributesMap.put(<span class="keyword">this</span>.annotationType, <span class="keyword">this</span>.attributes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类做的使用比较简单，就是当每访问当前注解的一个属性时，将其保存下来，最后当访问完成时以 <code>K-V</code> （<code>key</code> 为注解类型全名称，value 为注解对应的属性集合）的形式存入到 <code>Map</code> 中，比如，当我访问如下的类时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(value = <span class="string">"orderService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 <code>AnnotationAttributesReadingVisitor</code> 类的 <code>visit(String, Object)</code> 方法的参数即为当前注解的属性和属性的取值如下：</p><p><img src="https://i.loli.net/2021/02/14/TAdV8sbhznel7KU.png" alt="annotatoin-attributes-reading.png"></p><p>至此我们已经完成了第二步中的前半部分的扫描指定包路径下的类并读取注解，虽然功能已经实现了，但是对应使用者来说还是不够友好，还需要关心一大堆相关的 <code>Visitor</code> 类，这里能不能再做一些封装呢？此时相信爱思考的你脑海里应该已经浮现了一句计算机科学界的名言：</p><blockquote><p>计算机科学的任何一个问题，都可以通过增加一个中间层来解决。</p></blockquote><p>仔细观察可以发现，以上读取类和注解相关信息的本质是元数据的读取，上文提到的 <code>Resource</code> 其实也是一中元数据，提供信息读取来源，将该接口命名为 <code>MetadataReader</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MetadataReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ClassMetadata <span class="title">getClassMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AnnotationMetadata <span class="title">getAnnotationMetadata</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要提供该接口的实现，我们期望的最终结果是只要面向 <code>MetadataReader</code> 接口编程即可，只要传入 <code>Resource</code>  就可以获取 <code>ClassMetadata</code> 和 <code>AnnotationMetadata</code> 等信息，无需关心那些 <code>visitor</code>，将该实现类命名为 <code>SimpleMetadataReader</code>，其代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMetadataReader</span> <span class="keyword">implements</span> <span class="title">MetadataReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Resource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassMetadata classMetadata;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata annotationMetadata;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMetadataReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassReader classReader;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> BufferedInputStream(resource.getInputStream())) &#123;</span><br><span class="line">            classReader = <span class="keyword">new</span> ClassReader(is);</span><br><span class="line">        &#125;</span><br><span class="line">        AnnotationMetadataReadingVisitor visitor = <span class="keyword">new</span> AnnotationMetadataReadingVisitor();</span><br><span class="line">        classReader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">        <span class="keyword">this</span>.classMetadata = visitor;</span><br><span class="line">        <span class="keyword">this</span>.annotationMetadata = visitor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.resource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassMetadata <span class="title">getClassMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.classMetadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationMetadata <span class="title">getAnnotationMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.annotationMetadata;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时只需要在构造 <code>SimpleMetadataReader</code> 传入对应的 <code>Resource</code> 即可，如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bed841068764e038a07b11fefffc32d~tplv-k3u1fbpfcp-zoom-1.image" alt="metadata-reader.png"></p><p>到这里第二小步从字节码中读取注解的步骤已经完成了。</p><h5 id="③-根据读取到的-Component-注解信息创建出对应的-BeanDefintion"><a href="#③-根据读取到的-Component-注解信息创建出对应的-BeanDefintion" class="headerlink" title="③ 根据读取到的 @Component 注解信息创建出对应的 BeanDefintion"></a>③ 根据读取到的 <code>@Component</code> 注解信息创建出对应的 <code>BeanDefintion</code></h5><p>为了使之前定义好的 <code>BeanDefinition</code> 结构保持纯粹不被破坏，这里我们再增加一个针对注解的 <code>AnnotatedBeanDefinition</code> 接口继承自   <code>BeanDefinition</code> 接口，接口比较简单只有一个获取注解元数据的方法，定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">AnnotationMetadata <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时增加一个该接口的实现类，表示从扫描注解生成的 <code>BeanDefinition</code>，将其命名为 <code>ScannedGenericBeanDefinition</code>，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannedGenericBeanDefinition</span> <span class="keyword">extends</span> <span class="title">GenericBeanDefinition</span> <span class="keyword">implements</span> <span class="title">AnnotatedBeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnnotationMetadata metadata;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScannedGenericBeanDefinition</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.metadata = metadata;</span><br><span class="line">        setBeanClassName(<span class="keyword">this</span>.metadata.getClassName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationMetadata <span class="title">getMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.metadata;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个问题就是使用注解的方式时该如何生成 <code>Bean</code> 的名字，这里我们采用和 <code>Spring</code> 一样的策略，当在注解指定 <code>Bean</code> 的名字时使用指定的值为 <code>Bean</code> 的名字，否则使用类名的首字母小写为生成 <code>Bean</code> 的名字， 很明显这只是其中的一种默认实现策略，因此需要提供一个生成 <code>Baen</code> 名称的接口供后续灵活替换生成策略，接口命名为 <code>BeanNameGenerator</code> ，接口只有一个生成 <code>Bean</code> 名称的方法，其定义如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">generateBeanName</span><span class="params">(BeanDefinition bd, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其默认的生成策略实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationBeanNameGenerator</span> <span class="keyword">implements</span> <span class="title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> beanName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildDefaultBeanName(definition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">        String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());</span><br><span class="line">        <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">determineBeanNameFromAnnotation</span><span class="params">(AnnotatedBeanDefinition definition)</span> </span>&#123;</span><br><span class="line">        AnnotationMetadata metadata = definition.getMetadata();</span><br><span class="line">        Set&lt;String&gt; types = metadata.getAnnotationTypes();</span><br><span class="line">        String beanName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">            AnnotationAttributes attributes = metadata.getAnnotationAttributes(type);</span><br><span class="line">            <span class="keyword">if</span> (attributes.get(<span class="string">"value"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object value = attributes.get(<span class="string">"value"</span>);</span><br><span class="line">                <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    String stringVal = (String) value;</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(stringVal)) &#123;</span><br><span class="line">                        beanName = stringVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanName;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们再定义一个扫描器类组合以上的功能提供一个将包路径下的类读取并转换为对应的 <code>BeanDefinition</code>  方法，将该类命名为 <code>ClassPathBeanDefinitionScanner</code>，其代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-02-14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SEMICOLON_SEPARATOR = <span class="string">","</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PackageResourceLoader resourceLoader = <span class="keyword">new</span> PackageResourceLoader();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanNameGenerator beanNameGenerator = <span class="keyword">new</span> AnnotationBeanNameGenerator();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registry = registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">doScanAndRegistry</span><span class="params">(String packageToScan)</span> </span>&#123;</span><br><span class="line">        String[] basePackages = StringUtils.tokenizeToStringArray(packageToScan, SEMICOLON_SEPARATOR);</span><br><span class="line"></span><br><span class="line">        Set&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">                beanDefinitions.add(candidate);</span><br><span class="line">                registry.registerBeanDefinition(candidate.getId(), candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource[] resources = <span class="keyword">this</span>.resourceLoader.getResources(basePackage);</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                MetadataReader metadataReader = <span class="keyword">new</span> SimpleMetadataReader(resource);</span><br><span class="line">                <span class="keyword">if</span> (metadataReader.getAnnotationMetadata().hasAnnotation(Component.class.getName())) &#123;</span><br><span class="line">                    ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader.getAnnotationMetadata());</span><br><span class="line">                    String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(sbd, registry);</span><br><span class="line">                    sbd.setId(beanName);</span><br><span class="line">                    candidates.add(sbd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidates;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就已经把读取到的 <code>@Component</code> 注解信息转换为 <code>BeanDefinition</code> 了。</p><h4 id="根据创建出来的-BeanDefinition-创建对应的-Bean-实例"><a href="#根据创建出来的-BeanDefinition-创建对应的-Bean-实例" class="headerlink" title="根据创建出来的 BeanDefinition 创建对应的 Bean 实例"></a>根据创建出来的 <code>BeanDefinition</code> 创建对应的 <code>Bean</code> 实例</h4><p>这一步其实并不需要再修改创建 <code>Bean</code> 的代码了，创建的逻辑都是一样的，只需要将之前读取 <code>XML</code> 配置文件那里使用上文提到的扫描器 <code>ClassPathBeanDefinitionScanner</code> 扫描并注册到 <code>BeanFactory</code> 中即可，读取配置文件的 <code>XmlBeanDefinitionReader</code> 类的读取解析配置文件的方法修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinition</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> (InputStream is = resource.getInputStream()) &#123;</span><br><span class="line">    SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    Document document = saxReader.read(is);</span><br><span class="line">    Element root = document.getRootElement();  <span class="comment">// &lt;beans&gt;</span></span><br><span class="line">    Iterator&lt;Element&gt; iterator = root.elementIterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">      Element element = iterator.next();</span><br><span class="line">      String namespaceUri = element.getNamespaceURI();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">        parseDefaultElement(element);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.isContextNamespace(namespaceUri)) &#123;</span><br><span class="line">        parseComponentElement(element);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (DocumentException | IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionException(<span class="string">"IOException parsing XML document:"</span> + resource, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseComponentElement</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">  String basePackages = element.attributeValue(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">  <span class="comment">// 读取指定包路径下的类转换为 BeanDefinition 并注册到  BeanFactory 中</span></span><br><span class="line">  ClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(registry);</span><br><span class="line">  scanner.doScanAndRegistry(basePackages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里实现 <code>@Component</code> 注解的主要流程已经介绍完毕，完整代码已上传至仓库 <a href="https://github.com/mghio/mghio-spring" target="_blank" rel="noopener">GitHub </a>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍了实现 <code>@Component</code> 注解的主要流程，以上只是实现的最简单的功能，但是基本原理都是类似的，有问题欢迎留言讨论。下篇预告：<strong>如何实现 <code>@Autowried</code> 注解</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/12/ZaBY1LuEdOXKV3k.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;前面两篇文章（&lt;a href=&quot;https://www.mghio.cn/post/5731122e.html&quot;&gt;如何实现一个简易版的 Spring - 如何实现 Setter 注入&lt;/a&gt;、&lt;a href=&quot;https://www.mghio.cn/post/315ff4dc.html&quot;&gt;如何实现一个简易版的 Spring - 如何实现 Constructor 注入&lt;/a&gt;）介绍的都是基于 &lt;code&gt;XML&lt;/code&gt; 配置文件方式的实现，从 &lt;code&gt;JDK 5&lt;/code&gt; 版本开始 &lt;code&gt;Java&lt;/code&gt; 引入了注解支持，带来了极大的便利，&lt;code&gt;Sprinng&lt;/code&gt; 也从 &lt;code&gt;2.5&lt;/code&gt; 版本开始支持注解方式，使用注解方式我们只需加上相应的注解即可，不再需要去编写繁琐的 &lt;code&gt;XML&lt;/code&gt; 配置文件，深受广大 &lt;code&gt;Java&lt;/code&gt; 编程人员的喜爱。接下来一起看看如何实现 &lt;code&gt;Spring&lt;/code&gt; 框架中最常用的两个注解（&lt;code&gt;@Component&lt;/code&gt;、&lt;code&gt;@Autowired&lt;/code&gt;），由于涉及到的内容比较多，会分为两篇文章进行介绍，本文先来介绍上半部分 — &lt;strong&gt;如何实现 &lt;code&gt;@Component&lt;/code&gt; 注解&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简易版的 Spring - 如何实现 Constructor 注入</title>
    <link href="https://www.mghio.cn/post/315ff4dc.html"/>
    <id>https://www.mghio.cn/post/315ff4dc.html</id>
    <published>2021-01-16T07:36:22.000Z</published>
    <updated>2022-11-05T07:38:38.244Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/12/6gSsifO9GlI5rNL.jpg" alt="cover.jpg"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文是「如何实现一个简易版的 Spring」系列的第二篇，在 <a href="https://www.mghio.cn/post/5731122e.html">第一篇</a> 介绍了如何实现一个基于 <code>XML</code> 的简单 <code>Setter</code> 注入，这篇来看看要如何去实现一个简单的 <code>Constructor</code> 注入功能，实现步骤和 <code>Setter</code> 注入是一样的“套路”，先设计一个数据结构去解析表达 <code>XML</code> 配置文件里的信息，然后再使用这些解析好的数据结构做一些事情，比如这里的 <code>Constructor</code> 注入。话不多说，下面我们直接进入正题。</p><a id="more"></a><h4 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h4><p>使用 <code>Constructor</code> 注入方式的 <code>XML</code> 的一种配置如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.service.version3.OrderService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"stockService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"tradeService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"mghio"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上 <code>OrderService</code> 类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-01-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StockDao stockDao;</span><br><span class="line">    <span class="keyword">private</span> TradeDao tradeDao;</span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(StockDao stockDao, TradeDao tradeDao, String owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stockDao = stockDao;</span><br><span class="line">        <span class="keyword">this</span>.tradeDao = tradeDao;</span><br><span class="line">        <span class="keyword">this</span>.owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 <code>XML</code> 的配置结构上看和 <code>Setter</code> 注入类似，都是 <code>Key-Value</code> 类的格式，可以将每个 <code>constructor-arg</code> 节点抽象为 <code>ValueHolder</code>，包含实际解析后的值类型 <code>value</code>、类型 <code>type</code> 以及参数名称 <code>name</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-01-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// omit setter and getter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样一个 <code>Bean</code> 可以包含多个 <code>ValueHolder</code>，为了封装实现以及方便提供一些判断方法（比如是否配置有构造器注入等），将进一步封装为 <code>ConstructorArgument</code>，并提供一些 <code>CRUD</code> 接口，而 <code>ValueHolder</code> 作为内部类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-01-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorArgument</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ValueHolder&gt; argumentsValues = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.argumentsValues.add(<span class="keyword">new</span> ValueHolder(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ValueHolder&gt; <span class="title">getArgumentsValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.argumentsValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArgumentCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.argumentsValues.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.argumentsValues.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.argumentsValues.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some other methods...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Object value;</span><br><span class="line">        <span class="keyword">private</span> String type;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>BeanDefinition</code> 接口中增加获取 <code>ConstructorArgument</code> 方法和判断是否配置 <code>ConstructorArgument</code> 方法。结构如下图所示：</p><p><img src="https://i.loli.net/2021/01/17/2RYuMe9CqGLgbNx.png" alt="spring-constructor-injection.png"></p><h4 id="解析-XML-配置文件"><a href="#解析-XML-配置文件" class="headerlink" title="解析 XML 配置文件"></a>解析 XML 配置文件</h4><p>有了 <a href="(https://www.mghio.cn/post/24cb2421.html)">上篇文章</a> 的基础，解析 <code>XML</code> 也比较简单，这里我们解析的是 <code>constructor-arg</code> 节点，组装数据添加到 <code>BeanDefinition</code> 的 <code>ConstructorArgument</code> 属性中，修改 <code>XmlBeanDefinitionReader</code> 类的 <code>loadBeanDefinition(Resource resource)</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-01-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONSTRUCTOR_ARG_ELEMENT = <span class="string">"constructor-arg"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME_ATTRIBUTE = <span class="string">"name"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_ATTRIBUTE = <span class="string">"type"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other fields and methods ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinition</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = resource.getInputStream()) &#123;</span><br><span class="line">            SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = saxReader.read(is);</span><br><span class="line">            Element root = document.getRootElement();  <span class="comment">// &lt;beans&gt;</span></span><br><span class="line">            Iterator&lt;Element&gt; iterator = root.elementIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Element element = iterator.next();</span><br><span class="line">                String beanId = element.attributeValue(BEAN_ID_ATTRIBUTE);</span><br><span class="line">                String beanClassName = element.attributeValue(BEAN_CLASS_ATTRIBUTE);</span><br><span class="line">                BeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition(beanId, beanClassName);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != element.attributeValue(BEAN_SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line">                    bd.setScope(element.attributeValue(BEAN_SCOPE_ATTRIBUTE));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// parse &lt;constructor-arg&gt; node</span></span><br><span class="line">                parseConstructorArgElements(element, bd);</span><br><span class="line">                parsePropertyElementValues(element, bd);</span><br><span class="line">                <span class="keyword">this</span>.registry.registerBeanDefinition(beanId, bd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException | IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionException(<span class="string">"IOException parsing XML document:"</span> + resource, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElements</span><span class="params">(Element rootEle, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Element&gt; iterator = rootEle.elementIterator(CONSTRUCTOR_ARG_ELEMENT);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Element element = iterator.next();</span><br><span class="line">            parseConstructorArgElement(element, bd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElement</span><span class="params">(Element element, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">        String typeAttr = element.attributeValue(TYPE_ATTRIBUTE);</span><br><span class="line">        String nameAttr = element.attributeValue(NAME_ATTRIBUTE);</span><br><span class="line">        Object value = parsePropertyElementValue(element, <span class="keyword">null</span>);</span><br><span class="line">        ConstructorArgument.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgument.ValueHolder(value);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">            valueHolder.setType(typeAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            valueHolder.setName(nameAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        bd.getConstructorArgument().addArgumentValue(valueHolder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other fields and methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析 <code>XML</code> 的过程整体上分为两步，第一步在遍历每个 <code>&lt;bean&gt;</code> 节点时判断 <code>&lt;constructor-arg&gt;</code> 节点是否存在，存在则解析 <code>&lt;constructor-arg&gt;</code> 节点；第二步将解析拼装好的 <code>ValueHolder</code> 添加到 <code>BeanDefinition</code> 中，这样我们就把 <code>XML</code> 配置的 <code>Constructor</code> 注入解析到 <code>BeanDefinition</code> 中了，下面看看如何在创建 <code>Bean</code> 的过程中如何使用该数据结构进行构造器注入。</p><h4 id="如何选择-Constructor"><a href="#如何选择-Constructor" class="headerlink" title="如何选择 Constructor"></a>如何选择 Constructor</h4><p>很明显，使用构造器注入需要放在<code>实例化 Bean</code>的阶段，通过判断当前待实例化的 <code>Bean</code> 是否有配置构造器注入，有则使用构造器实例化。判断 <code>XML</code> 是否有配置构造器注入可以直接使用 <code>BeanDefinition</code> 提供的 <code>hasConstructorArguments()</code> 方法即可，实际上最终是通过判断 <code>ConstructorArgument.ValueHolder</code> 集合是否有值来判断的。这里还有个问题 <code>当存在多个构造器时如何选择</code>，比如 <code>OrderService</code> 类有如下三个构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-01-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StockDao stockDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TradeDao tradeDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String owner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(StockDao stockDao, TradeDao tradeDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stockDao = stockDao;</span><br><span class="line">        <span class="keyword">this</span>.tradeDao = tradeDao;</span><br><span class="line">        <span class="keyword">this</span>.owner = <span class="string">"nobody"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(StockDao stockDao, String owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stockDao = stockDao;</span><br><span class="line">        <span class="keyword">this</span>.owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(StockDao stockDao, TradeDao tradeDao, String owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stockDao = stockDao;</span><br><span class="line">        <span class="keyword">this</span>.tradeDao = tradeDao;</span><br><span class="line">        <span class="keyword">this</span>.owner = owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其 <code>XML</code> 构造器注入的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.service.version3.OrderService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"stockService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"tradeService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"mghio"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时该如何选择最适合的构造器进行注入呢？这里使用的匹配方法是 <code>1. 先判断构造函数参数个数，如果不匹配直接跳过，进行下一次循环；2. 当构造器参数个数匹配时再判断参数类型，如果和当前参数类型一致或者是当前参数类型的父类型则使用该构造器进行实例化</code>。这个使用的判断方法比较简单直接，实际上 <code>Spring</code> 的判断方式考虑到的情况比较全面同时代码实现也更加复杂，感兴趣的朋友可以查看 <code>org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(...)</code> 方法。这里需要注意的是，在解析 <code>XML</code> 配置的构造器注入参数时要进行类型转换为目标类型，将该类命名为 <code>ConstructorResolver</code>，实现代码比较多这里就不贴出来了，可以到 <a href="https://github.com/mghio/mghio-spring/blob/master/src/main/java/cn/mghio/beans/support/ConstructorResolver.java" target="_blank" rel="noopener">GitHub</a> 查看完整代码。然后只需要在实例化 <code>Bean</code> 的时候判断是否存在构造器注入配置，存在则使用构造器注入即可，修改 <code>DefaultBeanFactory</code> 的实例化方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-01-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other fields and methods ...        </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. instantiate bean</span></span><br><span class="line">        Object bean = instantiateBean(bd);</span><br><span class="line">        <span class="comment">// 2. populate bean</span></span><br><span class="line">        populateBean(bd, bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">instantiateBean</span><span class="params">(BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前 Bean 的 `XML` 配置是否配置为构造器注入方式</span></span><br><span class="line">        <span class="keyword">if</span> (bd.hasConstructorArguments()) &#123;</span><br><span class="line">            ConstructorResolver constructorResolver = <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> constructorResolver.autowireConstructor(bd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ClassLoader classLoader = <span class="keyword">this</span>.getClassLoader();</span><br><span class="line">            String beanClassName = bd.getBeanClassName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; beanClass = <span class="keyword">null</span>;</span><br><span class="line">                Class&lt;?&gt; cacheBeanClass = bd.getBeanClass();</span><br><span class="line">                <span class="keyword">if</span> (cacheBeanClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    beanClass = classLoader.loadClass(beanClassName);</span><br><span class="line">                    bd.setBeanClass(beanClass);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    beanClass = cacheBeanClass;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> beanClass.getDeclaredConstructor().newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(<span class="string">"Created bean for "</span> + beanClassName + <span class="string">" fail."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// other fields and methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就已经实现了一个简易版的基于 <code>XML</code> 配置的 <code>Constructor</code> 注入了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简要介绍了 <code>Spring</code> 基于 <code>XML</code> 配置的 <code>Constructor</code> 注入，其实有了第一篇的 <code>Setter</code> 注入的基础，实现 <code>Constructor</code> 注入相对来说难度要小很多，这里的实现相对来说比较简单，但是其思想和大体流程是类似的，想要深入了解 <code>Spring</code> 实现的具体细节可以查看源码。完整代码已上传至 <code>GitHub</code>，感兴趣的朋友可以到这里 <a href="https://github.com/mghio/mghio-spring" target="_blank" rel="noopener">mghio-spring</a> 查看完整代码，下篇预告：<strong>「如何实现一个简易版的 Spring - 实现字段注解方式注入」</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/12/6gSsifO9GlI5rNL.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;本文是「如何实现一个简易版的 Spring」系列的第二篇，在 &lt;a href=&quot;https://www.mghio.cn/post/5731122e.html&quot;&gt;第一篇&lt;/a&gt; 介绍了如何实现一个基于 &lt;code&gt;XML&lt;/code&gt; 的简单 &lt;code&gt;Setter&lt;/code&gt; 注入，这篇来看看要如何去实现一个简单的 &lt;code&gt;Constructor&lt;/code&gt; 注入功能，实现步骤和 &lt;code&gt;Setter&lt;/code&gt; 注入是一样的“套路”，先设计一个数据结构去解析表达 &lt;code&gt;XML&lt;/code&gt; 配置文件里的信息，然后再使用这些解析好的数据结构做一些事情，比如这里的 &lt;code&gt;Constructor&lt;/code&gt; 注入。话不多说，下面我们直接进入正题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简易版的 Spring - 如何实现 Setter 注入</title>
    <link href="https://www.mghio.cn/post/5731122e.html"/>
    <id>https://www.mghio.cn/post/5731122e.html</id>
    <published>2020-11-28T07:33:26.000Z</published>
    <updated>2022-11-05T07:34:48.198Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/12/jW1KskFCvHnxtf2.jpg" alt="cover.jpg"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>之前在 <a href="https://www.mghio.cn/post/558ca0bd.html">上篇</a> 提到过会实现一个简易版的 <code>IoC</code> 和 <code>AOP</code>，今天它终于来了。。。相信对于使用 <code>Java</code> 开发语言的朋友们都使用过或者听说过 <code>Spring</code> 这个开发框架，绝大部分的企业级开发中都离不开它，通过 <a href="https://spring.io" target="_blank" rel="noopener">官网</a> 可以了解到其生态非常庞大，针对不同方面的开发提供了一些解决方案，可以说 <code>Spring</code> 框架的诞生是对 <code>Java</code> 开发人员的一大福利，自 <code>2004</code> 年发布以来，<code>Spring</code> 为了解决一些企业开发中的痛点先后引入了很多的特性和功能，其中最重要的就是我们经常听到的 <code>IoC</code> 和 <code>AOP</code> 特性，由于涉及到的知识和细节比较多，会分为几篇文章来介绍，今天这篇（也是第一篇）我们来看看如何实现基于 <code>XML</code> 配置方式的 <strong>Setter 注入</strong>。</p><a id="more"></a><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>既然是通过 <code>XML</code> 配置文件的方式，首先第一件事就是要读取 <code>XML</code> 文件然后转换为我们需要的数据结构，解析 <code>XML</code> 文件有但不限于这些方式（<a href="http://www.jdom.org" target="_blank" rel="noopener">JDOM</a>、<a href="http://www.xom.nu" target="_blank" rel="noopener">XOM</a>、<a href="https://dom4j.github.io" target="_blank" rel="noopener">dom4j</a>），这里使用的是简单易上手的 <a href="https://dom4j.github.io" target="_blank" rel="noopener">dom4j</a>，所你得对其基础知识有一些简单了解，其实都是一些很简单的方法基础使用而已，第二个就是你要有一些 <code>Spring</code> 框架的使用经验，这里实现的简易版本质上是对 <code>Spring</code> 的一个精简后的核心部分的简单实现，是的，没错，你只需要有了这些基础预备知识就可以了。</p><h4 id="基础数据结构抽象"><a href="#基础数据结构抽象" class="headerlink" title="基础数据结构抽象"></a>基础数据结构抽象</h4><p>在开始编码实现前先要做一些简单的构思和设计，首先在 <code>Spring</code> 中把一个被其管理的对象称之为 <code>Bean</code>，然后其它的操作都是围绕这个 <code>Bean</code> 来展开设计的，所以为了能在程序中统一并且规范的表示一个 <code>Bean</code> 的定义，于是第一个接口 <code>BeanDefinition</code> 就出来了，本次需要的一些基本信息包含 <code>Bean</code> 的名称、所属类名称、是否单例、作用域等，如下所示：</p><p><img src="https://i.loli.net/2020/11/28/1UGMFCPVfwgl3D7.png" alt="spring-injection-beandefinition-1.png"></p><p>现在 <code>BeanDefinition</code> 有了，接下来就是要根据这个 <code>BeanDefinition</code> 去创建出对应的 <code>Bean</code> 实例了，很显然这需要一个 <code>Factory</code> 工厂接口去完成这个创建的工作，这个创建 <code>Bean</code> 的接口命名为 <code>BeanFactory</code>，其提供根据不同条件去创建相对应的 <code>Bean</code> 实例功能（比如 <code>beanId</code>），但是创建的前提是需要先注册这个 <code>BeanDefinition</code>，然后根据一定条件再从中去获取 <code>BeanDefinition</code>，根据 <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank" rel="noopener">单一职责</a> 原则，这个功能应该由一个新的接口去完成，主要是做注册和获取 <code>BeanDefinition</code> 的工作，故将其命名为 <code>BeanDefinitionRegistry</code>，我们需要的 <code>BeanDefinition</code> 要从哪里获取呢？很显然我们是基于 <code>XML</code> 配置的方式，当然是从 <code>XML</code> 配置文件中获取到的，同样根据单一职责原则，也需要一个类去完成这个事情，将其命名为 <code>XMLBeanDefinitionReader</code>，这部分的整体结构如下所示：</p><p><img src="https://i.loli.net/2020/11/28/YnDv6MqHVNwTAg5.png" alt="spring-injection-beanfactory-2.png"></p><p>接下来面临的一个问题就是，像 <code>XML</code> 这种配置文件资源要如何表示呢，这些配置对于程序来说是一种资源，可以统一抽象为 <code>Resource</code>，然后提供一个返回资源对应流（<code>InputStream</code>）对象接口，这种资源可以从项目中获取、本地文件获取甚至是从远程获取，它们都是一种 <code>Resource</code>，结构如下：</p><p><img src="https://i.loli.net/2020/11/29/GBP2M3aZLhbfcm5.png" alt="spring-injection-resource-3.png"></p><p>最后就是要一个提供去组合调用上面的那些类去完成 <code>XML</code> 配置文件解析为 <code>BeanDefinition</code> 并注入到容器中了的功能，担任这程序上下文的职责，将其命名为 <code>ApplicationContext</code>，这里同样也可以根据 <code>Resource</code> 的类型分为多种不同的类，比如：<code>FileSystmXmlApplicationContext</code>、<code>ClassPathXmlApplicationContext</code> 等，这些内部都有一个将配置文件转换为 <code>Resource</code> 的过程，可以使用 <a href="https://en.wikipedia.org/wiki/Template_method_pattern" target="_blank" rel="noopener">模板方法</a> 抽象出一个公共父类抽象类，如下所示:</p><p><img src="https://i.loli.net/2020/11/29/ux1cEOAGQoqD9h8.png" alt="spring-injection-applicationcontext.png"></p><p>总结以上分析结果，得出初步类图设计如下：</p><p><img src="https://i.loli.net/2020/11/29/wOijZNT8cAlMY1r.png" alt="spring-injection-all-4.png"></p><p>最终要实现 <code>Setter</code> 注入这个目标，可以将其分解为以下两个步骤：</p><ol><li>将 <code>XML</code> 配置文件中的 <code>&lt;bean&gt;</code> 标签解析为 <code>BeanDefinition</code> 并注入到容器中</li><li>实现 <code>Setter</code> 注入</li></ol><p>下面我们分为这两个部分来分别讲述如何实现。</p><h4 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h4><p>假设有如下内容的配置文件 <code>applicationcontext-config1.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.e3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.service.version1.OrderService"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终需要解析出一个 <code>id</code> 为 <code>orderService</code> 类型为 <code>cn.mghio.service.version1.OrderService</code> 的 <code>BeanDefinition</code>，翻译成测试类的话也就是需要让如下测试类可以运行通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line">    <span class="keyword">private</span> DefaultBeanFactory beanFactory;</span><br><span class="line">    <span class="keyword">private</span> XmlBeanDefinitionReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeEach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"applicationcontext-config1.xml"</span>);</span><br><span class="line">        beanFactory = <span class="keyword">new</span> DefaultBeanFactory();</span><br><span class="line">        reader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBeanFromXmlFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reader.loadBeanDefinition(resource);</span><br><span class="line">        BeanDefinition bd = beanFactory.getBeanDefinition(<span class="string">"orderService"</span>);</span><br><span class="line"></span><br><span class="line">        assertEquals(<span class="string">"cn.mghio.service.version1.OrderService"</span>, bd.getBeanClassNam());</span><br><span class="line">        OrderService orderService = (OrderService) beanFactory.getBean(<span class="string">"orderService"</span>);</span><br><span class="line">        assertNotNull(orderService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBeanFromXmlFileWithInvalidBeanId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertThrows(BeanCreationException.class, () -&gt; beanFactory.getBean(<span class="string">"notExistsBeanId"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetFromXmlFilWithFileNotExists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"notExists.xml"</span>);</span><br><span class="line">        assertThrows(BeanDefinitionException.class, () -&gt; reader.loadBeanDefinition(resource));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里面的关键就是如何去实现 <code>XmlBeanDefinitionReader</code> 类的 <code>loadBeanDefinition</code> 从配置中加载和注入 <code>BeanDefinition</code>，思考分析后不然发现这里主要是两步，第一步是解析 <code>XML</code> 配置转换为 <code>BeanDefinition</code>，这就需要上文提到的 <code>dom4j</code> 提供的能力了，第二步将解析出来的 <code>BeanDefinition</code> 注入到容器中，通过组合使用 <code>BeanDefinitionRegistry</code> 接口提供注册 <code>BeanDefinition</code> 的能力来完成。读取 <code>XML</code> 配置的类 <code>XmlBeanDefinitionReader</code> 的代码实现很快就可以写出来了，该类部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_ID_ATTRIBUTE = <span class="string">"id"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_CLASS_ATTRIBUTE = <span class="string">"class"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registry = registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinition</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = resource.getInputStream()) &#123;</span><br><span class="line">            SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">            Document document = saxReader.read(is);</span><br><span class="line">            Element root = document.getRootElement();  <span class="comment">// &lt;beans&gt;</span></span><br><span class="line">            Iterator&lt;Element&gt; iterator = root.elementIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Element element = iterator.next();</span><br><span class="line">                String beanId = element.attributeValue(BEAN_ID_ATTRIBUTE);</span><br><span class="line">                String beanClassName = element.attributeValue(BEAN_CLASS_ATTRIBUTE);</span><br><span class="line">                BeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition(beanId, beanClassName);</span><br><span class="line">                <span class="keyword">this</span>.registry.registerBeanDefinition(beanId, bd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException | IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionException(<span class="string">"IOException parsing XML document:"</span> + configurationFile, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后当调用 <code>BeanFactory</code> 的 <code>getBean</code> 方法时就可以根据 <code>Bean</code> 的全限定名创建一个实例出来了(PS：暂时不考虑实例缓存)，方法实现主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">    BeanDefinition bd = getBeanDefinition(beanId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == bd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(<span class="string">"BeanDefinition does not exists, beanId:"</span> + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    ClassLoader classLoader = <span class="keyword">this</span>.getClassLoader();</span><br><span class="line">    String beanClassName = bd.getBeanClassNam();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(beanClassName);</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(<span class="string">"Created bean for "</span> + beanClassName + <span class="string">" fail."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里配置文件解析方面的工作已完成，接下来看看要如何实现 <code>Setter</code> 注入。</p><h4 id="如何实现-Setter-注入"><a href="#如何实现-Setter-注入" class="headerlink" title="如何实现 Setter 注入"></a>如何实现 Setter 注入</h4><p>首先实现基于 <code>XML</code> 配置文件的 <code>Setter</code> 注入本质上也是解析 <code>XML</code> 配置文件，然后再调用对象属性的 <code>setXXX</code> 方法将配置的值设置进去，配置文件 <code>applicationcontext-config2.xml</code> 如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.e3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"stockDao"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.dao.version2.StockDao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tradeDao"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.dao.version2.TradeDao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.service.version2.OrderService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"stockDao"</span> <span class="attr">ref</span>=<span class="string">"stockDao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tradeDao"</span> <span class="attr">ref</span>=<span class="string">"tradeDao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"num"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"owner"</span> <span class="attr">value</span>=<span class="string">"mghio"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orderTime"</span> <span class="attr">value</span>=<span class="string">"2020-11-24 18:42:32"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们之前使用了 <code>BeanDefinition</code> 去抽象了 <code>&lt;bean&gt;</code> 标签，这里面临的第一个问题就是要如何去表达配置文件中的 <code>&lt;property&gt;</code> 标签，其中 <code>ref</code> 属性表示一个 <code>beanId</code>、<code>value</code> 属性表示一个值（值类型为：<code>Integer</code>、<code>String</code>、<code>Date</code> 等）。观察后可以发现，<code>&lt;property&gt;</code> 标签本质上是一个 <code>K-V</code> 格式的数据（<code>name</code> 作为 <code>Key</code>，<code>ref</code> 和 <code>value</code> 作为 <code>Value</code>），将这个类命名为 <code>PropertyValue</code>，很明显一个 <code>BeanDefinition</code> 会有多个 <code>PropertyValue</code>，结构如下：</p><p><img src="https://i.loli.net/2020/11/29/CK8HgDEuWTIFU45.png" alt="spring-injection-setter-property-1.png"></p><p>这里的 <code>value</code> 有两种不同的类型，一种是表示 <code>Bean</code> 的 <code>id</code> 值，运行时会解析为一个 <code>Bean</code> 的引用，将其命名为 <code>RuntimeBeanReference</code>，还有一种是 <code>String</code> 类型，运行时会解析为不同的类型，将其命名为 <code>TypeStringValue</code>。第二个问题就是要如何将一个类型转换为另一个类型呢？比如将上面配置中的字符串 <code>2</code> 转换为整型的 <code>2</code>、字符串 <code>2020-11-24 18:42:32</code> 转换为日期，这类通用的问题前辈们已经开发好了类库处理了，这里我们使用 <a href="https://commons.apache.org/proper/commons-beanutils" target="_blank" rel="noopener">commons-beanutils</a> 库提供的 <code>BeanUtils.copyProperty(final Object bean, final String name, final Object value)</code> 方法即可。然后只需在之前 <code>XmlBeanDefinitionReader</code> 类的 <code>loadBeanDefinition</code> 方法解析 <code>XML</code> 配置文件的时解析 <code>&lt;bean&gt;</code> 标签下的 <code>&lt;property&gt;</code> 标签并设置到 <code>BeanDefinition</code> 的 <code>propertyValues</code> 属性中；<code>DefaultBeanFactory</code> 中的 <code>getBean</code> 方法分为实例化 <code>Bean</code> 和读取向实例化完成的 <code>Bean</code> 使用 <code>Setter</code> 注入配置文件中配置属性对应的值。<code>XmlBeanDefinitionReader</code> 的 <code>loadBeanDefinition()</code> 方法代码修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinition</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream is = resource.getInputStream()) &#123;</span><br><span class="line">        SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = saxReader.read(is);</span><br><span class="line">        Element root = document.getRootElement();  <span class="comment">// &lt;beans&gt;</span></span><br><span class="line">        Iterator&lt;Element&gt; iterator = root.elementIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Element element = iterator.next();</span><br><span class="line">            String beanId = element.attributeValue(BEAN_ID_ATTRIBUTE);</span><br><span class="line">            String beanClassName = element.attributeValue(BEAN_CLASS_ATTRIBUTE);</span><br><span class="line">            BeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition(beanId, beanClassName);</span><br><span class="line">            parsePropertyElementValue(element, bd);  <span class="comment">// parse &lt;property&gt;</span></span><br><span class="line">            <span class="keyword">this</span>.registry.registerBeanDefinition(beanId, bd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DocumentException | IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionException(<span class="string">"IOException parsing XML document:"</span> + resource, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parsePropertyElementValue</span><span class="params">(Element element, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Element&gt; iterator = element.elementIterator(PROPERTY_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Element propertyElement = iterator.next();</span><br><span class="line">        String propertyName = propertyElement.attributeValue(NAME_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(propertyName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object value = parsePropertyElementValue(propertyElement, propertyName);</span><br><span class="line">        PropertyValue propertyValue = <span class="keyword">new</span> PropertyValue(propertyName, value);</span><br><span class="line">        bd.getPropertyValues().add(propertyValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">parsePropertyElementValue</span><span class="params">(Element propertyElement, String propertyName)</span> </span>&#123;</span><br><span class="line">    String elementName = (propertyName != <span class="keyword">null</span>) ?</span><br><span class="line">            <span class="string">"&lt;property&gt; element for property '"</span> + propertyName + <span class="string">"' "</span> : <span class="string">"&lt;constructor-arg&gt; element"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasRefAttribute = propertyElement.attribute(REF_ATTRIBUTE) != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasValueAttribute = propertyElement.attribute(VALUE_ATTRIBUTE) != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasRefAttribute) &#123;</span><br><span class="line">        String refName = propertyElement.attributeValue(REF_ATTRIBUTE);</span><br><span class="line">        RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;</span><br><span class="line">        String value = propertyElement.attributeValue(VALUE_ATTRIBUTE);</span><br><span class="line">        TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(value);</span><br><span class="line">        <span class="keyword">return</span> valueHolder;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(elementName + <span class="string">" must specify a ref or value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultBeanFactory</code> 的 <code>getBean</code> 方法也增加 <code>Bean</code> 属性注入操作，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">    BeanDefinition bd = getBeanDefinition(beanId);</span><br><span class="line">    <span class="comment">// 1. instantiate bean</span></span><br><span class="line">    Object bean = instantiateBean(bd);</span><br><span class="line">    <span class="comment">// 2. populate bean</span></span><br><span class="line">    populateBean(bd, bean);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">instantiateBean</span><span class="params">(BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoader = <span class="keyword">this</span>.getClassLoader();</span><br><span class="line">    String beanClassName = bd.getBeanClassName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(beanClassName);</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(<span class="string">"Created bean for "</span> + beanClassName + <span class="string">" fail."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(BeanDefinition bd, Object bean)</span> </span>&#123;</span><br><span class="line">    List&lt;PropertyValue&gt; propertyValues = bd.getPropertyValues();</span><br><span class="line">    <span class="keyword">if</span> (propertyValues == <span class="keyword">null</span> || propertyValues.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinitionResolver resolver = <span class="keyword">new</span> BeanDefinitionResolver(<span class="keyword">this</span>);</span><br><span class="line">    SimpleTypeConverted converter = <span class="keyword">new</span> SimpleTypeConverted();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : propertyValues) &#123;</span><br><span class="line">            String propertyName = propertyValue.getName();</span><br><span class="line">            Object originalValue = propertyValue.getValue();</span><br><span class="line">            Object resolvedValue = resolver.resolveValueIfNecessary(originalValue);</span><br><span class="line"></span><br><span class="line">            BeanUtils.copyProperty(bean, propertyName, resolvedValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(<span class="string">"Failed to obtain BeanInfo for class ["</span> + bd.getBeanClassName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，简单的 <code>Setter</code> 注入功能已完成。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简单概述了基于 <code>XML</code> 配置文件方式的 <code>Setter</code> 注入简单实现过程，整体实现 <code>Setter</code> 注入的思路就是先设计一个数据结构去表达 <code>XML</code> 配置文件中的标签数据（比如上面的 <code>PropertyValue</code>），然后再解析配置文件填充数据并利用这个数据结构完成一些功能（比如 <code>Setter 注入等</code>）。感兴趣的朋友可以到这里 <a href="https://github.com/mghio/mghio-spring" target="_blank" rel="noopener">mghio-spring</a> 查看完整代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/12/jW1KskFCvHnxtf2.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;之前在 &lt;a href=&quot;https://www.mghio.cn/post/558ca0bd.html&quot;&gt;上篇&lt;/a&gt; 提到过会实现一个简易版的 &lt;code&gt;IoC&lt;/code&gt; 和 &lt;code&gt;AOP&lt;/code&gt;，今天它终于来了。。。相信对于使用 &lt;code&gt;Java&lt;/code&gt; 开发语言的朋友们都使用过或者听说过 &lt;code&gt;Spring&lt;/code&gt; 这个开发框架，绝大部分的企业级开发中都离不开它，通过 &lt;a href=&quot;https://spring.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt; 可以了解到其生态非常庞大，针对不同方面的开发提供了一些解决方案，可以说 &lt;code&gt;Spring&lt;/code&gt; 框架的诞生是对 &lt;code&gt;Java&lt;/code&gt; 开发人员的一大福利，自 &lt;code&gt;2004&lt;/code&gt; 年发布以来，&lt;code&gt;Spring&lt;/code&gt; 为了解决一些企业开发中的痛点先后引入了很多的特性和功能，其中最重要的就是我们经常听到的 &lt;code&gt;IoC&lt;/code&gt; 和 &lt;code&gt;AOP&lt;/code&gt; 特性，由于涉及到的知识和细节比较多，会分为几篇文章来介绍，今天这篇（也是第一篇）我们来看看如何实现基于 &lt;code&gt;XML&lt;/code&gt; 配置方式的 &lt;strong&gt;Setter 注入&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
</feed>
