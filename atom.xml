<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mghio</title>
  
  <subtitle>Java 搬运工 &amp; 终身学习者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mghio.cn/"/>
  <updated>2025-04-04T14:56:43.781Z</updated>
  <id>https://www.mghio.cn/</id>
  
  <author>
    <name>mghio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo 中的集群容错</title>
    <link href="https://www.mghio.cn/post/739ea353.html"/>
    <id>https://www.mghio.cn/post/739ea353.html</id>
    <published>2025-04-04T13:28:13.000Z</published>
    <updated>2025-04-04T14:56:43.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2025/04/04/PYXecJzx2NW1ogF.jpg" alt="apache_dubbo.jpg"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在微服务架构中，服务间的依赖关系复杂且动态，任何一个服务的故障都可能引发连锁反应，导致系统雪崩。一个好的容错设计可以避免这些问题发生：</p><ul><li><p><strong>服务雪崩效应</strong>：单个服务崩溃或响应延迟可能导致调用链上的所有服务被阻塞，最终拖垮整个系统。例如，若服务 A 依赖服务 B，而服务 B 因高负载无法响应，A 的线程池可能被占满，进而影响其他依赖A的服务；</p></li><li><p><strong>分布式系统的脆弱性</strong>：网络抖动、节点宕机、资源耗尽等问题在分布式环境中不可避免。容错机制通过冗余和快速失败策略，确保部分故障不会扩散到整个系统；</p></li><li><p><strong>服务的可用性低</strong>：微服务的目标是提升系统可用性，而容错设计（如故障转移、熔断）是保障服务持续可用的核心手段。例如，通过自动切换健康节点，避免单点故障。</p></li></ul><a id="more"></a><h3 id="Dubbo-的集群容错机制"><a href="#Dubbo-的集群容错机制" class="headerlink" title="Dubbo 的集群容错机制"></a>Dubbo 的集群容错机制</h3><p>在 Dubbo 中，多个 Provider 实例构成一个「集群」。消费者调用时，Dubbo 通过 Cluster 模块实现容错策略的封装和路由，Cluster 模块会根据配置（如 cluster=failover）装配不同的容错策略实现类，对 Directory 中的多个 Invoker 进行处理，返回一个可执行的 Invoker。Dubbo 当前已支持以下 6 种容错策略（在 <code>org.apache.dubbo.rpc.cluster.support</code> 包下）：</p><table><thead><tr><th align="center">策略简称</th><th align="center">实现类名</th><th align="center">特性</th><th align="center">使用场景</th></tr></thead><tbody><tr><td align="center">Failover</td><td align="center">FailoverClusterInvoker</td><td align="center">失败自动重试，默认实现</td><td align="center">网络不稳定，民登操作</td></tr><tr><td align="center">Failfast</td><td align="center">FailfastClusterInvoker</td><td align="center">快速失败，不重试</td><td align="center">响应时间敏感，非幂等</td></tr><tr><td align="center">Failsafe</td><td align="center">FailsafeClusterInvoker</td><td align="center">失败忽略异常</td><td align="center">日志记录、监控等非主要场景</td></tr><tr><td align="center">Failback</td><td align="center">FailbackClusterInvoker</td><td align="center">失败后后台重试</td><td align="center">可容忍失败，后续补偿重试</td></tr><tr><td align="center">Forking</td><td align="center">ForkingClusterInvoker</td><td align="center">并行调用多个节点，最快成功返回</td><td align="center">实时性要求高，资源充足</td></tr><tr><td align="center">Broadcast</td><td align="center">BroadcastClusterInvoker</td><td align="center">广播方式调用所有服务提供着</td><td align="center">配置更新、通知类等操作</td></tr></tbody></table><h4 id="Failover-Cluster（失败自动切换，默认策略）"><a href="#Failover-Cluster（失败自动切换，默认策略）" class="headerlink" title="Failover Cluster（失败自动切换，默认策略）"></a>Failover Cluster（失败自动切换，默认策略）</h4><p><strong>实现原理</strong>：通过循环重试实现容错。<br>实现源码关键点：</p><ol><li>FailoverClusterInvoker 的 doInvoke 方法中，通过 for 循环控制重试次数（默认重试 2 次，共调用 3 次）;</li><li>每次重试前调用 list(invocation) 重新获取最新的 Invoker 列表，确保动态感知节点变化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段：org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker#doInvoke</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        copyInvokers = list(invocation); <span class="comment">// 动态刷新 Invoker 列表</span></span><br><span class="line">    &#125;</span><br><span class="line">    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">    <span class="comment">// 调用并处理异常...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Failfast-Cluster（快速失败）"><a href="#Failfast-Cluster（快速失败）" class="headerlink" title="Failfast Cluster（快速失败）"></a>Failfast Cluster（快速失败）</h4><p><strong>实现原理</strong>：仅发起一次调用，异常直接抛出。<br>实现源码关键点：</p><ol><li>FailfastClusterInvoker 直接调用目标 Invoker，不进行重试。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段：org.apache.dubbo.rpc.cluster.support.FailfastClusterInvoker#doInvoke</span></span><br><span class="line"><span class="function">fpublic Result <span class="title">doInvoke</span><span class="params">(...)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkInvokers(invokers, invocation);</span><br><span class="line">    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> invoker.invoke(invocation); <span class="comment">// 仅一次调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Failsafe-Cluster（失败安全）"><a href="#Failsafe-Cluster（失败安全）" class="headerlink" title="Failsafe Cluster（失败安全）"></a>Failsafe Cluster（失败安全）</h4><p><strong>实现原理</strong>：异常被捕获后返回空结果，不中断流程。<br>实现源码关键点：</p><ol><li>ailsafeClusterInvoker通过try-catch捕获异常并记录日志。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段：org.apache.dubbo.rpc.cluster.support.FailsafeClusterInvoker</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用逻辑...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    logger.error(<span class="string">"Failsafe ignore exception"</span>, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(); <span class="comment">// 返回空结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Failback-Cluster（失败自动恢复）"><a href="#Failback-Cluster（失败自动恢复）" class="headerlink" title="Failback Cluster（失败自动恢复）"></a>Failback Cluster（失败自动恢复）</h4><p><strong>实现原理</strong>：失败请求存入队列，定时重试。<br>实现源码关键点：</p><ol><li>捕获失败异常，使用 RetryTimerTask 存储失败请求，定时触发重试。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段：org.apache.dubbo.rpc.cluster.support.FailbackClusterInvoker#doInvoke</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFailed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        LoadBalance loadbalance,</span></span></span><br><span class="line"><span class="function"><span class="params">        Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Invoker&lt;T&gt;&gt; invokers,</span></span></span><br><span class="line"><span class="function"><span class="params">        Invoker&lt;T&gt; lastInvoker,</span></span></span><br><span class="line"><span class="function"><span class="params">        URL consumerUrl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (failTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                failTimer = <span class="keyword">new</span> HashedWheelTimer(</span><br><span class="line">                        <span class="keyword">new</span> NamedThreadFactory(<span class="string">"failback-cluster-timer"</span>, <span class="keyword">true</span>),</span><br><span class="line">                        <span class="number">1</span>,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        <span class="number">32</span>,</span><br><span class="line">                        failbackTasks);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RetryTimerTask retryTimerTask = <span class="keyword">new</span> RetryTimerTask(</span><br><span class="line">            loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD, consumerUrl);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(</span><br><span class="line">                CLUSTER_TIMER_RETRY_FAILED,</span><br><span class="line">                <span class="string">"add newTimeout exception"</span>,</span><br><span class="line">                <span class="string">""</span>,</span><br><span class="line">                <span class="string">"Failback background works error, invocation-&gt;"</span> + invocation + <span class="string">", exception: "</span> + e.getMessage(),</span><br><span class="line">                e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Forking-Cluster（并行调用）"><a href="#Forking-Cluster（并行调用）" class="headerlink" title="Forking Cluster（并行调用）"></a>Forking Cluster（并行调用）</h4><p><strong>实现原理</strong>：并发调用多个节点，首个成功结果即返回。<br>实现源码关键点：</p><ol><li>使用线程池并发调用，结果通过 BlockingQueue 异步接收。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段：org.apache.dubbo.rpc.cluster.support.ForkingClusterInvoker#doInvoke</span></span><br><span class="line"><span class="keyword">for</span> (Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        Result result = invoker.invoke(invocation);</span><br><span class="line">        ref.offer(result); <span class="comment">// 结果存入队列</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Broadcast-Cluster（广播调用）"><a href="#Broadcast-Cluster（广播调用）" class="headerlink" title="Broadcast Cluster（广播调用）"></a>Broadcast Cluster（广播调用）</h4><p><strong>实现原理</strong>：逐个调用所有节点，任一失败则整体失败。<br>实现源码关键点：</p><ol><li>遍历所有 Invoker 调用，异常累积后抛出。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码片段：org.apache.dubbo.rpc.cluster.support.BroadcastClusterInvoker#doInvoke</span></span><br><span class="line"><span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        invoker.invoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">        exception = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (exception != <span class="keyword">null</span>) <span class="keyword">throw</span> exception;</span><br></pre></td></tr></table></figure><h3 id="如何自定义集群容错策略"><a href="#如何自定义集群容错策略" class="headerlink" title="如何自定义集群容错策略"></a>如何自定义集群容错策略</h3><p>如果以上提供的容错策略不满足需求，Dubbo 支持通过 SPI 自定义 Cluster 实现，步骤如下：</p><h5 id="第一步：实现-Cluster-和-AbstractClusterInvoker"><a href="#第一步：实现-Cluster-和-AbstractClusterInvoker" class="headerlink" title="第一步：实现 Cluster 和 AbstractClusterInvoker"></a>第一步：实现 Cluster 和 AbstractClusterInvoker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"custom"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义逻辑，例如条件重试、动态路由等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第二步：添加-SPI-配置"><a href="#第二步：添加-SPI-配置" class="headerlink" title="第二步：添加 SPI 配置"></a>第二步：添加 SPI 配置</h5><p>在 <code>META-INF/dubbo/org.apache.dubbo.rpc.cluster.Cluster</code> 中添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mycluster=com.example.MyCluster</span><br></pre></td></tr></table></figure><h5 id="第三步：配置使用自定义容错策略"><a href="#第三步：配置使用自定义容错策略" class="headerlink" title="第三步：配置使用自定义容错策略"></a>第三步：配置使用自定义容错策略</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">"mycluster"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>建议核心服务优先使用 <code>Failover（失败自动切换）</code> 策略保障可用性，非核心服务可降级为 <code>Failsafe（失败安全）</code>。同时结合 <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">Hystrix(已停止更新)</a> 或 <a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener">Sentinel</a> 实现熔断与限流，增强容错能力。</p><p>通过灵活组合 Dubbo 的容错策略，可显著提升分布式系统的鲁棒性。实际应用配置时需要根据业务特性权衡延迟、资源开销与一致性要求，一切皆是 trade off ～</p><p><strong>P.S.</strong> 不妨再深入思考一下：Dubbo 的集群容错实现中有哪些优秀设计值得我们学习？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2025/04/04/PYXecJzx2NW1ogF.jpg&quot; alt=&quot;apache_dubbo.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在微服务架构中，服务间的依赖关系复杂且动态，任何一个服务的故障都可能引发连锁反应，导致系统雪崩。一个好的容错设计可以避免这些问题发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;服务雪崩效应&lt;/strong&gt;：单个服务崩溃或响应延迟可能导致调用链上的所有服务被阻塞，最终拖垮整个系统。例如，若服务 A 依赖服务 B，而服务 B 因高负载无法响应，A 的线程池可能被占满，进而影响其他依赖A的服务；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;分布式系统的脆弱性&lt;/strong&gt;：网络抖动、节点宕机、资源耗尽等问题在分布式环境中不可避免。容错机制通过冗余和快速失败策略，确保部分故障不会扩散到整个系统；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;服务的可用性低&lt;/strong&gt;：微服务的目标是提升系统可用性，而容错设计（如故障转移、熔断）是保障服务持续可用的核心手段。例如，通过自动切换健康节点，避免单点故障。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Dubbo" scheme="https://www.mghio.cn/categories/Java/Dubbo/"/>
    
      <category term="集群容错" scheme="https://www.mghio.cn/categories/Java/Dubbo/%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Dubbo" scheme="https://www.mghio.cn/tags/Dubbo/"/>
    
      <category term="集群容错" scheme="https://www.mghio.cn/tags/%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/"/>
    
      <category term="RPC" scheme="https://www.mghio.cn/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读论文（Paper）</title>
    <link href="https://www.mghio.cn/post/e1358fc9.html"/>
    <id>https://www.mghio.cn/post/e1358fc9.html</id>
    <published>2024-12-21T06:21:44.000Z</published>
    <updated>2024-12-21T06:23:35.972Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2024/05/04/657pj4LHFTeJBNr.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a href="#前言" title="前言"></a>前言</h2><p>论文（Paper）通常是新技术、算法、编程方法或软件工具的首次公布。通过阅读论文，我们可以了解最新的技术进展，保持自己的技能和知识是最新的。<br>同时，论文提供了对特定主题深入理解的机会。它们通常包含详细的理论分析和实验结果，这有助于深入理解某个概念或技术。但是，如何高效地阅读论文是一项关键但很少有人谈论的技能。刚开始大部分人自己通过试错来学习，但常常被挫败感所劝退。本文介绍一种阅读论文的方法——<strong>三遍阅读法</strong>。</p><a id="more"></a><h2 id="三遍阅读法"><a href="#三遍阅读法" class="headerlink" title="三遍阅读法"></a><a href="#三遍阅读法" title="三遍阅读法"></a>三遍阅读法</h2><p>关键思想是你应该最多阅读三遍论文，而不是从开头一直读到结尾。每一遍都完成特定的目标，并在前一遍的基础上构建：</p><h3 id="第一遍"><a href="#第一遍" class="headerlink" title="第一遍"></a><a href="#第一遍" title="第一遍"></a>第一遍</h3><p>快速浏览，获得论文的大致概念。你还可以决定是否需要进行更多的阅读。这一遍一般需要大约 5 到 10 分钟，并包括以下步骤：</p><ol><li>仔细阅读标题、摘要和引言</li><li>阅读章节和小节标题，但忽略其他所有内容</li><li>阅读结论</li><li>浏览参考文献，心中记下你已经阅读过的</li></ol><p>在第一遍结束时，你应该能够回答这五个 C（Category、Context、Correctness、Contributions、Clarity）：</p><ol><li>类别：这是哪种类型的论文？是测量论文吗？是对现有系统分析吗？是研究原型的描述吗？</li><li>上下文：它与哪些其他论文相关？使用哪些理论基础来分析问题？</li><li>正确性：假设看起来有效吗？</li><li>贡献：论文的主要贡献是什么？</li><li>清晰度：论文写得好吗？</li></ol><p>利用这些信息，你可能会决定不再继续阅读。这可能是因为论文不引起你的兴趣，或者你对该领域不够了解，无法理解论文，或者作者做出了无效的假设。第一遍对于不在你感兴趣的领域内，但将来可能相关的论文来说是足够的。如果读者在五分钟后不能理解论文的亮点，论文很可能永远不会被阅读。</p><h3 id="第二遍"><a href="#第二遍" class="headerlink" title="第二遍"></a><a href="#第二遍" title="第二遍"></a>第二遍</h3><p>在第二遍中，更仔细地阅读论文，但忽略细节，如证明。在阅读时记下关键点或在边缘做注释会很有帮助。<br>仔细查看论文中的图表、图表和其他插图。特别注意图形。轴是否正确标记？结果是否显示了误差条，以便结论具有统计意义？这些常见的错误将区分匆忙、粗制滥造的工作和真正优秀的工作。</p><p>记得标记相关未读的参考文献以供进一步阅读（这是了解论文背景的好方法）。 第二遍应该需要最多一个小时。在这一遍之后，你应该能够把握论文的内容。你应该能够向别人总结论文的主要论点，并提供支持证据。</p><p>这种细节水平适合你感兴趣的论文，但不属于你的研究专业。有时即使你在第二遍结束时也不理解论文。这可能是因为主题对你来说是新的，有不熟悉的术语和缩写词。或者作者使用了一个你不理解的证明或实验技术，以至于论文的大部分内容对你来说是无法理解的。</p><p>论文可能写得很糟糕，有未经证实的断言和许多前向引用。或者，可能只是因为现在是深夜，你很累。你现在可以选择：<br>(a) 把论文放在一边，希望你不需要理解这些材料就能在你的职业生涯中取得成功<br>(b) 稍后再回到论文，也许在阅读背景材料之后<br>(c) 坚持下去，进行第三遍阅读。</p><h3 id="第三遍"><a href="#第三遍" class="headerlink" title="第三遍"></a><a href="#第三遍" title="第三遍"></a>第三遍</h3><p>要完全理解一篇论文。第三遍的关键是尝试虚拟地重新实现论文：也就是说，做出与作者相同的假设，重新创建工作。通过将这个重新创建与实际论文进行比较，你可以很容易地识别出论文的创新之处，以及它的隐藏缺陷和假设。</p><p>这一遍需要极大的注意力。你应该识别并挑战每一条陈述中的每一个假设。此外，你应该思考你自己会如何表达一个特定的想法。实际与虚拟的比较可以非常深入地洞察论文中的证明和展示技巧，并且你很可能可以将这些技巧添加到你的工具箱中。在这一遍期间，你还应该记下未来工作的想法。</p><p>对于初学者来说，这一遍可能需要大约四到五个小时，对于有经验的读者来说，大约需要一个小时。在这一遍结束时，你应该能够从记忆中重建整篇论文的结构，并且能够识别出它的优点和缺点。特别是，你应该能够指出隐含的假设、遗漏的相关工作的引用，以及实验或分析技术可能存在的问题。</p><h2 id="最后，进行文献综述"><a href="#最后，进行文献综述" class="headerlink" title="最后，进行文献综述"></a><a href="#最后，进行文献综述" title="最后，进行文献综述"></a>最后，进行文献综述</h2><p>在进行文献综述时，会考验你的论文阅读技能。这将要求你阅读数十篇论文，可能在一个不熟悉的领域。你应该阅读哪些论文？以下是如何使用三遍阅读方法来帮助： 首先，使用学术搜索引擎，如 Google Scholar ，以及一些精心选择的关键词，找到该领域最近的三到五篇论文。</p><p>对每篇论文进行一遍阅读，以了解工作，然后阅读它们的相关工作部分。你将找到最近工作的缩略图摘要，也许你很幸运，会找到一个最近的综述论文。如果你能找到这样的综述，你就完成了。</p><p>阅读综述，为自己感到幸运。否则，在第二步中，在参考文献中找到共享的引用和重复的作者名字。这些是该领域的关键论文和研究人员。下载关键论文并将它们放在一边。然后，访问关键研究人员的网站，看看他们最近在哪里发表了文章。 这将帮助你确定该领域的顶级会议，因为最好的研究人员通常在顶级会议上发表文章。</p><p>第三步是访问这些顶级会议的网站，并浏览他们最近的会议记录。快速浏览通常可以识别出最近的高质量相关工作。这些论文，以及你之前放在一边的论文，构成了你的调查的第一版。对这些论文进行两遍阅读。如果它们都引用了一个你之前没有找到的关键论文，那么获取并阅读它，根据需要进行迭代。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2024/05/04/657pj4LHFTeJBNr.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#前言&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;论文（Paper）通常是新技术、算法、编程方法或软件工具的首次公布。通过阅读论文，我们可以了解最新的技术进展，保持自己的技能和知识是最新的。&lt;br&gt;同时，论文提供了对特定主题深入理解的机会。它们通常包含详细的理论分析和实验结果，这有助于深入理解某个概念或技术。但是，如何高效地阅读论文是一项关键但很少有人谈论的技能。刚开始大部分人自己通过试错来学习，但常常被挫败感所劝退。本文介绍一种阅读论文的方法——&lt;strong&gt;三遍阅读法&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文" scheme="https://www.mghio.cn/categories/%E8%AE%BA%E6%96%87/"/>
    
      <category term="Paper" scheme="https://www.mghio.cn/categories/%E8%AE%BA%E6%96%87/Paper/"/>
    
    
      <category term="论文" scheme="https://www.mghio.cn/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="Paper" scheme="https://www.mghio.cn/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>《UNIX 传奇：历史与回忆》读后感</title>
    <link href="https://www.mghio.cn/post/43d24671.html"/>
    <id>https://www.mghio.cn/post/43d24671.html</id>
    <published>2024-12-21T06:19:56.000Z</published>
    <updated>2024-12-21T06:23:58.092Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/08/05/RsGxkFc5UWJM6eq.jpg" alt="UNIX-A-History-and-a-Memoir.jpg"></p><p><a href="https://book.douban.com/subject/35292726" target="_blank" rel="noopener">《UNIX 传奇：历史与回忆》</a> 是 bwk（<a href="https://en.wikipedia.org/wiki/Brian_Kernighan" target="_blank" rel="noopener">Brian W. Kernighan</a>）2019 年的新作，回忆了 UNIX 在大半个世纪的风雨历程，是一本引人入胜的书籍。通过对 UNIX 操作系统的历史和发展进行详细的叙述和回顾，让我对这个操作系统有了更深入的了解。读完这本书，我不仅对 UNIX 的技术细节有了更清晰的认识，也对 UNIX 的影响力和价值有了更深刻的体会。</p><a id="more"></a><p>书中首先回顾了 UNIX 的诞生和发展过程，从贝尔实验室的研究项目到成为世界上最重要的操作系统没有之一，UNIX 经历了漫长而曲折的发展历程。作者通过详细的叙述和丰富的历史资料，将 UNIX 的发展与当时的技术环境和社会背景相结合，深入分析了 UNIX 的成功原因和对计算机科学的影响。</p><p>在书里，作者还介绍了 UNIX 的设计原则和哲学思想，如<strong>小即是美</strong>、<strong>一切皆文件</strong>等，这些原则不仅体现了 UNIX 的简洁和灵活性，也影响了后来的操作系统设计。通过对 UNIX 设计原则的解读，我对 UNIX 的设计理念有了更深入的理解，也对软件设计和开发有了新的思考。</p><p><img src="https://s2.loli.net/2023/08/05/9nXyrTvW7ubxLqt.jpg" alt="ken-and-den.jpg"></p><p>上图（<a href="https://www.bell-labs.com/usr/dmr/www/picture.html" target="_blank" rel="noopener">来源</a>）中站着的是 dmr（<a href="https://en.wikipedia.org/wiki/Dennis_Ritchie" target="_blank" rel="noopener">Dennis MacAlistair Ritchie</a>）、坐着打字的是 Ken（<a href="https://en.wikipedia.org/wiki/Ken_Thompson" target="_blank" rel="noopener">Ken Thompson</a>） 和几台 <a href="https://en.wikipedia.org/wiki/PDP-11" target="_blank" rel="noopener">PDP-11</a>。此外，本书还详细介绍了 UNIX 的核心组件和功能，如文件系统、进程管理、网络通信等等。通过对这些功能的解析，会 UNIX 的内部机制有了更深入的了解，也对操作系统的工作原理有了更全面的认识。同时，书中还介绍了 UNIX 的各种衍生版本和相关技术，如 <a href="https://github.com/torvalds/linux" target="_blank" rel="noopener">Linux</a>、BSD（加州大学伯克利分校维护的版本）等，这些衍生版本不仅丰富了 UNIX 的功能和应用领域，也推动了开源软件的发展。</p><p>书中除了对 UNIX 技术的介绍，还涉及了 UNIX 社区的发展和文化。UNIX 社区以其<strong>开放、自由</strong>的精神吸引了众多开发者和用户，形成了独特的文化氛围。通过对 UNIX 社区的描述和分析，我对 UNIX 社区的运作方式和价值观有了更深入的了解。UNIX 社区以其开放的开发模式和共享的文化，促进了知识和经验的交流，推动了技术的不断进步。在 UNIX 社区中，人们通过邮件列表、论坛和会议等形式进行交流和合作，共同解决问题、改进软件，形成了一种合作共赢的氛围。</p><p>此外，作者还介绍了 UNIX 在商业领域的应用和发展。UNIX 不仅在学术界和科研领域得到广泛应用，也在商业领域取得了巨大成功。通过对 UNIX 商业化的历史和案例的介绍，对 UNIX 在商业环境中的优势和挑战有了更深入的认识。UNIX 的开放性和灵活性使其成为企业 IT 系统的首选，而 UNIX 商业公司的崛起也推动了 UNIX 的发展和推广。</p><p><img src="https://s2.loli.net/2023/08/05/3jtaLZYGwNgnxBD.jpg" alt="Linux-declaration.jpg"></p><p>上图是 1991 年 8 月 <a href="https://en.wikipedia.org/wiki/Linus_Torvalds" target="_blank" rel="noopener">林纳斯·托瓦兹</a> 的 Linux宣告（<a href="https://www.cs.cmu.edu/~awb/linux.history.html" target="_blank" rel="noopener">图片来源</a>）。在读《UNIX 传奇：历史与回忆》之后，对 UNIX 的重要性和影响力有了更深刻的认识。UNIX 不仅是一种操作系统，更是一种<strong>思想和理念的体现</strong>。UNIX 的设计原则和开放的开发模式影响了整个计算机科学领域，推动了软件工程的发展。UNIX 的成功不仅在于其技术实力，更在于其背后的开放和合作精神。</p><p>然后，本书还通过对 UNIX 历史的回顾和个人经历的叙述，让我感受到了 UNIX 社区的热情和活力。UNIX 社区的成员们对技术的热爱和追求，以及对自由和开放的坚持，让我深受启发。作为一名从事软件开发的人，我深深地感受到了 UNIX 所传递的价值观和精神，这将对我的工作和职业发展产生积极的影响。</p><p>读完《UNIX 传奇：历史与回忆》后，我深受感动和启发。这本书不仅让我了解了 UNIX 的历史和技术，也让我感受到了 UNIX 的精神和价值。UNIX 的开放性、灵活性和合作精神，都是我在工作和生活中需要学习和借鉴的地方。</p><p>UNIX 的设计哲学「小即是美」，让我明白了在解决问题时，简洁的解决方案往往是最好的。在软件开发中，我们应该尽量避免复杂性，追求简洁和高效。同时，UNIX 的「一切皆文件」原则，也让我明白了抽象和统一的重要性。通过把所有资源都视为文件，UNIX 简化了操作和管理的复杂性，提高了效率和可用性。</p><p><img src="https://s2.loli.net/2023/08/05/viIaA1S4hkmtD9Z.png" alt="Unix_history.png"></p><p>上图是自 1969 年以来 UNIX 和类 UNIX 系统的演变历史（<a href="https://en.wikipedia.org/wiki/Unix-like" target="_blank" rel="noopener">图片来源</a>）。UNIX 开放源代码和开发模式，也让我认识到了开放和共享的价值。在今天的互联网时代，开放和共享是推动技术和知识进步的重要力量。我们应该积极参与开源社区，共享我们的知识和经验，共同推动技术的发展。</p><p>此外，UNIX 社区的活力和热情，也让我深受感动。在 UNIX 社区中，人们无私地分享知识，热情地帮助他人，共同解决问题，这种精神是我需要学习和倡导的。</p><p>总的来说，《UNIX 传奇：历史与回忆》是一本非常值得一读的书。它不仅让我了解了 UNIX 的历史和技术，也让我感受到了 UNIX 的精神和价值。</p><p>这本书对我来说，既是一次知识的旅行，也是一次精神的洗礼。我相信，这本书对任何对计算机科学和软件开发感兴趣的人，都会有所启发和帮助~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/08/05/RsGxkFc5UWJM6eq.jpg&quot; alt=&quot;UNIX-A-History-and-a-Memoir.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/35292726&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《UNIX 传奇：历史与回忆》&lt;/a&gt; 是 bwk（&lt;a href=&quot;https://en.wikipedia.org/wiki/Brian_Kernighan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Brian W. Kernighan&lt;/a&gt;）2019 年的新作，回忆了 UNIX 在大半个世纪的风雨历程，是一本引人入胜的书籍。通过对 UNIX 操作系统的历史和发展进行详细的叙述和回顾，让我对这个操作系统有了更深入的了解。读完这本书，我不仅对 UNIX 的技术细节有了更清晰的认识，也对 UNIX 的影响力和价值有了更深刻的体会。&lt;/p&gt;
    
    </summary>
    
    
      <category term="UNIX" scheme="https://www.mghio.cn/categories/UNIX/"/>
    
    
      <category term="UNIX" scheme="https://www.mghio.cn/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>Go 并发模型—Goroutines</title>
    <link href="https://www.mghio.cn/post/ba5cf393.html"/>
    <id>https://www.mghio.cn/post/ba5cf393.html</id>
    <published>2024-12-21T06:10:49.000Z</published>
    <updated>2024-12-21T06:19:05.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/07/09/rDYw1tPJydqOCp5.png" alt="Concurrency_in_Go.png"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a href="#前言" title="前言"></a>前言</h3><p>Goroutines 是 <a href="https://go.dev/" target="_blank" rel="noopener">Go</a> 语言主要的并发原语。它看起来非常像线程，但是相比于线程它的<strong>创建和管理成本很低</strong>。Go 在运行时将 goroutine 有效地调度到真实的线程上，以避免浪费资源，因此您可以轻松地创建大量的 goroutine（例如每个请求一个 goroutine），并且您可以编写简单的，命令式的阻塞代码。因此，Go 的网络代码往往比其它语言中的等效代码更直接，更容易理解（这点从下文中的示例代码可以看出）。</p><p>对我来说，goroutine 是将 Go 这门语言与其它语言区分开来的一个主要特征。这就是为什么大家更喜欢用 Go 来编写需要并发的代码。在下面讨论更多关于 goroutine 之前，我们先了解一些历史，这样你就能理解为什么你想要它们了。</p><a id="more"></a><h3 id="基于-fork-和线程"><a href="#基于-fork-和线程" class="headerlink" title="基于 fork 和线程"></a><a href="#基于-fork-和线程" title="基于 fork 和线程"></a>基于 fork 和线程</h3><p><img src="https://s2.loli.net/2023/07/09/c4g8HaVGtLY5Qw1.jpg" alt="fork_thread.jpeg"></p><p>高性能服务器需要同时处理来自多个客户端的请求。有很多方法可以设计一个服务端架构来处理这个问题。最容易想到的就是让一个主进程在循环中调用 accept，然后调用 fork 来创建一个处理请求的子进程。这篇 <a href="https://beej.us/guide/bgnet/html" target="_blank" rel="noopener">Beej’s Guide to Network Programming</a> 指南中提到了这种方式。</p><p>在网络编程中，fork 是一个很好的模式，因为你可以专注于网络而不是服务器架构。但是它很难按照这种模式编写出一个高效的服务器，现在应该没有人在实践中使用这种方式了。</p><p>fork 同时也存在很多问题，首先第一个是<strong>成本</strong>: Linux 上的 fork 调用看起来很快，但它会将你所有的内存标记为 <a href="https://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="noopener">copy-on-write</a>。每次写入 copy-on-write 页面都会导致一个小的页面错误，这是一个很难测量的小延迟，进程之间的上下文切换也很昂贵。</p><p>另一个问题是<strong>规模</strong>: 很难在大量子进程中协调共享资源（如 CPU、内存、数据库连接等）的使用。如果流量激增，并且创建了太多进程，那么它们将相互争夺 CPU。但是如果限制创建的进程数量，那么在 CPU 空闲时，大量缓慢的客户端可能会阻塞每个人的正常使用，这时使用超时机制会有所帮助（无论服务器架构如何，超时设置都是很必要的）。</p><p>通过使用线程而不是进程，上面这些问题在一定程度上能得到缓解。创建线程比创建进程更“便宜”，因为它共享内存和大多数其它资源。在共享地址空间中，线程之间的通信也相对容易，使用信号量和其它结构来管理共享资源，然而，线程仍然有很大的成本，如果你为每个连接创建一个新线程，你会遇到<strong>扩展问题</strong>。与进程一样，你此时需要限制正在运行的线程的数量，以避免严重的 CPU 争用，并且需要使慢速请求超时。创建一个新线程仍然需要时间，尽管可以通过使用线程池在请求之间回收线程来缓解这一问题。</p><p>无论你是使用进程还是线程，你仍然有一个难以回答的问题: <strong>你应该创建多少个线程？</strong>如果您允许无限数量的线程，客户端可能会用完所有的内存和 CPU，而流量会出现小幅激增。如果你限制服务器的最大线程数，那么一堆缓慢的客户端就会阻塞你的服务器。虽然超时是有帮助的，但它仍然很难有效地使用你的硬件资源。</p><h3 id="基于事件驱动"><a href="#基于事件驱动" class="headerlink" title="基于事件驱动"></a><a href="#基于事件驱动" title="基于事件驱动"></a>基于事件驱动</h3><p><img src="https://s2.loli.net/2023/07/09/ZNvAcjpRnlG69YC.png" alt="event-driven.png"></p><p>那么既然无法轻易预测出需要多少线程，当如果尝试将请求与线程<strong>解耦</strong>时会发生什么呢？如果我们只有一个线程专门用于应用程序逻辑（或者可能是一个小的、固定数量的线程），然后在后台使用异步系统调用处理所有的网络流量，会怎么样？这就是一种 <a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="noopener">事件驱动</a> 的服务端架构。</p><p>事件驱动架构模式是围绕 <a href="https://manpages.debian.org/unstable/manpages-dev/select.2.en.html" target="_blank" rel="noopener">select</a> 系统调用设计的。后来像 <a href="https://manpages.debian.org/bookworm/manpages-dev/poll.2.en.html" target="_blank" rel="noopener">poll</a> 这样的机制已经取代了 select，但是 select 是广为人知的，它们在这里都服务于相同的概念和目的。select 接受一个文件描述符列表（通常是套接字），并返回哪些是准备好读写的。如果所有文件描述符都没有准备好，则选择阻塞，直到<strong>至少有一个准备好</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, </span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *<span class="keyword">restrict</span> readfds, </span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *<span class="keyword">restrict</span> writefds, </span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *<span class="keyword">restrict</span> exceptfds, </span></span></span><br><span class="line"><span class="function"><span class="params">           struct timeval *<span class="keyword">restrict</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, </span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">nfds_t</span> nfds, </span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>为了实现一个事件驱动的服务器，你需要跟踪一个 socket 和网络上被阻塞的每个请求的一些状态。在服务器上有一个单一的主事件循环，它调用 select 来处理所有被阻塞的套接字。当 select 返回时，服务器知道哪些请求可以进行了，因此对于每个请求，它调用应用程序逻辑中的存储状态。当应用程序需要再次使用网络时，它会将套接字连同新状态一起添加回“阻塞”池中。这里的状态可以是应用程序恢复它正在做的事情所需的任何东西: 一个要回调的 closure，或者一个 Promise。</p><p>从技术上讲，这些其实都可以用一个线程实现。这里不能谈论任何特定实现的细节，但是像 JavaScript<br>这样缺乏线程的语言也很好的遵循了这个模型。Node.js 更是将自己描述为“an event-driven JavaScript runtime, designed to build scalable network applications.”</p><p>事件驱动的服务器通常比纯粹基于 fork 或线程的服务器更好地利用 CPU 和内存。你可以为每个核心生成一个应用程序线程来并行处理请求。线程不会相互争夺 CPU，因为<strong>线程的数量等于内核的数量</strong>。当有请求可以进行时，线程永远不会空闲，非常高效。效率如此之高，以至于现在大家都使用这种方式来编写服务端代码。</p><p>从理论上讲，这听起来不错，但是如果你编写这样的应用程序代码，就会发现这是一场噩梦。。。具体是什么样的噩梦，取决于你所使用的语言和框架。在 JavaScript 中，异步函数通常返回一个 Promise，你给它附加回调。在 Java gRPC 中，你要处理的是 StreamObserver。如果你不小心，你最终会得到很多深度嵌套的“箭头代码”函数。如果你很小心，你就把函数和类分开了，混淆了你的控制流。不管怎样，你都是在 <a href="https://stackoverflow.com/questions/25098066/what-is-callback-hell-and-how-and-why-does-rx-solve-it" target="_blank" rel="noopener">callback hell</a> 里。</p><p>下面是一个 <a href="https://grpc.io/docs/languages/java/basics/#bidirectional-streaming-rpc-1" target="_blank" rel="noopener">Java gRPC 官方教程</a> 中的一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">routeChat</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  info(<span class="string">"*** RoutChat"</span>);</span><br><span class="line">  <span class="keyword">final</span> CountDownLatch finishLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">  StreamObserver&lt;RouteNote&gt; requestObserver =</span><br><span class="line">      asyncStub.routeChat(<span class="keyword">new</span> StreamObserver&lt;RouteNote&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(RouteNote note)</span> </span>&#123;</span><br><span class="line">          info(<span class="string">"Got message \"&#123;0&#125;\" at &#123;1&#125;, &#123;2&#125;"</span>, note.getMessage(), note.getLocation()</span><br><span class="line">              .getLatitude(), note.getLocation().getLongitude());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">          Status status = Status.fromThrowable(t);</span><br><span class="line">          logger.log(Level.WARNING, <span class="string">"RouteChat Failed: &#123;0&#125;"</span>, status);</span><br><span class="line">          finishLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          info(<span class="string">"Finished RouteChat"</span>);</span><br><span class="line">          finishLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    RouteNote[] requests =</span><br><span class="line">        &#123;newNote(<span class="string">"First message"</span>, <span class="number">0</span>, <span class="number">0</span>), newNote(<span class="string">"Second message"</span>, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">            newNote(<span class="string">"Third message"</span>, <span class="number">1</span>, <span class="number">0</span>), newNote(<span class="string">"Fourth message"</span>, <span class="number">1</span>, <span class="number">1</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RouteNote request : requests) &#123;</span><br><span class="line">      info(<span class="string">"Sending message \"&#123;0&#125;\" at &#123;1&#125;, &#123;2&#125;"</span>, request.getMessage(), request.getLocation()</span><br><span class="line">          .getLatitude(), request.getLocation().getLongitude());</span><br><span class="line">      requestObserver.onNext(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// Cancel RPC</span></span><br><span class="line">    requestObserver.onError(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Mark the end of requests</span></span><br><span class="line">  requestObserver.onCompleted();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Receiving happens asynchronously</span></span><br><span class="line">  finishLatch.await(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码官方的初学者教程，它不是一个完整的例子，发送代码是同步的，而接收代码是异步的。在 Java 中，你可能会为你的 HTTP 服务器、gRPC、数据库和其它任何东西处理不同的异步类型，你需要在所有这些服务器之间使用适配器，这很快就会变得一团糟。</p><p>同时这里如果使用锁也很危险，你需要小心跨网络调用持有锁。锁和回调也很容易犯错误。例如，如果一个同步方法调用一个返回 ListenableFuture 的函数，然后附加一个内联回调，那么这个回调也需要一个同步块，即使它嵌套在父方法内部。</p><h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a><a href="#Goroutines" title="Goroutines"></a>Goroutines</h3><p><img src="https://s2.loli.net/2023/07/09/5pqmnA4Mwv6dHbS.jpg" alt="goroutine.jpg"></p><p>终于到了我们的主角——goroutines。它是 Go 语言版本的线程。像它语言（比如：Java）中的线程一样，每个 gooutine 都有自己的堆栈。goroutine 可以与其它 goroutine 并行执行。与线程不同，goroutine 的创建成本非常低:<strong>它不绑定到 OS 线程上，它的堆栈开始非常小（初始只有 2 K），但可以根据需要增长。当你创建一个 goroutine 时，你实际上是在分配一个 closure，并在运行时将其添加到队列中。</strong></p><p>在内部实现中，Go 的运行时有一组执行程序的 OS 线程（通常每个内核一个线程）。当一个线程可用并且一个 goroutine 准备运行时，运行时将这个 goroutine 调度到线程上，执行应用程序逻辑。如果一个运行例程阻塞了像 mutex 或 channel 这样的东西时，运行时将它添加到阻塞的运行 goroutine 集合中，然后将下一个就绪的运行例程调度到同一个 OS 线程上。</p><p>这也适用于网络:当一个线程程序在未准备好的套接字上发送或接收数据时，它将其 OS 线程交给调度器。这听起来是不是很熟悉？Go 的调度器很像事件驱动服务器中的主循环。除了仅仅依赖于 select 和专注于文件描述符之外，调度器处理语言中可能阻塞的所有内容。</p><p>你不再需要避免阻塞调用，因为调度程序可以有效地利用 CPU。可以自由地生成许多 goroutine（可以每个请求一个!），因为创建它们的成本很低，而且不会争夺 CPU，你不需要担心线程池和执行器服务，因为运行时实际上有一个大的线程池。</p><p>简而言之，你可以用干净的命令式风格编写简单的阻塞应用程序代码，就像在编写一个基于线程的服务器一样，但你保留了事件驱动服务器的所有效率优势，两全其美。这类代码可以很好地跨框架组合。你不需要 streamobserver 和 ListenableFutures 之间的这类适配器。</p><p>下面让我们看一下来自 <a href="https://grpc.io/docs/languages/go/basics/#bidirectional-streaming-rpc-1" target="_blank" rel="noopener">Go gRPC 官方教程</a> 的相同示例。可以发现这里的控制流比 Java 示例中的更容易理<br>解，因为<strong>发送和接收代码都是同步的</strong>。在这两个 goroutines 中，我们都可以在一个 for 循环中调用 stream.Recv 和stream.Send。不再需要回调、子类或执行器这些东西了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stream, err := client.RouteChat(context.Background())</span><br><span class="line">waitc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    in, err := stream.Recv()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">      <span class="comment">// read done.</span></span><br><span class="line">      <span class="built_in">close</span>(waitc)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">"Failed to receive a note : %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Got message %s at point(%d, %d)"</span>, in.Message, in.Location.Latitude, in.Location.Longitude)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> _, note := <span class="keyword">range</span> notes &#123;</span><br><span class="line">  <span class="keyword">if</span> err := stream.Send(note); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"Failed to send a note: %v"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">stream.CloseSend()</span><br><span class="line">&lt;-waitc</span><br></pre></td></tr></table></figure><h3 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a><a href="#虚拟线程" title="虚拟线程"></a>虚拟线程</h3><p><img src="https://s2.loli.net/2023/07/09/1TFslYDnSNv3pfC.png" alt="virtual_threads.png"></p><p>如何你使用 Java 这门语言，到目前为止，你要么必须生成数量不合理的线程，要么必须处理 Java 特有的回调地狱。令人高兴的是，<a href="https://openjdk.org/jeps/444" target="_blank" rel="noopener">JEP 444</a> 中增加了 <a href="https://blog.rockthejvm.com/ultimate-guide-to-java-virtual-threads" target="_blank" rel="noopener">virtual threads</a>，这看起来很像 Go 语言中的 goroutine。</p><p>创建虚拟线程的成本很低。JVM 将它们调度到平台线程（platform threads，内核中的真实线程）上。平台线程的数量是固定的，一般每个内核一个平台线程。当一个虚拟线程执行阻塞操作时，它会释放它的平台线程，JVM<br>可能会将另一个虚拟线程调度到它上面。与 gooutine 不同，虚拟线程调度是协作的: <strong>虚拟线程在执行阻塞操作之前不会服从于调度程序。这意味着紧循环可以无限期地保持线程</strong>。目前不清楚这是实现限制还是有更深层次的问题。Go 以前也有这个问题，直到 1.14 才实现了完全抢占式调度（可见 <a href="https://www.youtube.com/watch?v=wQpC99Xu1U4" target="_blank" rel="noopener">GopherCon 2021</a>）。</p><p>Java 的虚拟线程现在可以预览，预计在 <a href="https://openjdk.org/projects/jdk/21" target="_blank" rel="noopener">JDK 21</a> 中成为 stable（官方消息是预计 2023 年 9 月发布）状态。哈哈，很期待到时候能删除大量的 ListenableFutures。每当引入一种新的语言或运行时特性时，都会有一个漫长的迁移过渡期，个人认为 Java 生态系统在这方面还是过于保守了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/07/09/rDYw1tPJydqOCp5.png&quot; alt=&quot;Concurrency_in_Go.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#前言&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Goroutines 是 &lt;a href=&quot;https://go.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go&lt;/a&gt; 语言主要的并发原语。它看起来非常像线程，但是相比于线程它的&lt;strong&gt;创建和管理成本很低&lt;/strong&gt;。Go 在运行时将 goroutine 有效地调度到真实的线程上，以避免浪费资源，因此您可以轻松地创建大量的 goroutine（例如每个请求一个 goroutine），并且您可以编写简单的，命令式的阻塞代码。因此，Go 的网络代码往往比其它语言中的等效代码更直接，更容易理解（这点从下文中的示例代码可以看出）。&lt;/p&gt;
&lt;p&gt;对我来说，goroutine 是将 Go 这门语言与其它语言区分开来的一个主要特征。这就是为什么大家更喜欢用 Go 来编写需要并发的代码。在下面讨论更多关于 goroutine 之前，我们先了解一些历史，这样你就能理解为什么你想要它们了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Go" scheme="https://www.mghio.cn/categories/Go/"/>
    
      <category term="并发模型" scheme="https://www.mghio.cn/categories/Go/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="Go" scheme="https://www.mghio.cn/tags/Go/"/>
    
      <category term="并发模型" scheme="https://www.mghio.cn/tags/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB 是如何解决幻读的</title>
    <link href="https://www.mghio.cn/post/204a5428.html"/>
    <id>https://www.mghio.cn/post/204a5428.html</id>
    <published>2024-12-21T05:36:04.000Z</published>
    <updated>2024-12-21T06:17:07.017Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/04/05/XfSsyqzUIRjtc8d.jpg" alt="cover.jpg"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><a href="#前言" title="前言"></a>前言</h3><p>大部分人在日常的业务开发中，其实很少去关注数据库的事务相关问题，基本上都是 CURD 一把梭。正好最近在看 MySQL 的相关基础知识，其中对于幻读问题之前一直没有理解深刻，今天就来聊聊「InnoDB 是如何解决幻读的」，话不多说，下面进入主题。</p><a id="more"></a><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a><a href="#事务隔离级别" title="事务隔离级别"></a>事务隔离级别</h3><p>事务隔离是数据库处理的基础之一，是 <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_acid" target="_blank" rel="noopener">ACID</a> 中的 <code>I</code>。在 MySQL 的 InnoDB 引擎中支持在 <a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt" target="_blank" rel="noopener">SQL:1992</a> 标准中的四种事务隔离级别，如下图所示，其中 P1 表示脏读（Dirty read），P2 表示不可重复读（Dirty read），P3 表示幻读（Phantom）。</p><p><img src="https://s2.loli.net/2023/04/05/PuxXHcAVYnGwkqy.jpg" alt="SQL1992_transaction_isolation_levels.jpg"></p><p>为什么需要定义这么多隔离呢？从上图中也能猜出一二了，InnoDB 提供多个隔离级别主要原因是：让使用者可以在<strong>多个事务</strong>同时进行更改和执行查询时微调性能与结果的可靠性、一致性和可再现性之间的平衡的设置。是一种性能与结果可靠性间的 <code>trade off</code>。</p><h3 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a><a href="#什么是幻读" title="什么是幻读"></a>什么是幻读</h3><p>在聊「InnoDB 解决幻读方式」前我们需要先了解<strong>幻读是什么</strong>，<a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html" target="_blank" rel="noopener">官方文档</a>的描述如下：</p><blockquote><p>A row that appears in the <strong>result set</strong> of a query, but not in the <strong>result set</strong> of an earlier query.</p></blockquote><p>其中我加粗的「result set」是关键的地方，两次查询返回的是结果集，说明必须是一个<strong>范围查询</strong>操作。总结下，幻读就是：在同一个事务中，在前后两次查询相同范围时，两次查询得到的结果是不一致的。所以幻读会产生数据一致性问题。</p><p><img src="https://s2.loli.net/2023/04/05/zwqk6xm389EcUFS.jpg" alt="Xnip2023-04-05_16-05-06.jpg"></p><h3 id="InnoDB-解决幻读方式"><a href="#InnoDB-解决幻读方式" class="headerlink" title="InnoDB 解决幻读方式"></a><a href="#InnoDB-解决幻读方式" title="InnoDB 解决幻读方式"></a>InnoDB 解决幻读方式</h3><p>为了解决上述的幻读问题，InnoDB 引入了两种锁，分别是「间隙锁」和「next-key 锁」。下面通过一个示例来描述这两种锁的作用分别是什么。假如存在一个这样的 B+ Tree 的索引结构，结构中有 4 个索引元素分别是：9527、9530、9535、9540。</p><p><img src="https://s2.loli.net/2023/04/05/6epazYv92fG1scQ.jpg" alt="Xnip2023-04-05_16-16-53.jpg"></p><p>此时当我们使用如下 SQL 通过主键索引查询一条记录，并且加上 X 锁（排它锁）时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">9527</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>这时就会产生一个记录锁（也就是行锁），锁定 <code>id = 9527</code> 这个索引。</p><p><img src="https://s2.loli.net/2023/04/05/eSTOXqhUvLrilzf.jpg" alt="Xnip2023-04-05_16-26-17.jpg"></p><p>在被锁定的记录（这里是 id = 9527）的锁释放之前，其它事务无法对这条被锁定记录做任何操作。再回忆一下，前面说的幻读定义「在同一个事务中，在前后两次查询相同<strong>范围</strong>时，两次查询得到的结果是不一致」。注意，这里强调的是范围查询。</p><p>InnoDB 要解决幻读问题，就必须得保证在如果在一个事务中，通过如下这条语句进行锁定时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">9530</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt; <span class="number">9535</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>此时，另外一个语句再执行一如下这条 insert 语句时，需要被阻塞，直到上面这个获得锁的事务释放锁后才能执行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="keyword">id</span>, <span class="keyword">name</span>, age) <span class="keyword">values</span>(<span class="number">9533</span>, <span class="string">'Jack'</span>, <span class="number">44</span>);</span><br></pre></td></tr></table></figure><p>为此，InnoDB 引入了「间隙锁」，它的主要功能是<strong>锁定一段范围内的索引记录</strong>。比如上面查询 <code>id &gt; 9530 and id &lt; 9535</code> 的时候，对 B+ Tree 中的（9530，9535）这个开区间范围的索引加间隙锁。</p><p>在这种加了间隙锁的情况下，其它事务对这个区间的数据进行插入、更新、删除都会被锁住直到这个获取到锁的事务释放。</p><p><img src="https://s2.loli.net/2023/04/05/3rjDwAvMu1gnIZe.jpg" alt="Xnip2023-04-05_16-44-36.jpg"></p><p>这种是在区间之间的情况，你可能想到另外的一种情况：锁定多个区间，如下的一条语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">9530</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>上面这条查询语句是针对 <code>id &gt; 9530</code> 这个条件加锁，那么此时它需要锁定多个索引区间，所以在这种情况下 InnoDB 引入了「next-key 锁」机制。其实 next-key 锁的效果相当于间隙锁和记录锁的合集，记录锁锁定存在的记录行，间隙锁锁住记录行之间的间隙，而 next-key 锁它锁住的是两者之和。</p><p><img src="https://s2.loli.net/2023/04/05/P1dg6RBGxYMIqcH.jpg" alt="Xnip2023-04-05_16-56-55.jpg"></p><p>在 InnoDB 中，每个数据行上的<strong>非唯一索引</strong>列上都会存在一把 next-key 锁，当某个事务持有该数据行的 next-key 锁时，会锁住一段<strong>左开右闭区间</strong>的数据。因此，当通过 <code>id &gt; 9530</code> 这样一种范围查询加锁时，会加 next-key 锁，锁定区间是范围是：</p><blockquote><p>(9530，9535] (9535，9540] (9540，+∞]</p></blockquote><p><img src="https://s2.loli.net/2023/04/05/U2QXBVyzOILDRtA.jpg" alt="Xnip2023-04-05_17-04-07.jpg"></p><p>间隙锁（也叫 Gap 锁）和 next-key 锁的区别在于<strong>加锁的范围</strong>，间隙锁只锁定两个索引之间的引用间隙，而 next-key 锁会锁定多个索引区间，它包含「记录锁」和「间隙锁」。所以，当我们使用了范围查询，不仅仅命中了已存在的 Record 记录，还包含了 Gap 间隙。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#总结" title="总结"></a>总结</h3><p>虽然在 InnoDB 引擎中通过间隙锁和 next-key 锁的方式解决了幻读问题，但是加锁之后会影响到数据库的并发性能，因此，如果对性能要求较高的业务场景中，建议把隔离级别设置成 RC（READ COMMITTED），这个级别中不存在间隙锁，但是需要考虑到幻读问题会导致的数据一致性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2023/04/05/XfSsyqzUIRjtc8d.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#前言&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;大部分人在日常的业务开发中，其实很少去关注数据库的事务相关问题，基本上都是 CURD 一把梭。正好最近在看 MySQL 的相关基础知识，其中对于幻读问题之前一直没有理解深刻，今天就来聊聊「InnoDB 是如何解决幻读的」，话不多说，下面进入主题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://www.mghio.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="InnoDB" scheme="https://www.mghio.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB/"/>
    
    
      <category term="数据库" scheme="https://www.mghio.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="InnoDB" scheme="https://www.mghio.cn/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>抓包分析 TCP 握手和挥手</title>
    <link href="https://www.mghio.cn/post/216a8d02.html"/>
    <id>https://www.mghio.cn/post/216a8d02.html</id>
    <published>2022-11-06T04:51:47.000Z</published>
    <updated>2022-11-06T08:37:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/11/06/fz8Rgle4BNGySLU.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先需要明确的是 TCP 是一个<strong>可靠传输协议</strong>，它的所有特点最终都是为了这个可靠传输服务。在网上看到过很多文章讲 TCP 连接的<code>三次握手</code>和断开连接的<code>四次挥手</code>，但是都太过于理论，看完感觉总是似懂非懂。反复思考过后，觉得我自己还是偏工程型的人，要学习这些理论性的知识，最好的方式还是要通过实际案例来理解，这样才会具象深刻。本文通过 <a href="https://www.wireshark.org" target="_blank" rel="noopener">Wireshark</a> 抓包来分析 TCP <code>三次握手</code>和<code>四次挥手</code>，如果你也对这些理论感觉似懂非懂，那么强烈建议你也结合抓包实践来强化理解这些理论性的知识。</p><a id="more"></a><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP 建立连接的三次握手是连接的双方协商确认一些信息（Sequence number、Maximum Segment Size、Window Size 等），Sequence number 有两个作用：一个是 SYN 标识位为 1 时作为初始序列号（ISN），则实际第一个数据字节的序列号和相应 ACK 中的确认号就是这个序列号加 1；另一个是 SYN 标识位为 0 时，则是当前会话的 segment（传输层叫 segment，网络层叫 packet，数据链路层叫 frame）的第一个数据字节的累积序列号。Maximum Segment Size 简称 MSS，表示最大一个 segment 中能传输的信息（不含 TCP、IP 头部）。Window Size 表示发送方接收窗口的大小。下面看看我在本地访问博客 <a href="https://www.mghio.cn">mghio</a> 的三次握手过程：</p><p><img src="https://s2.loli.net/2022/11/06/wPBHKzRA7D3lV8g.jpg" alt="three-way-hand-shake.jpg"></p><p>图中三个小红框表示与<a href="https://www.mghio.cn">服务器</a>建立连接的三次握手。</p><ol><li>第一步，client 端（这个示例也就是浏览器）发送 SYN 到 server 端；</li><li>第二步，server 端收到 SYN 消息后，回复 SYN + ACK 到client 端，ACK 表示已经收到了 client 的 SYN 消息；</li><li>第三步，client 端收到回复 SYN + ACK 后，也回复一个 ACK 表示收到了 server 端的 SYN + ACK 了，其实</li></ol><p>到这一步，client 端的 60469 端口已经是 ESTABLISHED 状态了。<br>可以看到，其实三次握手的核心目的就是双方互相告知对象自己的 Sequence number，蓝框是 client 端的初始 Sequence number 和 client 端回复的 ACK，绿框是 server 端的初始 Sequence number 和 client 端回复的 ACK。这样协商好初始 Sequence number 后，发送数据包时发送端就可以判断丢包和进行丢包重传了。</p><p>三次握手还有一个目的是协商一些信息（上图中黄色方框是 Maximum Segment Size，粉色方框是 Window Size）。</p><p><img src="https://s2.loli.net/2022/11/06/jPxn1AU8ObwTqhg.jpg" alt="three-way-hand-shake-dg.jpg"></p><p>到这里，就可以知道平常所说的<code>建立TCP连接</code>本质是为了实现 TCP 可靠传输做的前置准备工作，实际上物理层并没有这个连接在那里。TCP 建立连接之后时拥有和维护一些状态信息，这个状态信息就包含了 Sequence number、MSS、Window Size 等，TCP 握手就是协商出来这些初始值。而这些状态才是我们平时所说的 TCP 连接的本质。因为这个太重要了，我还要再次强调一下，<strong>TCP 是一个可靠传输协议，它的所有特点最终都是为了这个可靠传输服务</strong>。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>下面再来看看，当关闭浏览器页面是发生断开连接的四次挥手过程:</p><p><img src="https://s2.loli.net/2022/11/06/u9ac8jHC2m3xZAO.jpg" alt="tcp-close-sequence.jpg"></p><p>相信你已经发现了，上图抓包抓到的不是四次挥手，而是三次挥手，这是为何呢？</p><p>这是由于 TCP 的时延机制（因为系统内核并不知道应用能不能立即关闭），当被挥手端（这里是 server 的 443 端口）第一次收到挥手端（这里是 client 的 63612 端口）的 FIN 请求时，并不会立即发送 ACK，而是会经过一段延迟时间后再发送，但是此时被挥手端也没有数据发送，就会向挥手端发送 FIN 请求，这里就可能造成被挥手端发送的 FIN 与 ACK 一起被挥手端收到，导致出现第二、三次挥手合并为一次的现象，也就最终呈现出“三次挥手”的情况。</p><p>断开连接四次挥手分为如下四步（假设没有出现挥手合并的情况）：</p><ol><li>第一步，client 端主动发送 FIN 包给 server 端；</li><li>第二步，server 端回复 ACK（对应第一步 FIN 包的 ACK）给 client，表示 server 知道 client 端要断开了；</li><li>第三步，server 端发送 FIN 包给 client 端，表示 server 端也没有数据要发送了，可以断开了；</li><li>第四步，client 端回复 ACK 包给 server 端，表示既然双发都已发送 FIN 包表示可以断开，那么就真的断开了啊。</li></ol><p>下面是 TCP 连接流转状态图（其中 CLOSED 状态是虚拟的，实际上并不存在），这个图很重要，记住这个图后基本上所有的 TCP 网络问题就可以解决。</p><p><img src="https://s2.loli.net/2022/11/06/vwpbGhPZcfmsKri.jpg" alt="tcp_state_diagram.png"></p><p>其中比较难以理解的是 TIME_WAIT 状态，主动关闭的那一端会经历这个状态。这一端停留在这个状态的最长时间是 Maximum segment lifetime（MSL）的 2 倍，大部分时候被简称之为 2MSL。存在 TIME_WAIT 状态有如下两个原因：</p><ol><li>要可靠的实现 TCP 全双工连接终止；</li><li>让老的重复 segment 在网络中消失（一个 sement 在网络中存活的最长时间为 1 个 MSL，一来一回就是 2 MSL）；</li></ol><h2 id="为什么握手是三次，而挥手是四次？"><a href="#为什么握手是三次，而挥手是四次？" class="headerlink" title="为什么握手是三次，而挥手是四次？"></a>为什么握手是三次，而挥手是四次？</h2><p>嘿嘿，这是个经典的面试题，其实大部分人都背过挥手是四次的原因：因为 TCP 是全双工（双向）的，所以回收需要四次……。但是再反问下：握手也是双向的，但是为什么是只要三次呢？</p><p>网上流传的资料都说 TCP 是双向的，所以回收需要四次，但是握手也是双向（握手双方都在告知对方自己的初始 Sequence number），那么为什么就不用四次握手呢？所以凡事需要多问几个为什么，要有探索和怀疑精神。</p><p>你再仔细回看上面三次握手的第二步（SYN + ACK），其实是可以拆分为两步的：第一步回复 ACK，第二步再发 SYN 也是完全可以的，只是效率会比较低，这样的话三次握手不也变成四次握手了。</p><p>看起来四次挥手主要是收到第一个 FIN 包后单独回复了一个 ACK 包这里多了一次，如果能像握手那样也回复 FIN + ACK 那么四次挥手也就变成三次了。这里再贴一下上面这个挥手的抓包图：</p><p><img src="https://s2.loli.net/2022/11/06/u9ac8jHC2m3xZAO.jpg" alt="tcp-close-sequence.jpg"></p><p>这个图中第二个红框就是 server 端回复的 FIN + ACK 包，这样四次挥手变成三次了（如果一个包算一次的话）。这里使用四次挥手原因主要是：被动关闭端在收到 FIN 后，知道主动关闭端要关闭了，然后系统内核层会通知应用层要关闭，此时应用层可能还需要做些关闭前的准备工作，可能还有数据没发送完，所以系统内核先回复一个 ACK 包，然后等应用层准备好了主动调 close 关闭时再发 FIN 包。</p><p>而握手过程中就没有这个准备过程了，所以可以立即发送 SYN + ACK（在这里的两步合成一步了，提高效率）。挥手过程中系统内核在收到对方的 FIN 后，只能 ACK，不能主动替应用来 FIN，因为系统内核并不知道应用能不能立即关闭。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP 是一个很复杂的协议，为了实现可靠传输以及处理各种网络传输中的 N 多问题，有一些很经典的解决方案，比如其中的网络拥塞控制算法、滑动窗口、数据重传等。强烈建议你去读一下 <a href="https://www.rfc-editor.org/rfc/rfc793" target="_blank" rel="noopener">rfc793</a> 和 <a href="https://book.douban.com/subject/1088054/" target="_blank" rel="noopener">TCP/IP 详解 卷1：协议</a> 这本书。</p><p>如果你是那些纯看理论就能掌握好一门技能，然后还能举三反一的人，那我很佩服你；如果不是，那么学习理论知识注意要结合实践来强化理解理论，要经过反反复复才能比较好地掌握一个知识，讲究技巧，必要时要学会通过工具来达到目的。</p><p>最后 TCP 所有特性基本上核心都是为了<strong>实现可靠传输</strong>这个目标来服务的，然后有一些是出于优化性能的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/11/06/fz8Rgle4BNGySLU.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;首先需要明确的是 TCP 是一个&lt;strong&gt;可靠传输协议&lt;/strong&gt;，它的所有特点最终都是为了这个可靠传输服务。在网上看到过很多文章讲 TCP 连接的&lt;code&gt;三次握手&lt;/code&gt;和断开连接的&lt;code&gt;四次挥手&lt;/code&gt;，但是都太过于理论，看完感觉总是似懂非懂。反复思考过后，觉得我自己还是偏工程型的人，要学习这些理论性的知识，最好的方式还是要通过实际案例来理解，这样才会具象深刻。本文通过 &lt;a href=&quot;https://www.wireshark.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wireshark&lt;/a&gt; 抓包来分析 TCP &lt;code&gt;三次握手&lt;/code&gt;和&lt;code&gt;四次挥手&lt;/code&gt;，如果你也对这些理论感觉似懂非懂，那么强烈建议你也结合抓包实践来强化理解这些理论性的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="network" scheme="https://www.mghio.cn/categories/network/"/>
    
      <category term="TCP" scheme="https://www.mghio.cn/categories/network/TCP/"/>
    
    
      <category term="network" scheme="https://www.mghio.cn/tags/network/"/>
    
      <category term="TCP" scheme="https://www.mghio.cn/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中 @EnableXXX 注解的套路</title>
    <link href="https://www.mghio.cn/post/aa9d18bf.html"/>
    <id>https://www.mghio.cn/post/aa9d18bf.html</id>
    <published>2022-06-05T08:29:44.000Z</published>
    <updated>2022-11-05T08:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/05/22/NC7L6GlyJYM1kxt.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Spring 框架中有很多实用的功能，不需要写大量的配置代码，只需添加几个注解即可开启。 其中一个重要原因是那些 @EnableXXX 注解，它可以让你通过在配置类加上简单的注解来快速地开启诸如事务管理（@EnableTransactionManagement）、Spring MVC（@EnableWebMvc）或定时任务（@EnableScheduling）等功能。这些看起来简单的注解语句提供了很多功能，但它们的内部机制从表面上看却不太明显。 一方面，对于使用者来说用这么少的代码获得这么多实用的功能是很好的，但另一方面，如果你不了解某个东西的内部是如何工作的，就会使调试和解决问题更加困难。</p><a id="more"></a><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>Spring 框架中那些 @EnableXXX 注解的设计目标是允许用户用最少的代码来开启复杂使用的功能。 此外，用户必须能够使用简单的默认值，或者允许手动配置该代码。最后，代码的复杂性要向框架使用者隐藏掉。 简而言之，让使用者设置大量的 Bean，并选择性地配置它们，而不必知道这些 Bean 的细节（或真正被设置的内容）。下面来看看具体的几个例子：</p><h2 id="EnableScheduling-导入一个-Configuration-类"><a href="#EnableScheduling-导入一个-Configuration-类" class="headerlink" title="@EnableScheduling (导入一个 @Configuration 类)"></a>@EnableScheduling (导入一个 @Configuration 类)</h2><p>首先要知道的是，@EnableXXX 注解并不神奇。实际上在 BeanFactory 中并不知道这些注解的具体内容，而且在 BeanFactory 类中，核心功能和特定注解（如 @EnableWebMvc）或它们所存放的 jar 包（如 spring-web）之间没有任何依赖关系。 让我们看一下 @EnableScheduling，下面看看它是如何工作的。 定义一个 SchedulingConfig 配置类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">// some bean in here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的内容没有什么特别之处。只是一个用 @EnableScheduling 注释的标准 Java 配置。@EnableScheduling 让你以设定的频率执行某些方法。例如，你可以每 10 分钟运行 BankService.transferMoneyToMghio()。  @EnableScheduling 注解源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(SchedulingConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 EnableScheduling 注解，我们可以看到它只是一个标准的类级注解（@Target/@Retention），应该包含在 JavaDocs 中（@Documented），但是它有一个 Spring 特有的注解（@Import）。 @Import 是将一切联系起来的关键。 在这种情况下，由于我们的 SchedulingConfig 被注解为 @EnableScheduling，当 BeanFactory 解析文件时（内部是ConfigurationClassPostProcessor 在解析它），它也会发现 @Import(SchedulingConfiguration.class) 注解，它将导入该值中定义的类。 在这个注解中，就是 SchedulingConfiguration。 </p><p>这里<strong>导入</strong>是什么意思呢？在这种情况下，它只是被当作另一个 Spring Bean。 SchedulingConfiguration 实际上被注解为@Configuration，所以 BeanFactory 会把它看作是另一个配置类，所有在该类中定义的 Bean 都会被拉入你的应用上下文，就像你自己定义了另一个 @Configuration 类一样。 如果我们检查 SchedulingConfiguration，我们可以看到它只定义了一个Bean（一个Post Processor），它负责我们上面描述的调度工作，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ScheduledAnnotationBeanPostProcessor <span class="title">scheduledAnnotationProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledAnnotationBeanPostProcessor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你会问，如果想配置 SchedulingConfiguration 中定义的 bean 呢？ 这里也只是在处理普通的Bean。 所以你对其它 Bean 所使用的机制也适用于此。 在这种情况下，ScheduledAnnotationBeanPostProcessor 使用一个标准的 Spring Bean 生命周期（postProcessAfterInitialization）来发现应用程序上下文何时被刷新。 当符合条件时，它会检查是否有任何 Bean 实现了 SchedulingConfigurer，如果有，就使用这些 Bean 来配置自己。 其实这一点并不明细（在 IDE 中也不太容易找到），但它与 BeanFactory 是完全分离的，而且是一个相当常见的模式，一个 Bean 被用来配置另一个 Bean。 而现在我们可以把所有的点连接起来，它（在某种程度上）很容易找到（你可以 Google 一下文档或阅读一下 JavaDocs）。</p><h2 id="EnableTransactionManagement（导入一个-ImportSelector）"><a href="#EnableTransactionManagement（导入一个-ImportSelector）" class="headerlink" title="@EnableTransactionManagement（导入一个 ImportSelector）"></a>@EnableTransactionManagement（导入一个 ImportSelector）</h2><p>在上一个示例中，我们讨论了像 @EnableScheduling 这样的注解如何使用 @Import 来导入另一个 @Configuration 类并使其所有的 Bean 对你的应用程序可用（和可配置）。但是如果你想根据某些配置加载不同的 Bean 集，会发生什么呢？ @EnableTransactionManagement 就是一个很好的例子。TransactioConfig 定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>(mode = AdviceMode.ASPECTJ)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactioConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some bean in here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再一次，上面没有什么特别之处。只是一个用@EnableTransactionManagement注释的标准Java配置。唯一与之前的例子有些不同的是，用户为注释指定了一个参数（mode=AdviceMode.ASPECTJ）。 @EnableTransactionManagement注解本身看起来像这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(TransactionManagementConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面一样，一个相当标准的注解，尽管这次它有一些参数。 然而，正如前文提到，@Import 注解是将一切联系在一起的关键，这一点再次得到证实。 但区别在于，这次我们导入的是 TransactionManagementConfigurationSelector 这个类，通过源码可以发现，其实它不是一个被 @Configuration 注解的类。 TransactionManagementConfigurationSelector 是一个实现ImportSelector 的类。 ImportSelector 的目的是让你的代码选择在运行时加载哪些配置类。 它有一个方法，接收关于注解的一些元数据，并返回一个类名数组。 在这种情况下，TransactionManagementConfigurationSelector 会查看模式并根据模式返回一些类。其中的 selectImports 方法源码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> PROXY:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">                           ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">    <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些类中的大多数是 @Configuration（例如 ProxyTransactionManagementConfiguration），通过前文介绍我们知道它们会像前面一样工作。 对于 @Configuration 类，它们被加载和配置的方式与我们之前看到的完全一样。 所以简而言之，我们可以使用 @Import 和 @Configuration 类来加载一套标准的 Bean，或者使用 @Import 和 ImportSelector 来加载一套在运行时决定的 Bean。</p><h2 id="EnableAspectJAutoProxy-在-Bean-定义层导入"><a href="#EnableAspectJAutoProxy-在-Bean-定义层导入" class="headerlink" title="@EnableAspectJAutoProxy (在 Bean 定义层导入)"></a>@EnableAspectJAutoProxy (在 Bean 定义层导入)</h2><p>@Import 支持的最后一种情况，即当你想直接处理 BeanRegistry（工厂）时。如果你需要操作Bean Factory或者在Bean定义层处理Bean，那么这种情况就适合你，它与上面的情况非常相似。 你的 AspectJProxyConfig 可能看起来像。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJProxyConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">// some bean in here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再一次，上面定义没有什么特别的东西。只是一个用 @EnableAspectJAutoProxy 注释的标准 Java 配置。 下面是@EnableAspectJAutoProxy 的源代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面一样，@Import 是关键，但这次它指向 AspectJAutoProxyRegistrar，它既没有 @Configuration 注解，也没有实现 ImportSelector 接口。 这次使用的是实现了 ImportBeanDefinitionRegistrar。 这个接口提供了对 Bean 注册中心（Bean Registry）和注解元数据的访问，因此我们可以在运行时根据注解中的参数来操作 Bean 注册表。 如果你仔细看过前面的示例，你可以看到我们忽略的类也是 ImportBeanDefinitionRegistrar。 在 @Configuration 类不够用的时候，这些类会直接操作 BeanFactory。</p><p>所以现在我们已经涵盖了 @EnableXXX 注解使用 @Import 将各种 Bean 引入你的应用上下文的所有不同方式。 它们要么直接引入一组 @Configuration 类，这些类中的所有 Bean 都被导入到你的应用上下文中。 或者它们引入一个 ImportSelector 接口实现类，在运行时选择一组 @Configuration 类并将这些 Bean 导入到你的应用上下文中。 最后，他们引入一个ImportBeanDefinitionRegistrars，可以直接与 BeanFactory 在 BeanDefinition 级别上合作。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总的来说，个人认为这种将 Bean 导入应用上下文的方法很好，因为它使框架使用者的使用某个功能非常容易。不幸的是，它模糊了如何找到可用的选项以及如何配置它们。 此外，它没有直接利用 IDE 的优势，所以很难知道哪些 Bean 正在被创建（以及为什么）。 然而，现在我们知道了 @Import 注解，我们可以使用 IDE 来挖掘一下每个注解及其相关的配置类，并了解哪些 Bean 正在被创建，它们如何被添加到你的应用上下文中，以及如何配置它们。 希望对你有帮助~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/05/22/NC7L6GlyJYM1kxt.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Spring 框架中有很多实用的功能，不需要写大量的配置代码，只需添加几个注解即可开启。 其中一个重要原因是那些 @EnableXXX 注解，它可以让你通过在配置类加上简单的注解来快速地开启诸如事务管理（@EnableTransactionManagement）、Spring MVC（@EnableWebMvc）或定时任务（@EnableScheduling）等功能。这些看起来简单的注解语句提供了很多功能，但它们的内部机制从表面上看却不太明显。 一方面，对于使用者来说用这么少的代码获得这么多实用的功能是很好的，但另一方面，如果你不了解某个东西的内部是如何工作的，就会使调试和解决问题更加困难。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Spring/"/>
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Spring/Java/"/>
    
      <category term="实现原理" scheme="https://www.mghio.cn/categories/Spring/Java/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="实现原理" scheme="https://www.mghio.cn/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>聊聊二维码</title>
    <link href="https://www.mghio.cn/post/9072a99a.html"/>
    <id>https://www.mghio.cn/post/9072a99a.html</id>
    <published>2022-05-05T08:27:10.000Z</published>
    <updated>2022-11-05T08:28:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/01/09/3UcOhXMfKG4gBP6.jpg" alt="cover.jpg"></p><h2 id="一维码（条形码）"><a href="#一维码（条形码）" class="headerlink" title="一维码（条形码）"></a>一维码（条形码）</h2><p>在介绍二维码之前，先来看看它的“大哥”一维码，一维码也叫条形码（好像在日常生活中都是叫这个），它是由不同宽度的黑条和白条按照一定的顺序排列组成的平行线图案，它的宽度记录着数据信息，长度没有记录信息，条形码常用于标出物品的生产国、制造厂家、商品名称、生产日期、图书分类号、邮件起止地点、类别、日期等信息，比如大部分食品包装袋背后都会印有条形码。</p><a id="more"></a><h2 id="一维码的编码规则"><a href="#一维码的编码规则" class="headerlink" title="一维码的编码规则"></a>一维码的编码规则</h2><p>全球的条形码标准都是由一个叫<code>GS1</code>的非营利性组织管理和维护的，通常情况下条形码由 <code>95</code> 条红或黑色的平行竖线组成，前三条是由<code>黑-白-黑</code> 组成，中间的五条由<code>白-黑-白-黑-白</code>组成，最后的三条和前三条一样也是由<code>黑-白-黑</code>组成，这样就把一个条形码分为左、右两个部分。剩下的 84 (95-3-5-3=84) 条按每 7 条一组分为 12 组，每组对应着一个数字，不同的数字的具体表示因编码方式而有所不同，不过都遵循着一个规律：<code>右侧部分每一组的白色竖线条数都是奇数个。</code>这样不管你是正着扫描还是反着扫描都是可以识别的。</p><p>中国使用的条形码大部分都是 <code>EAN-13</code> 格式的，条形码数字编码的含义从左至右分别是前三位标识来源 <a href="https://en.wikipedia.org/wiki/List_of_GS1_country_codes" target="_blank" rel="noopener">国家编码</a> ，比如中国为：690–699，后面的 4 ~ 8 位数字代表的是厂商公司代码，但是位数不是固定的，紧接着后面 的 9~12 位是商品编码，第 13 位是校验码，这就意味着公司编码越短，剩余可用于商品编码的位数也越多，可表示的商品也就越多，当然公司代码出售价格也相应更昂贵，另外用在商品上的 <code>EAN-13</code> 条码是要到 <a href="http://www.ancc.org.cn/" target="_blank" rel="noopener">国家物品编码中心</a> 去申请的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec4bbe275e4c4c5c9bf1f639e39769e0~tplv-k3u1fbpfcp-zoom-1.image" alt="ean13-example.jpg"></p><h2 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h2><p><strong>二维码</strong> 是在一维码的基础之上扩展出来的，二维码有不同的种类，大体上可以分为这两种 ① 堆叠式/行排式二维条码 ② 矩阵式二维码，其中矩阵式二维码最为流行(下文的二维码指矩阵式二维码)，它与一维码所不同的是它的宽度和长度均有记录数据信息，存储的数据量更大，除此之外还增加了“定位点”和“容错机制”。通过“定位点”使读码机正确识别进行解读，所以二维码不管是从何种方向读取都是可以被识别的。</p><p>“容错机制”可以在没有识别到全部条码时也能正确推断和还原出原始的条码信息，维码的纠错级别，按照不同的纠错率（全部码字与可以纠错的码字的比率）分为 L (约 7%)、M (约 15%)、Q (约 25%)、H (约 30%) 四个不同的级别。比如下面的「<strong>mghio</strong>」公众号二维码尽管中间有公众号头像，但是依然可以正确识别出来就是这个“容错机制”的功能。不管是条形码（一维码）还是二维码其本质上都是对信息的编码，区别只是对信息的编码方式有所不同。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9333e46c16d24f28bf46fc2c5c25b739~tplv-k3u1fbpfcp-zoom-1.image" alt="mghio-official-account.jpg"></p><h2 id="二维码的结构"><a href="#二维码的结构" class="headerlink" title="二维码的结构"></a>二维码的结构</h2><p>二维码的版本从 1 ~ 40 共 40 个不同的版本，每个版本的基本结构都是相同的，所不同的是每个版本的码元（构成二维码的方形黑白点）数量不同，从版本 1 (21 × 21 码元) 至版本 40 (177 × 177 码元) 依次递增。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cd41116c0034958a454fd9b2e402ecd~tplv-k3u1fbpfcp-zoom-1.image" alt="qrcode-version.png"></p><p>二维码可以分为这几不同的功能区域，分别是<code>版本信息</code>、<code>格式信息</code>、<code>数据及容错</code>、<code>定位标志</code>、<code>校正标志</code>等主要区域，其中定位标识用来对二维码进行定位，版本信息表示二维码的版本，有 40 种不同版本的二维码，从版本 1 到版本 40 ，每一版本比前一个版本每边增加 4 个码元，数据及容错用于实际保存的二维码数据信息和用于修正二维码损坏带来的错误的纠错码字，二维码的编码规则比较复杂，感兴趣的朋友可以去看看它的编码规范。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b01fccc0f8c44129cde2ebaead2432d~tplv-k3u1fbpfcp-zoom-1.image" alt="qr-code-structure.png"></p><h2 id="普通二维码存在的问题"><a href="#普通二维码存在的问题" class="headerlink" title="普通二维码存在的问题"></a>普通二维码存在的问题</h2><p>以上介绍的这种普通二维码只是对文字、网址、电话等信息进行编码，不支持图片、音频、视频等内容，且生成二维码后内容无法改变，在信息内容较多时生成的二维码图案复杂，不容易识别和打印，正是由于存在这些特性故称之为<strong>静态二维码</strong>。静态二维码的好处就是无需联网也能识别，但是有些时候在线下场景经常需要打印二维码出来让用户去扫码，或者在一些运营场景下需要对用户的扫码情况进行数据统计和分析，再使用普通的二维码就无法提供这些功能了，这时候就要使用<strong>动态二维码</strong>了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71385c728ac2409d8669c9bda2436b76~tplv-k3u1fbpfcp-zoom-1.image" alt="static-qrcode-theory.png"></p><h2 id="动态二维码（活码）及其原理"><a href="#动态二维码（活码）及其原理" class="headerlink" title="动态二维码（活码）及其原理"></a>动态二维码（活码）及其原理</h2><p>动态二维码也称之为<strong>活码</strong>，关键就在于“活”，“活”就是内容可变，但是二维码不变。活码的优点其实就是静态二维码的缺点，支持随时修改二维码的内容且二维码图案不变，可跟踪扫描统计数据，支持存储大量文字、图片、文件、音视、视频等内容，同时生成的图案简单易扫。</p><p>实际上二维码是按照指定的规则编码后的一串字符串，通常大部分情况下是一个网址，在二维码出现之前，我们访问一个网址是打开浏览器输入网址后按下回车即可访问相应的网站，而有了二维码之后，我们使用软件扫描二维码，软件首先会做一次从二维码到文本的解析、转换，然后根据解析出来的文本结果判断是否是链接，是则跳转到这个链接，尽管对我们而言操作方式改变了，但其原理是相同的。</p><p>既然二维码背后是网址，要解决静态二维码生成后内容无法修改的问题，是不是只要把网址做成“活的”就行了，即可操控内容的链接，对外暴露的依然还是同一个网址，服务端只需要对这个网址做个二次跳转就行，实际上“活码”就是这么干的，这个对外暴露固定不变的网址也称为“活址”。此时脑海里浮现着计算机科学界一句著名的话：</p><blockquote><p>计算机科学的任何一个问题，都可以通过增加一个中间层来解决。</p></blockquote><p>上面的这个“活址”就是一个“中间层”的角色，屏蔽和隔离了二维码内容的变化，对外始终都只是暴露一个固定的网址。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d82cd87ce94bfbb47b0e0659b8e839~tplv-k3u1fbpfcp-zoom-1.image" alt="live-qrcode-theory.png"></p><h2 id="静态二维码和动态二维码（活码）的区别"><a href="#静态二维码和动态二维码（活码）的区别" class="headerlink" title="静态二维码和动态二维码（活码）的区别"></a>静态二维码和动态二维码（活码）的区别</h2><table><thead><tr><th>比较项</th><th>普通二维码</th><th>动态二维码(活码)</th></tr></thead><tbody><tr><td>内容修改</td><td>不支持</td><td>可以随时修改</td></tr><tr><td>内容类型</td><td>支持文字、网址、电话等</td><td>支持文字、图片、文件、音视、视频等内容</td></tr><tr><td>二维码图案</td><td>内容越多越复杂</td><td>活码图案简单</td></tr><tr><td>数据统计</td><td>不支持</td><td>支持</td></tr><tr><td>样式排版</td><td>不支持</td><td>支持</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要对<strong>条形码</strong>、<strong>静态二维码</strong>和<strong>动态二维码</strong>的一些基本概念做了简单的介绍，想要深入了解二维码的实现细节和原理的朋友可以看看耗子叔的这篇文章 <a href="https://coolshell.cn/articles/10590.html" target="_blank" rel="noopener">二维码的生成细节和原理</a> 或者到 <a href="https://www.qrcode.com/zh/index.html" target="_blank" rel="noopener">官网</a> 查看相关文档。虽然现在绝大部分人对于二维码都非常熟悉，几乎每天都会进行着扫码操作，不过在人们的大脑中依然有一个“根深蒂固”的认知，认为一个二维码扫描之后只会出现一种固定的结果，在接触 <strong>活码</strong> 这个概念之前俺也是。你知道的越多，不知道的也越多。</p><hr><p>参考资料</p><ul><li><p><a href="https://coolshell.cn/articles/10590.html" target="_blank" rel="noopener">二维码的生成细节和原理</a></p></li><li><p><a href="https://www.qrcode.com/zh/index.html" target="_blank" rel="noopener">QR code.com</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/09/3UcOhXMfKG4gBP6.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一维码（条形码）&quot;&gt;&lt;a href=&quot;#一维码（条形码）&quot; class=&quot;headerlink&quot; title=&quot;一维码（条形码）&quot;&gt;&lt;/a&gt;一维码（条形码）&lt;/h2&gt;&lt;p&gt;在介绍二维码之前，先来看看它的“大哥”一维码，一维码也叫条形码（好像在日常生活中都是叫这个），它是由不同宽度的黑条和白条按照一定的顺序排列组成的平行线图案，它的宽度记录着数据信息，长度没有记录信息，条形码常用于标出物品的生产国、制造厂家、商品名称、生产日期、图书分类号、邮件起止地点、类别、日期等信息，比如大部分食品包装袋背后都会印有条形码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="二维码" scheme="https://www.mghio.cn/categories/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="科技" scheme="https://www.mghio.cn/categories/%E4%BA%8C%E7%BB%B4%E7%A0%81/%E7%A7%91%E6%8A%80/"/>
    
    
      <category term="二维码" scheme="https://www.mghio.cn/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
      <category term="科技" scheme="https://www.mghio.cn/tags/%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存模型</title>
    <link href="https://www.mghio.cn/post/2a3a86ee.html"/>
    <id>https://www.mghio.cn/post/2a3a86ee.html</id>
    <published>2022-04-15T08:24:50.000Z</published>
    <updated>2022-11-05T08:25:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/22/5ZlhXInxPCFUjYo.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在并发编程中，当多个线程同时访问同一个<strong>共享的可变变量</strong>时，会产生不确定的结果，所以要编写线程安全的代码，其本质上是对这些可变的共享变量的访问操作进行管理。导致这种不确定结果的原因就是<code>可见性</code>、<code>有序性</code>和<code>原子性</code>问题，<code>Java</code> 为解决可见性和有序性问题引入了 <a href="https://en.wikipedia.org/wiki/Java_memory_model" target="_blank" rel="noopener">Java 内存模型</a>，使用<code>互斥</code>方案（其核心实现技术是<code>锁</code>）来解决原子性问题。这篇先来看看解决可见性、有序性问题的 Java 内存模型（JMM）。</p><a id="more"></a><h2 id="什么是-Java-内存模型"><a href="#什么是-Java-内存模型" class="headerlink" title="什么是 Java 内存模型"></a>什么是 Java 内存模型</h2><p>Java 内存模型在<a href="https://en.wikipedia.org/wiki/Java_memory_model" target="_blank" rel="noopener">维基百科</a>上的定义如下：</p><blockquote><p>The Java memory model describes how threads in the Java programming language interact through memory. Together with the description of single-threaded execution of code, the memory model provides the semantics of the Java programming language.</p></blockquote><p>内存模型限制的是共享变量，也就是存储在堆内存中的变量，在 Java 语言中，所有的实例变量、静态变量和数组元素都存储在堆内存之中。而方法参数、异常处理参数这些局部变量存储在方法栈帧之中，因此不会在线程之间共享，不会受到内存模型影响，也不存在内存可见性问题。</p><p>通常，在线程之间的通讯方式有共享内存和消息传递两种，很明显，Java 采用的是第一种即<strong>共享的内存模型</strong>，在共享的内存模型里，多线程之间共享程序的公共状态，通过读-写内存的方式来进行隐式通讯。</p><p>从抽象的角度来看，JMM 其实是<code>定义了线程和主内存之间的关系</code>，首先，多个线程之间的共享变量存储在主内存之中，同时每个线程都有一个自己私有的本地内存，本地内存中存储着该线程读或写共享变量的副本（注意：本地内存是 JMM 定义的抽象概念，实际上并不存在）。抽象模型如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2769fe633304c1c8aeb0412df007b11~tplv-k3u1fbpfcp-zoom-1.image" alt="1.png"></p><p>在这个抽象的内存模型中，在两个线程之间的通信（共享变量状态变更）时，会进行如下两个步骤：</p><ol><li>线程 A 把在本地内存更新后的共享变量副本的值，刷新到主内存中。</li><li>线程 B 在使用到该共享变量时，到主内存中去读取线程 A 更新后的共享变量的值，并更新线程 B 本地内存的值。</li></ol><p>JMM 本质上是在硬件（处理器）内存模型之上又做了一层抽象，使得应用开发人员只需要了解 JMM 就可以编写出正确的并发代码，而无需过多了解硬件层面的内存模型。</p><h2 id="为什么需要-Java-内存模型"><a href="#为什么需要-Java-内存模型" class="headerlink" title="为什么需要 Java 内存模型"></a>为什么需要 Java 内存模型</h2><p>在日常的程序开发中，为一些共享变量赋值的场景会经常碰到，假设一个线程为整型共享变量 <code>count</code> 做赋值操作（<code>count = 9527;</code>），此时就会有一个问题，其它读取该共享变量的线程在什么情况下获取到的变量值为 <code>9527</code> 呢？如果缺少同步的话，会有很多因素导致其它读取该变量的线程无法立即甚至是永远都无法看到该变量的最新值。</p><p>比如缓存就可能会改变写入共享变量副本提交到主内存的次序，保存在本地缓存的值，对于其它线程是不可见的；编译器为了优化性能，有时候会改变程序中语句执行的先后顺序，这些因素都有可能会导致其它线程无法看到共享变量的最新值。</p><p>在文章开头，提到了 <code>JMM</code> 主要是为了解决<code>可见性</code>和<code>有序性</code>问题，那么首先就要先搞清楚，导致<code>可见性</code>和<code>有序性</code>问题发生的本质原因是什么？现在的服务绝大部分都是运行在多核 CPU 的服务器上，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据就会有一致性问题了，当一个线程对共享变量的修改，另外一个线程无法立刻看到。导致可见性问题的本质原因是<strong>缓存</strong>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06c9cbb595a447fd8b662ee0b18cb1d1~tplv-k3u1fbpfcp-zoom-1.image" alt="2.png"></p><p>有序性是指代码实际的执行顺序和代码定义的顺序一致，编译器为了优化性能，虽然会遵守 <code>as-if-serial</code> 语义（不管怎么重排序，在单线程下的执行结果不能改变），不过有时候编译器及解释器的优化也可能引发一些问题。比如：双重检查来创建单实例对象。下面是使用双重检查来实现延迟创建单例对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> DoubleCheckedInstance instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckedInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (DoubleCheckedInstance.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> DoubleCheckedInstance();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>instance = new DoubleCheckedInstance();</code>，看起来 <code>Java</code> 代码只有一行，应该是无法就行重排序的，实际上其编译后的实际指令是如下三步：</p><ol><li>分配对象的内存空间</li><li>初始化对象</li><li>设置 instance 指向刚刚已经分配的内存地址</li></ol><p>上面的第 2 步和第 3 步如果改变执行顺序也不会改变单线程的执行结果，也就是说可能会发生重排序，下图是一种多线程并发执行的场景：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8389814c8ce475eaea2e24afd7ce25b~tplv-k3u1fbpfcp-zoom-1.image" alt="3.png"></p><p>此时线程 B 获取到的 <code>instance</code> 是没有初始化过的，如果此来访问 <code>instance</code> 的成员变量就可能触发空指针异常。导致<code>有序性</code>问题的本质原因是编译器优化。那你可能会想既然缓存和编译器优化是导致可见性问题和有序性问题的原因，那直接禁用掉不就可以彻底解决这些问题了吗，但是如果这么做了的话，程序的性能可能就会受到比较大的影响了。</p><p>其实可以换一种思路，能不能把这些禁用缓存和编译器优化的权利交给编码的工程师来处理，他们肯定最清楚什么时候需要禁用，这样就只需要提供按需禁用缓存和编译优化的方法即可，使用比较灵活。因此<code>Java 内存模型</code>就诞生了，它规范了 JVM 如何提供按需禁用缓存和编译优化的方法，规定了 JVM 必须遵守一组最小的保证，这个最小保证规定了线程对共享变量的写入操作何时对其它线程可见。</p><h2 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h2><p>顺序一致性模型是一个理想化后的理论参考模型，处理器和编程语言的内存模型的设计都是参考的顺序一致性模型理论。其有如下两大特性：</p><ol><li>一个线程中的所有操作必须按照程序的顺序来执行</li><li>所有的线程都只能看到一个单一的执行操作顺序，不管程序是否同步</li></ol><p>在工程师视角下的顺序一致性模型如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b4ba04c342430dbcfd34f48f72d2df~tplv-k3u1fbpfcp-zoom-1.image" alt="4.png"></p><p>顺序一致性模型有一个单一的全局内存，这个全局内存可以通过左右摇摆的开关可以连接到任意一个线程，每个线程都必须按照程序的顺序来执行内存的读和写操作。该理想模型下，任务时刻都只能有一个线程可以连接到内存，当多个线程并发执行时，就可以通过开关就可以把多个线程的读和写操作<strong>串行化</strong>。</p><p>顺序一致性模型中，所有操操作完全按照顺序串行执行，但是在 JMM 中就没有这个保证了，<code>未同步的程序</code>在 JMM 中不仅程序的执行顺序是无序的，而且由于本地内存的存在，所有线程看到的操作顺序也可能会不一致，比如一个线程把写共享变量保存在本地内存中，在还没有刷新到主内存前，其它线程是不可见的，只有更新到主内存后，其它线程才有可能看到。</p><p>JMM 对在<code>正确同步的程序</code>做了顺序一致性的保证，也就是程序的执行结果和该程序在顺序一致性内存模型中的执行结果相同。</p><h2 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h2><p><code>Happens-Before</code> 规则是 JMM 中的核心概念，<code>Happens-Before</code> 概念最开始在 <a href="https://lamport.azurewebsites.net/pubs/time-clocks.pdf" target="_blank" rel="noopener">这篇论文</a> 提出，其在论文中使用 <code>Happens-Before</code> 来定义分布式系统之间的偏序关系。在 <a href="https://download.oracle.com/otndocs/jcp/memory_model-1.0-pfd-spec-oth-JSpec" target="_blank" rel="noopener">JSR-133</a> 中使用 <code>Happens-Before</code> 来指定两个操作之间的执行顺序。</p><p>JMM 正是通过这个规则来保证跨线程的内存可见性，<code>Happens-Before</code> 的含义是<code>前面一个对共享变量的操作结果对该变量的后续操作是可见的</code>，约束了编译器的优化行为，虽然允许编译器优化，但是优化后的代码必须要满足 <code>Happens-Before</code> 规则，这个规则给工程师做了这个保证：同步的多线程程序是按照 <code>Happens-Before</code> 指定的顺序来执行的。目的就是<code>为了在不改变程序（单线程或者正确同步的多线程程序）执行结果的前提下，尽最大可能的提高程序执行的效率</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f49183b6d2e44de8351b22bd8f93f29~tplv-k3u1fbpfcp-zoom-1.image" alt="5.png"></p><p><code>JSR-133</code> 规范中定了如下 6 项 <code>Happens-Before</code> 规则：</p><ol><li><strong>程序顺序规则：</strong>一个线程中的每个操作，<code>Happens-Before</code> 该线程中的任意后续操作</li><li><strong>监视器锁规则：</strong>对一个锁的解锁操作，<code>Happens-Before</code> 于后面对这个锁的加锁操作</li><li><strong>volatile 规则</strong>对一个 <code>volatile</code> 类型的变量的写操作，<code>Happens-Before</code> 与任意后面对这个 <code>volatile</code> 变量的读操作</li><li><strong>传递性规则：</strong>如果操作 A <code>Happens-Before</code> 于操作 B，并且操作 B <code>Happens-Before</code> 于操作 C，则操作 A <code>Happens-Before</code> 于操作 C</li><li><strong>start() 规则：</strong>如果一个线程 A 执行操作 <code>threadB.start()</code> 启动线程 B，那么线程 A 的 <code>start()</code> 操作 <code>Happens-Before</code> 于线程 B 的任意操作</li><li><strong>join() 规则：</strong>如果线程 A 执行操作 <code>threadB.join()</code> 并成功返回，那么线程 B 中的任意操作 <code>Happens-Before</code> 于线程 A 从 <code>threadB.join()</code> 操作成功返回</li></ol><p>JMM 的一个基本原则是：只要不改变单线程和正确同步的多线程的执行结果，编译器和处理器随便怎么优化都可以，实际上对于应用开发人员对于两个操作是否真的被重排序并不关心，真正关心的是执行结果不能被修改。因此 <code>Happens-Before</code> 本质上和 <code>sa-if-serial</code> 的语义是一致的，只是 <code>sa-if-serial</code> 只是保证在单线程下的执行结果不被改变。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了内存模型的相关基础知识和相关概念，JMM 屏蔽了不同处理器内存模型之间的差异，在不同的处理器平台上给应用开发人员抽象出了统一的 <code>Java 内存模型（JMM）</code>。常见的处理器内存模型比 JMM 的要弱，因此 JVM 会在生成字节码指令时在适当的位置插入内存屏障（内存屏障的类型会因处理器平台而有所不同）来限制部分重排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/22/5ZlhXInxPCFUjYo.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在并发编程中，当多个线程同时访问同一个&lt;strong&gt;共享的可变变量&lt;/strong&gt;时，会产生不确定的结果，所以要编写线程安全的代码，其本质上是对这些可变的共享变量的访问操作进行管理。导致这种不确定结果的原因就是&lt;code&gt;可见性&lt;/code&gt;、&lt;code&gt;有序性&lt;/code&gt;和&lt;code&gt;原子性&lt;/code&gt;问题，&lt;code&gt;Java&lt;/code&gt; 为解决可见性和有序性问题引入了 &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_memory_model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 内存模型&lt;/a&gt;，使用&lt;code&gt;互斥&lt;/code&gt;方案（其核心实现技术是&lt;code&gt;锁&lt;/code&gt;）来解决原子性问题。这篇先来看看解决可见性、有序性问题的 Java 内存模型（JMM）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Memory" scheme="https://www.mghio.cn/categories/Java/Memory/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Memory" scheme="https://www.mghio.cn/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>对象转换工具 MapStruct 介绍</title>
    <link href="https://www.mghio.cn/post/42aa4c23.html"/>
    <id>https://www.mghio.cn/post/42aa4c23.html</id>
    <published>2022-03-05T08:23:01.000Z</published>
    <updated>2022-11-05T08:24:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/09/hy2JYfX8vmdwVDC.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们日常开发的分层结构的应用程序中，为了各层之间互相解耦，一般都会定义不同的对象用来在不同层之间传递数据，因此，就有了各种 <code>XXXDTO</code>、<code>XXXVO</code>、<code>XXXBO</code> 等基于数据库对象派生出来的对象，当在不同层之间传输数据时，不可避免地经常需要将这些对象进行相互转换。</p><p>此时一般处理两种处理方式：① 直接使用 <code>Setter</code> 和 <code>Getter</code> 方法转换、② 使用一些工具类进行转换（e.g. <code>BeanUtil.copyProperties</code>）。第一种方式如果对象属性比较多时，需要写很多的 <code>Getter/Setter</code> 代码。第二种方式看起来虽然比第一种方式要简单很多，但是因为其使用了反射，性能不太好，而且在使用中也有很多陷阱。而今天要介绍的主角 <a href="https://mapstruct.org" target="_blank" rel="noopener">MapStruct</a> 在不影响性能的情况下，同时解决了这两种方式存在的缺点。</p><a id="more"></a><h2 id="MapStruct-是什么"><a href="#MapStruct-是什么" class="headerlink" title="MapStruct 是什么"></a>MapStruct 是什么</h2><p><code>MapStruct</code> 是一个代码生成器，它基于<strong>约定优于配置</strong>方法极大地简化了 <code>Java bean</code> 类型之间映射的实现。自动生成的映射转换代码只使用简单的方法调用，因此速度快、类型安全而且易于理解阅读，源码仓库 <code>Github</code> 地址 <a href="https://github.com/mapstruct/mapstruct" target="_blank" rel="noopener">MapStruct</a>。总的来说，有如下三个特点：</p><ol><li>基于注解</li><li>在编译期自动生成映射转换代码</li><li>类型安全、高性能、无依赖性</li></ol><h2 id="MapStruct-使用步骤"><a href="#MapStruct-使用步骤" class="headerlink" title="MapStruct 使用步骤"></a>MapStruct 使用步骤</h2><p><code>MapStruct</code> 的使用比较简单，只需如下三步即可。</p><h3 id="①-引入依赖（这里以-Gradle-方式为例）"><a href="#①-引入依赖（这里以-Gradle-方式为例）" class="headerlink" title="① 引入依赖（这里以 Gradle 方式为例）"></a>① 引入依赖（这里以 <code>Gradle</code> 方式为例）</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'org.mapstruct:mapstruct:1.4.2.Final'</span></span><br><span class="line">    annotationProcessor <span class="string">'org.mapstruct:mapstruct-processor:1.4.2.Final'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-创建相关转换对象"><a href="#②-创建相关转换对象" class="headerlink" title="② 创建相关转换对象"></a>② 创建相关转换对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoctorDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③-创建转换器类（Mapper）"><a href="#③-创建转换器类（Mapper）" class="headerlink" title="③ 创建转换器类（Mapper）"></a>③ 创建转换器类（Mapper）</h3><p>需要注意的是，转换器不一定都要使用 <code>Mapper</code> 作为结尾，只是官方示例推荐以 <code>XXXMapper</code> 格式命名转换器名称，这里举例的是最简单的映射情况（字段名称和类型都完全匹配），只需要在转换器类上添加 <code>@Mapper</code> 注解即可，转换器代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DoctorMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="function">DoctorDTO <span class="title">toDTO</span><span class="params">(Doctor doctor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过下面这个简单的测试来校验转换结果是否正确，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoctorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToDTO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer doctorId = <span class="number">9527</span>;</span><br><span class="line">    String doctorName = <span class="string">"mghio"</span>;</span><br><span class="line"></span><br><span class="line">    Doctor doctor = <span class="keyword">new</span> Doctor();</span><br><span class="line">    doctor.setId(doctorId);</span><br><span class="line">    doctor.setName(doctorName);</span><br><span class="line"></span><br><span class="line">    DoctorDTO doctorDTO = DoctorMapper.INSTANCE.toDTO(doctor);</span><br><span class="line"></span><br><span class="line">    assertEquals(doctorId, doctorDTO.getId());</span><br><span class="line">    assertEquals(doctorName, doctorDTO.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果正常通过，说明使用 <code>DoctorMapper</code> 转换器达到我们的预期结果。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/841e311677cb451b8362408e4708afb3~tplv-k3u1fbpfcp-zoom-1.image" alt="1.png"></p><h2 id="MapStruct-实现浅析"><a href="#MapStruct-实现浅析" class="headerlink" title="MapStruct 实现浅析"></a>MapStruct 实现浅析</h2><p>在以上示例中，使用 <code>MapStruct</code> 通过简单的三步就实现了 <code>Doctor</code> 到 <code>DoctorDTO</code> 的转换，那么，<code>MapStruct</code> 是如何做到的呢？其实通过我们定义的转换器可以发现，转换器是接口类型的，而我们知道在 <code>Java</code> 中，接口是无法提供功能的，只是定义规范，具体干活的还是它的实现类。</p><p>因此我们可以大胆猜想，<code>MapStruct</code> 肯定给我们定义的转换器接口（<code>DoctorMapper</code>）生成了实现类，而通过 <code>Mappers.getMapper(DoctorMapper.class)</code> 获取到的转换器实际上是获取到了转化器接口的实现类。下面通过在测试类中 <code>debug</code> 来验证一下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/209532bf5cb74f5c83fe2f0776f2b1be~tplv-k3u1fbpfcp-zoom-1.image" alt="2.png"></p><p>通过 <code>debug</code> 可以看出，<code>DoctorMapper.INSTANCE</code> 获取到的是接口的实现类 <code>DoctorMapperImpl</code>。这个转换器接口实现类是在<strong>编译期</strong>自动生成的，<code>Gradle</code> 项目是在 <code>build/generated/sources/anotationProcessor/Java</code> 下（<code>Maven</code> 项目在 <code>target/generated-sources/annotations</code> 目录下），生成以上示例转换器接口的实现类源码如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd55c1172e5d41679efb7b6bcd3da429~tplv-k3u1fbpfcp-zoom-1.image" alt="4.png"></p><p>可以发现，自动生成的代码和我们平时手写的差不多，简单易懂，代码完全在编译期间生成，没有运行时依赖。和使用反射的实现方式相比还有一个有点就是，出错时很容易去 <code>debug</code> 实现源码来定位，而反射相对来说定位问题就要困难得多了。</p><h2 id="常见使用场景介绍"><a href="#常见使用场景介绍" class="headerlink" title="常见使用场景介绍"></a>常见使用场景介绍</h2><h3 id="①-对象属性名称和类型完全相同"><a href="#①-对象属性名称和类型完全相同" class="headerlink" title="① 对象属性名称和类型完全相同"></a>① 对象属性名称和类型完全相同</h3><p>从上文的示例可以看出，当属性名称和类型完全一致时，我们只需要定义一个转换器接口并添加 <code>@Mapper</code> 注解即可，然后 <code>MapStruct</code> 会自动生成实现类完成转换。示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  SourceMapper INSTANCE = Mappers.getMapper(SourceMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="function">Target <span class="title">toTarget</span><span class="params">(Source source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-对象属性类型相同但是名称不同"><a href="#②-对象属性类型相同但是名称不同" class="headerlink" title="② 对象属性类型相同但是名称不同"></a>② 对象属性类型相同但是名称不同</h3><p>当对象属性类型相同但是属性名称不一样时，通过 <code>@Mapping</code> 注解来手动指定转换。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String sourceName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String targetName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  SourceMapper INSTANCE = Mappers.getMapper(SourceMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mapping</span>(source = <span class="string">"sourceName"</span>, target = <span class="string">"targetName"</span>)</span><br><span class="line">  <span class="function">Target <span class="title">toTarget</span><span class="params">(Source source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③-在-Mapper-中使用自定义转换方法"><a href="#③-在-Mapper-中使用自定义转换方法" class="headerlink" title="③ 在 Mapper 中使用自定义转换方法"></a>③ 在 Mapper 中使用自定义转换方法</h3><p>有时候，对于某些类型（比如：一个类的属性是自定义的类），无法以自动生成代码的形式进行处理。此时我们需要自定义类型转换的方法，在 <code>JDK 7</code> 之前的版本，就需要使用抽象类来定义转换 <code>Mapper</code> 了，在 <code>JDK 8</code> 以上的版本可以使用接口的<strong>默认方法</strong>来自定义类型转换的方法。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String sourceName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> InnerSource innerSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer deleted;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String targetName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> InnerTarget innerTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerTarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Boolean isDeleted;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  SourceMapper INSTANCE = Mappers.getMapper(SourceMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mapping</span>(source = <span class="string">"sourceName"</span>, target = <span class="string">"targetName"</span>)</span><br><span class="line">  <span class="function">Target <span class="title">toTarget</span><span class="params">(Source source)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> InnerTarget <span class="title">innerTarget2InnerSource</span><span class="params">(InnerSource innerSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (innerSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InnerTarget innerTarget = <span class="keyword">new</span> InnerTarget();</span><br><span class="line">    innerTarget.setIsDeleted(innerSource.getDeleted() == <span class="number">1</span>);</span><br><span class="line">    innerTarget.setName(innerSource.getName());</span><br><span class="line">    <span class="keyword">return</span> innerTarget;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="④-多个对象转换成一个对象返回"><a href="#④-多个对象转换成一个对象返回" class="headerlink" title="④ 多个对象转换成一个对象返回"></a>④ 多个对象转换成一个对象返回</h3><p>在一些实际业务编码的过程中，不可避免地需要将多个对象转化为一个对象的场景，<code>MapStruct</code> 也能很好的支持，对于这种最终返回信息来源于多个类，我们可以通过配置来实现多对一的转换。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String street;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer zipCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddressMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  AddressMapper INSTANCE = Mappers.getMapper(AddressMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mapping</span>(source = <span class="string">"doctor.id"</span>, target = <span class="string">"personId"</span>)</span><br><span class="line">  <span class="meta">@Mapping</span>(source = <span class="string">"address.street"</span>, target = <span class="string">"streetDesc"</span>)</span><br><span class="line">  <span class="function">DeliveryAddressDTO <span class="title">doctorAndAddress2DeliveryAddressDTO</span><span class="params">(Doctor doctor, Address address)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个示例中的转换器（<code>AddressMapper</code>）可以看出，当属性名称和类型完全匹配时同样可以自动转换，但是当来源对象有多个属性名称及类型完全和目标对象相同时，还是需要手动配置指定的，因为此时 <code>MapStruct</code> 也无法准确判断应该使用哪个属性转换。</p><h2 id="获取转换器（Mapper）的几种方式"><a href="#获取转换器（Mapper）的几种方式" class="headerlink" title="获取转换器（Mapper）的几种方式"></a>获取转换器（Mapper）的几种方式</h2><p>获取转换器的方式根据 <code>@Mapper</code> 注解的 <code>componentModel</code> 属性不同而不同，支持以下四种不同的取值：</p><ol><li><strong>default</strong> 默认方式，默认方式，使用工厂方式（<code>Mappers.getMapper(Class)</code>）来获取</li><li><strong>cdi</strong> 此时生成的映射器是一个应用程序范围的 <code>CDI bean</code>，使用 <code>@Inject</code> 注解来获取</li><li><strong>spring</strong> <code>Spring</code> 的方式，可以通过 <code>@Autowired</code> 注解来获取，在 <code>Spring</code> 框架中推荐使用此方式</li><li><strong>jsr330</strong> 生成的映射器用 <code>@javax.inject.Named</code> 和 <code>@Singleton</code> 注解，通过 <code>@Inject</code> 来获取</li></ol><h3 id="①-通过工厂方式获取"><a href="#①-通过工厂方式获取" class="headerlink" title="① 通过工厂方式获取"></a>① 通过工厂方式获取</h3><p>上文的示例中都是通过工厂方式获取的，也就是使用 <code>MapStruct</code> 提供的 <code>Mappers.getMapper(Class&lt;T&gt; clazz)</code> 方法来获取指定类型的 <code>Mapper</code>。然后在调用的时候就不需要反复创建对象了，方法的最终实现是通过我们定义接口的类加载器加载 <code>MapStruct</code> 生成的实现类（类名称规则为：接口名称 + <code>Impl</code>），然后调用该类的无参构造器创建对象。核心源码如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c45fa84f0384c57abdff835677e67fa~tplv-k3u1fbpfcp-zoom-1.image" alt="5.png"></p><h3 id="②-使用依赖注入方式获取"><a href="#②-使用依赖注入方式获取" class="headerlink" title="② 使用依赖注入方式获取"></a>② 使用依赖注入方式获取</h3><p>对于依赖注入（<code>dependency injection</code>），使用 <code>Spring</code> 框架开发的朋友们应该很熟悉了，工作中经常使用。<code>MapStruct</code> 也支持依赖注入的使用方式，并且官方也推荐使用依赖注入的方式获取。使用 <code>Spring</code> 依赖注入的方式只需要指定 <code>@Mapper</code> 注解的 <code>componentModel = &quot;spring&quot;</code> 即可，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span>(componentModel = <span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SourceMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  SourceMapper INSTANCE = Mappers.getMapper(SourceMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Mapping</span>(source = <span class="string">"sourceName"</span>, target = <span class="string">"targetName"</span>)</span><br><span class="line">  <span class="function">Target <span class="title">toTarget</span><span class="params">(Source source)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>@Autowired</code> 获取的原因是 <code>SourceMapper</code> 接口的实现类已经被注册为容器中一个 <code>Bean</code> 了，通过如下生成的接口实现类的代码也可以看到，在类上自动加上了 <code>@Component</code> 注解。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c2830645fc645b290446988a26a72ca~tplv-k3u1fbpfcp-zoom-1.image" alt="6.png"></p><p>最后还有两个注意事项：① 当两个转换对象的属性不一致时（比如 <code>DoctorDTO</code> 中不存在 <code>Doctor</code> 对象中的某个字段），编译时会出现警告提示。可以在<code>@Mapping</code> 注解中配置 <code>ignore = true</code>，或者当不一致字段比较多时，可以直接设置 <code>@Mapper</code> 注解的 <code>unmappedTargetPolicy</code> 属性或<code>unmappedSourcePolicy</code> 属性设置为 <code>ReportingPolicy.IGNORE</code>。② 如果你项目中也使用了 <a href="https://projectlombok.org" target="_blank" rel="noopener">Lombok</a>，需要注意一下 <code>Lombok</code> 的版本至少是 <code>1.18.10</code> 或者以上才行，否则会出现编译失败的情况。刚开始用的时候我也踩到这个坑了。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了对象转换工具 <code>Mapstruct</code> 库，以安全优雅的方式来减少我们的转换代码。从文中的示例中可以看出，<code>Mapstruct</code> 提供了大量的功能和配置，使我们能够以简单快捷的方式创建从简单到复杂的映射器。文中所介绍到的只是 <code>Mapstruct</code> 库的冰山一角，还有很多强大的功能文中没有提到，感兴趣的朋友可以自行查看 <a href="https://mapstruct.org/documentation/stable/reference/html" target="_blank" rel="noopener">官方使用指南</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/09/hy2JYfX8vmdwVDC.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在我们日常开发的分层结构的应用程序中，为了各层之间互相解耦，一般都会定义不同的对象用来在不同层之间传递数据，因此，就有了各种 &lt;code&gt;XXXDTO&lt;/code&gt;、&lt;code&gt;XXXVO&lt;/code&gt;、&lt;code&gt;XXXBO&lt;/code&gt; 等基于数据库对象派生出来的对象，当在不同层之间传输数据时，不可避免地经常需要将这些对象进行相互转换。&lt;/p&gt;
&lt;p&gt;此时一般处理两种处理方式：① 直接使用 &lt;code&gt;Setter&lt;/code&gt; 和 &lt;code&gt;Getter&lt;/code&gt; 方法转换、② 使用一些工具类进行转换（e.g. &lt;code&gt;BeanUtil.copyProperties&lt;/code&gt;）。第一种方式如果对象属性比较多时，需要写很多的 &lt;code&gt;Getter/Setter&lt;/code&gt; 代码。第二种方式看起来虽然比第一种方式要简单很多，但是因为其使用了反射，性能不太好，而且在使用中也有很多陷阱。而今天要介绍的主角 &lt;a href=&quot;https://mapstruct.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MapStruct&lt;/a&gt; 在不影响性能的情况下，同时解决了这两种方式存在的缺点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="MapStruct" scheme="https://www.mghio.cn/categories/Java/MapStruct/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="MapStruct" scheme="https://www.mghio.cn/tags/MapStruct/"/>
    
  </entry>
  
  <entry>
    <title>Java 异步编程的几种方式</title>
    <link href="https://www.mghio.cn/post/e3d37c7a.html"/>
    <id>https://www.mghio.cn/post/e3d37c7a.html</id>
    <published>2022-02-15T08:21:03.000Z</published>
    <updated>2022-11-05T08:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/08/01/5ZYw2EDlNizOSjQ.png" alt="cover.jpg"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>异步编程是让程序并发运行的一种手段。它允许多个事情<code>同时发生</code>，当程序调用需要长时间运行的方法时，它不会阻塞当前的执行流程，程序可以继续运行，当方法执行完成时通知给主线程根据需要获取其执行结果或者失败异常的原因。使用异步编程可以大大提高我们程序的吞吐量，可以更好的面对更高的并发场景并更好的利用现有的系统资源，同时也会一定程度上减少用户的等待时间等。本文我们一起来看看在 <code>Java</code> 语言中使用异步编程有哪些方式。</p><a id="more"></a><h4 id="Thread-方式"><a href="#Thread-方式" class="headerlink" title="Thread 方式"></a>Thread 方式</h4><p>在 <code>Java</code> 语言中最简单使用异步编程的方式就是创建一个 <code>Thread</code> 来实现，如果你使用的 <code>JDK</code> 版本是 8 以上的话，可以使用 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda 表达式</a> 会更加简洁。为了能更好的体现出异步的高效性，下面提供同步版本和异步版本的示例作为对照：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncWithAsyncDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doOneThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"doOneThing ----&gt;&gt;&gt; success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"doOtherThing ----&gt;&gt;&gt; success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch(<span class="string">"SyncWithAsyncDemo"</span>);</span><br><span class="line">    stopWatch.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步调用版本</span></span><br><span class="line">    <span class="comment">// testSynchronize();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步调用版本</span></span><br><span class="line">    testAsynchronize();</span><br><span class="line"></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    System.out.println(stopWatch);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAsynchronize</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-------------------- testAsynchronize --------------------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程执行 doOneThing</span></span><br><span class="line">    Thread doOneThingThread = <span class="keyword">new</span> Thread(SyncWithAsyncDemo::doOneThing, <span class="string">"doOneThing-Thread"</span>);</span><br><span class="line">    doOneThingThread.start();</span><br><span class="line"></span><br><span class="line">    doOtherThing();</span><br><span class="line">    <span class="comment">// 等待 doOneThing 线程执行完成</span></span><br><span class="line">    doOneThingThread.join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSynchronize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-------------------- testSynchronize --------------------"</span>);</span><br><span class="line"></span><br><span class="line">    doOneThing();</span><br><span class="line">    doOtherThing();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步执行的运行如下：</p><p><img src="https://i.loli.net/2021/08/01/CuhrJQ87kSjyYvO.png" alt="1.png"></p><p>注释掉同步调用版本的代码，得到异步执行的结果如下：</p><p><img src="https://i.loli.net/2021/08/01/AKOnGP1jTh8S3Vw.png" alt="2.png"></p><p>从两次的运行结果可以看出，同步版本耗时 <code>4002 ms</code>，异步版本执行耗时 <code>2064 ms</code>，异步执行耗时减少将近一半，可以看出使用异步编程后可以大大缩短程序运行时间。</p><p>上面的示例的异步线程代码在 <code>main</code> 方法内开启了一个线程 <code>doOneThing-Thread</code> 用来异步执行 <code>doOneThing</code> 任务，在这时该线程与 <code>main</code> 主线程并发运行，也就是任务 <code>doOneThing</code> 与任务 <code>doOtherThing</code> 并发运行，则等主线程运行完 <code>doOtherThing</code> 任务后同步等待线程 <code>doOneThing</code> 运行完毕，整体还是比较简单的。</p><p>但是这个示例只能作为示例使用，如果用到了生产环境发生事故后果自负，使用上面这种 <code>Thread</code> 方式异步编程存在两个明显的问题。</p><ol><li>创建线程没有复用。我们知道频繁的线程创建与销毁是需要一部分开销的，而且示例里也没有限制线程的个数，如果使用不当可能会把系统线程用尽，从而引发事故，这个问题使用线程池可以解决。</li><li>异步任务无法获取最终的执行结果。示例中的这种方式是满足不了的，这时候就需要使用下面介绍的第二种 <code>FutureTask</code> 的方式了。</li></ol><h4 id="FutureTask-方式"><a href="#FutureTask-方式" class="headerlink" title="FutureTask 方式"></a>FutureTask 方式</h4><p>自 <code>JDK 1.5</code> 开始，引入了 <code>Future</code> 接口和实现 <code>Future</code> 接口的 <code>FutureTask</code> 类来表示异步计算结果。这个 <code>FutureTask</code> 类不仅实现了 <code>Future</code> 接口还实现了 <code>Runnable</code> 接口，表示一种可生成结果的 <code>Runnable</code>。其可以处于这三种状态：</p><ul><li><strong>未启动</strong> 当创建一个 <code>FutureTask</code> 没有执行 <code>FutureTask.run()</code> 方法之前</li><li><strong>已启动</strong> 在 <code>FutureTask.run()</code> 方法执行的过程中</li><li><strong>已完成</strong> 在 <code>FutureTask.run()</code> 方法正常执行结果或者调用了 <code>FutureTask.cancel(boolean mayInterruptIfRunning)</code> 方法以及在调用 <code>FutureTask.run()</code> 方法的过程中发生异常结束后</li></ul><p><code>FutureTask</code> 类实现了 <code>Future</code> 接口的开启和取消任务、查询任务是否完成、获取计算结果方法。要获取 <code>FutureTask</code> 任务的结果，我们只能通过调用 <code>getXXX()</code> 系列方法才能获取，当结果还没出来时候这些方法会被阻塞，同时这了任务可以是 <code>Callable</code> 类型（有返回结果），也可以是 <code>Runnable</code> 类型（无返回结果）。我们修改上面的示例把两个任务方法修改为返回 <code>String</code> 类型，使用 <code>FutureTask</code> 的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-------------------- testFutureTask --------------------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 FutureTask（doOneThing 任务）</span></span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(FutureTaskDemo::doOneThing);</span><br><span class="line">    <span class="comment">// 使用线程池执行 doOneThing 任务</span></span><br><span class="line">    ForkJoinPool.commonPool().execute(futureTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 doOtherThing 任务</span></span><br><span class="line">    String doOtherThingResult = doOtherThing();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步等待线程执行 doOneThing 任务结束</span></span><br><span class="line">    String doOneThingResult = futureTask.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行结果输出</span></span><br><span class="line">    System.out.println(<span class="string">"doOneThingResult ----&gt;&gt;&gt; "</span> + doOneThingResult);</span><br><span class="line">    System.out.println(<span class="string">"doOtherThingResult ----&gt;&gt;&gt; "</span> + doOtherThingResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>FutureTask</code> 异步编程方式的耗时和上面的 <code>Thread</code> 方式是差不多的，其本质都是另起一个线程去做 <code>doOneThing</code> 任务然后等待返回，运行结果如下：</p><p><img src="https://i.loli.net/2021/08/01/geL3PaO7tIAdz4r.png" alt="3.png"></p><p>这个示例中，<code>doOneThing</code> 和 <code>doOtherThing</code> 都是有返回值的任务（都返回 <code>String</code> 类型结果），我们在主线程 <code>main</code> 中创建一个异步任务 <code>FutureTask</code> 来执行 <code>doOneThing</code>，然后使用 <code>ForkJoinPool.commonPool()</code> 创建线程池（有关 <code>ForkJoinPool</code> 的介绍见 <a href="https://www.mghio.cn/post/30ff968d.html">这里</a>），然后调用了线程池的 <code>execute</code> 方法把 <code>futureTask</code> 提交到线程池来执行。</p><p>通过示例可以看到，虽然 <code>FutureTask</code> 提供了一些方法让我们获取任务的执行结果、任务是否完成等，但是使用还是比较复杂，在一些较为复杂的场景（比如多个 <code>FutureTask</code> 之间的关系表示）的编码还是比较繁琐，还是当我们调用 <code>getXXX()</code> 系列方法时还是会在任务执行完毕前阻塞调用线程，达不到异步编程的效果，基于这些问题，在 <code>JDK 8</code> 中引入了 <code>CompletableFuture</code> 类，下面来看看如何使用 <code>CompletableFuture</code> 来实现异步编程。</p><h4 id="CompletableFuture-方式"><a href="#CompletableFuture-方式" class="headerlink" title="CompletableFuture 方式"></a>CompletableFuture 方式</h4><p><code>JDK 8</code> 中引入了 <code>CompletableFuture</code> 类，实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口，为异步编程提供了一些列方法，如 <code>supplyAsync</code>、<code>runAsync</code> 和 <code>thenApplyAsync</code> 等，除此之外 <code>CompletableFuture</code> 还有一个重要的功能就是可以让两个或者多个 <code>CompletableFuture</code> 进行运算来产生结果。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-08-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;String&gt; <span class="title">doOneThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"doOneThing"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;String&gt; <span class="title">doOtherThing</span><span class="params">(String parameter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> parameter + <span class="string">" "</span> + <span class="string">"doOtherThing"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch(<span class="string">"CompletableFutureDemo"</span>);</span><br><span class="line">    stopWatch.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步执行版本</span></span><br><span class="line">    testCompletableFuture();</span><br><span class="line"></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    System.out.println(stopWatch);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCompletableFuture</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">// 先执行 doOneThing 任务，后执行 doOtherThing 任务</span></span><br><span class="line">    CompletableFuture&lt;String&gt; resultFuture = doOneThing().thenCompose(CompletableFutureDemo::doOtherThing);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务结果</span></span><br><span class="line">    String doOneThingResult = resultFuture.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取执行结果</span></span><br><span class="line">    System.out.println(<span class="string">"DoOneThing and DoOtherThing execute finished. result = "</span> + doOneThingResult);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://i.loli.net/2021/08/01/VNZndkpSHGIKWtR.png" alt="4.png"></p><p> 在主线程 <code>main</code> 中首先调用了方法 <code>doOneThing()</code> 方法开启了一个异步任务，并返回了对应的 <code>CompletableFuture</code> 对象，我们取名为 <code>doOneThingFuture</code>，然后在 <code>doOneThingFuture</code> 的基础上使用 <code>CompletableFuture</code> 的 <code>thenCompose()</code> 方法，让 <code>doOneThingFuture</code> 方法执行完成后，使用其执行结果作为 <code>doOtherThing(String parameter)</code> 方法的参数创建的异步任务返回。</p><p> 我们不需要显式使用 <code>ExecutorService</code>，在 <code>CompletableFuture</code> 内部使用的是 <code>Fork/Join</code> 框架异步处理任务，因此，它使我们编写的异步代码更加简洁。此外，<code>CompletableFuture</code> 类功能很强大其提供了和很多方便的方法，更多关于 <code>CompletableFuture</code> 的使用请见 <a href="https://www.mghio.cn/post/7b9ead86.html">这篇</a>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文介绍了在 <code>Java</code> 中的 <code>JDK</code> 使用异步编程的三种方式，这些是我们最基础的实现异步编程的工具，在其之上的还有 <code>Guava</code> 库提供的 <a href="https://guava.dev/releases/28.2-jre/api/docs/index.html?com/google/common/util/concurrent/ListenableFuture.html" target="_blank" rel="noopener">ListenableFuture</a> 和 <a href="https://guava.dev/releases/28.2-jre/api/docs/com/google/common/util/concurrent/Futures.html" target="_blank" rel="noopener">Futures</a> 类以及 <code>Spring</code> 框架提供的异步执行能力，使用 <code>@Async</code> 等注解实现异步处理，感兴趣的话可以自行学习了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/01/5ZYw2EDlNizOSjQ.png&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;异步编程是让程序并发运行的一种手段。它允许多个事情&lt;code&gt;同时发生&lt;/code&gt;，当程序调用需要长时间运行的方法时，它不会阻塞当前的执行流程，程序可以继续运行，当方法执行完成时通知给主线程根据需要获取其执行结果或者失败异常的原因。使用异步编程可以大大提高我们程序的吞吐量，可以更好的面对更高的并发场景并更好的利用现有的系统资源，同时也会一定程度上减少用户的等待时间等。本文我们一起来看看在 &lt;code&gt;Java&lt;/code&gt; 语言中使用异步编程有哪些方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="异步" scheme="https://www.mghio.cn/categories/Java/%E5%BC%82%E6%AD%A5/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="异步" scheme="https://www.mghio.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 Fork/Join 框架</title>
    <link href="https://www.mghio.cn/post/30ff968d.html"/>
    <id>https://www.mghio.cn/post/30ff968d.html</id>
    <published>2022-01-05T08:19:10.000Z</published>
    <updated>2022-11-05T08:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/25/ZjDdPW3NGlkSb7V.jpg" alt="cover.jpg"></p><h4 id="什么是-Fork-Join-框架"><a href="#什么是-Fork-Join-框架" class="headerlink" title="什么是 Fork/Join 框架"></a>什么是 Fork/Join 框架</h4><p><code>Fork/Join</code> 框架是一种在 <code>JDK 7</code> 引入的线程池，用于并行执行<code>把一个大任务拆成多个小任务并行执行，最终汇总每个小任务结果得到大任务结果</code>的特殊任务。通过其命名也很容易看出框架主要分为 <code>Fork</code> 和 <code>Join</code> 两个阶段，第一阶段 <code>Fork</code> 是把一个大任务拆分为多个子任务并行的执行，第二阶段 <code>Join</code> 是合并这些子任务的所有执行结果，最后得到大任务的结果。</p><p>这里不难发现其执行主要流程：首先判断一个任务是否足够小，如果任务足够小，则直接计算，否则，就拆分成几个更小的小任务分别计算，这个过程可以反复的拆分成一系列小任务。<code>Fork/Join</code> 框架是一种基于 <a href="https://en.wikipedia.org/wiki/Divide_and_conquer" target="_blank" rel="noopener">分治</a> 的算法，通过拆分大任务成多个独立的小任务，然后并行执行这些小任务，最后合并小任务的结果得到大任务的最终结果，通过并行计算以提高效率。</p><a id="more"></a><h4 id="Fork-Join-框架使用示例"><a href="#Fork-Join-框架使用示例" class="headerlink" title="Fork/Join 框架使用示例"></a>Fork/Join 框架使用示例</h4><p>下面通过一个<code>计算列表中所有元素的总和</code>的示例来看看 <code>Fork/Join</code> 框架是如何使用的，总的思路是：将这个列表分成许多子列表，然后对每个子列表的元素进行求和，然后，我们再计算所有这些值的总和就得到原始列表的和了。<code>Fork/Join</code> 框架中定义了 <code>ForkJoinTask</code> 来表示一个 <code>Fork/Join</code> 任务，其提供了 <code>fork()</code>、<code>join()</code> 等操作，通常情况下，我们并不需要直接继承这个 <code>ForkJoinTask</code> 类，而是使用框架提供的两个 <code>ForkJoinTask</code> 的子类：</p><ul><li><strong>RecursiveAction</strong> 用于表示<code>没有返回结果</code>的 <code>Fork/Join</code> 任务。</li><li><strong>RecursiveTask</strong> 用于表示<code>有返回结果</code>的 <code>Fork/Join</code> 任务。</li></ul><p>很显然，在这个示例中是需要返回结果的，可以定义 <code>SumAction</code> 类继承自 <code>RecursiveTask</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEQUENTIAL_THRESHOLD = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Long&gt; data;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(List&lt;Long&gt; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.size() &lt;= SEQUENTIAL_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">long</span> sum = computeSumDirectly();</span><br><span class="line">      System.out.format(<span class="string">"Sum of %s: %d\n"</span>, data.toString(), sum);</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = data.size() / <span class="number">2</span>;</span><br><span class="line">      SumTask firstSubtask = <span class="keyword">new</span> SumTask(data.subList(<span class="number">0</span>, mid));</span><br><span class="line">      SumTask secondSubtask = <span class="keyword">new</span> SumTask(data.subList(mid, data.size()));</span><br><span class="line">      <span class="comment">// 执行子任务</span></span><br><span class="line">      firstSubtask.fork();</span><br><span class="line">      secondSubtask.fork();</span><br><span class="line">      <span class="comment">// 等待子任务执行完成，并获取结果</span></span><br><span class="line">      <span class="keyword">long</span> firstSubTaskResult = firstSubtask.join();</span><br><span class="line">      <span class="keyword">long</span> secondSubTaskResult = secondSubtask.join();</span><br><span class="line">      <span class="keyword">return</span> firstSubTaskResult + secondSubTaskResult;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeSumDirectly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Long l : data) &#123;</span><br><span class="line">      sum += l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    List&lt;Long&gt; data = random</span><br><span class="line">        .longs(<span class="number">1_000</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">        .boxed()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    SumTask task = <span class="keyword">new</span> SumTask(data);</span><br><span class="line">    pool.invoke(task);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Sum: "</span> + pool.invoke(task));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里当列表大小小于 <code>SEQUENTIAL_THRESHOLD</code> 变量的值（阈值）时视为小任务，直接计算求和列表元素结果，否则再次拆分为小任务，运行结果如下：</p><p><img src="https://i.loli.net/2021/07/25/jkq3ZeJwfGhrOst.png" alt="1.png"></p><p>通过这个示例代码可以发现，<code>Fork/Join</code> 框架 中 <code>ForkJoinTask</code> 任务与平常的一般任务的主要不同点在于：<code>ForkJoinTask</code> 需要实现抽象方法 <code>compute()</code> 来定义计算逻辑，在这个方法里一般通用的实现模板是，首先先判断当前任务是否是小任务，如果是，就执行执行任务，如果不是小任务，则再次拆分为两个子任务，然后当每个子任务调用 <code>fork()</code> 方法时，会再次进入到 <code>compute()</code> 方法中，检查当前任务是否需要再拆分为子任务，如果已经是小任务，则执行当前任务并返回结果，否则继续分割，最后调用 <code>join()</code> 方法等待所有子任务执行完成并获得执行结果。伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (problem is small) &#123;</span><br><span class="line">  directly solve problem.</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  Step <span class="number">1</span>. split problem into independent parts.</span><br><span class="line">  Step <span class="number">2</span>. fork <span class="keyword">new</span> subtasks to solve each part.</span><br><span class="line">  Step <span class="number">3</span>. join all subtasks.</span><br><span class="line">  Step <span class="number">4</span>. compose result from subresults.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Fork-Join-框架设计"><a href="#Fork-Join-框架设计" class="headerlink" title="Fork/Join 框架设计"></a>Fork/Join 框架设计</h4><p><code>Fork/Join</code> 框架核心思想是把一个大任务拆分成若干个小任务，然后汇总每个小任务的结果最终得到大任务的结果，如果让你设计一个这样的框架，你会如何实现呢？（建议思考一下），<code>Fork/Join</code> 框架的整个流程正如其名所示，分为两个步骤：</p><ol><li><strong>大任务分割</strong> 需要有这么一个的类，用来将大任务拆分为子任务，可能一次拆分后的子任务还是比较大，需要多次拆分，直到拆分出来的子任务符合我们定义的小任务才结束。</li><li><strong>执行任务并合并任务结果</strong> 第一步拆分出来的子任务分别存放在一个个 <a href="https://en.wikipedia.org/wiki/Double-ended_queue" target="_blank" rel="noopener">双端队列</a> 里面（P.S. 这里为什么要使用双端队列请看下文），然后每个队列启动一个线程从队列中获取任务执行。这些子任务的执行结果都会放到一个统一的队列中，然后再启动一个线程从这个队列中拿数据，最后合并这些数据返回。</li></ol><p><code>Fork/Join</code> 框架使用了如下两个类来完成以上两个步骤：</p><ul><li><strong>ForkJoinTask 类</strong> 在上文的实例中也有提到，表示 <code>ForkJoin</code> 任务，在使用框架时首先必须先定义任务，通常只需要继承自 <code>ForkJoinTask</code> 类的子类 <code>RecursiveAction</code>(无返回结果) 或者 <code>RecursiveTask</code>(有返回结果)即可。</li><li><strong>ForkJoinPool</strong> 从名字也可以猜到一二了，就是用来执行 <code>ForkJoinTask</code> 的线程池。大任务拆分出的子任务会添加到当前线程的<code>双端队列</code>的头部。</li></ul><p>喜欢思考的你，心中想必会想到这么一种场景，当我们需要完成一个大任务时，会先把这个大任务拆分为多个独立的子任务，这些子任务会放到独立的队列中，并为每个队列都创建一个单独的线程去执行队列里的任务，即这里线程和队列时一对一的关系，那么当有的线程可能会先把自己队列的任务执行完成了，而有的线程则没有执行完成，这就导致一些先执行完任务的线程干等了，这是个好问题。</p><p>既然是做并发的，肯定要最大程度压榨计算机的性能，对于这种场景并发大师 <a href="http://gee.cs.oswego.edu" target="_blank" rel="noopener">Doug Lea</a> 使用了<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="noopener">工作窃取算法</a>处理，使用<code>工作窃取算法</code>后，先完成自己队列中任务的线程会去其它线程的队列中”窃取“一个任务来执行，哈哈，一方有难，八方支援。但是此时这个线程和队列的持有线程会同时访问同一个队列，所以为了<code>减少窃取任务的线程和被窃取任务的线程之间的竞争</code>，<code>ForkJoin</code> 选择了<code>双端队列</code>这种数据结构，这样就可以按照这种规则执行任务了：被窃取任务的线程始终从队列头部获取任务并执行，窃取任务的线程使用从队列尾部获取任务执行。这个算法在绝大部分情况下都可以充分利用多线程进行并行计算，但是在双端队列里只有一个任务等极端情况下还是会存在一定程度的竞争。</p><p><img src="https://i.loli.net/2021/07/25/Z2RIdHN8iWvKtlk.png" alt="2.png"></p><h4 id="Fork-Join-框架实现原理"><a href="#Fork-Join-框架实现原理" class="headerlink" title="Fork/Join 框架实现原理"></a>Fork/Join 框架实现原理</h4><p><code>Fork/Join</code> 框架的实现核心是 <code>ForkJoinPool</code> 类，该类的重要组成部分为 <code>ForkJoinTask</code> 数组和 <code>ForkJoinWorkerThread</code> 数组，其中 <code>ForkJoinTask</code> 数组用来存放框架使用者给提交给 <code>ForkJoinPool</code> 的任务，<code>ForkJoinWorkerThread</code> 数组则负责执行这些任务。任务有如下四种状态：</p><ul><li><strong>NORMAL</strong> 已完成</li><li><strong>CANCELLED</strong> 被取消</li><li><strong>SIGNAL</strong> 信号</li><li><strong>EXCEPTIONAL</strong> 发生异常</li></ul><p>下面来看看这两个类的核心方法实现原理，首先来看 <code>ForkJoinTask</code> 的 <code>fork()</code> 方法，源码如下：</p><p><img src="https://i.loli.net/2021/07/25/REUWxv9VfukS1la.png" alt="6.png"></p><p>方法对于 <code>ForkJoinWorkerThread</code> 类型的线程，首先会调用 <code>ForkJoinWorkerThread</code> 的 <code>workQueue</code> 的 <code>push()</code> 方法<code>异步的去执行这个任务</code>，然后马上返回结果。继续跟进 <code>ForkJoinPool</code> 的 <code>push()</code> 方法，源码如下：</p><p><img src="https://i.loli.net/2021/07/25/GRIbPCZodErX5UK.png" alt="8.png"></p><p>方法将当前任务添加到 <code>ForkJoinTask</code> 任务队列数组中，然后再调用 <code>ForkJoinPool</code> 的 <code>signalWork</code> 方法创建或者唤醒一个工作线程来执行该任务。然后再来看看 <code>ForkJoinTask</code> 的 <code>join()</code> 方法，方法源码如下：</p><p><img src="https://i.loli.net/2021/07/25/NAqC5XL6Iektm8f.png" alt="3.png"></p><p><img src="https://i.loli.net/2021/07/25/dRCjtwSYpDlrEJq.png" alt="4.png"></p><p>方法首先调用了 <code>doJoin()</code> 方法，该方法返回当前任务的状态，根据返回的任务状态做不同的处理：</p><ol><li>已完成状态则直接返回结果</li><li>被取消状态则直接抛出异常（<code>CancellationException</code>）</li><li>发生异常状态则直接抛出对应的异常</li></ol><p>继续跟进 <code>doJoin()</code> 方法，方法源码如下：</p><p><img src="https://i.loli.net/2021/07/25/KcYRWj2iPbUgCAo.png" alt="5.png"></p><p>方法首先判断当前任务状态是否已经执行完成，如果执行完成则直接返回任务状态。如果没有执行完成，则从任务数组中（<code>workQueue</code>）取出任务并执行，任务执行完成则设置任务状态为 <code>NORMAL</code>，如果出现异常则记录异常并设置任务状态为 <code>EXCEPTIONAL</code>（在 <code>doExec()</code> 方法中）。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍了 <code>Java</code> 并发框架中的 <code>Fork/Join</code> 框架的基本原理和其使用的<code>工作窃取算法</code>(<code>work-stealing</code>)、设计方式和部分实现源码。<code>Fork/Join</code> 框架在 <code>JDK</code> 的官方标准库中也有应用。比如 <code>JDK 1.8+</code> 标准库提供的 <code>Arrays.parallelSort(array)</code> 可以进行并行排序，它的原理就是内部通过 <code>Fork/Join</code> 框架对大数组分拆进行并行排序，可以提高排序的速度，还有集合中的 <code>Collection.parallelStream()</code> 方法底层也是基于 <code>Fork/Join</code> 框架实现的，最后就是定义小任务的阈值往往是需要通过测试验证才能合理给出，并且保证程序可以达到最好的性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/25/ZjDdPW3NGlkSb7V.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是-Fork-Join-框架&quot;&gt;&lt;a href=&quot;#什么是-Fork-Join-框架&quot; class=&quot;headerlink&quot; title=&quot;什么是 Fork/Join 框架&quot;&gt;&lt;/a&gt;什么是 Fork/Join 框架&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Fork/Join&lt;/code&gt; 框架是一种在 &lt;code&gt;JDK 7&lt;/code&gt; 引入的线程池，用于并行执行&lt;code&gt;把一个大任务拆成多个小任务并行执行，最终汇总每个小任务结果得到大任务结果&lt;/code&gt;的特殊任务。通过其命名也很容易看出框架主要分为 &lt;code&gt;Fork&lt;/code&gt; 和 &lt;code&gt;Join&lt;/code&gt; 两个阶段，第一阶段 &lt;code&gt;Fork&lt;/code&gt; 是把一个大任务拆分为多个子任务并行的执行，第二阶段 &lt;code&gt;Join&lt;/code&gt; 是合并这些子任务的所有执行结果，最后得到大任务的结果。&lt;/p&gt;
&lt;p&gt;这里不难发现其执行主要流程：首先判断一个任务是否足够小，如果任务足够小，则直接计算，否则，就拆分成几个更小的小任务分别计算，这个过程可以反复的拆分成一系列小任务。&lt;code&gt;Fork/Join&lt;/code&gt; 框架是一种基于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Divide_and_conquer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分治&lt;/a&gt; 的算法，通过拆分大任务成多个独立的小任务，然后并行执行这些小任务，最后合并小任务的结果得到大任务的最终结果，通过并行计算以提高效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Fork-Join" scheme="https://www.mghio.cn/categories/Java/%E5%B9%B6%E5%8F%91/Fork-Join/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="并发" scheme="https://www.mghio.cn/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Fork-Join" scheme="https://www.mghio.cn/tags/Fork-Join/"/>
    
  </entry>
  
  <entry>
    <title>Spring 的循环依赖问题</title>
    <link href="https://www.mghio.cn/post/f7a05eb0.html"/>
    <id>https://www.mghio.cn/post/f7a05eb0.html</id>
    <published>2021-12-05T08:16:39.000Z</published>
    <updated>2022-11-05T08:18:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/17/lw3qMrmSkIRfOGp.jpg" alt="cover.jpg"></p><h4 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h4><p>什么是<code>循环依赖</code>呢？可以把它拆分成<code>循环</code>和<code>依赖</code>两个部分来看，<strong>循环</strong>是指计算机领域中的循环，执行流程形成闭合回路；<strong>依赖</strong>就是完成这个动作的前提准备条件，和我们平常说的依赖大体上含义一致。放到 <code>Spring</code> 中来看就一个或多个 <code>Bean</code> 实例之间存在直接或间接的依赖关系，构成循环调用，循环依赖可以分为<code>直接循环依赖</code>和<code>间接循环依赖</code>，直接循环依赖的简单依赖场景：<code>Bean A</code> 依赖于 <code>Bean B</code>，然后 <code>Bean B</code> 又反过来依赖于 <code>Bean A</code>（<code>Bean A -&gt; Bean B -&gt; Bean A</code>），间接循环依赖的一个依赖场景：<code>Bean A</code> 依赖于 <code>Bean B</code>，<code>Bean B</code> 依赖于 <code>Bean C</code>，<code>Bean C</code> 依赖于 <code>Bean A</code>，中间多了一层，但是最终还是形成循环（<code>Bean A -&gt; Bean B -&gt; Bean C -&gt; Bean A</code>）。</p><a id="more"></a><h4 id="循环依赖的类型"><a href="#循环依赖的类型" class="headerlink" title="循环依赖的类型"></a>循环依赖的类型</h4><p>第一种是<strong>自依赖</strong>，自己依赖自己从而形成循环依赖，一般情况下不会发生这种循环依赖，因为它很容易被我们发现。</p><p><img src="https://i.loli.net/2021/07/17/LGgVfXmPKU3EwcS.png" alt="1.png"></p><p>第二种是<strong>直接依赖</strong>，发生在两个对象之间，比如：<code>Bean A</code> 依赖于 <code>Bean B</code>，然后 <code>Bean B</code> 又反过来依赖于 <code>Bean A</code>，如果比较细心的话肉眼也不难发现。</p><p><img src="https://i.loli.net/2021/07/17/yNlpDUtmQT2RXnu.png" alt="2.png"></p><p>第三种是<strong>间接依赖</strong>，这种依赖类型发生在 3 个或者以上的对象依赖的场景，间接依赖最简单的场景：<code>Bean A</code> 依赖于 <code>Bean B</code>，<code>Bean B</code> 依赖于 <code>Bean C</code>，<code>Bean C</code> 依赖于 <code>Bean A</code>，可以想象当中间依赖的对象很多时，是很难发现这种循环依赖的，一般都是借助一些工具排查。</p><p><img src="https://i.loli.net/2021/07/17/OH3JobWDSPqrYZE.png" alt="3.png"></p><h4 id="Spring-对几种循环依赖场景支持情况"><a href="#Spring-对几种循环依赖场景支持情况" class="headerlink" title="Spring 对几种循环依赖场景支持情况"></a>Spring 对几种循环依赖场景支持情况</h4><p>在介绍 Spring 对几种循环依赖场景的处理方式之前，先来看看在 Spring 中循环依赖会有哪些场景，大部分常见的场景总结如下图所示：</p><p><img src="https://i.loli.net/2021/07/17/qu4Y6s8nBi1NvRa.png" alt="4.png"></p><p>有句话说得好，<code>源码之下无秘密</code>，下面就通过源码探究这些场景 <code>Spring</code> 是否支持，以及支持的原因或者不支持的原因，话不多说，下面进入正题。</p><h5 id="第-①-种场景——单例-Bean-的-setter-注入"><a href="#第-①-种场景——单例-Bean-的-setter-注入" class="headerlink" title="第 ① 种场景——单例 Bean 的 setter 注入"></a>第 ① 种场景——单例 Bean 的 setter 注入</h5><p>这种使用方式也是最常用的方式之一，假设有两个 <code>Service</code> 分别为 <code>OrderService</code>（订单相关业务逻辑）和 <code>TradeService</code>（交易相关业务逻辑），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TradeService tradeService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateTrade</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种循环依赖场景，程序是可以正常运行的，从代码上看确实是有循环依赖了，也就是说 <code>Spring</code> 是支持这种循环依赖场景的，这里我们察觉不到循环依赖的原因是 <code>Spring</code> 已经默默地解决了。</p><p>假设没有做任何处理，按照正常的创建逻辑来执行的话，流程是这样的：容器先创建 <code>OrderService</code>，发现依赖于 <code>TradeService</code>，再创建 <code>OrderService</code>，又发现依赖于 <code>TradeService</code> … ，发生无限死循环，最后发生栈溢出错误，程序停止。为了支持这种常见的循环依赖场景，<code>Spring</code> 将创建对象分为如下几个步骤：</p><ol><li>实例化一个新对象（在堆中），但此时尚未给对象属性赋值</li><li>给对象赋值</li><li>调用 <code>BeanPostProcessor</code> 的一些实现类的方法，在这个阶段，<code>Bean</code> 已经创建并赋值属性完成。这时候容器中所有实现 <code>BeanPostProcessor</code> 接口的类都会被调用（e.g. <code>AOP</code>）</li><li>初始化（如果实现了 <code>InitializingBean</code>，就会调用这个类的方法来完成类的初始化）</li><li>返回创建出来的实例</li></ol><p>为此，<code>Spring</code> 引入了三级缓存来处理这个问题（三级缓存定义在 <code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</code> 中），第一级缓存 <code>singletonObjects</code> 用于存放完全初始化好的 <code>Bean</code>，从该缓存中取出的 <code>Bean</code> 可以直接使用，第二级缓存 <code>earlySingletonObjects</code> 用于存放提前暴露的单例对象的缓存，存放原始的 <code>Bean</code> 对象（属性尚未赋值），用于解决循环依赖，第三级缓存 <code>singletonFactories</code> 用于存放单例对象工厂的缓存，存放 <code>Bean</code> 工厂对象，用于解决循环依赖。上述实例使用三级缓存的处理流程如下所示：</p><p><img src="https://i.loli.net/2021/07/17/jPUQ6Sfs8mpBtLg.png" alt="5.png"></p><p>如果你看过三级缓存的定义源码的话，可能也有这样的疑问：为什么第三级的缓存的要定义成 <code>Map&lt;String, ObjectFactory&lt;?&gt;&gt;</code>，不能直接缓存对象吗？这里不能直接保存对象实例，因为这样就无法对其做增强处理了。详情可见类 <code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</code> 方法部分源码如下：</p><p><img src="https://i.loli.net/2021/07/17/ribwoNKSgs7L3Jn.png" alt="6.png"></p><hr><h5 id="第-②-种场景——多例-Bean-的-setter-注入"><a href="#第-②-种场景——多例-Bean-的-setter-注入" class="headerlink" title="第 ② 种场景——多例 Bean 的 setter 注入"></a>第 ② 种场景——多例 Bean 的 setter 注入</h5><p>这种方式平常使用得相对较少，还是使用前文的两个 <code>Service</code> 作为示例，唯一不同的地方是现在都声明为<code>多例</code>了，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TradeService tradeService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateTrade</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你在 <code>Spring</code> 中运行以上代码，是可以正常启动成功的，原因是在类 <code>org.springframework.beans.factory.support.DefaultListableBeanFactory</code> 的 <code>preInstantiateSingletons()</code> 方法预实例化处理时，过滤掉了多例类型的 <code>Bean</code>，方法部分代码如下：</p><p><img src="https://i.loli.net/2021/07/17/jO3nk4vrZ9yhXSi.png" alt="7.png"></p><p>但是如果此时有其它单例类型的 <code>Bean</code> 依赖到这些多例类型的 <code>Bean</code> 的时候，就会报如下所示的循环依赖错误了。</p><p><img src="https://i.loli.net/2021/07/17/MDVst5Er2UXCRzm.png" alt="8.png"></p><hr><h5 id="第-③-种场景——代理对象的-setter-注入"><a href="#第-③-种场景——代理对象的-setter-注入" class="headerlink" title="第 ③ 种场景——代理对象的 setter 注入"></a>第 ③ 种场景——代理对象的 setter 注入</h5><p>这种场景也会经常碰到，有时候为了实现异步调用会在 <code>XXXXService</code> 类的方法上添加 <code>@Async</code> 注解，让方法对外部变成异步调用（前提要是要在启用类上添加启用注解哦 <code>@EnableAsync</code>），示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlogMghioCodeApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(BlogMghioCodeApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TradeService tradeService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Async</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateTrade</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在标有 <code>@Async</code> 注解的场景下，在添加启用异步注解（<code>@EnableAsync</code>）后，代理对象会通过 <code>AOP</code> 自动生成。以上代码运行会抛出 <code>BeanCurrentlyInCreationException</code> 异常。运行的大致流程如下图所示：</p><p><img src="https://i.loli.net/2021/07/17/UMEi1GCOo3FDmKB.png" alt="9.png"></p><p>源码在 <code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</code> 类的方法 <code>doCreateBean</code> 中，会判断第二级缓存 <code>earlySingletonObjects</code> 中的对象是否等于原始对象，方法判断部分的源码如下：</p><p><img src="https://i.loli.net/2021/07/17/685tnVsEjD7aqWh.png" alt="10.png"></p><p>二级缓存存放的对象是 <code>AOP</code> 生成出来的代理对象，和原始对象不相等，所以抛出了循环依赖错误。如果细看源码的话，会发现如果二级缓存是空的话会直接返回（因为比较的对象都没有，根本无法校验了），就不会报循环依赖的错误了，默认情况下，<code>Spring</code> 是按照文件全路径递归搜索，按<code>路径</code> + <code>文件名</code> 排序，排序靠前先加载，所以我们只要调整这两个类名称，让方法标有 <code>@Async</code> 注解的类排序在后面即可。</p><hr><h5 id="第-④-种场景——构造器注入"><a href="#第-④-种场景——构造器注入" class="headerlink" title="第 ④ 种场景——构造器注入"></a>第 ④ 种场景——构造器注入</h5><p>构造器注入的场景很少，到目前为止我所接触过的公司项目和开源项目中还没遇到使用构造器注入的，虽然用得不多，但是需要知道 <code>Spring</code> 为什么不支持这种场景的循环依赖，构造器注入的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> TradeService tradeService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(TradeService tradeService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tradeService = tradeService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TradeService</span><span class="params">(OrderService orderService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateTrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器注入无法加入到第三级缓存当中，<code>Spring</code> 框架中的三级缓存在此场景下无用武之地，所以只能抛出异常，整体流程如下（虚线表示无法执行，为了直观也把下一步画出来了）:</p><p><img src="https://i.loli.net/2021/07/17/k3f7VgNIyQjnUwG.png" alt="11.png"></p><hr><h5 id="第-⑤-种场景——DependsOn-循环依赖"><a href="#第-⑤-种场景——DependsOn-循环依赖" class="headerlink" title="第 ⑤ 种场景——DependsOn 循环依赖"></a>第 ⑤ 种场景——DependsOn 循环依赖</h5><p>这种 <code>DependsOn</code> 循环依赖场景很少，一般情况下不怎么使用，了解一下会导致循环依赖的问题即可，<code>@DependsOn</code> 注解主要是用来指定实例化顺序的，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@DependsOn</span>(<span class="string">"tradeService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TradeService tradeService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-07-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@DependsOn</span>(<span class="string">"orderService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateTrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// omit business logic ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上文，我们知道，如果这里的类没有标注 <code>@DependsOn</code> 注解的话是可以正常运行的，因为 <code>Spring</code> 支持单例 <code>setter</code> 注入，但是加了示例代码的 <code>@DependsOn</code> 注解后会报循环依赖错误，原因是在类 <code>org.springframework.beans.factory.support.AbstractBeanFactory</code> 的方法 <code>doGetBean()</code> 中检查了 <code>dependsOn</code> 的实例是否有循环依赖，如果有循环依赖则抛出循环依赖异常，方法判断部分代码如下：</p><p><img src="https://i.loli.net/2021/07/17/DdnyNJAe15rpkjZ.png" alt="12.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍了什么是循环依赖以及 <code>Spring</code> 对各种循环依赖场景的处理，文中只列出了部分涉及到的源码，都标了所在源码中的位置，感兴趣的朋友可以去看看完整源码，最后 <code>Spring</code> 对各种循环依赖场景的支持情况如下图所示（P.S. <code>Spring</code> 版本：5.1.9.RELEASE）：<br><img src="https://i.loli.net/2021/07/17/KTIwXJSUYdNMOuW.png" alt="13.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/17/lw3qMrmSkIRfOGp.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是循环依赖&quot;&gt;&lt;a href=&quot;#什么是循环依赖&quot; class=&quot;headerlink&quot; title=&quot;什么是循环依赖&quot;&gt;&lt;/a&gt;什么是循环依赖&lt;/h4&gt;&lt;p&gt;什么是&lt;code&gt;循环依赖&lt;/code&gt;呢？可以把它拆分成&lt;code&gt;循环&lt;/code&gt;和&lt;code&gt;依赖&lt;/code&gt;两个部分来看，&lt;strong&gt;循环&lt;/strong&gt;是指计算机领域中的循环，执行流程形成闭合回路；&lt;strong&gt;依赖&lt;/strong&gt;就是完成这个动作的前提准备条件，和我们平常说的依赖大体上含义一致。放到 &lt;code&gt;Spring&lt;/code&gt; 中来看就一个或多个 &lt;code&gt;Bean&lt;/code&gt; 实例之间存在直接或间接的依赖关系，构成循环调用，循环依赖可以分为&lt;code&gt;直接循环依赖&lt;/code&gt;和&lt;code&gt;间接循环依赖&lt;/code&gt;，直接循环依赖的简单依赖场景：&lt;code&gt;Bean A&lt;/code&gt; 依赖于 &lt;code&gt;Bean B&lt;/code&gt;，然后 &lt;code&gt;Bean B&lt;/code&gt; 又反过来依赖于 &lt;code&gt;Bean A&lt;/code&gt;（&lt;code&gt;Bean A -&amp;gt; Bean B -&amp;gt; Bean A&lt;/code&gt;），间接循环依赖的一个依赖场景：&lt;code&gt;Bean A&lt;/code&gt; 依赖于 &lt;code&gt;Bean B&lt;/code&gt;，&lt;code&gt;Bean B&lt;/code&gt; 依赖于 &lt;code&gt;Bean C&lt;/code&gt;，&lt;code&gt;Bean C&lt;/code&gt; 依赖于 &lt;code&gt;Bean A&lt;/code&gt;，中间多了一层，但是最终还是形成循环（&lt;code&gt;Bean A -&amp;gt; Bean B -&amp;gt; Bean C -&amp;gt; Bean A&lt;/code&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
      <category term="循环依赖" scheme="https://www.mghio.cn/categories/Java/Spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
      <category term="循环依赖" scheme="https://www.mghio.cn/tags/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring 整合 Feign 的原理</title>
    <link href="https://www.mghio.cn/post/1d4949a7.html"/>
    <id>https://www.mghio.cn/post/1d4949a7.html</id>
    <published>2021-11-05T08:13:23.000Z</published>
    <updated>2022-11-05T08:15:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/07/04/Rh1fuymO8Dbewc2.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://www.mghio.cn/post/7d1b964a.html">上篇</a> 介绍了 Feign 的核心实现原理，在文末也提到了会再介绍其和 Spring Cloud 的整合原理，Spring 具有很强的扩展性，会把一些常用的解决方案通过 starter 的方式开放给开发者使用，在引入官方提供的 starter 后通常只需要添加一些注解即可使用相关功能（通常是 @EnableXXX）。下面就一起来看看 Spring Cloud 到底是如何整合 Feign 的。</p><a id="more"></a><h2 id="整合原理浅析"><a href="#整合原理浅析" class="headerlink" title="整合原理浅析"></a>整合原理浅析</h2><p>在 Spring 中一切都是围绕 Bean 来展开的工作，而所有的 Bean 都是基于 BeanDefinition 来生成的，可以说 BeanDefinition 是整个 Spring 帝国的基石，这个整合的关键也就是要如何生成 Feign 对应的 BeanDefinition。</p><p>要分析其整合原理，我们首先要从哪里入手呢？如果你看过 <a href="https://www.mghio.cn/post/6e436292.html">上篇</a> 的话，在介绍结合 Spring Cloud 使用方式的例子时，第二步就是要在项目的 XXXApplication 上加添加 @EnableFeignClients 注解，我们可以从这里作为切入点，一步步深入分析其实现原理（通常相当一部分的 starter 一般都是在启动类中添加了开启相关功能的注解）。</p><p><img src="https://i.loli.net/2021/07/04/pEegIXqVMovGbCd.png" alt="feign-1.png"></p><p>进入 @EnableFeignClients 注解中，其源码如下：</p><p><img src="https://i.loli.net/2021/07/04/OswIXcqPyjlBVME.png" alt="feign-2.png"></p><p>从注解的源码可以发现，该注解除了定义几个参数（basePackages、defaultConfiguration、clients 等）外，还通过 @Import 引入了 FeignClientsRegistrar 类，一般 @Import 注解有如下功能（具体功能可见 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html" target="_blank" rel="noopener">官方 Java Doc</a>）：</p><ul><li>声明一个 Bean</li><li>导入 @Configuration 注解的配置类</li><li>导入 ImportSelector 的实现类</li><li>导入 ImportBeanDefinitionRegistrar 的实现类（<strong>这里使用这个功能</strong>）</li></ul><p>到这里不难看出，整合实现的主要流程就在 FeignClientsRegistrar 类中了，让我们继续深入到类 FeignClientsRegistrar 的源码，</p><p><img src="https://i.loli.net/2021/07/04/1bJ5PI2U3ANuDvq.png" alt="feign-3.png"></p><p>通过源码可知 FeignClientsRegistrar 实现 ImportBeanDefinitionRegistrar 接口，该接口从名字也不难看出其主要功能就是将所需要初始化的 BeanDefinition 注入到容器中，接口定义两个方法功能都是用来注入给定的 BeanDefinition 的，一个可自定义 beanName（通过实现 BeanNameGenerator 接口自定义生成 beanName 的逻辑），另一个使用默认的规则生成 beanName（类名首字母小写格式）。接口源码如下所示：</p><p><img src="https://i.loli.net/2021/07/04/aY3C9T67qnAbLx5.png" alt="feign-4.png"></p><p>对 Spring 有一些了解的朋友们都知道，Spring 会在容器启动的过程中根据 BeanDefinition 的属性信息完成对类的初始化，并注入到容器中。所以这里 FeignClientsRegistrar 的终极目标就是<strong>将生成的代理类注入到 Spring 容器中。</strong><br>虽然 FeignClientsRegistrar 这个类的源码看起来比较多，但是从其终结目标来看，我们主要是看如何生成 BeanDefinition 的，通过源码可以发现其实现了 ImportBeanDefinitionRegistrar 接口，并且重写了 registerBeanDefinitions(AnnotationMetadata, BeanDefinitionRegistry) 方法，在这个方法里完成了一些 BeanDefinition 的生成和注册工作。源码如下：</p><p><img src="https://i.loli.net/2021/07/04/o9dhOBS4PQEs83C.png" alt="feign-5.png"></p><p>整个过程主要分为如下两个步骤：</p><ol><li>给 @EnableFeignClients 的全局默认配置（注解的 defaultConfiguration 属性）创建 BeanDefinition 对象并注入到容器中（对应上图中的第 ① 步）</li><li>给标有了 @FeignClient 的类创建 BeanDefinition 对象并注入到容器中（对应上图中的第 ② 步）</li></ol><p>下面分别深入方法源码实现来看其具体实现原理，首先来看看第一步的方法 registerDefaultConfiguration(AnnotationMetadata, BeanDefinitionRegistry)，源码如下：</p><p><img src="https://i.loli.net/2021/07/04/eoHI9PgkFOzR1Wq.png" alt="feign-6.png"></p><p>可以看到这里只是获取一下注解 @EnableFeignClients 的默认配置属性 defaultConfiguration 的值，最终的功能实现交给了 registerClientConfiguration(BeanDefinitionRegistry, Object, Object) 方法来完成，继续跟进深入该方法，其源码如下：</p><p><img src="https://i.loli.net/2021/07/04/YDkedFGaugh5OyP.png" alt="feign-7.png"></p><p>可以看到，全局默认配置的 BeanClazz 都是 FeignClientSpecification，然后这里将全局默认配置 configuration 设置为 BeanDefinition 构造器的输入参数，然后当调用构造器实例化时将这个参数传进去。到这里就已经把 @EnableFeignClients 的全局默认配置（注解的 defaultConfiguration 属性）创建出 BeanDefinition 对象并注入到容器中了，第一步到此完成，整体还是比较简单的。</p><p>下面再来看看第二步 <strong>给标有了 @FeignClient 的类创建 BeanDefinition 对象并注入到容器中</strong> 是如何实现的。深入第二步的方法 registerFeignClients(AnnotationMetadata, BeanDefinitionRegistry) 实现中，由于方法实现代码较多，使用截图会比较分散，所以用贴出源代码并在相关位置添加必要注释的方式进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终获取到有 @FeignClient 注解类的集合</span></span><br><span class="line">    LinkedHashSet&lt;BeanDefinition&gt; candidateComponents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取 @EnableFeignClients 注解的属性 map</span></span><br><span class="line">    Map&lt;String, Object&gt; attrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">    <span class="comment">// 获取 @EnableFeignClients 注解的 clients 属性</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="keyword">null</span> ? <span class="keyword">null</span> : (Class&lt;?&gt;[]) attrs.get(<span class="string">"clients"</span>);</span><br><span class="line">    <span class="keyword">if</span> (clients == <span class="keyword">null</span> || clients.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// 如果 @EnableFeignClients 注解未指定 clients 属性则扫描添加（扫描过滤条件为：标注有 @FeignClient 的类）</span></span><br><span class="line">        ClassPathScanningCandidateComponentProvider scanner = getScanner();</span><br><span class="line">        scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(FeignClient.class));</span><br><span class="line">        Set&lt;String&gt; basePackages = getBasePackages(metadata);</span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            candidateComponents.addAll(scanner.findCandidateComponents(basePackage));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 @EnableFeignClients 注解已指定 clients 属性，则直接添加，不再扫描（从这里可以看出，为了加快容器启动速度，建议都指定 clients 属性）</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">            candidateComponents.add(<span class="keyword">new</span> AnnotatedGenericBeanDefinition(clazz));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历最终获取到的 @FeignClient 注解类的集合</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">            <span class="comment">// 验证带注释的类必须是接口，不是接口则直接抛出异常（大家可以想一想为什么只能是接口？）</span></span><br><span class="line">            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();</span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(), <span class="string">"@FeignClient can only be specified on an interface"</span>);</span><br><span class="line">            <span class="comment">// 获取 @FeignClient 注解的属性值</span></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                    .getAnnotationAttributes(FeignClient.class.getCanonicalName());</span><br><span class="line">            <span class="comment">// 获取 clientName 的值，也就是在构造器的参数值（具体获取逻辑可以参见 getClientName(Map&lt;String, Object&gt;) 方法      </span></span><br><span class="line">            String name = getClientName(attributes);</span><br><span class="line">            <span class="comment">// 同上文第一步最后调用的方法，注入 @FeignClient 注解的配置对象到容器中</span></span><br><span class="line">            registerClientConfiguration(registry, name, attributes.get(<span class="string">"configuration"</span>));</span><br><span class="line">            <span class="comment">// 注入 @FeignClient 对象，该对象可以在其它类中通过 @Autowired 直接引入（e.g. XXXService）</span></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码可以看到最后是通过方法 registerFeignClient(BeanDefinitionRegistry, AnnotationMetadata, Map&lt;String, Object&gt;) 注入的 @FeignClient 对象，继续深入该方法，源码如下：</p><p><img src="https://i.loli.net/2021/07/04/93NYJuOwdRBiTXF.png" alt="feign-8.png"></p><p>方法实现比较长，最终目标是构造出 BeanDefinition 对象，然后通过 BeanDefinitionReaderUtils.registerBeanDefinition(BeanDefinitionHolder, BeanDefinitionRegistry) 注入到容器中。</p><p>其中关键的一步是从 @FeignClient 注解中获取信息并设置到 BeanDefinitionBuilder 中，BeanDefinitionBuilder 中注册的类是 FeignClientFactoryBean，这个类的功能正如它的名字一样是用来创建出 FeignClient 的 Bean 的，然后 Spring 会根据 FeignClientFactoryBean 生成对象并注入到容器中。</p><p>需要明确的一点是，实际上这里最终注入到容器当中的是 FeignClientFactoryBean 这个类，Spring 会在类初始化的时候会根据这个类来生成实例对象，就是调用 FeignClientFactoryBean.getObject() 方法，这个生成的对象就是我们实际使用的代理对象。下面再进入到类 FeignClientFactoryBean 的 getObject() 这个⽅法，源码如下：</p><p><img src="https://i.loli.net/2021/07/04/evjCWpEgx2s4YA5.png" alt="feign-9.png"></p><p>可以看到这个方法是直接调用的类中的另一个方法 getTarget() 的，在继续跟进该方法，由于该方法实现代码较多，使用截图会比较分散，所以用贴出源代码并在相关位置添加必要注释的方式进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> &lt;T&gt; the target type of the Feign client</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> Feign&#125; client created with the specified data and the context</span></span><br><span class="line"><span class="comment">  * information</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 Spring 容器中获取 FeignContext Bean</span></span><br><span class="line">    FeignContext context = beanFactory != <span class="keyword">null</span> ? beanFactory.getBean(FeignContext.class)</span><br><span class="line">            : applicationContext.getBean(FeignContext.class);</span><br><span class="line">    <span class="comment">// 根据获取到的 FeignContext 构建出 Feign.Builder         </span></span><br><span class="line">    Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注解 @FeignClient 未指定 url 属性 </span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(url)) &#123;</span><br><span class="line">        <span class="comment">// url 属性是固定访问某一个实例地址，如果未指定协议则拼接 http 请求协议</span></span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">            url = <span class="string">"http://"</span> + name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            url = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 格式化 url</span></span><br><span class="line">        url += cleanPath();</span><br><span class="line">        <span class="comment">// 生成代理和我们之前的代理一样，注解 @FeignClient 未指定 url 属性则返回一个带有负载均衡功能的客户端对象</span></span><br><span class="line">        <span class="keyword">return</span> (T) loadBalance(builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(type, name, url));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注解 @FeignClient 已指定 url 属性 </span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(url) &amp;&amp; !url.startsWith(<span class="string">"http"</span>)) &#123;</span><br><span class="line">        url = <span class="string">"http://"</span> + url;</span><br><span class="line">    &#125;</span><br><span class="line">    String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">    <span class="comment">// 获取一个 client</span></span><br><span class="line">    Client client = getOptional(context, Client.class);</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> FeignBlockingLoadBalancerClient) &#123;</span><br><span class="line">            <span class="comment">// not load balancing because we have a url,</span></span><br><span class="line">            <span class="comment">// but Spring Cloud LoadBalancer is on the classpath, so unwrap</span></span><br><span class="line">            <span class="comment">// 这里没有负载是因为我们有指定了 url </span></span><br><span class="line">            client = ((FeignBlockingLoadBalancerClient) client).getDelegate();</span><br><span class="line">        &#125;</span><br><span class="line">        builder.client(client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成代理和我们之前的代理一样，最后被注入到 Spring 容器中</span></span><br><span class="line">    Targeter targeter = get(context, Targeter.class);</span><br><span class="line">    <span class="keyword">return</span> (T) targeter.target(<span class="keyword">this</span>, builder, context, <span class="keyword">new</span> HardCodedTarget&lt;&gt;(type, name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码得知 FeignClientFactoryBean 继承了 FactoryBean，其方法 FactoryBean.getObject 返回的就是 Feign 的代理对象，最后这个代理对象被注入到 Spring 容器中，我们就通过 @Autowired 可以直接注入使用了。同时还可以发现上面的代码分支最终都会走到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Targeter targeter = get(context, Targeter.class);</span><br><span class="line"><span class="keyword">return</span> targeter.target(<span class="keyword">this</span>, builder, context, target);</span><br></pre></td></tr></table></figure><p>点进去深入 targeter.target 的源码，可以看到实际上这里创建的就是一个代理对象，也就是说在容器启动的时候，会为每个 @FeignClient 创建了一个代理对象。至此，Spring Cloud 和 Feign 整合原理的核心实现介绍完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 Spring Cloud 整合 Feign 的原理。通过上文介绍，你已经知道 Srpring 会我们的标注的 @FeignClient 的接口创建了一个代理对象，那么有了这个代理对象我们就可以做<strong>增强</strong>处理（e.g. 前置增强、后置增强），那么你知道是如何实现的吗？感兴趣的朋友可以再翻翻源码寻找答案（温馨提示：增强逻辑在 InvocationHandler 中）。还有 Feign 与 Ribbon 和 Hystrix 等组件的协作，感兴趣的朋友可以自行下载源码学习了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/04/Rh1fuymO8Dbewc2.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.mghio.cn/post/7d1b964a.html&quot;&gt;上篇&lt;/a&gt; 介绍了 Feign 的核心实现原理，在文末也提到了会再介绍其和 Spring Cloud 的整合原理，Spring 具有很强的扩展性，会把一些常用的解决方案通过 starter 的方式开放给开发者使用，在引入官方提供的 starter 后通常只需要添加一些注解即可使用相关功能（通常是 @EnableXXX）。下面就一起来看看 Spring Cloud 到底是如何整合 Feign 的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="实现原理" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="Feign" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Feign/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Feign/Spring/"/>
    
    
      <category term="实现原理" scheme="https://www.mghio.cn/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="Feign" scheme="https://www.mghio.cn/tags/Feign/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Feign 实现原理</title>
    <link href="https://www.mghio.cn/post/7d1b964a.html"/>
    <id>https://www.mghio.cn/post/7d1b964a.html</id>
    <published>2021-10-06T08:10:30.000Z</published>
    <updated>2022-11-05T08:15:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/27/cfwIm4da7jBX6tL.jpg" alt="cover.jpg"></p><h2 id="What-is-Feign"><a href="#What-is-Feign" class="headerlink" title="What is Feign?"></a>What is Feign?</h2><p>Feign 是⼀个 HTTP 请求的轻量级客户端框架。通过 接口 + 注解的方式发起 HTTP 请求调用，面向接口编程，而不是像 Java 中通过封装 HTTP 请求报文的方式直接调用。服务消费方拿到服务提供方的接⼝，然后像调⽤本地接⼝⽅法⼀样去调⽤，实际发出的是远程的请求。让我们更加便捷和优雅的去调⽤基于 HTTP 的 API，被⼴泛应⽤在 Spring Cloud 的解决⽅案中。开源项目地址：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">Feign</a>，官方描述如下：</p><blockquote><p>Feign is a Java to HTTP client binder inspired by Retrofit, JAXRS-2.0, and WebSocket. Feign’s first goal was reducing the complexity of binding Denominator uniformly to HTTP APIs regardless of ReSTfulness.</p></blockquote><a id="more"></a><h2 id="Why-Feign"><a href="#Why-Feign" class="headerlink" title="Why Feign?"></a>Why Feign?</h2><p>Feign 的首要目标就是减少 HTTP 调用的复杂性。在微服务调用的场景中，我们调用很多时候都是基于 HTTP 协议的服务，如果服务调用只使用提供 HTTP 调用服务的 HTTP Client 框架（e.g. Apache HttpComponnets、HttpURLConnection OkHttp 等），我们需要关注哪些问题呢？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44ddd61c8f2248479dd3b9edaaf6b907~tplv-k3u1fbpfcp-watermark.image" alt="feign-1.png"></p><p>相比这些 HTTP 请求框架，Feign 封装了 HTTP 请求调用的流程，而且会强制使用者去养成面向接口编程的习惯（因为 Feign 本身就是要面向接口）。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h4 id="原生使用方式"><a href="#原生使用方式" class="headerlink" title="原生使用方式"></a>原生使用方式</h4><p>以获取 Feign 的 GitHub 开源项目的 Contributors 为例，原生方式使用 Feign 步骤有如下三步（这里以使用 Gradle 进行依赖管理的项目为例）：<br><strong>第一步：</strong> 引入相关依赖：implementation ‘io.github.openfeign:feign-core:11.0’<br>在项目的 build.gradle 文件的依赖声明处 dependencies 添加该依赖声明即可。</p><p><strong>第二步：</strong> 声明 HTTP 请求接口<br>使用 Java 的接口和 Feign 的原生注解 @RequestLine 声明 HTTP 请求接口，从这里就可以看到 Feign 给使用者封装了 HTTP 的调用细节，极大的减少了 HTTP 调用的复杂性，只要定义接口即可。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/645054130d41409c95aa320791932bd3~tplv-k3u1fbpfcp-zoom-1.image" alt="declare-interface.png"></p><p><strong>第三步：</strong> 配置初始化 Feign 客户端<br>最后一步配置初始化客户端，这一步主要是设置请求地址、编码（Encoder）、解码（Decoder）等。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a1bc5cd80174914877a25bc5cf3e147~tplv-k3u1fbpfcp-zoom-1.image" alt="config-feign-client.png"></p><p>通过定义接口，使用注解的方式描述接口的信息，就可以发起接口调用。最后请求结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21fa8de05c6479788cb59dae78567df~tplv-k3u1fbpfcp-zoom-1.image" alt="native-use-feign-result.png"></p><h4 id="结合-Spring-Cloud-使用方式"><a href="#结合-Spring-Cloud-使用方式" class="headerlink" title="结合 Spring Cloud 使用方式"></a>结合 Spring Cloud 使用方式</h4><p>同样还是以获取 Feign 的 GitHub 开源项目的 Contributors 为例，结合 Spring Cloud 的使用方式有如下三步：<br><strong>第一步：</strong> 引入相关 starter 依赖：org.springframework.cloud:spring-cloud-starter-openfeign<br>在项目的 build.gradle 文件的依赖声明处 dependencies 添加该依赖声明即可。</p><p><strong>第二步：</strong> 在项目的启动类 XXXApplication 上添加 @EnableFeignClients 注解启用 Feign 客户端功能。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adcceea29c1b4d8382d7a7551d1996f7~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-6.png"></p><p><strong>第三步：</strong> 创建 HTTP 调用接口，并添加声明 @FeignClient 注解。<br>最后一步配置初始化客户端，这一步主要是设置请求地址（url）、编码（Encoder）、解码（Decoder）等，与原生使用方式不同的是，现在我们是通过 @FeignClient 注解配置的 Feign 客户端属性，同时请求的 URL 也是使用的 Spring MVC 提供的注解。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6cecd86c4ba4aa68853e24506517fc7~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-7.png"></p><p>测试类如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b30cdcb90019472daf396449f410d351~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-8.png"></p><p>运行结果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc966ac99d63455d9f77104e0598265e~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-9.png"></p><p>可以看到这里是通过 @Autowired 注入刚刚定义的接口的，然后就可以直接使用其来发起 HTTP 请求了，使用是不是很方便、简洁。</p><h2 id="Dive-into-Feign"><a href="#Dive-into-Feign" class="headerlink" title="Dive into Feign"></a>Dive into Feign</h2><p>从上面第一个原生使用的例子可以看到，只是定了接口并没有具体的实现类，但是却可以在测试类中直接调用接口的方法来完成接口的调用，我们知道在 Java 里面接口是无法直接进行使用的，因此可以大胆猜测是 Feign 在背后默默生成了接口的代理实现类，也可以验证一下，只需在刚刚的测试类 debug 一下看看接口实际使用的是什么实现类：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c430676371448deb19c0a7dd6c5cd7b~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-11.png"></p><p>从 debug 结果可知，框架生成了接口的代理实现类 HardCodedTarget 的对象 $Proxy14 来完成接口请求调用，和刚刚的猜测一致。Feign 主要是封装了 HTTP 请求调用，其整体架构如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17e2cdc545a84f8b90fab286e1cdbeb3~tplv-k3u1fbpfcp-zoom-1.image" alt="feign-10.png"></p><p>测试类代码里面只在 GitHub github = Feign.builder().target(GitHub.class, “<a href="https://api.github.com&quot;" target="_blank" rel="noopener">https://api.github.com&quot;</a>); 用到了 Feign 框架的功能，所以我们选择从这里来深入源码，点击进入发现是 Feign 抽象类提供的方法，同样我们知道抽象类也是无法进行初始化的，所以肯定是有子类的，如果你刚刚有仔细观察上面的 debug 代码的话，可以发现有一个 ReflectiveFeign 类，这个类就是抽象类 Feign 的子类了。抽象类 feign.Feign 的部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Feign</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  ...  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;RequestInterceptor&gt; requestInterceptors = <span class="keyword">new</span> ArrayList&lt;RequestInterceptor&gt;();</span><br><span class="line">    <span class="keyword">private</span> Logger.Level logLevel = Logger.Level.NONE;</span><br><span class="line">    <span class="keyword">private</span> Contract contract = <span class="keyword">new</span> Contract.Default();</span><br><span class="line">    <span class="keyword">private</span> Client client = <span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">private</span> Retryer retryer = <span class="keyword">new</span> Retryer.Default();</span><br><span class="line">    <span class="keyword">private</span> Logger logger = <span class="keyword">new</span> NoOpLogger();</span><br><span class="line">    <span class="keyword">private</span> Encoder encoder = <span class="keyword">new</span> Encoder.Default();</span><br><span class="line">    <span class="keyword">private</span> Decoder decoder = <span class="keyword">new</span> Decoder.Default();</span><br><span class="line">    <span class="keyword">private</span> QueryMapEncoder queryMapEncoder = <span class="keyword">new</span> FieldQueryMapEncoder();</span><br><span class="line">    <span class="keyword">private</span> ErrorDecoder errorDecoder = <span class="keyword">new</span> ErrorDecoder.Default();</span><br><span class="line">    <span class="keyword">private</span> Options options = <span class="keyword">new</span> Options();</span><br><span class="line">    <span class="keyword">private</span> InvocationHandlerFactory invocationHandlerFactory =</span><br><span class="line">        <span class="keyword">new</span> InvocationHandlerFactory.Default();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> decode404;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> closeAfterDecode = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> ExceptionPropagationPolicy propagationPolicy = NONE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> forceDecoding = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Capability&gt; capabilities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输入打印日志级别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">logLevel</span><span class="params">(Logger.Level logLevel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.logLevel = logLevel;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置接口方法注解处理器（契约） </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">contract</span><span class="params">(Contract contract)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.contract = contract;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置使用的 Client（默认使用 JDK 的 HttpURLConnection）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">client</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.client = client;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置重试器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">retryer</span><span class="params">(Retryer retryer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.retryer = retryer;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求编码器 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">encoder</span><span class="params">(Encoder encoder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.encoder = encoder;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置响应解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">decoder</span><span class="params">(Decoder decoder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.decoder = decoder;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 404 返回结果解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">decode404</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.decode404 = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置错误解码器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">errorDecoder</span><span class="params">(ErrorDecoder errorDecoder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.errorDecoder = errorDecoder;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">requestInterceptors</span><span class="params">(Iterable&lt;RequestInterceptor&gt; requestInterceptors)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.requestInterceptors.clear();</span><br><span class="line">      <span class="keyword">for</span> (RequestInterceptor requestInterceptor : requestInterceptors) &#123;</span><br><span class="line">        <span class="keyword">this</span>.requestInterceptors.add(requestInterceptor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Class&lt;T&gt; apiType, String url)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> target(<span class="keyword">new</span> HardCodedTarget&lt;T&gt;(apiType, url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">target</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在方法 public <t> T target(Class<t> apiType, String url) 中直接创建了 HardCodedTarget 对象出来，这个对象也是上面 debug 看到的对象。再继续深入，就来到了 feign.Feign 的 newInstance(Target<t> target) 的方法了，是个抽象方法，其实现在子类 ReflectiveFeign 中，这个方法就是接口代理实现生成的地方，下面通过源码来看看实现逻辑是怎样的：</t></t></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveFeign</span> <span class="keyword">extends</span> <span class="title">Feign</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ParseHandlersByName targetToHandlersByName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InvocationHandlerFactory factory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> QueryMapEncoder queryMapEncoder;</span><br><span class="line"></span><br><span class="line">  ReflectiveFeign(ParseHandlersByName targetToHandlersByName, InvocationHandlerFactory factory,</span><br><span class="line">      QueryMapEncoder queryMapEncoder) &#123;</span><br><span class="line">    <span class="keyword">this</span>.targetToHandlersByName = targetToHandlersByName;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.queryMapEncoder = queryMapEncoder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Target&lt;T&gt; target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;类名#方法签名, MethodHandler&gt;，key 是通过 feign.Feign.configKey(Class targetType, Method method) 生成的</span></span><br><span class="line">    Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);</span><br><span class="line">    <span class="comment">// 将 Map&lt;String, MethodHandler&gt; 转换为  Map&lt;Method, MethodHandler&gt; 方便调用</span></span><br><span class="line">    Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">    <span class="comment">// 默认方法处理器</span></span><br><span class="line">    List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Method method : target.type().getMethods()) &#123;</span><br><span class="line">      <span class="comment">// 跳过 Object 类定于的方法  </span></span><br><span class="line">      <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isDefault(method)) &#123;</span><br><span class="line">        <span class="comment">// 默认方法（接口声明的默认方法）使用默认的方法处理器  </span></span><br><span class="line">        DefaultMethodHandler handler = <span class="keyword">new</span> DefaultMethodHandler(method);</span><br><span class="line">        defaultMethodHandlers.add(handler);</span><br><span class="line">        methodToHandler.put(method, handler);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 接口正常声明的方法（e.g. GitHub.listContributors(String, String)）  </span></span><br><span class="line">        methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 Feign 封装的 InvocationHandler</span></span><br><span class="line">    InvocationHandler handler = factory.create(target, methodToHandler);</span><br><span class="line">    <span class="comment">// 基于 JDK 动态代理生成接口的代理类（e.g. Github 接口）</span></span><br><span class="line">    T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">      defaultMethodHandler.bindTo(proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体流程就是在方法 <t> T newInstance(Target<t> target) 生成一个含有 FeignInvocationHandler 的代理对象，FeignInvocationHandler 对象会持有 Map&lt;Method, MethodHandler&gt; map，代理对象调用的时候进入 FeignInvocationHandler#invoke 方法，根据调用的方法来获取对应 MethodHandler，然后再 MethodHandler 完成对方法的处理（处理 HTTP 请求等）。</t></t></p><p>下面再深入 MethodHandler，看看是如何完成对方法 HTTP 请求处理的，MethodHandler 是一个接口定义在 feign.InvocationHandlerFactory 接口中（P.S. 基础知识点，接口是可以在内部定义内部接口的哦），有两个实现类分别为 DefaultMethodHandler 和 SynchronousMethodHandler，第一个 DefaultMethodHandler 用来处理接口的默认方法，第二个是用来处理正常的接口方法的，一般情况下都是由该类来处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousMethodHandler</span> <span class="keyword">implements</span> <span class="title">MethodHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 RequestTemplate 将请求参数封装成请求模板  </span></span><br><span class="line">    RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">    Options options = findOptions(argv);</span><br><span class="line">    <span class="comment">// 请求重试器</span></span><br><span class="line">    Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行请求并解码后返回  </span></span><br><span class="line">        <span class="keyword">return</span> executeAndDecode(template, options);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RetryableException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 发生重试异常则进行重试处理  </span></span><br><span class="line">          retryer.continueOrPropagate(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RetryableException th) &#123;</span><br><span class="line">          Throwable cause = th.getCause();</span><br><span class="line">          <span class="keyword">if</span> (propagationPolicy == UNWRAP &amp;&amp; cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> cause;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> th;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">          logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template, Options options)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 从请求模板 RequestTemplate 构造请求参数对象 Request  </span></span><br><span class="line">    Request request = targetRequest(template);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">      logger.logRequest(metadata.configKey(), logLevel, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 通过 client（Apache HttpComponnets、HttpURLConnection OkHttp 等）执行 HTTP 请求调用，默认是 HttpURLConnection </span></span><br><span class="line">      response = client.execute(request, options);</span><br><span class="line">      <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 12</span></span><br><span class="line">      response = response.toBuilder()</span><br><span class="line">          .request(request)</span><br><span class="line">          .requestTemplate(template)</span><br><span class="line">          .build();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) &#123;</span><br><span class="line">        logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> errorExecuting(request, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (decoder != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">// 对返回结果进行解码操作</span></span><br><span class="line">      <span class="keyword">return</span> decoder.decode(response, metadata.returnType());</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Object&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    asyncResponseHandler.handleResponse(resultFuture, metadata.configKey(), response,</span><br><span class="line">        metadata.returnType(),</span><br><span class="line">        elapsedTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!resultFuture.isDone())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Response handling not done"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> resultFuture.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CompletionException e) &#123;</span><br><span class="line">      Throwable cause = e.getCause();</span><br><span class="line">      <span class="keyword">if</span> (cause != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> cause;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Feign 的核心实现流程介绍完毕，从代码上看 feign.SynchronousMethodHandler 的操作相对比较简单，主要是通过 client 完成请求，对响应进行解码以及异常处理操作，整体流程如下：</p><p><img src="https://i.loli.net/2021/06/27/VMAbsPCRy3jD7ch.png" alt="feign-12.png"></p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Feign 通过给我们定义的目标接口（比如例子中的 GitHub）生成一个 HardCodedTarget 类型的代理对象，由 JDK 动态代理实现，生成代理的时候会根据注解来生成一个对应的 Map&lt;Method, MethodHandler&gt;，这个 Map 被 InvocationHandler 持有，接口方法调用的时候，进入 InvocationHandler 的 invoke 方法（为什么会进入这里？JDK 动态代理的基础知识）。</p><p>然后根据调用的方法从 Map&lt;Method, MethodHandler&gt; 获取对应的 MethodHandler，然后通过 MethodHandler 根据指定的 client 来完成对应处理， MethodHandler 中的实现类 DefaultMethodHandler 处理默认方法（接口的默认方法）的请求处理的，SynchronousMethodHandler 实现类是完成其它方法的 HTTP 请求的实现，这就是 Feign 的主要核心流程，源码已上传 <a href="https://github.com/mghio/feign-demo.git" target="_blank" rel="noopener">Github</a>。以上是 Feign 框架实现的核心流程介绍，Spring Cloud 是如何整合 Feign 的呢？请看下篇博文，敬请期待。s</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/27/cfwIm4da7jBX6tL.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;What-is-Feign&quot;&gt;&lt;a href=&quot;#What-is-Feign&quot; class=&quot;headerlink&quot; title=&quot;What is Feign?&quot;&gt;&lt;/a&gt;What is Feign?&lt;/h2&gt;&lt;p&gt;Feign 是⼀个 HTTP 请求的轻量级客户端框架。通过 接口 + 注解的方式发起 HTTP 请求调用，面向接口编程，而不是像 Java 中通过封装 HTTP 请求报文的方式直接调用。服务消费方拿到服务提供方的接⼝，然后像调⽤本地接⼝⽅法⼀样去调⽤，实际发出的是远程的请求。让我们更加便捷和优雅的去调⽤基于 HTTP 的 API，被⼴泛应⽤在 Spring Cloud 的解决⽅案中。开源项目地址：&lt;a href=&quot;https://github.com/OpenFeign/feign&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Feign&lt;/a&gt;，官方描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Feign is a Java to HTTP client binder inspired by Retrofit, JAXRS-2.0, and WebSocket. Feign’s first goal was reducing the complexity of binding Denominator uniformly to HTTP APIs regardless of ReSTfulness.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="实现原理" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="Feign" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Feign/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/Feign/Spring/"/>
    
    
      <category term="实现原理" scheme="https://www.mghio.cn/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="Feign" scheme="https://www.mghio.cn/tags/Feign/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>信息爆炸时代，该如何获取优质信息？</title>
    <link href="https://www.mghio.cn/post/7f4af1a1.html"/>
    <id>https://www.mghio.cn/post/7f4af1a1.html</id>
    <published>2021-09-05T08:07:58.000Z</published>
    <updated>2022-11-05T08:09:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/20/jrvkdhabSB7wOCD.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们现在所处的信息爆炸时代，如何强调快速获取信息都不为过，信息多种多样，有些能找到源头，有些则不能，有些能找到规律，有些则不一定能找到，信息的源头和获取渠道很重要。然而事实上，能够真正有效获取到<strong>优质信息</strong>并加以消化利用的人并不多。</p><p>在信息的获取的过程中，应该要具备筛选信息的能力，什么是官方信息，你要核实，什么是虚假信息，你要甄别。看到网上有些陷入杀猪盘的，负载累累。仔细思考一下，其实甄别筛选信息的能力真的是最大的问题。</p><p>当然一个人将信息并内化利用是一个很复杂的过程，每个人都有自己独到的方法。今天来聊聊应该如何去获取「优质信息」以及如何去过滤无用信息。下面分享几个获取信息的原则：</p><a id="more"></a><h2 id="尽自己最大努力去获取“一手信息”"><a href="#尽自己最大努力去获取“一手信息”" class="headerlink" title="尽自己最大努力去获取“一手信息”"></a>尽自己最大努力去获取“一手信息”</h2><p>这个原则的关键是，这里的“一手信息”是如何定义呢? 对于那些权威机构或者国家机构，或者专家大咖，或者作者本人所发布的信息绝大部分情况下都可以看作为一手信息，第一手信息，不是被别人理解过、消化过的二手信息。</p><p>尤其对于知识性的东西来说，更应该是这样。应该是原汁原味的，不应该是被添油加醋的。对于一手信息的价值为什么大于二手信息甚至多手信息呢？很简单，这个效应在股票或者投资市场会被放大的很明显，能够在第一时间获取到第一手信息，是能否准确快速判断出市场行情走向的关键因素之一。</p><h2 id="收费的信息优于免费的信息"><a href="#收费的信息优于免费的信息" class="headerlink" title="收费的信息优于免费的信息"></a>收费的信息优于免费的信息</h2><p>对于这个原则，可能不是绝对，但至少在绝大部分情况下是正确的，对于现在很多“白嫖党”来说，可能确实要改一改自己的陋习了，要知道，其实免费反而最贵，因为它给你带来的负面作用或者时间成本，甚至可能会“毒害”你对于信息和知识的热情，当然也会有少部分人会把好的东西给开源或者免费掉。</p><h2 id="国外大部分情况优于国内"><a href="#国外大部分情况优于国内" class="headerlink" title="国外大部分情况优于国内"></a>国外大部分情况优于国内</h2><p>和上面的第二点一样，需要你带着审视和批判思维来看待了，国内整体的创作环境个人角色还是相关比较浮躁和恶劣的，尽管这些年有所改观，但当前的自媒体，包括一些所谓的大 V，也会有很多滥竽充数的文章，视频等内容，包括当前都说信息过载，其实准确来说，是垃圾信息过载，那些优质的内容与知识，毕竟少数。</p><p>有选择的相信专家，并关注他们的日常分享，但不要迷恋迷信专家，很多人会无脑喷当前所谓的砖家伪公知 ，但在大部分情况，专家是在某些领域沉淀研究了很多年，你可以看看别人的一些思路，观点，与框架性东西，在某些情况下，可能真会对自己有所启发。</p><h2 id="通过信息的冗余和比对"><a href="#通过信息的冗余和比对" class="headerlink" title="通过信息的冗余和比对"></a>通过信息的冗余和比对</h2><p>举一个简单的例子，如果今天巴菲特发表了一番言论，当然媒体会对此有记录和报道。但是，各种媒体可能记录有误差，而且可能还有意无意加入自己的看法，把不是巴菲特发表的言论加到他头上，这样就主观或客观地引入了错误信息。</p><p>此时如果你只从一个信息源了解信息，其实是很难判断所获得的是准确信息还是夹杂着一定的错误信息的。但是如果你能从多个信息源了解信息，虽然它们各自都有部分个人主观因素，但是由于各自角度的不同，很多噪音彼此可以抵消掉，获得的则是相对比较准确的信息。</p><p>要时刻警惕回音室响应，避免把自己关进一个封闭的信息圈子，这样慢慢的外部的信息就没法进来了，总之在获取信息的时候一定要尝试从不同维度，不同角度去摄取。</p><h2 id="将信息分解到不同的维度过滤"><a href="#将信息分解到不同的维度过滤" class="headerlink" title="将信息分解到不同的维度过滤"></a>将信息分解到不同的维度过滤</h2><p>在中国，人们常常都会很纠结一个问题，「就是老婆和妈妈掉到水里后先救谁？」，如果仔细思考一下，这个两难问题的重要原因在于，我们要考虑的因素太多，以至于大家越想越糊涂。其实只要你细想就会发现，这个问题的关键是分清楚什么是我们该考虑的信息，什么是不用考虑的信息。</p><p>比如，如果你觉得孝是第一位的，或者觉得以后谁和我生活更长时间是第一位的，作出选择就没有什么难的。这时，你其实是将这个有很多干扰信息的问题，分解到了某些你能够区分的维度，比如孝的维度，或者和一起生活的时间的维度。</p><h2 id="要主动去-pull-信息，不要总是等-push-信息"><a href="#要主动去-pull-信息，不要总是等-push-信息" class="headerlink" title="要主动去 pull 信息，不要总是等 push 信息"></a>要主动去 pull 信息，不要总是等 push 信息</h2><p>这是最后一点，也是最重要的一点，这里的 pull 和 push 可能说得有点偏技术化，解释一下就是 pull 是说要目的地在网络上主动查询一些信息，而不是等各种 APP 给你推送信息，虽然主动查询信息可能会让你感到比较难受，但这是获取优质信息的第一步。</p><p>我个人是目前做技术相关的工作，对这点比较有感触，一个人的学习能力强不强，其实就像生存能力一样，一个重要判断点就是看这个人是能自己找食吃，还是要等别人“喂着吃”。</p><p>别人投喂给你的信息未必都是错的，都是坏的，比如某些自媒体的信息，但如果要获取到更为准确的信息，我建议你还是要去主动搜索核对一下，而不是单凭别人的一面之词。也就是说，别人是不会为你的后果负责的，而你要为自己的后果负责。</p><hr><p>当然，以上是个人在选择信息源的一些原则和思考，希望可以对需要进行信息获取和筛选的朋友有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/20/jrvkdhabSB7wOCD.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们现在所处的信息爆炸时代，如何强调快速获取信息都不为过，信息多种多样，有些能找到源头，有些则不能，有些能找到规律，有些则不一定能找到，信息的源头和获取渠道很重要。然而事实上，能够真正有效获取到&lt;strong&gt;优质信息&lt;/strong&gt;并加以消化利用的人并不多。&lt;/p&gt;
&lt;p&gt;在信息的获取的过程中，应该要具备筛选信息的能力，什么是官方信息，你要核实，什么是虚假信息，你要甄别。看到网上有些陷入杀猪盘的，负载累累。仔细思考一下，其实甄别筛选信息的能力真的是最大的问题。&lt;/p&gt;
&lt;p&gt;当然一个人将信息并内化利用是一个很复杂的过程，每个人都有自己独到的方法。今天来聊聊应该如何去获取「优质信息」以及如何去过滤无用信息。下面分享几个获取信息的原则：&lt;/p&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://www.mghio.cn/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="信息获取" scheme="https://www.mghio.cn/categories/%E6%80%9D%E8%80%83/%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/"/>
    
    
      <category term="思考" scheme="https://www.mghio.cn/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="信息获取" scheme="https://www.mghio.cn/tags/%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>分享几个好用的 Google 搜索技巧</title>
    <link href="https://www.mghio.cn/post/4219480f.html"/>
    <id>https://www.mghio.cn/post/4219480f.html</id>
    <published>2021-08-15T08:03:47.000Z</published>
    <updated>2022-11-05T08:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/12/pzf8mEDUoWbxF6J.jpg" alt="cover.jpg"></p><p>搜索能力是被绝大多数人低估一项基本素质，绝大部分做编程技术相关的朋友应该都知道如何使用 <code>Google</code>，但是并不知道如何利用它的潜力。其实不管是 <code>Google</code> 还是 <code>百度</code>，会搜索的人一样都可以查找到需要的东西，不会搜索的人用什么都不好使。下面介绍一些 <code>Google</code> 常用的搜索技巧以及搜索快捷方式，可以帮助你更快，更准确地找到结果。<code>Google</code> 是世界上功能最强大的搜索引擎，它已经改变了我们查找信息的方式。</p><a id="more"></a><h2 id="0-使用准确的词组"><a href="#0-使用准确的词组" class="headerlink" title="0. 使用准确的词组"></a>0. 使用准确的词组</h2><p>将您要搜索的关键字用引号引起来，<code>Google</code> 会进行精确的词组搜索。</p><blockquote><p>语法：”[searchkey 1] [searchkey 2]” [searchkey 3]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be7884a6df0c4a7ea0737237b79af0f2~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-1.jpg"></p><h2 id="1-多个互斥的搜索条件使用-OR"><a href="#1-多个互斥的搜索条件使用-OR" class="headerlink" title="1. 多个互斥的搜索条件使用 OR"></a>1. 多个互斥的搜索条件使用 OR</h2><p>默认情况下，除非指定，否则 <code>Google</code> 会包含你搜索条件中的所有搜索关键字。通过在您的关键词之字输入<code>OR</code>，<code>Google</code> 会知道它可以查找一组或另一组。大写 <code>OR</code>，否则 <code>Google</code> 会认为它只是你的关键字的一部分。</p><blockquote><p>语法：[searchkey 1] <em>OR</em> [searchkey 2]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45309eefc510442aa754940a0b55b42a~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-2.jpg"></p><h2 id="2-排除指定关键词"><a href="#2-排除指定关键词" class="headerlink" title="2. 排除指定关键词"></a>2. 排除指定关键词</h2><p>通过在单词的前面添加减号，将单词从 <code>Google</code> 搜索中排除。</p><blockquote><p>语法：-[searchkey to exclude] [searchkey to include]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b5d349fcbc7430a898eac862f1f56a3~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-3.jpg"></p><h2 id="3-查找文本块中的所有单词"><a href="#3-查找文本块中的所有单词" class="headerlink" title="3. 查找文本块中的所有单词"></a>3. 查找文本块中的所有单词</h2><p>使用 <code>Google</code> 的 <code>allintext：</code> 语法仅搜索网站的正文，而忽略链接，<code>URL</code> 和标题。</p><blockquote><p> 语法：<em>allintext:</em>[searchkeys]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8858990204646c0bf1bbe53d308cb12~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-4.jpg"></p><h2 id="4-在文本-标题-URL-等查找单词"><a href="#4-在文本-标题-URL-等查找单词" class="headerlink" title="4. 在文本 + 标题 +  URL 等查找单词"></a>4. 在文本 + 标题 +  URL 等查找单词</h2><p>查找搜索词在不同位置的网页。即-在页面正文中，页面标题，<code>URL</code> 等中。为此，在您的关键字之前使用 <code>intext:</code>。</p><blockquote><p>语法：<em>intext:</em>[searchkeys]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892bc2b709ce4b83b3f2d6166374f1dd~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-5.jpg"></p><h2 id="5-标题搜索（单个关键字）"><a href="#5-标题搜索（单个关键字）" class="headerlink" title="5. 标题搜索（单个关键字）"></a>5. 标题搜索（单个关键字）</h2><p>在网页标题内搜索一个单词，然后在网页上的其他位置搜索另一个单词。为此，您需要将 <code>intitle：</code> 混合到您的搜索查询中。</p><blockquote><p>语法：[searchkeys 1] <em>intitle:</em>[searchkeys 2]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3abec6aa60844643be9e0d3b99afd01f~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-6.jpg"></p><h2 id="6-标题搜索（多个关键字）"><a href="#6-标题搜索（多个关键字）" class="headerlink" title="6. 标题搜索（多个关键字）"></a>6. 标题搜索（多个关键字）</h2><p>在网页标题中搜索查询中的所有关键字，在我们的搜索词之前使用 <code>allintitle：</code>。</p><blockquote><p>语法：<em>allintitle:</em>[searchkey1 searchkey2]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef452f1b907044c1b676788682c988a1~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-7.jpg"></p><h2 id="7-在-URL-中搜索"><a href="#7-在-URL-中搜索" class="headerlink" title="7. 在 URL 中搜索"></a>7. 在 URL 中搜索</h2><p>使用 <code>allinURL</code> 可以很容易地在 <code>URL</code> 中搜索关键字 。</p><blockquote><p>语法：<em>allinURL:</em>[searchkeys]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86005ebf9a694f448151c4d868774ff4~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-8.jpg"></p><h2 id="8-在指定网站内搜索"><a href="#8-在指定网站内搜索" class="headerlink" title="8. 在指定网站内搜索"></a>8. 在指定网站内搜索</h2><p>在网站内搜索单词-使用网站 <code>URL</code> 前面的 <code>site：</code> 语法，后跟您的搜索词。这会将搜索结果仅限制在该网站上。</p><blockquote><p>语法：<em>site:</em>[website URL] [searchkeys]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3392f9e2af43a8b6713b1ada33e59f~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-9.jpg"></p><h2 id="9-Google-搜索定义"><a href="#9-Google-搜索定义" class="headerlink" title="9. Google 搜索定义"></a>9. Google 搜索定义</h2><p>通过在单词之前使用 <code>define：</code> 轻松地找到单词的定义，而无需访问词典网站。<code>Google</code> 将提供定义，并提供一个音频播放器来提供该单词的语音发音。</p><blockquote><p>语法：<em>define:</em>[searchkey]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb4f2a9f5ab64008ad64b3c084fcbe52~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-10.jpg"></p><h2 id="10-Google-搜索通配符（遗漏或未知词）"><a href="#10-Google-搜索通配符（遗漏或未知词）" class="headerlink" title="10. Google 搜索通配符（遗漏或未知词）"></a>10. Google 搜索通配符（遗漏或未知词）</h2><p>没想到所有的话吗？加上 <code>*</code> 告诉 <code>Google</code> 为您填写空白，这对于歌曲歌词或书名搜索非常有效。</p><blockquote><p>语法：[searchkeys 1] * [searchkeys 2]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e11426ec76aa4862befaa12c90307d9b~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-11.jpg"></p><h2 id="11-Google-搜索文件类型"><a href="#11-Google-搜索文件类型" class="headerlink" title="11. Google 搜索文件类型"></a>11. Google 搜索文件类型</h2><p>搜索文件类型（例如 <code>PowerPoint</code>，<code>PDF</code> 等）时，请在搜索词中使用 <code>filetype：</code> 命令。</p><blockquote><p>语法：[searchkeyword] <em>filetype:</em>[file type extension]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1a69555faaa4b71a32c73f27119f0e9~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-12.jpg"></p><h2 id="12-转换计算"><a href="#12-转换计算" class="headerlink" title="12. 转换计算"></a>12. 转换计算</h2><p>使用 <code>Google</code> 可以进行任何度量转换。</p><blockquote><p>语法：<em>convert</em> [data value + unit of measure] <em>to</em> [like unit of measure]</p></blockquote><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30f3b8850e2f4c8dbdff7f5b0c318eaa~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-13.jpg"></p><h2 id="13-Google-搜索计算器"><a href="#13-Google-搜索计算器" class="headerlink" title="13. Google 搜索计算器"></a>13. Google 搜索计算器</h2><p>在搜索栏中输入您的计算结果，将 <code>Google</code> 用作计算器。<strong>数值运算符</strong>: <code>*</code> 表示乘，<code>+</code> 表示加，<code>-</code> 表示减，<code>/</code> 表示除。</p><blockquote><p>语法：[number] <em>[operator]</em> [number]</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d25fecfe46c457bb98ae2e894ede6fe~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-14.jpg"></p><h2 id="14-Google-图片搜索"><a href="#14-Google-图片搜索" class="headerlink" title="14. Google 图片搜索"></a>14. Google 图片搜索</h2><p>查找图像的名称，描述和类型。</p><blockquote><p>语法：[searchkeyw] <em>image type</em></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/820f6862b73f42d48fa0d391f5cd41ea~tplv-k3u1fbpfcp-zoom-1.image" alt="Google-Tips-15.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/12/pzf8mEDUoWbxF6J.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;搜索能力是被绝大多数人低估一项基本素质，绝大部分做编程技术相关的朋友应该都知道如何使用 &lt;code&gt;Google&lt;/code&gt;，但是并不知道如何利用它的潜力。其实不管是 &lt;code&gt;Google&lt;/code&gt; 还是 &lt;code&gt;百度&lt;/code&gt;，会搜索的人一样都可以查找到需要的东西，不会搜索的人用什么都不好使。下面介绍一些 &lt;code&gt;Google&lt;/code&gt; 常用的搜索技巧以及搜索快捷方式，可以帮助你更快，更准确地找到结果。&lt;code&gt;Google&lt;/code&gt; 是世界上功能最强大的搜索引擎，它已经改变了我们查找信息的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Google" scheme="https://www.mghio.cn/categories/Google/"/>
    
      <category term="Search" scheme="https://www.mghio.cn/categories/Google/Search/"/>
    
      <category term="Tips" scheme="https://www.mghio.cn/categories/Google/Search/Tips/"/>
    
    
      <category term="Google" scheme="https://www.mghio.cn/tags/Google/"/>
    
      <category term="Search" scheme="https://www.mghio.cn/tags/Search/"/>
    
      <category term="Tips" scheme="https://www.mghio.cn/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>论基础理论知识的重要性</title>
    <link href="https://www.mghio.cn/post/a328bfd.html"/>
    <id>https://www.mghio.cn/post/a328bfd.html</id>
    <published>2021-07-05T08:00:25.000Z</published>
    <updated>2022-11-05T08:01:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/12/9gD8NzcjWSMO2a3.jpg" alt="cover.jpg"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在计算机行业工作的人们，最大的感触就是这个行业里总是会出现很多的新东西，各种技术、框架等等，变化无处不在，有很大一部分人都比较焦虑。在一些论坛或者社区里面总是有人在问如何学习一门新技术？怎样才能跟上技术的潮流？我想说是，我们应该<strong>打牢基础，应对变化，以不变应万变</strong>。</p><a id="more"></a><h4 id="从变化中寻找不变的东西"><a href="#从变化中寻找不变的东西" class="headerlink" title="从变化中寻找不变的东西"></a>从变化中寻找不变的东西</h4><p>变化都是我们看到表面现象，本质的变化其实并没有多大。计算机发展的这几十年来，理论的层面变得不多，很多理论都是在几十年前就已经发现了的，只是在表现形式上变化比较大，夸张一点的甚至是一年一个样的都有。</p><p>所以想要应对这种变化就要抓住其本质不变的地方，也就是其背后的理论基础，打牢理论基础，提升自己的编程内功修养，一些与语言无关比较通用的东西要重点掌握，比如编程里面的一些设计模式、代码重用、解耦以及抽象能力等等。想要代码重用就必须得解耦，想要解耦就进行抽象，抽取出公共不变的东西，这些都是和语言无关的通用的技能。</p><h4 id="基础知识决定你能飞多高"><a href="#基础知识决定你能飞多高" class="headerlink" title="基础知识决定你能飞多高"></a>基础知识决定你能飞多高</h4><p>当你有牢固的基础知识以后，其实也会更加容易的突破自己的技术和成长瓶颈。我认为在技术领域里面其实是不存在量变可以达到质变这么一说的。量变达到质变也是说只要我努力多写代码就能成为架构师，技术有一个质的突破，其实并不是这样的。</p><p>尽管你代码写得再多，如果不懂得背后的技术原理，不懂得科学的学习方法，不进行归纳总结输出，是永远达到质变的。所以必须学习和打牢基础理论知识，如果总是只学习一些浮于表面上的东西，当技术形式发生一些变化后，你会发现之前学习的知识已经用不到了，又得重新学习，而在技术世界里变化又是非常快的，所以很多都迷失在不停的学习技术形式之中，这也是造成一部分人感到焦虑的原因之一。</p><p>上层的技术实现都是有背后的理论基础作为支撑的，因为这些理论基础都是抽象和归纳，比如不管是 <code>Java</code> 还是其它的一些开发语言，只要只用 TCP/IP 协议，用的都是一样的原理，不同的只是技术实现形式上的差异，你只要打牢基础理论知识，抓住本质原理，不管它技术实现形式上如何变化，都能很快掌握它。</p><h4 id="计算机基础理论分类"><a href="#计算机基础理论分类" class="headerlink" title="计算机基础理论分类"></a>计算机基础理论分类</h4><p>这些知识绝大部分都是一个科班学生本科的专业课讲到的原理知识，但是大部分人在学校可能都没有静下心来认真学习钻研，有句话说得好：“出来混，迟早要还的~”，一个好的学习方法就是一定要看一些经典的书和世界顶级学校的课程，最后自己归纳总结输出。这些知识总的来说可以分为以下几类，</p><ol><li>系统知识类：计算机系统、网络协议、数据库等</li><li>算法和数据结构类：算法和数据结构、分布式系统等</li><li>中间件类：消息队列、任务调度、网关代理等</li><li>程序语言类：类库实现、设计模式、编程技术（多线程、异步等）、语言原理等</li></ol><p>计算机发展的这几十年来，核心的基础知识就是上面列举的这些，虽然我们的直观感受技术是在不断更替的，实际上本质的东西并没有改变，其理论基础还是这些内容，变化的只是技术形式，我想说的一点是对这些基础理论知识的掌握程能直接决定的成长天花板。万丈高楼平地起，勿在浮沙筑高台。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/12/9gD8NzcjWSMO2a3.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在计算机行业工作的人们，最大的感触就是这个行业里总是会出现很多的新东西，各种技术、框架等等，变化无处不在，有很大一部分人都比较焦虑。在一些论坛或者社区里面总是有人在问如何学习一门新技术？怎样才能跟上技术的潮流？我想说是，我们应该&lt;strong&gt;打牢基础，应对变化，以不变应万变&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础知识" scheme="https://www.mghio.cn/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="思考" scheme="https://www.mghio.cn/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="https://www.mghio.cn/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="基础知识" scheme="https://www.mghio.cn/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title> 如何实现一个简易版的 Spring - 如何实现 AOP（终结篇）</title>
    <link href="https://www.mghio.cn/post/bd7ad750.html"/>
    <id>https://www.mghio.cn/post/bd7ad750.html</id>
    <published>2021-06-13T07:57:09.000Z</published>
    <updated>2022-11-05T07:58:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/13/42YRj7pdfJkK3wN.jpg" alt="cover.jpg"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://www.mghio.cn/post/2a28641b.html">上篇</a> 实现了 判断一个类的方式是符合配置的 pointcut 表达式、根据一个 Bean 的名称和方法名，获取 Method 对象、实现了 BeforeAdvice、AfterReturningAdvice 以及 AfterThrowingAdvice并按照指定次序调用 等功能，这篇再来看看剩下的 <strong>代理对象如何生成</strong>、<strong>根据 XML 配置文件生成 BeanDefintion</strong>以及<strong>如何将生成的代理对象放入到容器中</strong> 等功能，话不多说，下面进入主题。</p><a id="more"></a><h2 id="代理对象生成"><a href="#代理对象生成" class="headerlink" title="代理对象生成"></a>代理对象生成</h2><p>代理对象的生成策略和 Spring 框架一致，当被代理类实现了接口时采用 JDK 动态代理的方式生成代理对象，被代理对象未实现接口时使用 CGLIB 来生成代理对象，为了简单起见这里不支持手动指定生成代理对象的策略，JDK 动态代理的实现这里不在介绍，感兴趣可以自己实现一下，这里主要讨论 CGLIB 的生成方式。</p><p><img src="https://img-blog.csdnimg.cn/2021061320514299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lbGRveV9tZ2g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>基于面向接口编程的思想，这里的生成代理对象需要定义一个统一的接口，不管是 CGLIB 生成方式还是JDK 动态代理生成方式都要实现该接口。生成代理对象是根据一些配置去生成的，同样，这里生成代理的配置也可以抽取一个统一的接口，在实现类中定义拦截器（也就是 Advice）以及实现的接口等，<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a> 的基本使用可以到官网自行查找。代理对象生成的整体的类图如下：</p><p><img src="https://img-blog.csdnimg.cn/20210613205250678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lbGRveV9tZ2g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>其中代理创建的工厂接口 AopProxyFactory 如下，提供了不指定 ClassLoader（使用默认的 ClassLoader）和指定 ClassLoader 两种方式创建代理对象，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 CGLIB 创建代理的工厂接口实现类如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Constants for CGLIB callback array indices</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AOP_PROXY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Advised advised;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyFactory</span><span class="params">(Advised config)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(config, <span class="string">"AdvisedSupport must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (config.getAdvices().size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"No advisors and no TargetSource specified"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advised = config;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getProxy(<span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Creating CGLIB proxy: target class is "</span> + <span class="keyword">this</span>.advised.getTargetClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">      Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">      <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        enhancer.setClassLoader(classLoader);</span><br><span class="line">      &#125;</span><br><span class="line">      enhancer.setSuperclass(rootClass);</span><br><span class="line">      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);  <span class="comment">// BySpringCGLIB</span></span><br><span class="line">      enhancer.setInterceptDuringConstruction(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">      Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">        types[i] = callbacks[i].getClass();</span><br><span class="line">      &#125;</span><br><span class="line">      enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(<span class="keyword">this</span>.advised));</span><br><span class="line">      enhancer.setCallbackTypes(types);</span><br><span class="line">      enhancer.setCallbacks(callbacks);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">      <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> +</span><br><span class="line">          <span class="keyword">this</span>.advised.getTargetClass() + <span class="string">"]: "</span> +</span><br><span class="line">          <span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">          ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体来看还是比较简单的，主要是 CGLIB 第三方字节码生成库的基本用法，当然，前提是你已经了解了 CGLIB 的基本使用。AOP 的相关配置接口 Advised 相对来说就比较简单了，主要是一些相关属性的增、删、改等操作，主要部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; getTargetClass();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isInterfaceProxied</span><span class="params">(Class&lt;?&gt; intf)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Advice&gt; <span class="title">getAdvices</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(Advice advice)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Advice&gt; <span class="title">getAdvices</span><span class="params">(Method method)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addInterface</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类也比较简单，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvisedSupport</span> <span class="keyword">implements</span> <span class="title">Advised</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> proxyTargetClass = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> Object targetObject = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Advice&gt; advices = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AdvisedSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetObject.getClass();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterfaceProxied</span><span class="params">(Class&lt;?&gt; intf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> interfaces.contains(intf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Advice&gt; <span class="title">getAdvices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.advices;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.advices.add(advice);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Advice&gt; <span class="title">getAdvices</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    List&lt;Advice&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Advice advice : <span class="keyword">this</span>.getAdvices()) &#123;</span><br><span class="line">      Pointcut pc = advice.getPointcut();</span><br><span class="line">      <span class="keyword">if</span> (pc.getMethodMatcher().matches(method)) &#123;</span><br><span class="line">        result.add(advice);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterface</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.interfaces.add(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，代理对象使用 CGLIB 生成的方式就已经实现了，核心代码其实比较简单，主要是需要多考虑考虑代码后期的扩展性。</p><h2 id="创建-BeanDefinition"><a href="#创建-BeanDefinition" class="headerlink" title="创建 BeanDefinition"></a>创建 BeanDefinition</h2><p>我们先来看看一般 AOP 在 XML 配置文件中是如何定义的，一个包含 BeforeAdvice、AfterReturningAdvice以及AfterThrowingAdvice 的 XML 配置文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.e3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:scann-package</span> <span class="attr">base-package</span>=<span class="string">"cn.mghio.service.version5,cn.mghio.dao.version5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tx"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.tx.TransactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"tx"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"placeOrder"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.mghio.service.version5.*.placeOrder(..))"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"start"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"commit"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"rollback"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了之前解析 XML 的 Bean 定义的经验后，很显然这里我们需要一个数据结构去表示这个 AOP 配置，如果你阅读过 <a href="https://www.mghio.cn/post/2a28641b.html">上篇</a> 的话，类 AspectJExpressionPointcut 表示的是 &lt;aop:pointcut id=”placeOrder” expression=”execution(* cn.mghio.service.version5.*.placeOrder(..))”/&gt;，另外几个 Advice 配置分别对应 AspectJBeforeAdvice、AspectJAfterReturningAdvice以及 AspectJAfterThrowingAdvice 等几个类。<br>这里只要解析 XML 配置文件，然后使用对应的 Advice 的构造器创建对应的对象即可，解析 XML 使用的是 dom4j，主要部分代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigBeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASPECT = <span class="string">"aspect"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXPRESSION = <span class="string">"expression"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID = <span class="string">"id"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REF = <span class="string">"ref"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE = <span class="string">"before"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER = <span class="string">"after"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_RETURNING_ELEMENT = <span class="string">"after-returning"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_THROWING_ELEMENT = <span class="string">"after-throwing"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AROUND = <span class="string">"around"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT = <span class="string">"pointcut"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_REF = <span class="string">"pointcut-ref"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASPECT_NAME_PROPERTY = <span class="string">"aspectName"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Element element, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    List&lt;Element&gt; childElements = element.elements();</span><br><span class="line">    <span class="keyword">for</span> (Element el : childElements) &#123;</span><br><span class="line">      String localName = el.getName();</span><br><span class="line">      <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">        parseAspect(el, registry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAspect</span><span class="params">(Element aspectElement, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    String aspectName = aspectElement.attributeValue(REF);</span><br><span class="line"></span><br><span class="line">    List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;RuntimeBeanReference&gt; beanReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse advice</span></span><br><span class="line">    List&lt;Element&gt; elements = aspectElement.elements();</span><br><span class="line">    <span class="keyword">boolean</span> adviceFoundAlready = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isAdviceNode(element)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adviceFoundAlready) &#123;</span><br><span class="line">          adviceFoundAlready = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (!StringUtils.hasText(aspectName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          beanReferences.add(<span class="keyword">new</span> RuntimeBeanReference(aspectName));</span><br><span class="line">        &#125;</span><br><span class="line">        GenericBeanDefinition advisorDefinition = parseAdvice(aspectName, element, registry,</span><br><span class="line">            beanDefinitions, beanReferences);</span><br><span class="line">        beanDefinitions.add(advisorDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse pointcut</span></span><br><span class="line">    List&lt;Element&gt; pointcuts = aspectElement.elements(POINTCUT);</span><br><span class="line">    <span class="keyword">for</span> (Element pointcut : pointcuts) &#123;</span><br><span class="line">      parsePointcut(pointcut, registry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parsePointcut</span><span class="params">(Element pointcutElement, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    String id = pointcutElement.attributeValue(ID);</span><br><span class="line">    String expression = pointcutElement.attributeValue(EXPRESSION);</span><br><span class="line"></span><br><span class="line">    GenericBeanDefinition pointcutDefinition = createPointcutDefinition(expression);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(id)) &#123;</span><br><span class="line">      registry.registerBeanDefinition(id, pointcutDefinition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      BeanDefinitionReaderUtils.registerWithGeneratedName(pointcutDefinition, registry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> GenericBeanDefinition <span class="title">parseAdvice</span><span class="params">(String aspectName, Element adviceElement,</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionRegistry registry, List&lt;BeanDefinition&gt; beanDefinitions,</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;RuntimeBeanReference&gt; beanReferences)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GenericBeanDefinition methodDefinition = <span class="keyword">new</span> GenericBeanDefinition(MethodLocatingFactory.class);</span><br><span class="line">    methodDefinition.getPropertyValues().add(<span class="keyword">new</span> PropertyValue(<span class="string">"targetBeanName"</span>, aspectName));</span><br><span class="line">    methodDefinition.getPropertyValues().add(<span class="keyword">new</span> PropertyValue(<span class="string">"methodName"</span>,</span><br><span class="line">        adviceElement.attributeValue(<span class="string">"method"</span>)));</span><br><span class="line">    methodDefinition.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create instance definition factory</span></span><br><span class="line">    GenericBeanDefinition aspectFactoryDef = <span class="keyword">new</span> GenericBeanDefinition(AopInstanceFactory.class);</span><br><span class="line">    aspectFactoryDef.getPropertyValues().add(<span class="keyword">new</span> PropertyValue(<span class="string">"aspectBeanName"</span>, aspectName));</span><br><span class="line">    aspectFactoryDef.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register the pointcut</span></span><br><span class="line">    GenericBeanDefinition adviceDef = createAdviceDefinition(adviceElement, aspectName,</span><br><span class="line">        methodDefinition, aspectFactoryDef, beanDefinitions, beanReferences);</span><br><span class="line">    adviceDef.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register the final advisor</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerWithGeneratedName(adviceDef, registry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adviceDef;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 BeanDefinition 已经完成了，现在可根据 XML 配置文件解析出对应的 BeanDefintion 了，下面只需要在合适的时机将这些 BeanDefinition 放到容器中就完成了全部流程了。 </p><h2 id="如何放到容器中"><a href="#如何放到容器中" class="headerlink" title="如何放到容器中"></a>如何放到容器中</h2><p>该如何把解析出来的 BeanDefintion 放到容器当中去呢？我们知道在 Spring 框架当中提供了很多的“钩子函数”，可以从这里入手，Bean 的生命周期如下：</p><p><img src="https://img-blog.csdnimg.cn/2021061320530617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lbGRveV9tZ2g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>选择在 Bean 实例化完成之后 BeanPostProcessor 的 postProcessAfterInitialization() 方法创建代理对象，AOP 使用的是 AspectJ，将创建代理对象的类命名为 AspectJAutoProxyCreator，实现 BeanPostProcessor 接口，处理代理对象的创建，AspectJAutoProxyCreator 类的核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyCreator</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ConfigurableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">beforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">afterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果这个 bean 本身就是 Advice 及其子类，则不生成动态代理</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Advice&gt; advices = getCandidateAdvices(bean);</span><br><span class="line">    <span class="keyword">if</span> (advices.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createProxy(advices, bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(List&lt;Advice&gt; advices, Object bean)</span> </span>&#123;</span><br><span class="line">    Advised config = <span class="keyword">new</span> AdvisedSupport();</span><br><span class="line">    <span class="keyword">for</span> (Advice advice : advices) &#123;</span><br><span class="line">      config.addAdvice(advice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&gt; targetInterfaces = ClassUtils.getAllInterfacesForClassAsSet(bean.getClass());</span><br><span class="line">    <span class="keyword">for</span> (Class targetInterface : targetInterfaces) &#123;</span><br><span class="line">      config.addInterface(targetInterface);</span><br><span class="line">    &#125;</span><br><span class="line">    config.setTargetObject(bean);</span><br><span class="line"></span><br><span class="line">    AopProxyFactory proxyFactory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (config.getProxiedInterfaces().length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// CGLIB 代理</span></span><br><span class="line">      proxyFactory = <span class="keyword">new</span> CglibProxyFactory(config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// TODO(mghio): JDK dynamic proxy ...</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(ConfigurableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;Advice&gt; <span class="title">getCandidateAdvices</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    List&lt;Object&gt; advices = <span class="keyword">this</span>.beanFactory.getBeansByType(Advice.class);</span><br><span class="line">    List&lt;Advice&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Object advice : advices) &#123;</span><br><span class="line">      Pointcut pointcut = ((Advice) advice).getPointcut();</span><br><span class="line">      <span class="keyword">if</span> (canApply(pointcut, bean.getClass())) &#123;</span><br><span class="line">        result.add((Advice) advice);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pointcut, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    MethodMatcher methodMatcher = pointcut.getMethodMatcher();</span><br><span class="line">    Set&lt;Class&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">    classes.add(targetClass);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">      Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">      <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (methodMatcher.matches(m)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInfrastructureClass</span><span class="params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Advice.class.isAssignableFrom(beanClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后别忘了，这里的 BeanPostProcessor 接口是我们新加的，需要到之前定义的 DefaultFactoryBean 中加上对 BeanPostProcessor 的处理逻辑，主要修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition bd)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. instantiate bean</span></span><br><span class="line">        Object bean = instantiateBean(bd);</span><br><span class="line">        <span class="comment">// 2. populate bean</span></span><br><span class="line">        populateBean(bd, bean);</span><br><span class="line">        <span class="comment">// 3. initialize bean</span></span><br><span class="line">        bean = initializeBean(bd, bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(BeanDefinition bd, Object bean)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非合成类型则创建代理</span></span><br><span class="line">        <span class="keyword">if</span> (!bd.isSynthetic()) &#123;</span><br><span class="line">            <span class="keyword">return</span> applyBeanPostProcessorAfterInitialization(bean, bd.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">applyBeanPostProcessorAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span> </span>&#123;</span><br><span class="line">        Object result = existingBean;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor postProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">            result = postProcessor.afterInitialization(result, beanName);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// omit other field and methods ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后运行事先测试用例，正常通过符合预期。</p><p><img src="https://img-blog.csdnimg.cn/20210613205223527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01lbGRveV9tZ2g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 AOP 代理对象生成、解析 XML 配置文件并创建对应的 BeanDefinition 以及最后注入到容器中，只是介绍了大体实现思路，具体代码实现已上传 <a href="https://github.com/mghio/mghio-spring" target="_blank" rel="noopener">mghio-spring</a>，感兴趣的朋友可以参考，到这里，AOP 实现部分已经全部介绍完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/13/42YRj7pdfJkK3wN.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://www.mghio.cn/post/2a28641b.html&quot;&gt;上篇&lt;/a&gt; 实现了 判断一个类的方式是符合配置的 pointcut 表达式、根据一个 Bean 的名称和方法名，获取 Method 对象、实现了 BeforeAdvice、AfterReturningAdvice 以及 AfterThrowingAdvice并按照指定次序调用 等功能，这篇再来看看剩下的 &lt;strong&gt;代理对象如何生成&lt;/strong&gt;、&lt;strong&gt;根据 XML 配置文件生成 BeanDefintion&lt;/strong&gt;以及&lt;strong&gt;如何将生成的代理对象放入到容器中&lt;/strong&gt; 等功能，话不多说，下面进入主题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/categories/Java/Spring/AOP/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简易版的 Spring - 如何实现 AOP（下）</title>
    <link href="https://www.mghio.cn/post/2a28641b.html"/>
    <id>https://www.mghio.cn/post/2a28641b.html</id>
    <published>2021-06-06T07:54:32.000Z</published>
    <updated>2022-11-05T07:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/06/10/lOLEuXIUreJkNgM.jpg" alt="cover.jpg"></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>前面两篇 <a href="https://www.mghio.cn/post/9294037e.html">如何实现 AOP（上）</a>、<a href="https://www.mghio.cn/post/af7194f9.html">如何实现 AOP（中）</a> 做了一些 <code>AOP</code> 的核心基础知识简要介绍，本文进入到了实战环节了，去实现一个基于 <code>XML</code> 配置的简易版 <code>AOP</code>，虽然是简易版的但是<code>麻雀虽小五脏俱全</code>，一些核心的功能都会实现，通过实现这个简易版的 <code>AOP</code>，相信你会对 <code>AOP</code> 有深入的理解，不止知其然，还能知其所以然。<code>AOP</code> 的顶层接口规范和底层依赖基础组件都是由一个叫 <a href="http://aopalliance.sourceforge.net" target="_blank" rel="noopener">AOP Alliance</a> 的组织制定的，我们经常听到的 <code>AspectJ</code>、<code>ASM</code>、<code>CGLIB</code> 就是其中被管理的一些项目，需要明确的一点是，在 <code>Spring</code> 中只是使用了 <code>AspectJ</code> 的核心概念和核心类，并不是像 <code>AspectJ</code> 那样在编译期实现的 <code>AOP</code>，而是在<strong>运行期</strong>。话不多说，下面开始进入主题。</p><a id="more"></a><h4 id="解析-XML-中的-pointcut-定义及方法解析"><a href="#解析-XML-中的-pointcut-定义及方法解析" class="headerlink" title="解析 XML 中的 pointcut 定义及方法解析"></a>解析 XML 中的 pointcut 定义及方法解析</h4><p>假设有一个 <code>OrderService</code> 类(P.S. 这里的 <code>@Component</code> 是我自定义的注解，详见 <a href="https://www.mghio.cn/post/6775e26e.html">这篇</a>)，其中有一个下单的方法 <code>placeOrder()</code>，我们想实现的效果是想给这个 <code>placeOrder()</code> 方法加上 <a href="https://en.wikipedia.org/wiki/Database_transaction" target="_blank" rel="noopener">数据库事务</a>，即执行方法之前开启事务，执行过程中发生异常回滚事务，正常执行完成提交事务。<code>OrderService</code> 类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(value = <span class="string">"orderService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"place order"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这里的 <code>pointcut</code> 就是 <code>placeOrder()</code> 方法，在 <code>XML</code> 配置文件中的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"placeOrder"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.mghio.service.version5.*.placeOrder(..))"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>我们需要一个类去表达这个概念，<code>pointcut</code> 要实现的功能是给定一个类的方法，判断是否匹配配置文件中给定的表达式。总的来看 <code>pointcut</code> 由<code>方法匹配器</code>和<code>匹配表达式</code>两部分组成，方法匹配器可以有各种不同的实现，所以是一个接口，<code>pointcut</code> 同样也可以基于多种不同技术实现，故也是一个接口，默认是基于 <code>AspectJ</code> 实现的，类图结构如下：</p><p><img src="https://i.loli.net/2021/06/06/JZHDROnPEletVwU.png" alt="pointcut-implemented.png"></p><p>实现类 <code>AspectJExpressionPointcut</code> 是基于 <code>AspectJ</code> 实现的，方法的匹配过程是委托给 <code>AspectJ</code> 中的 <code>PointcutExpression</code> 来判断给定的方法是否匹配表达式，该类的核心实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJExpressionPointcut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span>, <span class="title">MethodMatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;PointcutPrimitive&gt; SUPPORTED_PRIMITIVES = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    SUPPORTED_PRIMITIVES.add(PointcutPrimitive.EXECUTION);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String expression;</span><br><span class="line">  <span class="keyword">private</span> ClassLoader pointcutClassLoader;</span><br><span class="line">  <span class="keyword">private</span> PointcutExpression pointcutExpression;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MethodMatcher <span class="title">getMethodMatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    checkReadyToMatch();</span><br><span class="line"></span><br><span class="line">    ShadowMatch shadowMatch = getShadowMatch(method);</span><br><span class="line">    <span class="keyword">return</span> shadowMatch.alwaysMatches();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkReadyToMatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(getExpression())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Must set property 'expression' before attempting to match"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(<span class="keyword">this</span>.pointcutExpression)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.pointcutClassLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line">      <span class="keyword">this</span>.pointcutExpression = buildPointcutExpression(<span class="keyword">this</span>.pointcutClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> PointcutExpression <span class="title">buildPointcutExpression</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    PointcutParser pointcutParser = PointcutParser</span><br><span class="line">        .getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(SUPPORTED_PRIMITIVES, classLoader);</span><br><span class="line">    <span class="keyword">return</span> pointcutParser.parsePointcutExpression(replaceBooleanOperators(getExpression()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">replaceBooleanOperators</span><span class="params">(String pcExpr)</span> </span>&#123;</span><br><span class="line">    String result = StringUtils.replace(pcExpr, <span class="string">" and "</span>, <span class="string">" &amp;&amp; "</span>);</span><br><span class="line">    result = StringUtils.replace(result, <span class="string">" or "</span>, <span class="string">" || "</span>);</span><br><span class="line">    result = StringUtils.replace(result, <span class="string">" not "</span>, <span class="string">" ! "</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ShadowMatch <span class="title">getShadowMatch</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    ShadowMatch shadowMatch;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      shadowMatch = <span class="keyword">this</span>.pointcutExpression.matchesMethodExecution(method);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"not implemented yet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shadowMatch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other setter、getter ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就完成了给定一个类的方法，判断是否匹配配置文件中给定的表达式的功能。再来看如下的一个完整的 <code>AOP</code> 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.e3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:scann-package</span> <span class="attr">base-package</span>=<span class="string">"cn.mghio.service.version5,cn.mghio.dao.version5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tx"</span> <span class="attr">class</span>=<span class="string">"cn.mghio.tx.TransactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"tx"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"placeOrder"</span> <span class="attr">expression</span>=<span class="string">"execution(* cn.mghio.service.version5.*.placeOrder(..))"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"start"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"commit"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"placeOrder"</span> <span class="attr">method</span>=<span class="string">"rollback"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实现各种 <code>XXXAdvice</code> 之前需要定位到这个 <code>Method</code>，比如以上配置文件中的 <code>start</code>、<code>commit</code>、<code>rollback</code> 等方法，为了达到这个目标我们还需要实现的功能就是根据一个 <code>Bean</code> 名称（比如这里的 <code>tx</code>）定位到指定的 <code>Method</code>，然后通过反射调用这个定位到的方法。实际上也比较简单，这个类命名为 <code>MethodLocatingFactory</code>，根据其功能可以定义出目标 <code>Bean</code> 的名称 <code>targetBeanName</code>、需要定位的方法名称 <code>methodName</code> 以及定位完成后得到的方法 <code>method</code> 这三个属性，整体类图结构如下所示：</p><p><img src="https://i.loli.net/2021/06/06/rQyJt8KuSDEO6gZ.png" alt="method-locating.png"></p><p>根据名称和类型定位到方法主要是在 <code>setBeanFactory()</code> 方法中完成的，前提是对应的目标 <code>Bean</code> 名称和方法名称要设置完成，方法定位的类 <code>MethodLocatingFactory</code> 类的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodLocatingFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Method</span>&gt;, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String targetBeanName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Method method;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTargetBeanName</span><span class="params">(String targetBeanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.targetBeanName = targetBeanName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.targetBeanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'targetBeanName' is required"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.methodName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'methodName' is required"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; beanClass = beanFactory.getType(<span class="keyword">this</span>.targetBeanName);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(beanClass)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can't determine type of bean with name '"</span> + <span class="keyword">this</span>.targetBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.method = BeanUtils.resolveSignature(<span class="keyword">this</span>.methodName, beanClass);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(<span class="keyword">this</span>.method)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to locate method ["</span> + <span class="keyword">this</span>.methodName + <span class="string">"] on bean ["</span></span><br><span class="line">          + <span class="keyword">this</span>.targetBeanName + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Method <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.method;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">    <span class="keyword">return</span> Method.class;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现各种不同类型的-Advice"><a href="#实现各种不同类型的-Advice" class="headerlink" title="实现各种不同类型的 Advice"></a>实现各种不同类型的 Advice</h4><p>各种不同类型的 <code>Advice</code>（<code>BeforeAdvice</code>、<code>AfterAdvice</code> 等）目标都是需要在指定对象的指定方法执行前后按指定次序执行一些操作（称之为 <code>拦截器</code>），比如以上示例中的一种执行次序为：<code>BeforeAdvice</code> -&gt; <code>placeOrder</code> -&gt; <code>AfterAdvice</code>。这里的一个关键问题就是<strong>如何去实现按照指定次序的链式调用？</strong>，这里先卖个关子，这个问题先放一放等下再介绍具体实现，先来看看要如何定义各种不同类型的 <code>Advice</code>，我们的 <code>Advice</code> 定义都是扩展自 <code>AOP Alliance</code> 定义的 <code>MethodInterceptor</code> 接口，<code>Advice</code> 部分的核心类图如下：</p><p><img src="https://i.loli.net/2021/06/06/gvOmqs4ci8jp1Nx.png" alt="advice-implemented.png"></p><p>其实到这里如果有了前面两篇文章（<a href="https://www.mghio.cn/post/9294037e.html">如何实现 AOP（上）</a>、<a href="https://www.mghio.cn/post/af7194f9.html">如何实现 AOP（中）</a>）的基础了，实现起来就相对比较简单了，就是在方法执行之前、之后以及发生异常时调用一些特定的方法即可，<code>AbstractAspectJAdvice</code> 类定义了一下公共的属性和方法，核心实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAspectJAdvice</span> <span class="keyword">implements</span> <span class="title">Advice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Method adviceMethod;</span><br><span class="line">  <span class="keyword">protected</span> AspectJExpressionPointcut pc;</span><br><span class="line">  <span class="keyword">protected</span> AopInstanceFactory adviceObjectFactory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractAspectJAdvice</span><span class="params">(Method adviceMethod, AspectJExpressionPointcut pc, AopInstanceFactory adviceObjectFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.adviceMethod = adviceMethod;</span><br><span class="line">    <span class="keyword">this</span>.pc = pc;</span><br><span class="line">    <span class="keyword">this</span>.adviceObjectFactory = adviceObjectFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeAdviceMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    adviceMethod.invoke(adviceObjectFactory.getAspectInstance());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getAdviceInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adviceObjectFactory.getAspectInstance();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit getter ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个公共抽象父类之后其它几个 <code>Advice</code> 的实现就很简单了，<code>AspectJBeforeAdvice</code> 就是在执行拦截方法之前调用，核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit constructor ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.invokeAdviceMethod();</span><br><span class="line">    <span class="keyword">return</span> mi.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，<code>AspectJAfterReturningAdvice</code> 就是在方法正常执行结束后调用，核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit constructor ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object result = mi.proceed();</span><br><span class="line">    <span class="keyword">this</span>.invokeAdviceMethod();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的 <code>AspectJAfterThrowingAdvice</code> 想必你已经猜到了，没错，就是在方法执行过程中发生异常时调用，对应 <code>Java</code> 的异常机制也就是在 <code>try{...}catch{...}</code> 的 <code>catch</code> 中调用，核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-06-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAfterThrowingAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractAspectJAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit constructor ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mi.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">this</span>.invokeAdviceMethod();</span><br><span class="line">      <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们支持的三种不同的 <code>Advice</code> 已经定义好了，接下来就是如何组装调用的问题了，同时也处理了<strong>如何去实现按照指定次序的链式调用？</strong>的问题，这里的方法调用我们也是扩展 <code>AOP Alliance</code> 定义的规范，即方法调用 <code>MethodInvocation</code> 接口。</p><p>由于这里的方法调用是基于反射完成的，将该类命名为 <code>ReflectiveMethodInvocation</code>，要使用反射来调用方法，很显然需要知道目标对象 <code>targetObject</code>、<code>targetMethod</code> 以及方法参数列表 <code>arguments</code> 等参数，当然还有我们的拦截器列表（也就是上文定义的 <code>Advice</code>）<code>interceptors</code>，因为这个是一个类似<strong>自调用的过程</strong>，为了判断是否已经执行完成所有拦截器，还需要记录当前调用拦截器的下标位置 <code>currentInterceptorIndex</code>，当 <code>currentInterceptorIndex</code> 等于 <code>interceptors.size() - 1</code> 时表示所有拦截器都已调用完成，再调用我们的实际方法即可。核心的类图如下：</p><p><img src="https://i.loli.net/2021/06/06/Df4bx7AkdLavjrX.png" alt="ReflectiveMethodInvocation-implemented.png"></p><p>其中类 <code>ReflectiveMethodInvocation</code> 的核心源码实现如下，强烈建议大家将 <code>proceed()</code> 方法结合上问定义的几个 <code>Advice</code> 类一起看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mghio</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-04-05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title">MethodInvocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Object targetObject;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Method targetMethod;</span><br><span class="line">  <span class="keyword">protected</span> Object[] arguments;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;MethodInterceptor&gt; interceptors;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> currentInterceptorIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReflectiveMethodInvocation</span><span class="params">(Object targetObject, Method targetMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">      Object[] arguments, List&lt;MethodInterceptor&gt; interceptors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line">    <span class="keyword">this</span>.targetMethod = targetMethod;</span><br><span class="line">    <span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">    <span class="keyword">this</span>.interceptors = interceptors;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// all interceptors have been called.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == interceptors.size() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.currentInterceptorIndex++;</span><br><span class="line">    MethodInterceptor methodInterceptor = <span class="keyword">this</span>.interceptors.get(<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">return</span> methodInterceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.targetMethod.invoke(<span class="keyword">this</span>.targetObject, <span class="keyword">this</span>.arguments);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// omit other method ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，各种不同类型的 <code>Advice</code> 的核心实现已经介绍完毕，本来打算在这边介绍完 <code>AOP</code> 剩下部分的实现的，但是鉴于文章长度太长，还是放到下一次再开一篇来介绍吧。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍了 <code>AOP</code> 在 <code>XML</code> 配置的 <code>pointcut</code> 解析实现、方法匹配定位以及各种不同类型的 <code>Advice</code> 的实现，特别是 <code>Advice</code> 的实现部分，建议自己动手实现一版，这样印象会更加深刻，另源码已上传至 <a href="https://github.com/mghio/mghio-spring" target="_blank" rel="noopener">GitHub</a>，可自行下载参考，有任何问题请留言交流讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/10/lOLEuXIUreJkNgM.jpg&quot; alt=&quot;cover.jpg&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;前面两篇 &lt;a href=&quot;https://www.mghio.cn/post/9294037e.html&quot;&gt;如何实现 AOP（上）&lt;/a&gt;、&lt;a href=&quot;https://www.mghio.cn/post/af7194f9.html&quot;&gt;如何实现 AOP（中）&lt;/a&gt; 做了一些 &lt;code&gt;AOP&lt;/code&gt; 的核心基础知识简要介绍，本文进入到了实战环节了，去实现一个基于 &lt;code&gt;XML&lt;/code&gt; 配置的简易版 &lt;code&gt;AOP&lt;/code&gt;，虽然是简易版的但是&lt;code&gt;麻雀虽小五脏俱全&lt;/code&gt;，一些核心的功能都会实现，通过实现这个简易版的 &lt;code&gt;AOP&lt;/code&gt;，相信你会对 &lt;code&gt;AOP&lt;/code&gt; 有深入的理解，不止知其然，还能知其所以然。&lt;code&gt;AOP&lt;/code&gt; 的顶层接口规范和底层依赖基础组件都是由一个叫 &lt;a href=&quot;http://aopalliance.sourceforge.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AOP Alliance&lt;/a&gt; 的组织制定的，我们经常听到的 &lt;code&gt;AspectJ&lt;/code&gt;、&lt;code&gt;ASM&lt;/code&gt;、&lt;code&gt;CGLIB&lt;/code&gt; 就是其中被管理的一些项目，需要明确的一点是，在 &lt;code&gt;Spring&lt;/code&gt; 中只是使用了 &lt;code&gt;AspectJ&lt;/code&gt; 的核心概念和核心类，并不是像 &lt;code&gt;AspectJ&lt;/code&gt; 那样在编译期实现的 &lt;code&gt;AOP&lt;/code&gt;，而是在&lt;strong&gt;运行期&lt;/strong&gt;。话不多说，下面开始进入主题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.mghio.cn/categories/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/categories/Java/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/categories/Java/Spring/AOP/"/>
    
    
      <category term="Java" scheme="https://www.mghio.cn/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.mghio.cn/tags/Spring/"/>
    
      <category term="AOP" scheme="https://www.mghio.cn/tags/AOP/"/>
    
  </entry>
  
</feed>
